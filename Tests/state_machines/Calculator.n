using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart.Tests
{
  /// <summary>
  /// Description of Calculator.
  /// </summary>
  [statechart(" #include 'Calculator.nsch' ")]
  public class Calculator
  {
    error : bool {get;set;default false}
    
    mutable op1 : string;
    mutable op2 : string;
    mutable operator : char;
    
    mutable history : list[string * char];
    
    public static GetEventFromStr(str : string) : option[HsmEvent]
    {
      match (str[0])
      {
        | x when x >= '0' && x <= '9' => Some(Event.Digit(x))
        | ','                         => Some(Event.Point())
        | '+'                         => Some(Event.Oper('+'))
        | '-'                         => Some(Event.Oper('-'))
        | '*'                         => Some(Event.Oper('*'))
        | '/'                         => Some(Event.Oper('/'))
        | '='                         => Some(Event.Equal())
        | _                           => None()
      }
    }
    
    priority(op1 : char, op2 : char) : int
    {
      | ('-', '/')
      | ('+', '/')
      | ('-', '*')
      | ('/', '*')
      | ('+', '*') => -1
      | ('/', '-')
      | ('/', '+') 
      | ('*', '+') 
      | ('*', '/')
      | ('*', '-') => 1
      | _          => 0
    }

    mem_op1(o : char) : void
    {
      memory(); 
      op1 = op2; 
      operator = o;
    }
    
    memory() : void
    {
      history ::= (op1, operator)
    }
    
    clear() : void
    {
      op1 = "";
      op2 = "";
      show("0");
      history = [];
    }
    
    clear_op2() : void
    {
      op2 = "";
    }
    
    negate() : void
    {
      prefix = "-";
      show("-0");
    }
    
    insert(n : char) : void
    {
      ent_op += n;
      show(ent_op);
    }
    
    calc_proc1() : void
    {
      result = calc(op1, "100", '/')
    }

    calc_proc2() : void
    {
      op2 = calc(op2, "100", '/');
    }
    
    calc_all() : void
    {
      def hist = (op1, operator) :: history;
      
      def evaluate(hist, op2)
      {
        match (hist)
        {
          | (op1, oper) :: (((op3, oper2) :: _) as tail) => if (priority(oper, oper2) > 0)
                                                            {
                                                              def res = calc(op1, op2, oper);
                                                              evaluate(tail, res)
                                                            } else
                                                            {
                                                              def eval = evaluate(tail, op3);
                                                              calc(eval, op2, oper)
                                                            }
          | (op1, oper) :: []                          => calc(op1, op2, oper)
        }
      }
      
     def res = evaluate(hist, op2);
     result = res;
     show(result)
    }

    calc(op1 : string, op2 : string, oper : char) : string
    {
      def op1 = double.Parse(op1);
      def op2 = double.Parse(op2);
      def res = match (oper)
      {
        | '+' => op1 + op2
        | '-' => op1 - op2
        | '*' => op1 * op2
        | '/' => op1 / op2
        | _   => throw InvalidOperationException("invalid operator")
      }
      res.ToString();
    }
    
    calculate() : string
    {
      def res = calc(op1, op2, operator);
      
      def loop(hist, acc, oper1)
      {
        match (hist)
        {
          | (op1, oper) :: tail => if (priority(oper, oper1) >= 0)
                                   {
                                     def res = calc(op1, acc, oper);
                                     loop(tail, res, oper)
                                   } else
                                   {
                                     (hist, acc)
                                   }
         | []                   => ([], acc)
        }
      }
      
      def (hist, res) = loop(history, res, operator);
      history = hist;
      show(res);
      res
    }
    
    show(str : string) : void
    {
      Show?.Invoke(str)
    }
    
    public event Show : Action[string];
    
    [Accessor]
    mutable result : string;
  }
}
