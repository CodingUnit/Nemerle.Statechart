using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections.Concurrent;
using System.Threading;
using CommonLib.Macros;
using System.Reactive.Linq;
//using System.Threading.Tasks;

namespace Nemerle.Statechart
{
  public class CompletionEvent : HsmEvent
  {
    static instance : HsmEvent = CompletionEvent();

    public static Instance : HsmEvent
    {
      get
      {
        instance
      }
    }

    public override Name : string
    {
      get
      {
        "Completion"
      }
    }

    public override FullName : string
    {
      get
      {
        Name
      }
    }
  }

  [Record]
  public class EventInfo
  {
    public name  : string;
    public parms : list[string];
  }

  /// <summary>
  /// Description of Implementation.
  /// </summary>
  public abstract class ActiveStateMachine[TState] : StateMachine[TState], IActiveStateMachine where TState : HsmState
  {

    public this()
    {
      
      //Thread(QueueThread);
      //queue_thread.IsBackground = true;
    }

    public abstract Events : IEnumerable[EventInfo] {get;}

    public Messenger : FsmMessenger = FsmMessenger.Instance;

    protected virtual Subscribe() : void
    {
      Messenger.Subscribe(this);
    }

    protected virtual Unsubscribe() : void
    {
      Messenger.Unsubscribe(this);
      _disp.Dispose();
    }

    public virtual Initiate() : void
    {
      _ = work_event.Reset();
      TrySwitch(Initial());
      _queue_disp = work_event.Subscribe(_ => QueueThread());
      //queue_thread.Start();
      Subscribe();
    }

    queue : ConcurrentQueue[HsmEvent] = ConcurrentQueue();

    mutable _queue_disp : IDisposable;

    //queue_thread_cancel : CancellationTokenSource = CancellationTokenSource();
    work_event : SignalObservable = SignalObservable();

    _disp : ListDisposable = ListDisposable();
    
    public abstract PostEvent(evt : string) : void;

    public PostEvent(evt : HsmEvent) : void
    {
      queue.Enqueue(evt);
      work_event.Signal();
    }

    public WhenStateChange(st : TState) : IObservable[bool]
    {
      Nemerle.Statechart.Observable.WhenChange(States.Select(_ => IsInState(st)))
    }

    public WhenStateChange(st : string) : IObservable[bool]
    {
      Nemerle.Statechart.Observable.WhenChange(States.Select(_ => IsInState(st)))
    }
                    
    public BindSignal[T](obs : IObservable[T], evt : HsmEvent) : void
    {
      _disp.Add(obs.Subscribe(_ => this.PostEvent(evt)))
    }

    public BindSignal[T](obs : IObservable[T], evt : T -> HsmEvent) : void
    {
      _disp.Add(obs.Subscribe(x => this.PostEvent(evt(x))))
    }

    public BindSignal[T](obs : IObservable[T], evt : void -> HsmEvent) : void
    {
      _disp.Add(obs.Subscribe(_ => this.PostEvent(evt())))
    }
    
    protected abstract DoActivityStop() : void;

    public Terminate() : void
    {
      Dispose()
    }
    
    public new Dispose() : void
    {
      Unsubscribe();
      DoActivityStop();

      base.Dispose();
      _queue_disp.Dispose();
      _disp.Dispose();
      //queue_thread_cancel.Cancel();
      //work_event.Set();
      //when (Thread.CurrentThread != this.queue_thread : object)
      //{
      //  queue_thread.Join();
      //}

    }

    public Completion() : void
    {
      completion = true;
      work_event.Signal();
    }

    CheckCompletion() : bool
    {
      if (completion) 
      {
        completion = false;
        Dispatch(CompletionEvent.Instance);
        true
      } else false
    }

    CheckQueue(queue : ConcurrentQueue[HsmEvent]) : bool
    {
      mutable item;
      if (queue.TryDequeue(out item))
      {
        Dispatch(item);
        true
      } else false
    }

    QueueThread() : void
    {
      if (CheckCompletion()) () else
        if (CheckQueue(queue)) ()
        else work_event.Reset();
    }

  }
}
