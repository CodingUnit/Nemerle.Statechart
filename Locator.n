using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using CommonLib.Macros;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of Locator.
  /// </summary>
  class Locator
  {
    parser : Parser;
    loc    : Location;
    //builder : FsmBuilder;
    
    public this(parser : Parser, loc : Location)
    {
      this.parser = parser;
      this.loc = loc;
      //this.builder = builder;
    }
    
    public static ConvLocation(location : Nitra.Location, base_loc : Location) : Location
    {
      def startLineColumn = location.StartLineColumn;
      def endLineColumn = location.EndLineColumn;
      
	    def startLine = startLineColumn.Line;
	    def startCol = startLineColumn.Column;
	    
	    def endLine = endLineColumn.Line;
	    def endCol = endLineColumn.Column;
	    def nloc =  Location(location.Source.File.FullName, startLine, startCol, endLine, endCol);
  //    def nloc = Nitra.Util.ToNemerleLocation(location);
      if (base_loc.IsGeneratedOrEmpty)
      {
        nloc
      } else
      {
	      if (nloc.Line > 1) 
	        Location(nloc, nloc.Line + base_loc.Line - 1, nloc.Column, base_loc.Line + nloc.EndLine - 1, nloc.EndColumn) 
	      else               
	        Location(nloc, nloc.Line, nloc.Column + base_loc.Column, nloc.EndLine, nloc.EndColumn + base_loc.Column);
      }
    }    
    
    public GetLoc(pos : int) : Location
    {
      if (pos == -1)
      {
        loc
      } else
      {
        def nloc = parser.Source.GetSourceLine(pos);
        def offs = pos - nloc.StartPos;
        def nloc = Nitra.Location(nloc.Source, nloc.StartPos + offs, nloc.EndPos);
        ConvLocation(nloc, loc)
      }
    }
    
    LocateTarget(t : TargetType) : void
    {
      Locate(t);
      match (t)
      {
        | TargetType.Qualified(_, t) => LocateTarget(t)
        | TargetType.PseudoState(n)  => LocatePseudo(n)
        | _                          => ()
      }
    }
    
    LocatePseudo(node : PseudoStateModelNode) : void
    {
      Locate(node);
      match (node)
      {
        | PseudoStateModelNode.Initial(p)            => p.Iter(LocateTran);
        | PseudoStateModelNode.History(default = t)  => t.Iter(LocateTran);
        | PseudoStateModelNode.Fork(t)               => t.Iter(LocateTarget)
        | PseudoStateModelNode.Join(_, _, t)         => LocateTran(t)
        | PseudoStateModelNode.Junction(nodes = n)   => foreach (n in n)
                                                        {
                                                          | JunctionNode(g, a, t) => Locate(n);
                                                                                     Locate(g);
                                                                                     when (a is Some(a))
                                                                                     {
                                                                                       Locate(a);
                                                                                       Locate(a.actions);
                                                                                     }
                                                                                     Locate(t);
                                                                                     LocateTarget(t);
                                                        }
        | PseudoStateModelNode.EntryPoint(_, null)    => ()
        | PseudoStateModelNode.EntryPoint(_, tr)      => Locate(tr);
                                                         LocateTran(tr)
        | PseudoStateModelNode.ExitPoint(_, tr)       => tr.Iter(Locate);
                                                         tr.Iter(LocateTran)
        | _                                           => ()
      }
    }
    
    LocateTran(tr : StateNode.Transition) : void
    {
      | StateNode.Transition(f, e, g, a, t, _) => 
     
        Locate(tr);
        when (a is Some(a))
        {
          Locate(a);
          Locate(a.actions);
        }
        Locate(e);
        LocateTarget(f);
        Locate(g);
        Locate(t);
        LocateTarget(t);
    }
    
    Locate(node : LocatedNode) : void
    {
       node.Location = GetLoc(node.pos);
    }
    
    Locate(node : IEnumerable[LocatedNode]) : void
    {
      foreach (n in node)
      {
          Locate(n)
      }
    }
    
    public Locate(fsm : StateNode.StateMachine) : void
    {
      Locate(fsm : LocatedNode);
      Locate(fsm.usings);
      Locate(fsm.event_classes);
      Locate(fsm.event_decls);
      foreach (StateNode.Error(n) in fsm.errors)
      {
        Locate(n)
      }
      
      def iter = TreeUtils.GetBreadthFirstEnumerable(fsm.state, _.sub_states);
      
      foreach (st in iter)
      {
        Locate(st);
        Locate(st.attributes);
        Locate(st.defer);
        foreach (evt in st.defer) Locate(evt.evt);
        Locate(st.do_activity);
        def act = st.entry.Map(x => x.action) + st.exit.Map(x => x.action);
        foreach (a in act)
        {
          Locate(a);
          Locate(a.actions);
        }
        Locate(st.entry);
        Locate(st.errors);
        foreach (StateNode.Error(n) in st.errors)
        {
          Locate(n)
        }
        Locate(st.exit);
        Locate(st.pseudo_states);
        Locate(st.transitions);
        st.transitions.Iter(LocateTran);
        st.pseudo_states.Iter(x => LocatePseudo(x.node));
      }
    }

  }
}
