using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using CommonLib.Macros;


namespace Nemerle.Statechart
{
  using StateNode;
  using CommonLib.Macros.LensUtils;
  using PseudoStateModelNode;
  /// <summary>
  /// Description of Locator.
  /// </summary>
  class Locator
  {
    parser : Parser;
    loc    : Location;
    //builder : FsmBuilder;
    
    public this(parser : Parser, loc : Location)
    {
      this.parser = parser;
      this.loc = loc;
      //this.builder = builder;
    }
    
    public static ConvLocation(location : Nitra.Location, base_loc : Location) : Location
    {
      def startLineColumn = location.StartLineColumn;
      def endLineColumn = location.EndLineColumn;
      
	    def startLine = startLineColumn.Line;
	    def startCol = startLineColumn.Column;
	    
	    def endLine = endLineColumn.Line;
	    def endCol = endLineColumn.Column;
	    def nloc =  Location(location.Source.File.FullName, startLine, startCol, endLine, endCol);
  //    def nloc = Nitra.Util.ToNemerleLocation(location);
      if (base_loc.IsGeneratedOrEmpty)
      {
        nloc
      } else
      {
	      if (nloc.Line > 1) 
	        Location(nloc, nloc.Line + base_loc.Line - 1, nloc.Column, base_loc.Line + nloc.EndLine - 1, nloc.EndColumn) 
	      else               
	        Location(nloc, nloc.Line, nloc.Column + base_loc.Column, nloc.EndLine, nloc.EndColumn + base_loc.Column);
      }
    }    
    
    public GetLoc(pos : int) : Location
    {
      if (pos == -1)
      {
        loc
      } else
      {
        def nloc = parser.Source.GetSourceLine(pos);
        def offs = pos - nloc.StartPos;
        def nloc = Nitra.Location(nloc.Source, nloc.StartPos + offs, nloc.EndPos);
        ConvLocation(nloc, loc)
      }
    }
    
    LocateTarget(t : TargetType) : TargetType
    {
      //TargetType.PseudoState.node_lens.ToBasePartial().Update(t, LocatePseudo) |>
      //TargetType.Qualified.target_lens.ToBasePartial().Update(_, LocateTarget)
      match (LocateT(t))
      {
        | TargetType.Qualified   as t => TargetType.Qualified.target_lens.Update(t, LocateTarget)//LocateTarget(t) |> tar.ChangeTarget
        | TargetType.PseudoState as t => TargetType.PseudoState.node_lens.Update(t, LocatePseudo)//LocatePseudo(n) |> tar.ChangeNode
        | _                           => t
      }
    }
    
    
    
    LocatePseudo(node : PseudoStateModelNode) : PseudoStateModelNode
    {
      def tran = Initial.tran_lens.ToEnum() | History.default_lens.OptToEnum() | Join.tran_lens.ToEnum()  | EntryPoint.tran_lens.ToEnum()    | ExitPoint.tran_lens.OptToEnum();
      def junc = Junction.nodes_lens.ToBasePartial();
      def mapper = JunctionNode.action_lens.Mapper(LocateAction) + JunctionNode.guard_lens.Mapper(LocateT) + JunctionNode.to_lens.Mapper(LocateTarget) + Mapper(LocateT);
      
      Fork.target_lens.ToBasePartial().Map(node, LocateTarget) |>
      tran.Map(_, LocateTran) |> 
      junc.Map(_, _.Reduce(mapper.func)) |>
      LocateT
      /*
      match (LocateT(node))
      {
        //| PseudoStateModelNode.Initial(p) as n           => p.Map(LocateTran) |> n.ChangeTran
        //| PseudoStateModelNode.History(default = t) as n => t.Map(LocateTran) |> n.ChangeDefault
        //| PseudoStateModelNode.Fork(t) as n              => t.Map(LocateTarget) |> n.ChangeTarget
        //| PseudoStateModelNode.Join(_, _, t) as n        => LocateTran(t) |> n.ChangeTran
        | PseudoStateModelNode.Junction as j  => 
                                                              //| JunctionNode(g, a, t) as n => def n = Locate(n) :> JunctionNode;
                                                              //                                def g = Locate(g) :> GuardNode;
                                                              //                                def a = a.Map(LocateAction);
                                                              //                                def t = Locate(t) :> TargetType |> LocateTarget;
                                                              //n.ChangeGuardActionTo(g, a, t)
                                                              def loc(n)
                                                              {
                                                                LocateT(n)               |>
                                                                act.Map(_, LocateAction) |>
                                                                guard.Map(_, LocateT)    |>
                                                                tar.Map(_, LocateTarget)
                                                              }
                                                              
                                                              
                                                            
                                                            //def j = TreeUtils.Reduce(j, x : Junction => x.nodes.AsEnumerable(), locate);
                                                            Junction.nodes_lens.Map(j, _.Reduce(loc))
                                                            //n.Map(locate) |> j.ChangeNodes
        //| PseudoStateModelNode.EntryPoint(_, null) as n => n
        //| PseudoStateModelNode.EntryPoint(_, tr) as n   => Locate(tr) :> StateNode.Transition |> LocateTran |> n.ChangeTran
        //| PseudoStateModelNode.ExitPoint(_, tr) as n    => tr.Map(x => Locate(x) :> StateNode.Transition) |> _.Map(LocateTran) |> n.ChangeTran
        | n                                             => n
      }*/
    }
    
    LocateAction(a : Actions) : Actions
    {
      Actions.actions_lens.Map(a, LocateT)
      //Locate(a) :> Actions |> _.ChangeActions(Locate(a.actions))
    }
    
    LocateTran(tr : StateNode.Transition) : StateNode.Transition
    {
      if (tr != null)
      {
        def lst = StateNode.Transition.lens_list_StateNode.FilterType();//Where(x => x.Get(tr) is LocatedNode).Select(_.Cast());
        //| StateNode.Transition(f, e, g, a, t, _) => 
        LocateT(tr) |>
        lst.Update(_, x => Locate(x : LocatedNode)) |>
        Transition.action_lens.Update(_, x => x.Map(LocateAction)) |>
        Transition.from_lens.CombineEnum(Transition.to_lens).Update(_, LocateTarget);
      } else null
      //def g = Locate(g) :> GuardNode;
      //def t = Locate(t) :> TargetType;
      //def t = LocateTarget(t);
      //tr.ChangeEvtFromGuardActionTo(e, f, g, a, t)
    }
    
    //LocateImpl(node : LocatedNode) : LocatedNode
    //{
    //   GetLoc(node.pos) |> node.ChangeLocation
    //}
    
    Locate(node : LocatedNode) : LocatedNode
    {
      LocatedNode.location_lens.Set(node, GetLoc(node.pos))
       //GetLoc(node.pos) |> node.ChangeLocation
    }
    
    Locate[T](node : list[T]) : list[T] where T : LocatedNode
    {
      node.Map(LocateT)
    }
    
    LocateT[T](node : T) : T where T : LocatedNode
    {
      //node.;
      //Set(node, GetLoc(node.pos))
      Locate(node : LocatedNode) :> T
    }
    
    //Locate(node : object) : object
    //{
    //  | LocatedNode as n  => Locate(n)
    //  | x is list[object] => x.Map(Locate)
    //  | IEnumerable as n  => n.Map(x : object => Locate(x))
    //  | n                 => n
    //}
    
    public Locate(fsm : StateNode.StateMachine) : StateNode.StateMachine
    {
      //assert2(false);
      
      def lst = StateMachine.lens_list_StateNode.FilterType(fsm);//Where(x => x.Get(fsm) is LocatedNode).Select(_.Cast());
      def fsm = lst.Update(fsm, x => Locate(x : LocatedNode));
      def fsm = Locate(fsm : LocatedNode) :> StateMachine;//GetLoc(fsm.pos) |> fsm.ChangeLocation;
      //def fsm = Locate(fsm.usings) |> fsm.ChangeUsings;
      //def fsm = Locate(fsm.event_classes) |> fsm.ChangeEventClasses;
      //def fsm = Locate(fsm.event_decls) |> fsm.ChangeEventDecls;
      //def fsm = fsm.errors.Map(x => Locate(x) :> StateNode.Error) |> fsm.ChangeErrors;
      
      
      def locate(st : StateNode) : StateNode
      {
        | StateNode.State as st => 
        
              def lst = StateNode.State.lens_list_StateNode.FilterType(st);//Where(x => x.Get(st) is LocatedNode).Select(_.Cast());
              def defer = State.defer_lens >> Defer.evt_lens;
              def pseudo = State.pseudo_states_lens >> PseudoState.node_lens;
              def tran = State.transitions_lens;
              def entry = State.entry_lens >> Entry.action_lens;
              def exit = State.exit_lens >> Exit.action_lens;
              def entry_act = entry >> Actions.actions_lens;
              def exit_act = entry >> Actions.actions_lens;
              
              def lst = lst %+ defer %+ pseudo %+ entry %+ exit %+ entry_act %+ exit_act;
              def st = lst.Update(st, x => Locate(x : LocatedNode));
              pseudo.Map(st, LocatePseudo) |> tran.Map(_, LocateTran) |> LocateT
              //def st = defer.Map(st, Locate);
              //def defer = st.defer.Map(x => Locate(x.evt) |> x.ChangeEvt);
              ///def st = Locate(defer) |> st.ChangeDefer;
              //def st = Locate(st.include) |> st.ChangeInclude;
              //def st = defer |> st.ChangeDefer;
              //def st = Locate(st.do_activity) |> st.ChangeDoActivity;
              //def st = Locate(st.entry.Map(x => LocateAction(x.action) |> x.ChangeAction)) |> st.ChangeEntry;
              //def st = Locate(st.exit.Map(x => LocateAction(x.action) |> x.ChangeAction)) |> st.ChangeExit;
              //def st = Locate(st.errors) |> st.ChangeErrors;
              //def pseudo = Locate(st.pseudo_states);
              //def st = pseudo.Map(x => LocatePseudo(x.node) |> x.ChangeNode) |> st.ChangePseudoStates;
              //def tran = Locate(st.transitions);
              //def st = tran.Map(LocateTran) |> st.ChangeTransitions;
         | _ => st
      }
      
      fsm.state.Reduce(locate) :> StateNode.StateMachine;//TreeUtils.R(fsm.state, _.sub_states);
    }

  }
}
