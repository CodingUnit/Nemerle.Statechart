using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using CommonLib.Macros;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of Locator.
  /// </summary>
  class Locator
  {
    parser : Parser;
    loc    : Location;
    //builder : FsmBuilder;
    
    public this(parser : Parser, loc : Location)
    {
      this.parser = parser;
      this.loc = loc;
      //this.builder = builder;
    }
    
    public static ConvLocation(location : Nitra.Location, base_loc : Location) : Location
    {
      def startLineColumn = location.StartLineColumn;
      def endLineColumn = location.EndLineColumn;
      
	    def startLine = startLineColumn.Line;
	    def startCol = startLineColumn.Column;
	    
	    def endLine = endLineColumn.Line;
	    def endCol = endLineColumn.Column;
	    def nloc =  Location(location.Source.File.FullName, startLine, startCol, endLine, endCol);
  //    def nloc = Nitra.Util.ToNemerleLocation(location);
      if (base_loc.IsGeneratedOrEmpty)
      {
        nloc
      } else
      {
	      if (nloc.Line > 1) 
	        Location(nloc, nloc.Line + base_loc.Line - 1, nloc.Column, base_loc.Line + nloc.EndLine - 1, nloc.EndColumn) 
	      else               
	        Location(nloc, nloc.Line, nloc.Column + base_loc.Column, nloc.EndLine, nloc.EndColumn + base_loc.Column);
      }
    }    
    
    public GetLoc(pos : int) : Location
    {
      if (pos == -1)
      {
        loc
      } else
      {
        def nloc = parser.Source.GetSourceLine(pos);
        def offs = pos - nloc.StartPos;
        def nloc = Nitra.Location(nloc.Source, nloc.StartPos + offs, nloc.EndPos);
        ConvLocation(nloc, loc)
      }
    }
    
    LocateTarget(t : TargetType) : TargetType
    {
      match (Locate(t))
      {
        | TargetType.Qualified(_, t) as tar => LocateTarget(t) |> tar.ChangeTarget
        | TargetType.PseudoState(n) as tar  => LocatePseudo(n) |> tar.ChangeNode
        | _                                 => t
      }
    }
    
    LocatePseudo(node : PseudoStateModelNode) : PseudoStateModelNode
    {
      match (Locate(node) :> PseudoStateModelNode)
      {
        | PseudoStateModelNode.Initial(p) as n           => p.Map(LocateTran) |> n.ChangeTran
        | PseudoStateModelNode.History(default = t) as n => t.Map(LocateTran) |> n.ChangeDefault
        | PseudoStateModelNode.Fork(t) as n              => t.Map(LocateTarget) |> n.ChangeTarget
        | PseudoStateModelNode.Join(_, _, t) as n        => LocateTran(t) |> n.ChangeTran
        | PseudoStateModelNode.Junction(nodes = n) as j  => 
                                                            def locate(n)
                                                            {
                                                              | JunctionNode(g, a, t) as n => def n = Locate(n) :> JunctionNode;
                                                                                              def g = Locate(g) :> GuardNode;
                                                                                              def a = a.Map(LocateAction);
                                                                                              def t = Locate(t) :> TargetType |> LocateTarget;
                                                                                              n.ChangeGuardActionTo(g, a, t)
                                                            }
                                                            
                                                            n.Map(locate) |> j.ChangeNodes
        | PseudoStateModelNode.EntryPoint(_, null) as n => n
        | PseudoStateModelNode.EntryPoint(_, tr) as n   => Locate(tr) :> StateNode.Transition |> LocateTran |> n.ChangeTran
        | PseudoStateModelNode.ExitPoint(_, tr) as n    => tr.Map(x => Locate(x) :> StateNode.Transition) |> _.Map(LocateTran) |> n.ChangeTran
        | n                                             => n
      }
    }
    
    LocateAction(a : Actions) : Actions
    {
      Locate(a) :> Actions |> _.ChangeActions(Locate(a.actions))
    }
    
    LocateTran(tr : StateNode.Transition) : StateNode.Transition
    {
      | StateNode.Transition(f, e, g, a, t, _) => 
     
        def tr = Locate(tr) :> StateNode.Transition;
        def a = a.Map(LocateAction);
        def e = Locate(e);
        def f = LocateTarget(f);
        def g = Locate(g) :> GuardNode;
        def t = Locate(t) :> TargetType;
        def t = LocateTarget(t);
        tr.ChangeEvtFromGuardActionTo(e, f, g, a, t)
    }
    
    LocateImpl(node : LocatedNode) : LocatedNode
    {
       GetLoc(node.pos) |> node.ChangeLocation
    }
    
    Locate(node : LocatedNode) : LocatedNode
    {
       GetLoc(node.pos) |> node.ChangeLocation
    }
    
    Locate[T](node : list[T]) : list[T] where T : LocatedNode
    {
      node.Map(x => Locate(x) :> T)
    }
    
    public Locate(fsm : StateNode.StateMachine) : StateNode.StateMachine
    {
      assert2(false);
      def fsm = GetLoc(fsm.pos) |> fsm.ChangeLocation;
      def fsm = Locate(fsm.usings) |> fsm.ChangeUsings;
      def fsm = Locate(fsm.event_classes) |> fsm.ChangeEventClasses;
      def fsm = Locate(fsm.event_decls) |> fsm.ChangeEventDecls;
      def fsm = fsm.errors.Map(x => Locate(x) :> StateNode.Error) |> fsm.ChangeErrors;
      
      
      def locate(st : StateNode, childs)
      {
        match (st)
        {
          | StateNode.State as st => 
        
              def st = Locate(st.attributes) |> st.ChangeAttributes;
              def defer = st.defer.Map(x => Locate(x.evt) |> x.ChangeEvt);
              def st = Locate(defer) |> st.ChangeDefer;
              def st = Locate(st.include) |> st.ChangeInclude;
              def st = defer |> st.ChangeDefer;
              def st = Locate(st.do_activity) |> st.ChangeDoActivity;
              def st = Locate(st.entry.Map(x => LocateAction(x.action) |> x.ChangeAction)) |> st.ChangeEntry;
              def st = Locate(st.exit.Map(x => LocateAction(x.action) |> x.ChangeAction)) |> st.ChangeExit;
              def st = Locate(st.errors) |> st.ChangeErrors;
              def pseudo = Locate(st.pseudo_states);
              def st = pseudo.Map(x => LocatePseudo(x.node) |> x.ChangeNode) |> st.ChangePseudoStates;
              def tran = Locate(st.transitions);
              def st = tran.Map(LocateTran) |> st.ChangeTransitions;
              Locate(st) :> StateNode.State |> _.Rebuild(childs)
          | x => x
        }
      }
      
      fsm.state.Reduce(locate) :> StateNode.StateMachine;//TreeUtils.R(fsm.state, _.sub_states);
    }

  }
}
