using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of States.
  /// </summary>
  [Record]
  class States
  {
    gen : StaticGenerator;
    mutable ty : TypeBuilder;
    
    id_type : PExpr
    {
      get
      {
        gen.StateIdType
      }
    }
    
    default_id : PExpr
    {
      get
      {
        gen.StateIdDefaultValue
      }
    }

    top : ClassMember.TypeDeclaration
    {
      get
      {
        <[decl:
          public variant State : HsmState
          {

              public virtual get_id() : $id_type { $default_id }

              public override ToString() : string
              {
                null
              }
          } ]>
      }
    }

    concurrent_field_pattern : bool
    {
      [Memoize]
      get
      {
        def flags = gen.FsmFlags;
        if (flags.ForceFieldConcurrentStates) true
         else
         {
           if (flags.ForceConcurrentStateCombination) false else
            gen.ActiveStates.Count() > gen.ConcurrentCombinationsLimit || gen.transitions.Length > gen.ConcurrentTransitionsLimit
         }
      }
    }
    
    GenBaseStruct() : void
    {
      ty = gen.DefineNested(gen.ty, top);
      gen.state_builder = ty;
      when (gen.HasDeferedEvents) DeferrableEvents.EmitIsDeferDeclaration(ty);
      def defs = gen.gen_events.EventDeclsInTopState;
      gen.Define(ty, defs);
      gen.compile_list ::= ty;
    }
   
    EmitConcField() : void
    {
    }

    EmitConcCombinations() : void
    {
      foreach (st in gen.ActiveStates)
      {
        def st_gen = GenActiveStateConfig(gen, st, ty);
        //def ty = DefineState(ty, st);
        def ty = st_gen.Emit();
        gen.compile_list ::= ty;
        gen.StateBuilders ::= (st, ty);
      }
    }
    
    public Emit() : void
    {
      GenBaseStruct();
      //if (concurrent_field_pattern) 
        //EmitConcField() else 
        EmitConcCombinations()

    }
  }
}
