using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{

  [Record]
  class HistoryEmitter
  {
    history : PseudoState.History;
    gen : StaticGenerator;
    
    [Memoized]
    name_at_state : string
    {
      get
      {
        $"$(history.state)History"
      }
    }

    name : string
    {
      get
      {
        history.Name
      }
    }
    
    [Memoized]
    save_func_name : string
    {
      get
      {
        $"$(name_at_state)Save"
      }
    }

    [Memoized]
    save_func : ClassMember
    {
      get
      {
        <[
          decl: $(save_func_name : usesite)() : void 
          { 
            $(history.Name : usesite) = cur_state;
          }
        ]>
      }
    }

    [Memoized]
    clear_func_name : string
    {
      get
      {
        $"$(name_at_state)Clear"
      }
    }
    
    [Memoized]
    clear_func : ClassMember
    {
      get
      {
        <[
          decl: $(clear_func_name : usesite)() : void 
          {
              $(name : usesite) = null
          }
        ]>
      }
    }
    
    [Memoized]
    restore_name : string
    {
      get
      {
        get_restore_name(history)
      }
    }
  
    static get_restore_name(h : PseudoState.History) : string
    {
      $"$(h.Name)Restore"
    }
    
    [Memoized]
    restore_func : option[ClassMember]
    {
      get
      {
        if (restore_body is Some(r)) Some(<[decl: $(restore_name : usesite)() : State { $r } ]>) else None()
      }
    }
    
    [Memoized]
    default_tran_name : option[string]
    {
      get
      {
        history.default.Map(_ => $"$(name)DefaultTransition")
      }
    }
    
    [Memoized]
    restore_body : option[PExpr]
    {
      get
      {
        if (default_tran_name is Some(n))
        {
          def body = <[ if ($(name : usesite) != null) // check if
                            $(name : usesite).$(history_restore_name_at_state : usesite)(this); else $(n : usesite)(); ]>;
          Some(body)
        } else None()
      }
    }
    
    [Memoized]
    default_transition : option[ClassMember]
    {
      get
      {
        history.default.Map(x => gen.GetTransitionFunction(default_tran_name.Value, x))
      }
    }
    
    [Memoized]
    history_field : ClassMember
    {
      get
      {
        <[ decl: mutable $(name : usesite) : State ]>
      }
    }
    
    state : HState
    {
      get
      {
        history.state
      }
    }
    
    [Memoized]
    history_restore_name_at_state : string
    {
      get
      {
        get_history_restore_name_at_state(history)
      }
    }
    
    static get_history_restore_name_at_state(h : PseudoState.History) : string
    {
      | PseudoState.History(type = t) when (h.state.history.IsTwo) => $"$(t)HistoryFrom$(h.state)"
      | _                                                          => $"HistoryFrom$(h.state)"
    }
    
    [Memoized]
    restore_func_at_state : ClassMember
    {
      get
      {
        <[decl: public virtual $(history_restore_name_at_state : usesite)(_ : $(gen.ChartName : usesite)) : State { null } ]>
      }
    }
    
    get_history_restore_handler(path : HistoryPath) : ClassMember
    {
      <[decl: public override $(history_restore_name_at_state : usesite)(fsm : $(gen.ChartName : usesite)) : State { fsm.$(path.Name : usesite)() }]>
    }
    
    public static HistoryRestoreCode(hist : PseudoState.History) : PExpr
    {
      if (hist.default.IsSome)
      {
        def name = get_restore_name(hist);
        <[ $(name : usesite)();]>
      } else
      {
        def n    = hist.Name;
        def name = get_history_restore_name_at_state(hist);
        <[ $(n : usesite).$(name : usesite)(this) ]>;
      }
    }
    
    public Emit() : void
    {
      gen.state_builder.Define(restore_func_at_state); // history restore definitions in top state
      def defs = if (restore_func is Some(f)) f :: default_transition.Value :: [] else [];
      def defs = history_field :: clear_func :: save_func :: defs;
      gen.Define(defs); // add definition to state class

      // history restore definitions in state
      foreach ((st, ty) in gen.StateBuilders)
      {
        def paths = st.HistoryPath;
        match (paths.Find(x => x.History == history : object))
        {
          | Some(h) => gen.Define(ty, get_history_restore_handler(h))
          | _       => ()
        }
           
      }
    }
  }

  /// <summary>
  /// Description of History.
  /// </summary>
  [Record]
  class GenHistory
  {
    gen : StaticGenerator;
    history_paths : list[HistoryPath];
    history       : list[PseudoState.History];

    public Define() : void
    {
      foreach (hist in history)
      {
        def emit = HistoryEmitter(hist, gen);
        emit.Emit()
      }

      def body = history_paths.Map(x => (x.Name, x.transition));
      def paths = gen.GetTransitionFunction(body);
      gen.Define(paths)

    }
  }
}
