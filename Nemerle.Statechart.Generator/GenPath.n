using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{
 [Record]
 class GenPath
  {
    public map  : Map[string, string];
    public node : PathNode;
    public util : GenUtil;
    
    //public this(map : Map[string, string], node : PathNode, util : GenUtil) 
    //{
    //  this.map = map;
    //  this.node = node;
    //  this.util = util
    //}
    
    action(name : string) : FsmAction
    {
      FsmAction(-1, name, [])
    }
    
    [Memoized]
    public action_name : FsmAction
    {
      get
      {
        match (node)
        {
          | ClearHistory(hist)                          => def name = hist.HistoryName();
                                                           action($"$(name)Clear")
          | SaveHistory(hist)                           => def name = hist.HistoryName();
                                                           action($"$(name)Save")
          | Action(act)                                 => act
          | Entry(action = act)                         => act//action($"Entry$st")
          | Exit(action = act)                          => act//action($"Exit$st")
          | RunDoActivity(state = st)                   => action($"DoActivity$(st)Run")
          | StopDoActivity(state = st)                  => action($"DoActivity$(st)Stop")
        //| Sequence(lst)                               => lst.SelectMany(CreateActions(_, map))
        //| n                                             => TraverseUtils.SingleElement(FsmAction(-1, n.ToString(), []))
        }
      }
    }
    
    [Memoized]
    public node_name : FsmAction
    {
      get
      {
        match (node)
        {
          | Entry(state = st)                         => action($"Entry$st")
          | Exit(state = st)                          => action($"Exit$st")
          | _                                         => action_name
        //| Sequence(lst)                               => lst.SelectMany(CreateActions(_, map))
        //| n                                             => TraverseUtils.SingleElement(FsmAction(-1, n.ToString(), []))
        }
      }
    }
    
    [Memoized]
    public gen_action : GenAction
    {
      get
      {
        GenAction(action_name, map, util)
      }
    }
    
    [Memoized]
    public node_action : GenAction
    {
      get
      {
        GenAction(node_name, map, util)
      }
    }
    //public GetActions(node : IEnumerable[PathNode]) : PExpr
    //{
    //  def node = node.Exclude(_ is PathNode.Empty);
      
    //  def get_act(n)
    //  {
        
    //  }
      
    //  def body = node.Map(get_act);
    //  <[ {..$body} ]>
    //}
    
    public ExecExpr : PExpr
    {
      get
      {
        match (node)
        {
          | Action
          | Entry                         
          | Exit       => gen_action.ExecExpr
          | _          => gen_action.DeclExecExpr
        //| Sequence(lst)                               => lst.SelectMany(CreateActions(_, map))
        //| n                                             => TraverseUtils.SingleElement(FsmAction(-1, n.ToString(), []))
        }
      }
    }
    
    public TranExecExpr : PExpr
    {
      get
      {
        match (node)
        {
          | Action
          | Entry                         
          | Exit       => node_action.ExecExpr
          | _          => gen_action.DeclExecExpr
        //| Sequence(lst)                               => lst.SelectMany(CreateActions(_, map))
        //| n                                             => TraverseUtils.SingleElement(FsmAction(-1, n.ToString(), []))
        }
        
      }
    }
    
    public BodyFunc : PExpr -> PExpr {get;set;}
    
    public Define() : void
    {
      def act = node_action;
      act.BodyFunc = BodyFunc;
      act.Define()
    }
  }
  
  [Record]
  class GenPathNode
  {
    map  : Map[string, string];
    util : GenUtil;
    
    path : TranPath;
    
    kind : PathKind
    {
      get
      {
        path.kind
      }
    }
    
    [Memoized]
    node : GenPath
    {
      get
      {
        def node = match (kind)
                   {
                     | Entry => PathNode.Entry(state, FsmAction.Empty)
                     | Exit  => PathNode.Exit(state, FsmAction.Empty)
                     | _     => null
                   }
        GenPath(map, node, util, x => x)
      }
    }
    
    state : FsmState
    {
      get
      {
        path.state
      }
    }
    
    [Memoized]
    path_nodes  : list[GenPath]
    {
      get
      {
        path.nodes.Map(x => GenPath(map, x, util, x => x))
      }
    }
    
    [Memoized]
    TranPathNodes : list[GenPath]
    {
      get
      {
        def matched(n)
        {
          match (n.node)
          {
            | PathNode.Entry 
            | Exit
            | Action => true
            | _      => false
          }
        }
        
        path_nodes.Filter(matched)
      }
    }
    
    [Memoized]
    public ExecExpr : PExpr
    {
      get
      {
        def expr = TranPathNodes.Map(x => x.TranExecExpr);
        <[ {..$expr} ]>
      }
    }
    
    [Memoized]
    public HandlerExecExpr : PExpr
    {
      get
      {
        def expr = path_nodes.Map(x => x.ExecExpr);
        <[ {..$expr} ]>
      }
    }
    
    BodyFunc(x : PExpr) : PExpr
    {
      match (kind)
      {
        | Entry => <[ $x; $HandlerExecExpr ]>
        | Exit  => <[ $HandlerExecExpr; $x; ]>
        | _     => x
      }
    }
    
    public Define() : void
    {
      node.BodyFunc = BodyFunc;
      node.Define()
    }
  }
  
  [Record]
  class GenTranPath
  {
    map  : Map[string, string];
    util : GenUtil;
    
    public this(seq : PathSequence, map : Map[string, string], util : GenUtil)
    {
       entry_path = seq.entry_tran_path.Map(GenPathNode(map, util, _));
       exit_path = seq.exit_tran_path.Map(GenPathNode(map, util, _));
       action_path = seq.actions_path.Map(GenPathNode(map, util, _));
       this.map = map;
       this.util = util;
    }
    
    public this(seq : list[TranPath], map : Map[string, string], util : GenUtil)
    {
       def (entry, other) = seq.Partition(x => x.kind == PathKind.Entry);
       entry_path = entry.Map(GenPathNode(map, util, _));
       def (exit, other) = other.Partition(x => x.kind == PathKind.Exit);
       exit_path = exit.Map(GenPathNode(map, util, _));
       def (act, _) = other.Partition(x => x.kind == PathKind.Action);
       action_path = act.Map(GenPathNode(map, util, _));
       this.map = map;
       this.util = util;
    }
    
    //exit_node(st : FsmState) : GenPath
    //{
    //  GenPath(map, PathNode.Exit(st, FsmAction.Empty), util)
    //}
    
    //entry_node(st : FsmState) : GenPath
    //{
    //  GenPath(map, PathNode.Entry(st, FsmAction.Empty), util)
    //}
    
    [Memoized]
    public tran_path : list[GenPathNode]
    {
      get
      {
        exit_path + action_path + entry_path
      }
    }
    
    [Memoized]
    public tran_act_nodes : list[GenPathNode]
    {
      get
      {
        exit_path + entry_path
      }
    }
    
    //[Memoized]
    //exit_nodes : list[GenPath]
    //{
    //  get
    //  {
    //    exit_path.Map((x, _) => GenPath(map, PathNode.Exit(x, FsmAction.Empty), util))
    //  }
    //}
    
    //[Memoized]
    //entry_nodes : list[GenPath]
    //{
    //  get
    //  {
    //    entry_path.Map((x, _) => GenPath(map, PathNode.Entry(x, FsmAction.Empty), util))
    //  }
    //}
    
    public exit_path   : list[GenPathNode];
    public entry_path  : list[GenPathNode];
    public action_path : list[GenPathNode];
    
    
    
    public TranBody : PExpr
    {
      get
      {
        def body = tran_path.Map(x => x.ExecExpr);
        <[ {..$body } ]>
      }
    }
    
    public DefineHandlers() : void
    {
      foreach (act in tran_act_nodes)
      {
        act.Define()
      }
    }
  }
}
