using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using PseudoStateNode;

  /// <summary>
  /// Description of GeneratePseudo.
  /// </summary>
  public partial class StaticGenerator
  {
    get_junction_body(node : DecisionNode, ctx : GenCtx) : PExpr
    {

      def get_cond(t, b, e)
      {
        def c = t.condition;
        def check = GetGuards([c], ctx);
        def act = GetActions(t.Path, true);
        def body = <[ $act; $b ]>;
        match (e)
        {
          | Some(e)                     => 
              <[ 
                if ($check) 
                {
                  $body
                } else $e
              ]>
            
          | _ when c is GuardNode.Empty => body
          | _                           => 
             <[ 
               when ($check) 
               {
                $body
               }
             ]>
        }
      }

      def get_target(t)
      {
        def d = t.destination;
        GetBody(t.Path, d, d.PostConditions, ctx)
      }

      def body = node.Fold(<[ null ]>, get_cond, get_target);
      <[
        {
          res:
            {
              $body
            }
        }
      ]>

    }

    get_choice_body(p : DecisionNode, ctx : GenCtx, ret : bool = true) : PExpr
    {


      def get_body(p, ret = true)
      {
        match (p)
        {
          | DecisionNode.Condition(condition = GuardNode.Empty, body = b, Path = p) => 
              def body = get_body(b);
              def act = GetActions(p, true);
                  <[
                    $act;
                    $body
                  ]>
          | Condition(condition = g, body = b, Path = p, else_node = null) => 
              def body = get_body(b);
              def check = GetGuards([g], ctx);
              def act = GetActions(p, true);
                  <[ 
                    when ($check) 
                    {
                      $act;
                      $body
                    }
                  ]>


          | Condition(condition = c, body = b, else_node = els, Path = np) =>
              def check = GetGuards([c], ctx);
              def path = GetActions(np, true);
              def body = get_body(b);
              def els = if (els is Some(els)) get_body(els); else <[ () ]>;
              <[ 
                  when ($check)
                  {
                    $path;
                    $body;
                  }
                  $els
              ]>

          | Target(destination = d, Path = p) =>

              def dest = GetDestination(d, ctx);
              def jact = GetActions(p, true);
              if (ret)
              <[
                $jact;
                res($dest)
              ]> else
              <[
                $jact;
                $dest
              ]>
        }
      }
      def body = get_body(p, ret);
                <[
                {
                  res:
                    {
                      $body
                    }
                }
                ]>
    }

    DefineHistoryPaths(builder : TypeBuilder, st : GeneralTree[FsmState]) : void
    {
      def create_body(hist)
      {
        def body = <[ fsm.$(hist.GetName() : usesite)(); ]>;
        if (st.Data is FsmState.ConcurrentRegion && st.HaveFinal())
        {
          def tran = (hist.Value :> PseudoStateNode.History).default.Value;
        <[
          if (IsFinal) fsm.$(tran.Value.Name : usesite)() else $body;
        ]>
        } else body
      }

      if (st.IsTopState()) // if it is top state
      {
        def names = analyser.HistoryStates |> get_history_run_name(_, _.Parent.Name()); // get name of history states
        def decls = names |> <[decl: public virtual $(_ : usesite)(_ : $(ChartName : usesite)) : State {null} ]>; // create transition methods for history states
        Define(builder, decls);
      } else
      {
        if (st.Lived() && st.Data is FsmState.Final) 
        {
          def create_body(hist)
          {
            | NodeValue(Value = PseudoStateNode.History(default = Some(d))) => 
            //def tran = hist.Value.default.Value;
              <[ fsm.$(d.Value.Name : usesite)() ]>
            | _ => <[ () ]>
          }

          def hist  =  st.ParticipateInHistory();
          def name  =  hist |> (_, get_history_run_name(_, _.Parent.Name())); // create transition names
          def decl  =  name.MapToList((x, y) => <[decl: public override $(y : usesite)(fsm : $(ChartName : usesite)) : State {$(create_body(x))}]>);
          Define(builder, decl)
        } else
          when (st.HaveHistoryPaths() && (st.Lived() || st.Data is FsmState.ConcurrentRegion)) // if state has history paths or it is lived
          {
            def paths  =  st.HistoryPaths();
            def name  =  paths.Map(x => (x.History, get_history_run_name(x.History, x.From.Name()))); // create transition names
            def decl  =  name.MapToList((x, y) => <[decl: public override $(y : usesite)(fsm : $(ChartName : usesite)) : State {$(create_body(x))}]>);
            Define(builder, decl)
          }
      }

    }

    DefineHistory() : void
    {
      def get_run_hist_body(hist)
      {
        | StateTransition.Default(From = from, history = hist) as t =>
            def name = hist.GetName();
            def hname = get_history_run_name(hist, from.Name());
                <[ 
                if ($(name : usesite) != null) // определяем выбор в случае если есть переход по умолчанию в случ.если нет истории
                    $(name : usesite).$(hname : usesite)(this); else $(DefineTransBody([t], GenCtx.Normal()));
                ]>
      }

      def def_history(h)
      {
        def create_history(hist)
        {
          def hist_field =  <[decl: mutable $(hist.GetName() : usesite) : State;]>;
          def clear = <[decl: $($"$(hist)Clear" : usesite)() : void 
            {
                $(hist.GetName() : usesite) = null
            }]>;    
          def create_default(x)
          {
            def tr = x.Value :> StateTransition.Default;
            [<[decl: $($"$(tr.history)Run" : usesite)() : State {$(get_run_hist_body(tr));} ]>]
          }
          def default = (hist.Value :> PseudoStateNode.History).default.Map(create_default).WithDefault([]);
          [hist_field, clear] + default
        }

        def save_body(hist)
        {
          def idx = hist.Parent.Data.Id.UInt;
          def st : GeneralTree[_] = hist.Parent;
          def reg = st.PartOfRegion();
          def sreg = st.PartOfSubRegion();
          match (reg, sreg)
          {
            | (Some(r), Some(sr)) => 
            //| FsmState(PartOfRegion = Some(r), PartOfSubRegion = Some(sr)) => 
                def name = GetExecStateName(r, GenCtx.Normal());
                def reg = <[ $name.$($"cur_state$(sr.Index())" : usesite); ]>;
                <[ $(hist.GetName() : usesite) = if ($reg != null) $reg.GetCopy($idx) else null ]>
             | _ => 
                // in case where deal with concurrent states
             if (hist.SubStatesParticipateIn().Exists(x => x.Data is FsmState.ConcurrentRegion)) <[ $(hist.GetName() : usesite) = cur_state.GetCopy($idx);]> else
                   // in normal case
                   <[ $(hist.GetName() : usesite) = cur_state; ]>
          }
        }

        def head = h.First();
        def hist_func =  head.SimpleName();

        def body = h.Map(save_body);
            // save history function
        def save =  <[decl: $($"$(hist_func)Save" : usesite)() : void 
            {
              ..$body
            }]>;

        def defs = h.SelectMany(create_history);
        def defs = defs.AddBefore(save);
        // default transitions
        Define(defs); // add definition to state class
      }

      def def_hist(st)
      {
        when (st.History().HasValue)
        {
          def hist = st.UsedHistory();
          when (!hist.IsEmpty()) def_history(hist);
        }
      }

      analyser.LivedNestedStates.Iter(def_hist)
    }

    DefinePseudo() : void
    {
      def get_join(j, a)
      {
        match (j)
        {
          | NodeValue(Value = Join(name = n)) => 

              def fname = $"join$n";
              <[ decl: mutable $(fname : usesite) : int; ]> :: a
          | _ => a
      }
      }

      //def get_junction(j)
      //{
      //  | Junction(Name = n, DecisionTree = t) => <[decl: $(n : usesite)() : State {$(get_junction_body(t, GenCtx.Normal()))} ]>
      //}

      def pseudo = analyser.PseudoStates.Values;
      def defs = pseudo.FoldLeft([], get_join);
      //def junc = $[get_junction(x), x in analyser.Junctions, x.DecisionTree.IsSetDestination];
      //def defs = joins + junc;
      Define(defs);
    }

  }
}
