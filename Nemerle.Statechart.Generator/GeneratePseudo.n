using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;


namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of GeneratePseudo.
  /// </summary>
  public partial class StaticGenerator
  {
    
    get_junction_body(node : DecisionNode) : PExpr
    {

      def loop(n)
      {
        
        | DecisionNode.Condition(g, b) as n =>
        
          def check = GetGuards(g);
          def e = n.else_node;
          def act = GetPath(n.path);
          def body = loop(b);
          match (g)
          {
            | GuardNode.Empty => body
            | _               => 
                    match (e)
                    {
                      | Some(e) => def els = loop(e);
                                   <[ if ($check) 
                                      {
                                        $act;
                                        $body;
                                      } else 
                                      {
                                        $els
                                      } ]>
                      | _       => <[ if ($check) $body else null ]>
                    }
                    
          }
          
         | Target(destination = d, path = seq) => 
            def act = GetPath(seq);
            def target = GetDestination(d);
            <[
              $act;
              $target;
            ]>
      }
      
      loop(node)
    }

#if 0    
    get_choice_body(p : DecisionNode, ctx : GenCtx, ret : bool = true) : PExpr
    {


      def get_body(p, ret = true)
      {
        match (p)
        {
          | DecisionNode.Condition(condition = GuardNode.Empty, body = b, Path = p) => 
              def body = get_body(b);
              def act = GetActions(p, true);
                  <[
                    $act;
                    $body
                  ]>
          | Condition(condition = g, body = b, Path = p, else_node = null) => 
              def body = get_body(b);
              def check = GetGuards([g], ctx);
              def act = GetActions(p, true);
                  <[ 
                    when ($check) 
                    {
                      $act;
                      $body
                    }
                  ]>


          | Condition(condition = c, body = b, else_node = els, Path = np) =>
              def check = GetGuards([c], ctx);
              def path = GetActions(np, true);
              def body = get_body(b);
              def els = if (els is Some(els)) get_body(els); else <[ () ]>;
              <[ 
                  when ($check)
                  {
                    $path;
                    $body;
                  }
                  $els
              ]>

          | Target(destination = d, Path = p) =>

              def dest = GetDestination(d, ctx);
              def jact = GetActions(p, true);
              if (ret)
              <[
                $jact;
                res($dest)
              ]> else
              <[
                $jact;
                $dest
              ]>
        }
      }
      def body = get_body(p, ret);
                <[
                {
                  res:
                    {
                      $body
                    }
                }
                ]>
    }

  #endif

    DefineHistoryPaths(builder : TypeBuilder, st : ActiveStateConfig) : void
    {
      def create_body(hist : HistoryPath)
      {
        <[ fsm.$(hist.Name : usesite)(); ]>;
      }

      if (builder : object == state_builder)
      {
        def name = HistoryStates.Map(x => get_history_run_name(x)); // get name of history states
        def decls = name.Map(x => <[decl: public virtual $(x : usesite)(_ : $(ChartName : usesite)) : State { null } ]>); // create transition methods for history states
        Define(builder, decls)
      } else
      {
        def paths  =  st.HistoryPath;
        def name  =  paths.Map(x => (x, get_history_run_name(x.History))); // create transition names
        def decl  =  name.MapToList((x, y) => <[decl: public override $(y : usesite)(fsm : $(ChartName : usesite)) : State {$(create_body(x))}]>);
        Define(builder, decl)
      }
    }

    DefineHistory() : void
    {
      def get_run_hist_body(h, tran)
      {
        | (hist, Transition as t) =>
            def name = hist.Name;
            def hname = get_history_run_name(hist);
            //null
                <[ 
                if ($(name : usesite) != null) // определяем выбор в случае если есть переход по умолчанию в случ.если нет истории
                    $(name : usesite).$(hname : usesite)(this); else $(DefineTransBody(t));
                ]>
      }

        def create_history(hist)
        {
          def hist_field =  <[decl: mutable $(hist.Name : usesite) : State;]>;
          def clear = <[decl: $($"$(hist)Clear" : usesite)() : void 
            {
                $(hist.Name : usesite) = null
            }]>;

          def create_default(h, tr)
          {
            [<[decl: $($"$(h)Run" : usesite)() : State {$(get_run_hist_body(h, tr));} ]>]
          }

          def default = hist.default.Map(create_default(hist, _)).WithDefault([]);
          [hist_field, clear] + default
        }

        def save_body(hist)
        {
          <[ $(hist.Name : usesite) = cur_state; ]>
        }


      foreach (hist in HistoryStates)
      {
                //def head = h.First();
        def hist_func =  $"$(hist.state)History";

        def body = save_body(hist);//hist.Map();
            // save history function
        def save =  <[decl: $($"$(hist_func)Save" : usesite)() : void { $body }]>;
        match (hist.default)
        {
          | Some(t) => Define(GetTransitionFunction(t))
          | _       => ()
        }
        
        def defs = create_history(hist);//.SelectMany();
        def defs = defs.AddBefore(save);
        // default transitions
        Define(defs); // add definition to state class
      }
      
      def body = HistoryPaths.Map(x => (x.Name, x.transition));
      def paths = GetTransitionFunction(body);
      Define(paths)
    }

    DefinePseudo() : void
    {
      //def get_join(j, a)
      //{
      //  match (j)
      //  {
      //    | Join(name = n) => 

      //        def fname = $"join$n";
      //        <[ decl: mutable $(fname : usesite) : int; ]> :: a
      //    | _ => a
      //  }
      //}

      //def pseudo = analyser.PseudoStates;
      //def defs = pseudo.FoldLeft([], get_join);
      //Define(defs);
    }

  }
}
