using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;


namespace Nemerle.Statechart
{
  using PseudoStateNode;

  /// <summary>
  /// Description of GeneratePseudo.
  /// </summary>
  public partial class StaticGenerator
  {
    
    get_junction_body(node : DecisionNode, ctx : GenCtx) : PExpr
    {

      def loop(n)
      {
        
        | DecisionNode.Condition(g, b, e) =>
        
          def check = GetGuards(g, ctx);
          //def acts = if (c.path != null) GetPath(c.path) else <[]>;
          def body = loop(b);
          match (g)
          {
            | GuardNode.Empty => body
            | _               => 
                    match (e)
                    {
                      | Some(e) => def els = loop(e);
                                   <[ if ($check) $body else $els ]>
                      | _       => <[ if ($check) $body else null ]>
                    }
                    
          }
          
         | Target(destination = d, path = seq) => GetBody(seq, d, d.PostConditions, ctx)
      }
      
      loop(node)
      //<[
      //  {
      //    res:
      //      {
      //        $body
      //      }
      //  }
      //]>
    }

#if 0    
    get_choice_body(p : DecisionNode, ctx : GenCtx, ret : bool = true) : PExpr
    {


      def get_body(p, ret = true)
      {
        match (p)
        {
          | DecisionNode.Condition(condition = GuardNode.Empty, body = b, Path = p) => 
              def body = get_body(b);
              def act = GetActions(p, true);
                  <[
                    $act;
                    $body
                  ]>
          | Condition(condition = g, body = b, Path = p, else_node = null) => 
              def body = get_body(b);
              def check = GetGuards([g], ctx);
              def act = GetActions(p, true);
                  <[ 
                    when ($check) 
                    {
                      $act;
                      $body
                    }
                  ]>


          | Condition(condition = c, body = b, else_node = els, Path = np) =>
              def check = GetGuards([c], ctx);
              def path = GetActions(np, true);
              def body = get_body(b);
              def els = if (els is Some(els)) get_body(els); else <[ () ]>;
              <[ 
                  when ($check)
                  {
                    $path;
                    $body;
                  }
                  $els
              ]>

          | Target(destination = d, Path = p) =>

              def dest = GetDestination(d, ctx);
              def jact = GetActions(p, true);
              if (ret)
              <[
                $jact;
                res($dest)
              ]> else
              <[
                $jact;
                $dest
              ]>
        }
      }
      def body = get_body(p, ret);
                <[
                {
                  res:
                    {
                      $body
                    }
                }
                ]>
    }

  #endif

    DefineHistoryPaths(builder : TypeBuilder, st : FsmState) : void
    {
      def create_body(hist : HistoryPath)
      {
        def body = <[ fsm.$(hist.Name : usesite)(); ]>;
        if (st.type is StateType.Region && st.HaveFinal)
        {
          def tran = hist.History.default.Value;
        <[
          if (IsFinal) fsm.$(tran.Name : usesite)() else $body;
        ]>
        } else body
      }

      if (st.IsTopState) // if it is top state
      {
        def names = analyser.HistoryStates.Map(x => get_history_run_name(x, x.state.Name)); // get name of history states
        def decls = names.Map(x => <[decl: public virtual $(x : usesite)(_ : $(ChartName : usesite)) : State {null} ]>); // create transition methods for history states
        Define(builder, decls);
      } else
      {
        if (st.Lived && st.type is StateType.Final) 
        {
          def create_body(hist)
          {
            | PseudoStateNode.History(default = Some(d)) => 
            //def tran = hist.Value.default.Value;
              <[ fsm.$(d.Name : usesite)() ]>
            | _ => <[ () ]>
          }

          def hist  =  st.ParticipateInHistory;
          def name  =  hist.Map(x => (x, get_history_run_name(x, x.state.Name))); // create transition names
          def decl  =  name.MapToList((x, y) => <[decl: public override $(y : usesite)(fsm : $(ChartName : usesite)) : State {$(create_body(x))}]>);
          Define(builder, decl)
        } else
          when (st.HaveHistoryPaths && (st.Lived || st.type is StateType.Region)) // if state has history paths or it is lived
          {
            def paths  =  st.HistoryPaths;
            def name  =  paths.Map(x => (x, get_history_run_name(x.History, x.From.Name))); // create transition names
            def decl  =  name.MapToList((x, y) => <[decl: public override $(y : usesite)(fsm : $(ChartName : usesite)) : State {$(create_body(x))}]>);
            Define(builder, decl)
          }
      }

    }

    DefineHistory() : void
    {
      def get_run_hist_body(h, tran)
      {
        | (hist, StateTransition(From = from) as t) =>
            def name = hist.Name;
            def hname = get_history_run_name(hist, from.Name);
                <[ 
                if ($(name : usesite) != null) // определяем выбор в случае если есть переход по умолчанию в случ.если нет истории
                    $(name : usesite).$(hname : usesite)(this); else $(DefineTransBody(t, GenCtx.Normal()));
                ]>
      }

      def def_history(h : list[_])
      {
        def create_history(hist)
        {
          def hist_field =  <[decl: mutable $(hist.Name : usesite) : State;]>;
          def clear = <[decl: $($"$(hist)Clear" : usesite)() : void 
            {
                $(hist.Name : usesite) = null
            }]>;

          def create_default(h, tr)
          {
            [<[decl: $($"$(h)Run" : usesite)() : State {$(get_run_hist_body(h, tr));} ]>]
          }

          def default = hist.default.Map(create_default(hist, _)).WithDefault([]);
          [hist_field, clear] + default
        }

        def save_body(hist)
        {
          def idx = hist.state.Id.UInt;
          def st = hist.state;
          def reg = st.PartOfRegion;
          def sreg = st.PartOfSubRegion;
          match (reg, sreg)
          {
            | (Some(r), Some(sr)) => 
            //| FsmState(PartOfRegion = Some(r), PartOfSubRegion = Some(sr)) => 
                def name = GetExecStateName(r, GenCtx.Normal());
                def reg = <[ $name.$($"cur_state$(sr.Index)" : usesite); ]>;
                <[ $(hist.Name : usesite) = if ($reg != null) $reg.GetCopy($idx) else null ]>
            | _ => 
                // in case where deal with concurrent states
                if (hist.SubStatesParticipateIn.Exists(x => x.type is StateType.Region)) <[ $(hist.Name : usesite) = cur_state.GetCopy($idx);]> else
                  // in normal case
                   <[ $(hist.Name : usesite) = cur_state; ]>
          }
        }

        def head = h.First();
        def hist_func =  head.SimpleName;

        def body = h.Map(save_body);
            // save history function
        def save =  <[decl: $($"$(hist_func)Save" : usesite)() : void 
            {
              ..$body
            }]>;

        def defs = h.SelectMany(create_history);
        def defs = defs.AddBefore(save);
        // default transitions
        Define(defs); // add definition to state class
      }

      def def_hist(st)
      {
        when (st.history.HasValue)
        {
          def hist = st.UsedHistory.NToList();
          when (!hist.IsEmpty()) def_history(hist);
        }
      }

      analyser.LivedNestedStates.Iter(def_hist)
    }

    DefinePseudo() : void
    {
      def get_join(j, a)
      {
        match (j)
        {
          | Join(name = n) => 

              def fname = $"join$n";
              <[ decl: mutable $(fname : usesite) : int; ]> :: a
          | _ => a
        }
      }

      //def get_junction(j)
      //{
      //  | Junction(Name = n, DecisionTree = t) => <[decl: $(n : usesite)() : State {$(get_junction_body(t, GenCtx.Normal()))} ]>
      //}

      def pseudo = analyser.PseudoStates;
      def defs = pseudo.FoldLeft([], get_join);
      //def junc = $[get_junction(x), x in analyser.Junctions, x.DecisionTree.IsSetDestination];
      //def defs = joins + junc;
      Define(defs);
    }

  }
}
