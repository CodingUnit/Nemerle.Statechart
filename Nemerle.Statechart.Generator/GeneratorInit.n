using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using Nemerle.Statechart;
using System.Threading.Tasks;
using System.Collections.Concurrent;
using System.Threading;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of GeneratorInit.
  /// </summary>
  public partial class StaticGenerator
  {
    DefineMain() : void
    {
      def def_initial(i)
      {
        DefineTransBody(i, GenCtx.Normal());
      }
      
      def initial = def_initial(analyser.TopState.initial_tran); // define initial transition
      def events = analyser.Events.Map(x => <[ $x ]>);
      def states = analyser.LivedNestedStates.Exclude(_.IsTopState).Map(x => <[ $(x.Name : string) ]>);
      def state_names = $[(st.Name, $"State$(st)"), st in analyser.LivedNestedStates, st.UsedInGenerate && !st.IsTopState && !(st.type is StateType.SubRegion)]; // создаем имена состояний      
      //def state_init_expr = state_names.Map((x, y) => <[ $(y : usesite) = State.$(x : usesite)();]>);
      def cons_expr = constructor.MapDefault(x  => <[ $(x : usesite)(); ]>, <[ () ]>);
      def trans_complete_expr =  if (analyser.FsmFlags.TransitionCompleted) <[ OnTransitionCompleted(); ]> else <[ () ]>;
      def actions = actions.Exclude(_.IsDeclared);
      def actions = actions.RemoveDuplicatesSort(_.end_name);
      def actions = actions.Map(x => <[ $(x.exec_name) ]>);
      def dummy =  <[decl:
                  class Test
                  {
                    [Accessor] mutable cur_state : State;

                    // define constructor
                    public this()
                    {
                        // constructor body
                        //{..$state_init_expr}
                        {..$init_exprs}
                        $cons_expr;
                    }

                    
                    // define method for changing state
                    TrySwitch(st : State) : void
                    {
                       when (st != null)
                       {
                         cur_state = st;
                         $trans_complete_expr;
                       }
                    }

                    // define method for changing state
                    Switch(st : State) : void
                    {
                        //IsEventDeclined = false;
                        cur_state = st;
                        $trans_complete_expr;
                    }

                    public IsTerminated : bool
                    {
                      get
                      {
                        cur_state == null
                      }
                    }

                    QueueThread() : void
                    {
                      while (!IsTerminated)
                      {
                        mutable item;
                        if (queue.TryDequeue(out item))
                        {
                          SendEvent(item)
                        } else 
                        {
                          _ = reset_event.Reset();
                          _ = reset_event.WaitOne()
                        }
                      }
                    }
                    
                    public PostEvent(evt : Event) : void
                    {
                      queue.Enqueue(evt);
                      _ = reset_event.Set();
                    }
                    
                    //public IsEventDeclined : bool {get;private set;}
                    public Initiate() : void
                    {
                        queue_thread = Thread(QueueThread);
                        _ = reset_event.Reset();
                        Switch($initial);
                        queue_thread.Start();
                    }

                    public override ToString() : string
                    {
                        cur_state.ToString()
                    }

                    public static ContainsStates : array[string] = array[..$states];
                    public static ProcessEvents  : array[string] = array[..$events];
                    public static ExecActions    : array[string] = array[..$actions];
                    
                    mutable queue_thread : Thread;
                    queue : ConcurrentQueue[Event] = ConcurrentQueue();
                    reset_event : ManualResetEvent = ManualResetEvent(false);
                  }

                  ]>;
      when (analyser.FsmFlags.TestingFeatures) ty.AddImplementedInterface(<[ Nemerle.Statechart.IStateMachine ]>);
      Define(state_names.Map((x, y) =>  <[decl: $(y : usesite) : State.$(x : usesite) = State.$(x : usesite)(); ]>)); // create state variables for fast using 
      Define(dummy.td.GetMembers());
    }

    /// <summary>
    /// Define initial class structure
    /// </summary>
    DefineInit() : void
    {
      DefineMain();
      DefineStates(); // define states
      when (analyser.FsmFlags.TransitionCompleted)
      {
        DefineEvent("TransitionCompleted");
      }
      DefineIsInState();
      DefineTerminate();
      DefineTesting();
    }

    DefineTerminate() : void
    {
      def stop_activity(act)
      {
        def name = act.Name;
        <[
          $($"$(name)Stop" : usesite)();
        ]>
      }

      def stop_body = analyser.DoActivities.Map(stop_activity);
      def terminate = <[ decl: public Terminate() : void
                         {
                           {..$stop_body}
                           cur_state = null;
                           _ = reset_event.Set();
                           when (Thread.CurrentThread != queue_thread : object) queue_thread.Join();
                         }
                      ]>;
      Define(terminate);
    }

    DefineIsInState() : void
    {
      def create_comp_expr(st_id)
      {
        //def comp = TopState.Id.Result;
        def comp = ListUtils.Init(StatesId.Length, i => <[ cur_id.$($"id$i" : usesite) & id.$($"id$i" : usesite) == id.$($"id$i" : usesite) ]>);
        def expr = MergeExpr(comp, (x,y) => <[ $x && $y ]>);
        <[
          def id = $st_id;
          def cur_id = cur_state.get_id();
          $expr
        ]>
      }

      //def id = TopState.Id;

      def get_body(st_id)
      {
        if (StatesId.IsSimple)
        {
          match (st_id)
          {
            | <[ $(_ : usesite) ]> => <[ cur_state.get_id() & id == id ]>
            | _ => <[
                      def id = $st_id;
                      cur_state.get_id() & id  == id 
                   ]>
          }
        } else
        {
          def ids = StatesId;
          def names = ListUtils.Init(ids.Length, i => $"id$i");
          def mem = if (ids.IsStruct)
                     {
                       def ids = names.Map(x => <[decl: public $(x : usesite) : uint; ]>);
                       def vars = names.Map(x => <[parameter: $(x : usesite) : uint]>);
                       def assign = names.Map(x => <[ this.$(x : usesite) = $(x : usesite)]>);
                       def ctor = <[decl: public this(..$vars)
                                                      {
                                                        ..$assign
                                                      }]>;
                       def ids = ctor :: ids;
                        <[decl: struct LongId
                          {
                          ..$ids
                          } ]>
                     } else
                     {
                       def ids = names.Map(x => <[decl: public mutable $(x : usesite) : uint; ]>);
                        <[decl: class LongId
                          {
                          ..$ids
                          }
                        ]>
                     }
          DefineNested(mem).Compile();
          create_comp_expr(st_id);
        }
      }
      def is_in_state = <[decl:
                public IsInState(st : State) : bool
                {
                  IsInState(st.get_id())
                }
            ]>;
      def id_type = StateIdType;
      def is_in_state2 = <[decl:
                public IsInState(id : $id_type) : bool
                {
                  $(get_body(<[ id ]>))
                }
            ]>;
      def st_is_in_state = <[decl: static IsInState(cur_state : State, st : State) : bool
                            {
                              $(get_body(<[ st.get_id() ]>))
                            }
                            ]>;
                            
      def states = analyser.LivedNestedStates.Exclude(_.IsTopState);
      def mexpr = states.FoldRight([<[case: | _ => throw InvalidOperationException("Invalid state") ]>], 
                                   (x, a) => <[case: | $(x.Name : string) => State.$(x.Name : usesite).Id()]> :: a);
      def str_is_in_state = <[decl: public IsInState(st : string) : bool
                              {
                                def id = match (st) {..$mexpr };
                                IsInState(id)
                              } ]>;
      Define([is_in_state, is_in_state2, st_is_in_state, str_is_in_state]);
    }


    Init() : void
    {

      InitActionNames();

      //tran_events = analyser.Events.;
      events = analyser.Events.NToList();
      events_call = Map(events.Map(x => (x, <[ cur_state.$(x : usesite)(this) ]>)));
      //history_paths = analyser.HistoryPaths.Select(x => (x.Key, x.Value)).Map((x, y) => (x.Name(), GenAction.CreateActions(y.Path, action_for)));
      //history_transitions = analyser.history_transitions.Map((x, y) => (x, GenAction.CreateActions(y.PathNode, action_for)));
      history_def_transitions = analyser.history_default_transitions.Map(x => (x.Name, GenAction.CreateActions(x.PathNode, action_for)));
    }

    InitActionNames() : void
    {
      def action_for_name(macros)
      {
        |  <[ $_($name) ]>  => name.ToString()
        | _                 => macros.ToString()
      }

      def class_decls  =  ty.GetParsedMembers(false);
      method_decls = class_decls.Filter(_ is ClassMember.Function).Map(x => x.Name);
      def macros = class_decls.Map(x => (x.Name, x.ParsedAttributsAndModifiers.ParsedCustomAttributes));
      def macros = macros.Filter((_, x)  => !x.IsEmpty());
      macro_actions  =  Map(macros);
      decls = Map(class_decls.Map(x => (x.Name, x)));

      def declared = decls.Keys();
      def action_for_decls =  macros.FindSingleList(_ is <[ ActionFor($_) ]>);
      def event_for_decls =  macros.FindSingleList(_ is <[ EventFor($_) ]>);
      def guard_for_decls = macros.FindSingleList(_ is <[ GuardFor($_) ]>);
      constructor =  macros.FindSingle(_ is <[Constructor]>).Map(x => x[0]);

      def decl = declared.Map(x => (x, x)).NToList();
      def action = action_for_decls.Map((x, y) => (action_for_name(y), x));
      def evt = event_for_decls.Map((x, y) => (action_for_name(y), x));
      def methods = method_decls.Map(x => (x, x));
      action_for = Map(action + methods);
      event_for = Map(evt + methods);
      def guard = guard_for_decls.Map((x, y) => (action_for_name(y), x));
      def guard = guard + decl;
      def guard = guard.RemoveDuplicatesSort(((k1, _), (k2, _))  => k1.CompareTo(k2));
      guard_for = Map(guard);

      def acts = analyser.action_node_all;
      def acts = acts.Filter(x => {
                               | PathNode.ClearHistory
                               | PathNode.RunDoActivity
                               | PathNode.StopDoActivity => false
                               | _                       => true
                             });
      def acts = acts.SelectMany(GenAction.GetActions(_, action_for));
      def acts = acts.RemoveDuplicatesSort(_.action);
      actions = acts;
    }

  }

}
