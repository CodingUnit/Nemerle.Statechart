using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;
using System.Threading.Tasks;
using System.Threading;

namespace Nemerle.Statechart
{

  class GenActivity
  {
    activity : StateAction.Do;
    map : Map[string, string];
    util : GenUtil;
    
    //[FlagAccessor (Concurrently,  NoWaitCancel, NotLong)]
    flags : ActivityFlag;

    public InitExpr : list[PExpr] {get;set;default []}
    
    actions : list[FsmAction]
    {
      get
      {
        activity.actions
      }
    }

    [Memoized]
    action_list : list[GenElement]
    {
      get
      {
        def acts = actions.Map(x => x.name);
        acts.Map(x => GenElement(x, map))
      }
    }

    public Name : string
    {
      get
      {
        activity.Name
      }
    }

    public this(act : StateAction.Do, map : Map[string, string], util : GenUtil)
    {
      activity = act;
      flags = activity.flags;
      this.map = map;
      this.util = util;
    }

    public act_exec_name : string
    {
      get
      {
        $"$(Name)Actions"
      }
    }

    public activity_start_name : string
    {
      get
      {
        $"$(Name)Run"
      }
    }
    
    public activity_stop_name : string
    {
      get
      {
        $"$(Name)Stop"
      }
    }
    
    public run_action_name : string
    {
      get
      {
        $"$(act_exec_name)Action"
      }
    }
    
    public task_name : string
    {
      get
      {
        $"$(Name)Task"
      }
    }

    public CancelSourceName : string
    {
      get
      {
        $"$(Name)CancelSource"
      }
    }

    GenBaseStruct() : void
    {
      //def act = act.Map(x => x.name);
            //def name = do_act.Name;
            //def actions = $"$(name)Actions";
            //def cancel_source = CancelSourceName;
            //def act_list = act.Map(x => GenElement(x, action_for));//act |> $"On$_";
            // events for not declared actions
      def not_def_act = action_list.Exclude(_.IsDeclared);
      not_def_act.Iter(x => util.DefineEvent(x.name, <[ Action[CancellationToken] ]>, [<[parameter: tok : CancellationToken ]>], <[ tok ]>));

      util.Define(<[decl: task_factory : TaskFactory = TaskFactory(); ]>);
            // cancellation source
      util.Define(<[decl: mutable $(CancelSourceName : usesite) : CancellationTokenSource; ]>);
      util.Define(<[decl: mutable $(task_name : usesite) : Task;]>); // declare task
      
      // creation of action
      InitExpr ::= <[ $(run_action_name : usesite) = Action($(act_exec_name : usesite)) ]>;
      util.Define(<[decl: $(run_action_name : usesite) : Action; ]>); // action for task
    }

    DefineActions() : void
    {
      def act_body = match (action_list)
                      {
                        | head :: [] => <[ $(head.ExecName : usesite)($(CancelSourceName : usesite).Token); ]>
                        | _          => def run_acts = action_list.Map(x => <[ $(x.ExecName : usesite)(tok); ]>);
                                        <[ 
                                            def tok = $(CancelSourceName : usesite).Token;
                                            {..$run_acts}
                                        ]>

                      }
      util.DefineMethod(act_exec_name, act_body);
    }
    
    GenRunBody() : void
    {
      //init_exprs.Add(<[ $(run_act : usesite) = ;]>); // create action
      
      def task = if (activity.need_completion) 
      {
        <[ Task.Factory.StartNew($(run_action_name : usesite), $(CancelSourceName : usesite).Token).ContinueWith(CompletionAfterActivityAction) ]>
      } else
      {
        <[ Task.Factory.StartNew($(run_action_name : usesite), $(CancelSourceName : usesite).Token) ]>;
      }
      util.Define(<[decl: $(activity_start_name : usesite)() : void
                          {
                            $(CancelSourceName : usesite) = System.Threading.CancellationTokenSource();
                            $(task_name : usesite) = $task;
                          } ]>);
    }

    //GetRunBodyConc() : PExpr
    //{
    //  def acts    = act_list.Map(x => if (x.IsDeclared) (x, x.name) else (x, $"$name$(x)Action"));
    //                                      def act_run = acts.Exclude((x, _) => x.IsDeclared);
    //                                      gen_members = gen_members.HeadAppend(act_run.Map((n, x) => <[decl: $(x : usesite) : Action = () => $(n.exec_name : usesite)($(cancel_source : usesite).Token);]>));
    //                                      def tasks = act.Map(x => $"$task$x");
    //                                      def task_arr = <[decl: mutable $(task : usesite) : array[Task] = array($(tasks.Length));]>;
    //                                      gen_members ::= task_arr;
    //                                      def stop = if (no_wait) <[ () ]> else <[ Task.WaitAll($(task : usesite)); ]>;
    //                                      def tasks = acts.MapIndex(((_, y), i) => 
    //                                                                    if (not_long) <[$(task : usesite)[$i] = Task.Factory.StartNew($(y : usesite), tok, TaskCreationOptions.None, TaskScheduler.Current);]> else
    //                                          <[ $(task : usesite)[$i] = Task.Factory.StartNew($(y : usesite), tok); ]>
    //                                          );
    //                                      (<[ $tok;{..$tasks}]>, <[ $stop ]>)
    //}


    GenStopBody() : void
    {
      util.Define(<[decl: $(activity_stop_name : usesite)() : void
              {
                when ($(CancelSourceName : usesite) != null)
                {
                  try
                  {
                    $(CancelSourceName : usesite).Cancel();
                    $(task_name : usesite).Wait();
                  }
                  catch
                  {
                    |_ is AggregateException => ()
                  }
                }
              } ]>);
    }

    public Generate() : void
    {
      GenBaseStruct();
      DefineActions();
      GenRunBody();
      GenStopBody();
    }
    
    //GetStopBodyConc() : PExpr
    //{
    //}
  }

  /// <summary>
  /// Description of GenActivity.
  /// </summary>
  partial class StaticGenerator
  {

    DefineDoActivity() : void
    {
      def act = analyser.DoActivities;
      when (!act.IsEmpty())
      {
        def have_completion = act.Exists(_.need_completion);
        when (have_completion)
          {
            init_exprs ::= <[ CompletionAfterActivityAction = Action(CompletionAfterActivity); ]>;
            Define(<[decl: CompletionAfterActivityAction : Action[Task]; ]>);
            Define(<[ decl: CompletionAfterActivity(_ : Task) : void
                        {
                          Completion()
                        } ]>);
          }
        foreach (act in act)
        {
          def act = GenActivity(act, action_for, util);
          act.Generate();
          init_exprs += act.InitExpr;
        }
        
      }
    }


  }
}
