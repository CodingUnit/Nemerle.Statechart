using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Threading;

namespace Nemerle.Statechart
{
  
  
  //using GuardNode;
  // TODO: Action events with flag
  /// <summary>
  /// Description of StaticGenerator.
  /// </summary>
  public partial class StaticGenerator
  {

    DefineState(ty : TypeBuilder, type : ClassMember.TypeDeclaration, st : ActiveStateConfig) : TypeBuilder
    {
      def type = DefineNested(ty, type);// else this.ty.GlobalEnv.Define(type);
      //DefineActions(type, st);
      DefineTransitions(type, st); // define transitions in state
      DefineHistoryPaths(type, st); // define history paths
      //match (st)
      //{
      //  | _ when st.IsTopState      => DefineRegions(type);
      //  | _                         => ()
      //}
      type
    }

    DefineState(builders : list[TypeBuilder], ty : TypeBuilder, st : ActiveStateConfig) : list[TypeBuilder]
    {
      //match (st)
      //{
      //  | _ when (!st.IsTopState && st.UsedInGenerate) => 
          def id_type = StateIdType;
          def (expr, _) = GetId(st.Id);

          def type = <[ variant_option: |  $(st.name : usesite)
                            {
                                public override get_id() : $id_type {$expr}

                                public static Id() : $id_type
                                {
                                    $expr
                                }

                                public override ToString() : string
                                {
                                    $(st.name)
                                }
                            } 
                     ]>;
        
            def type = DefineState(ty, type, st);
            type :: builders
      //  | _ => builders
      //}
    }

    //TopState : FsmState
    //{
    //  get
    //  {
    //    analyser.TopState
    //  }
    //}
    
    DefineStates() : void
    {
      //def st = TopState;
      def id_type = StateIdType;
      def default = StateIdDefaultValue;
      def top = <[decl:
                  public variant State : HsmState//$(name : usesite)
                  {

                      //public virtual GetCopy(_ : int) : State {this}
                      public virtual get_id() : $id_type { $default }

                      public override ToString() : string
                      {
                        null
                      }
                  } ]>;
      def ty = DefineNested(ty, top);
      state_builder = ty;
      Define(ty, <[decl: public virtual IsDefer(_ : Event) : bool { false } ]>);
      def defs = Events.Map(x => <[ decl: public virtual $(x.Name : usesite)(_ : $(ChartName : usesite)) : State { null } ]>);
      DefineHistoryPaths(ty, null);
      Define(ty, defs);
      def builders = ActiveStates.Fold(ty :: compile_list, (s, a) => DefineState(a, ty, s));
      compile_list = builders;
    }

    DefineEvents() : void
    {
      def evt = GenEvent(this, Events);
      evt.Generate()
    }

    DefineGuards() : void
    {
    }    

    DefineActions() : void
    {
      foreach (act in actions)
      {
        DefineActionEvent(act)
      }
      
      def gen_paths = GenTranPath(path_state_actions, action_for, util, FsmFlags);
      gen_paths.DefineHandlers()
    }

    DefineSubMachines() : void
    {
      def clone(f)
      {
        | ClassMember.Function(name = n) as f => ClassMember.Function(f.Location, n, f.modifiers, f.header, f.implemented, f.body)
      }
      
      def top = ty.Manager.Hierarchy.TopTypeBuilders();
      def this_mems = ty.AstParts.SelectMany(x => x.GetMembers()).Select(_.Name);
      foreach (st in LoadedMachines)
      {
        match (top.Find(x => x.Name == st.Key))
        {
          | Some(t) => def mems = t.GetParsedMembers();
                       foreach (m in mems)
                       {
                         when (!this_mems.Exists(x => x == m.Name))
                         {
                           def m = match (m)
                           {
                             | ClassMember.Property(name = n, modifiers = mod, parameters = pp, getter = g, setter = s, initializer = i) as p =>
                                 ClassMember.Property(p.Location, n, mod, p.returnType, pp, g.Map(clone), s.Map(clone), i)
                             | _                      => m
                           }
                           ty.Define(m)
                         }
                       }
          | _       => ()
        }
        
      }
    }
  }
}
