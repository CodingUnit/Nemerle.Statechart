using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;
using System.Threading.Tasks;
using System.Threading;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using GuardNode;
  // TODO: Action events with flag
  /// <summary>
  /// Description of StaticGenerator.
  /// </summary>
  public partial class StaticGenerator
  {

    DefineState(ty : TypeBuilder, type : ClassMember.TypeDeclaration, st : GeneralTree[FsmState]) : TypeBuilder
    {
      def type = DefineNested(ty, type);
      DefineActions(type, st);
      DefineTransitions(type, st); // define transitions in state
      DefineHistoryPaths(type, st); // define history paths
      match (st.Data)
      {
        | SubMachine as st            => DefineSubMachine(type, st);
        | _ when st.IsTopState()      => DefineRegions(type);
        | _                           => ()
      }
      type
    }

    DefineState(builders : list[TypeBuilder], ty : TypeBuilder, st : GeneralTree[FsmState]) : list[TypeBuilder]
    {
      match (st.Data)
      {
        //| Final
        | _ when (!st.IsTopState() && st.UsedInGenerate()) => 
        //| InlinedSubMachineInstance
        //| InlinedSubMachine => 
          def id_type = StateIdType;
          def (expr, _) = GetId(st.Data.Id);

          def type = <[ variant_option: |  $(st.Name() : usesite)
                            {
                                public override get_id() : $id_type {$expr}

                                public static Id() : $id_type
                                {
                                    $expr
                                }

                                public override ToString() : string
                                {
                                    $(st.Name())
                                }
                            } 
                     ]>;
            def type = DefineState(ty, type, st);
            type :: builders

        | _ => builders
      }
    }

    TopState : GeneralTree[FsmState]
    {
      get
      {
        analyser.TopState
      }
    }

    DefineStates() : void
    {
      def st = TopState;
      def id_type = StateIdType;
      def default = StateIdDefaultValue;
      //def (_, default) = GetId(st.Id);
      def top = <[decl:
                  public variant State
                  {

                      public virtual GetCopy(_ : int) : State {this}
                      public virtual get_id() : $id_type { $default }

                      public override ToString() : string
                      {
                        $(FsmState.TopStateName)
                      }
                  } ]>;
      def ty = DefineState(ty, top, st);
      def builders = TopState.Fold(ty :: compile_list, 
                                   (s, a) => DefineState(a, ty, s));
      compile_list = builders;
    }

    DefineSubMachine(type : TypeBuilder, st : FsmState.SubMachine) : void
    {
      def field = <[decl: machine : $(st.type : usesite);]>;
      type.Define(field);
    }

    DefineEvents() : void
    {
      def get_body(e)
      {
        <[ 
           lock (this)
           {
             TrySwitch($(events_call.Get(e.name)));
           }
        ]>
      }

      def decl_events = events;
      def decl_events = decl_events |> <[decl: | $(_ : usesite) ]>;
      DefineNested(<[ decl:
            public enum Event
            {
              ..$decl_events
            }]>).Compile();
      def events = events |> GenElement(_, event_for);
      def (hiden, defs) = events.Partition(_.IsDeclared);
      def def_events = events.Map(x => (x, x.Declared));
      def hiden = hiden.Filter(x => !method_decls.Contains(x.name));
      def hiden = hiden.Select(x => <[decl: private $(x.name : usesite)() : void {$(get_body(x))} ]>);
      def defs  = defs.Select(x => <[decl: public $(x.name : usesite)() : void {$(get_body(x))} ]>).Concat(hiden);

      def evts = def_events.Map((x, y) => <[case: | Event.$(x.name : usesite) => this.$(y : usesite)();]>);
      Define(<[ decl:
            public SendEvent(evt : Event) : void
            {
                match (evt)
                {
                  ..$evts
                }
            }
            ]>);
      Define(defs);
    }

    DefineGuards() : void
    {
      def guards : IEnumerable[Guard] = analyser.guards.FilterType();
      def guards_elem = guards.Select(x => (x, GenElement(x.condition, x.Name, guard_for)));
      def actions = guards_elem.Filter((_, x)  => !x.IsDeclared);
      def need_body = guards.Filter(x  => GuardNeedBody(x));
      def need_body = need_body.Map(x  => (x, get_guard_cond_expr(x, GenCtx.Normal())));
      need_body.Iter((x, _)  => guard_for = guard_for.Replace(x.condition, x.Name));
      def cond_body = need_body.Map((x, y)  => <[decl: $(x.Name : usesite)() : bool {$y}]>);
      def gnames = actions.Map((x, e) => (e.exec_name, x.Name));
      def methods = gnames |> <[decl: $(_ : usesite)() : bool {$(get_guard_call(_[2]))}]>;
      def props = gnames.Map((_, y) => <[decl: public $(y : usesite) : void -> bool {get;set;}]>);
      def defs = methods + props + cond_body;
      Define(defs);
    }    

    DefineActions() : void
    {
      def st = analyser.LivedStates.Filter(x => x.PartOfSubRegion().HasValue);

      def st_exit = st.Map(x => ($"ExitFrom$(x.PartOfRegion().Value)In$(x.Name())", GetActions(x.region_exit_path(), action_for)));
      def exit_acts = st.SelectMany(x => GenAction.CreateActions(x.region_exit_path(), action_for));
      def actions = actions.Exclude(_.IsDeclared).Concat(exit_acts);
      def actions = actions.RemoveDuplicatesSort(_.end_name);

      DefineActionEvent(actions);
      DefineMethods(st_exit)
    }

  }
}
