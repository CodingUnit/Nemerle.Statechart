using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using System.Collections.Concurrent;
using System.Threading;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of GenEvent.
  /// </summary>
  
  [Record]
  class GenEvent
  {
    an : FsmAnalyser;
    gen : StaticGenerator;
    events : list[string];
   
    NeedEvtContextName : bool
    {
      get
      {
        an.EventCtx.NeedName
      }
    }
    
    NeedEvtContext : bool
    {
      get
      {
        an.EventCtx.NeedContext
      }
    }
    
    [Memoized]
    RunEventInState : list[MatchCase]
    {
      get
      {
        events.Map(x => <[case: | Event.$(x : usesite) => cur_state.$(x : usesite)(this) ]>);
      }
    }
    
    [Memoized]
    EventCtxBody : PExpr
    {
      get
      {
        if (NeedEvtContext) <[ Evt.evt = evt ]> else <[]>
      }
    }
    
    GenEventCtx() : void
    {
      def cls = <[decl: public class EventCtx
                        {
                          public evt : Event {get;set;}
                          
                          public name : string
                          {
                            get
                            {
                              evt.ToString()
                            }
                          }
                        } ]>;
      def field = <[decl: public Evt : EventCtx = EventCtx() ]>;
      gen.DefineNested(cls).Compile();
      gen.Define(field);
    }
    
    GenBaseStruct() : void
    {
      when (NeedEvtContext) GenEventCtx();
      gen.Define(<[ decl:
            protected override DispatchEvent(evt : Event) : State
            {
                $EventCtxBody;
                match (evt)
                {
                  ..$RunEventInState
                }
            }
            ]>);
            
    }
    
    GenEvents() : void
    {
      def get_events(evt)
      {
        evt.Map(x => <[decl: public $(x : usesite)() : void { PostEvent(Event.$(x : usesite)) } ]>);
      }
      
      def lst = match (events.Partition(_ == "Completion"))
      {
        | (head :: _, other) => def comp = <[decl: public $(head : usesite)() : void { PostEventMostPriority(Event.$(head : usesite)) }]>;
                                def evt = get_events(other);
                                comp :: evt
        | (_, evt)           => get_events(evt)
      }
      gen.Define(lst);
      
      def decl_events = events.Map(x =>  <[decl: | $(x : usesite) ]>);
      gen.DefineNested(<[ decl:
            public enum Event
            {
              ..$decl_events
            }]>).Compile();
    }
    
    [Memoized]
    StringToEvent : list[MatchCase]
    {
      get
      {
        events.FoldRight([<[case: | _ => throw InvalidOperationException("Unknown event") ]>], 
                                  (x, a) => <[case: | $(x : string) => Event.$(x : usesite); ]> :: a);
      }
    }
    
    GenPost() : void
    {
      gen.Define(<[ decl:
            public override PostEvent(evt : string) : void
            {
                def res = match (evt)
                {
                  ..$StringToEvent
                }
                PostEvent(res)
            }
            ]>);
    }
    
    public Generate() : void
    {
      GenBaseStruct();
      GenEvents();
      GenPost();
    }
  }
}
