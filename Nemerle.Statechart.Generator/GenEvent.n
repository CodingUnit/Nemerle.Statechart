using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using System.Collections.Concurrent;
using System.Threading;
using Nemerle.Compiler;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of GenEvent.
  /// </summary>

  [Record]
  class GenEvent
  {
    public evt : StateEvent;
    public gen : StaticGenerator;

    [Memoized]
    public run_event_with_parms : list[PExpr]
    {
      get
      {
        def parms = evt.ParmNames;
        parms.Map(x => <[ $(x : usesite) ]>);
      }
    }

    TargetName : string
    {
      get
      {
        evt.TargetName
      }
    }

    public static fsm_event_declaration(this n : StateEvent) : PExpr
    {
      def parms = n.ParmTypes;
      def parms = parms.Map(x => <[ $x ]>);
      <[ EventInfo($(n.Name), [..$(parms)]) ]>
    }
    
    public static event_parms_names(this n : StateEvent) : list[PExpr]
    {
      n.parms.Map((x, _) => <[ $(x : usesite)]>)
    }

    public static event_parms(this n : StateEvent) : list[string * PExpr]
    {
      n.parms.Map((x, y) => (x, <[ $(y : usesite)]>))
    }

    public static SendEventCode(evt : string) : PExpr
    {
      <[ PostEvent(Event.$(evt.ToUpperFirst() : usesite).New) ]>
    }
    
    [Memoized]
    public EventDeclInTopState : ClassMember
    {
      get
      {
        def fsm = <[parameter: _ : $(gen.ChartName : usesite)]>;
        def parms = evt.event_parms();
        def parms = parms.Map((_, t) => <[parameter: _ : $t]>);
        def parms = fsm :: parms;
        <[ decl: public virtual $(evt.Name : usesite)(..$parms) : State { null } ]>
     }
    }

    public static event_parameter_decls(this evt : StateEvent) : list[PParameter]
    {
      if (evt != null)
      {
        def parms = event_parms(evt);
        parms.Map((n, t) => <[parameter: $(n : dyn) : $t ]>)
      } else []
    }

    public PostEventByNameBody : ClassMember
    {
      get
      {
        def parms = evt.event_parameter_decls();
        <[decl: public $(evt.Name : usesite)(..$parms) : void { PostEvent($(evt.CreateExpr())) } ]>
      }
    }
    
    [Memoized]
    public RunEventBody : MatchCase
    {
      get
      {
        def parms = run_event_with_parms;
        <[case: | Event.$(TargetName : usesite)(..$parms) => $RunEvent ]>
      }
    }

    public RunEvent : PExpr
    {
      get
      {
        def parms = evt.ParmNames.Map(x => <[ $(x : usesite) ]>);
        def parms = <[ this ]> :: parms;
        <[ cur_state.$(evt.Name : usesite)(..$parms) ]>
      }
    }

    [Memoized]
    InstanceWoParms : ClassMember
    {
      get
      {
        <[decl:
                  public static New : HsmEvent
                  {
                    get
                    {
                      when (instance == null) 
                      {
                        instance = $(TargetName : usesite)()
                      }
                      instance
                    }
                  } ]>
      }
    }

    [Memoized]
    InstanceField : ClassMember
    {
      get
      {
        <[decl: mutable static instance : HsmEvent; ]>;
      }
    }

    [Memoized]
    full_name : string
    {
      get
      {
        $"$(gen.ty.FullName).$TargetName";
      }
    }

    [Memoized]
    event_decl : ClassMember.TypeDeclaration
    {
      get
      {
        <[ variant_option: | $(TargetName : usesite)
        {

          public override ToString() : string
          {
            Name
          }

          public override FullName : string
          {
            get
            {
              $full_name
            }
          }

          public override Name : string 
          {
            get
            {
              $(evt.Name)
            }
          }

          public override GetHashCode() : int
          {
            $(full_name.GetHashCode())
          }

        } ]>
      }
    }

    public static CreateExpr(this evt : StateEvent) : PExpr
    {
      if (evt.IsCompletion) <[ CompletionEvent.New ]> else
      match (evt.ParmNames)
      {
        | []    => <[ Event.$(evt.TargetName : usesite).New ]>
        | parms => def parms = parms.Map(x => <[ $(x : usesite) ]>);
                   <[ Event.$(evt.TargetName : usesite)(..$parms) ]>
      }
    }
    
    public EventDecl(ty : TypeBuilder) : void
    {
      def parms = evt.event_parms();
      def decl = event_decl;
      def ty = ty.DefineNestedTypeWithSource(decl);

      match (parms)
      {
        | []    => ty.Define(InstanceWoParms);
                   ty.Define(InstanceField);
        | parms => foreach ((n, t) in parms)
                   {
                    _ = ty.DefineWithSource(<[decl: public $(n : usesite) : $t; ]>);
                   }
      }
      ty.Compile()
    }    
    
    
  }

}
