using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using System.Collections.Concurrent;
using System.Threading;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of GenEvent.
  /// </summary>
  
  [Record]
  class GenEvent
  {
    gen : StaticGenerator;
    events : list[StateEvent];
   
    NeedEvtContextName : bool
    {
      get
      {
        gen.EventCtx.NeedName
      }
    }
    
    NeedEvtContext : bool
    {
      get
      {
        gen.EventCtx.NeedContext
      }
    }
    
    [Memoized]
    RunEventInState : list[MatchCase]
    {
      get
      {
        events.Map(x => <[case: | Event.$(x.TargetName : usesite) => cur_state.$(x.Name : usesite)(this) ]>);
      }
    }
    
    [Memoized]
    EventCtxBody : PExpr
    {
      get
      {
        if (NeedEvtContext) <[ Evt.evt = evt ]> else <[]>
      }
    }
    
    EventDecl(n : StateEvent) : ClassMember.TypeDeclaration
    {
      def name = n.TargetName;
      def full = $"$(gen.Ty.FullName).$name";
      def hash = full.GetHashCode();
      <[ variant_option: | $(name : usesite)
      {
        static mutable instance : HsmEvent;
        
        public override ToString() : string
        {
          Name
        }
        
        public override FullName : string
        {
          get
          {
            $full
          }
        }
        
        public override Name : string 
        {
          get
          {
            $(n.Name)
          }
        }
        
        public override GetHashCode() : int
        {
          $hash
        }
        
        public static New() : HsmEvent
        {
          when (instance == null) 
          {
            instance = $(name : usesite)()
          }
          instance
        }
        
      } 
      ]>
    }
    
    GenEventCtx() : void
    {
      def cls = <[decl: public class EventCtx
                        {
                          public evt : HsmEvent {get;set;}
                          
                          public name : string
                          {
                            get
                            {
                              evt.ToString()
                            }
                          }
                        } ]>;
      def field = <[decl: public Evt : EventCtx = EventCtx() ]>;
      gen.DefineNested(cls).Compile();
      gen.Define(field);
    }
    
    public static CreateExpr(this evt : StateEvent) : PExpr
    {
      <[ Event.$(evt.TargetName : usesite).New() ]>
    }
    
    GenBaseStruct() : void
    {
      when (NeedEvtContext) GenEventCtx();
      gen.Define(<[ decl:
            protected override DispatchEvent(evt : HsmEvent) : State
            {
                match (evt)
                {
                  | e is Event =>
                  
                    $EventCtxBody;
                    match (e)
                    {
                      ..$RunEventInState
                    }
                    
                  | _ => null
              }
            }
            ]>);
       when (gen.FsmFlags.TransitionCompleted)
      {
        def expr = <[decl:
                   protected override OnEventComplete() : void
                    {
                      OnTransitionCompleted()
                    }
                   ]>;
        gen.Define(expr);
        gen.DefineEvent("TransitionCompleted")
      }      
    }
    
    GenEvents() : void
    {
      def get_events(evt)
      {
        evt.Map(x => <[decl: public $(x.Name : usesite)() : void { PostEvent($(x.CreateExpr())) } ]>);
      }
      
      def lst = match (events.Partition(_.IsCompletion))
      {
        | (head :: _, other) => def comp = <[decl: public $(head.Name : usesite)() : void { PostEventMostPriority($(head.CreateExpr())) }]>;
                                def evt = get_events(other);
                                comp :: evt
        | (_, evt)           => get_events(evt)
      }
      gen.Define(lst);
      
      def decl_events = events.Map(EventDecl);
      def ty = gen.DefineNested(<[ decl:
            public variant Event : HsmEvent
            {
              
            }]>);
      //..$decl_events
      decl_events.Iter(x => gen.DefineNested(ty, x).Compile());
      ty.Compile();
    }
    
    [Memoized]
    StringToEvent : list[MatchCase]
    {
      get
      {
        events.FoldRight([<[case: | _ => throw InvalidOperationException("Unknown event") ]>], 
                                  (x, a) => <[case: | $(x.Name : string) => $(x.CreateExpr()); ]> :: a);
      }
    }
    
    GenPost() : void
    {
      gen.Define(<[ decl:
            public override PostEvent(evt : string) : void
            {
                def res = match (evt)
                {
                  ..$StringToEvent
                }
                PostEvent(res)
            }
            ]>);
    }
    
    public Generate() : void
    {
      GenBaseStruct();
      GenEvents();
      GenPost();
    }
  }
}
