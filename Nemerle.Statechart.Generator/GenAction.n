using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using PathNode;
  using CheckNode;
  
  public variant GenCtx
  {
    | Normal
    | InEventHandler
    
    public IsInEventHandler : bool
    {
      get
      {
        this is InEventHandler
      }
    }
    public mutable HaveActionsAfter : bool;
  }
  
  class GenElement
  {
    public decl_map : Map[string, string] {get;set;}
    
    public name : string;
    public mutable exec_name : string;
    
    public this(n : string)
    {
      name = n;
    }

    public this(n : string, exec : string, map : Map[string, string])
    {
      name = n;
      decl_map = map;
      exec_name = if (IsDeclared) decl_map.Get(name) else CreateExecName(exec);            
    }
    
    public this(n : string, map : Map[string, string])
    {
      name = n;
      decl_map = map;
      CreateEndExecName();
    }

    public CreateEndExecName() : void
    {
      exec_name = if (IsDeclared) decl_map.Get(name) else CreateExecName(name)
    }

    public static CreateExecName(act : string) : string
    {
      $"On$act"
    }
    
    public IsDestDeclared : bool
    {
      get
      {
        decl_map.Exists((_, x)  => name == x)
      }
    }

    public IsDeclared : bool
    {
      get
      {
        decl_map.Exists((x, _)  => name == x)
      }
    }

    public Declared : string
    {
      get
      {
        if (decl_map.Contains(name)) decl_map.Get(name) else name
      }

    }
    
    public override ToString() : string
    {
      exec_name
    }
    
  }
  
  /// <summary>
  /// Description of GenAction.
  /// </summary>
  class GenAction : GenElement
  {
    [Accessor] node : PathNode;
    
    [Accessor] mutable inlined_actions : list[GenAction] = [];          

    public this(act : string, node : PathNode, map : Map[string, string])
    {
      base(act);
      exec_name = act;
      decl_map = map;
      this.node = node;
      CreateEndName();
      TryInline();
    }

    public this(act : string, exec_name : string, node : PathNode, map : Map[string, string])
    {
      base(act);
      this.exec_name = exec_name;
      decl_map = map;
      this.node = node;
      CreateEndName();
      TryInline();
    }
    
    public action : string
    {
      get
      {
        name
      }
    }
        
    public mutable end_name : string;
    
    public ExecExpr : PExpr
    {
      get
      {
        <[ $(end_name : usesite)(); ]>
      }
    }
    
    public override ToString() : string
    {
      end_name
    }
                
    CreateExecActionName() : string
    {
      if (IsDeclared) Declared else CreateExecName(exec_name)
    }    
         
    public TryInline() : void
    {
      match (node)
      {      
        | Entry(action = act)
        | Exit(action = act) => //def inl = inl.Map((x, _) => x);
                                inlined_actions = create_act_name(act, Action(act), decl_map);
                                              //inlined_actions = CreateActions(inl, decl_map).Concat(act).NToList();
        | _                  => ()
      }
    }
    
    // TODO: fold for actions
    public static CreateActions(node : PathNode, map : Map[string, string]) : IEnumerable[GenAction]
    {
      match (node)
      {
        | PathNode.Action(act)                          => create_act_name(act, node, map)
        | Entry(state = st)                             => TraverseUtils.SingleElement(GenAction($"$(st)Entry", node, map))
        | Exit(state = st)                              => TraverseUtils.SingleElement(GenAction($"$(st)Exit", node, map))
        //| Sequence(lst)                               => lst.SelectMany(CreateActions(_, map))
        | RunDoActivity as n        
        | StopDoActivity as n                           => TraverseUtils.SingleElement(GenAction(n.ToString(), node, map))
        | _                                             => Enumerable.Empty()
      }
      
  }

    public static CreateActions(node : IEnumerable[PathNode], map : Map[string, string]) : IEnumerable[GenAction]
    {
      node.SelectMany(CreateActions(_, map))
  }
  
    public static GetActions(node : PathNode, map : Map[string, string]) : IEnumerable[GenAction]
    {
      match (node)
      {
        | PathNode.Action(act)                                 => create_act_name(act, node, map)
        | Entry(act, _, st)                                    => GenAction($"$(st)Entry", node, map) :: create_act_name(act, Action(act), map)
        | Exit(act, _, st)                                     => GenAction($"$(st)Exit", node, map)  :: create_act_name(act, Action(act), map)
        ///| Sequence(lst)                                        => lst.SelectMany(CreateActions(_, map))
        | RunDoActivity as n
        | StopDoActivity as n                                  => TraverseUtils.SingleElement(GenAction(n.ToString(), node, map))
        | _                                                    => Enumerable.Empty()
      }
    }
    
    public CreateEndName() : void
    {
      end_name = match (node)
                 {
                   | Action
                   | Entry 
                   | Exit           => CreateExecActionName()
                   | RunDoActivity
                   | StopDoActivity => action
                   | _              => action
                 }
    }        

    static create_act_name(act : Actions, node : PathNode, map : Map[string, string]) : list[GenAction]
    {      
      def names = act.actions.Select(x => (x, $"$(x)Action"));
      names.Map(GenAction(_, _, node, map))
    }

  }
      
  public partial class StaticGenerator
  {
    public static GetExecStateName(st : string, ctx : GenCtx) : PExpr
    {
      def name = $"State$st";
      if (ctx.IsInEventHandler) <[ $(st : usesite)() ]> else <[ $(name : usesite) ]>
    }
    
    public static GetExecStateName(st : FsmState, ctx : GenCtx) : PExpr
    {
      def name = $"State$st";
      if (ctx.IsInEventHandler)
        if (st is FsmState.ConcurrentRegion) <[ fsm.$(name : usesite) ]> else <[ $(st.Name : usesite)() ]>
       else <[ $(name : usesite) ]>
    }
    
    public static GetSubRegionsExit(reg : IEnumerable[FsmState.ConcurrentSubRegion]) : string
    {
      def pat = FsmState.ConcurrentRegion.get_pattern(reg);
      $"Exit$pat"
    }
    
    public static IsEmpty(node : IEnumerable[PathNode]) : bool
    {
      def implicit = node.All(x => x is Exit || x is Entry);//node is Exit || node is Entry;
      node.PathActions().IsEmpty() && !implicit
    }
        
    public static GetHistoryClear(hist : IEnumerable[StateHistory]) : PExpr
    {
      def expr = hist.Map(x => <[ $($"$(x)Clear" : usesite)(); ]>); 
      <[ {..$expr} ]>
    }
    
    public static get_sub_region_name(r : FsmState.ConcurrentSubRegion) : string
    {
      $"cur_state$(r.index)"
    }

    public GetActions(node : PathNode, map : Map[string, string], supress_inline : bool = false) : PExpr
    {
      //def node = node.Unsequenced;
      GetActions(TraverseUtils.SingleElement(node), map, supress_inline)
    }

    public GetActions(node : IEnumerable[PathNode], map : Map[string, string], supress_inline : bool = false) : PExpr
    {
      def node = node.Exclude(_ is PathNode.Empty);
      
      def get_act(n)
      {
        | ClearHistory(hist)  => GetHistoryClear(hist)
        | SaveHistory(hist) => if (supress_inline) <[ () ]> else
                               {
                                 match (hist.Select(_.Updated).Filter(_.Used))
                                 {
                                   | StateHistory(SimpleName = n) :: _ => <[ $($"$(n)Save" : usesite)() ]>
                                   | _                                 => <[ () ]>
                                 }
                               }
        | RunDoActivity as n
        | StopDoActivity as n => if (supress_inline) <[ () ]> else <[ $($"$n" : usesite)() ]>;
        | RegionExit([], reg) => def reg_state = GetExecStateName(reg, GenCtx.Normal());
                                 <[ $reg_state.Exit(this) ]>
        | RegionExit(st, reg) => def reg_state = GetExecStateName(reg, GenCtx.Normal());
            def reg_exit = GetSubRegionsExit(st);
            <[ $reg_state.$(reg_exit : usesite)(this) ]>
        | _  => def act =  GenAction.CreateActions(n, map);
                def act = act |> end_name;
                def acts = act |> <[$(_ : usesite)();]>;
                <[ {..$acts} ]>
      }
      
      def body = node |> get_act(_);
      <[ {..$body} ]>
    }
      
    GetForceStateChange(nest : TransitionDestination, ctx : GenCtx) : PExpr
    {
      def st = nest.ConcreteTo;
      def body = GetDestination(nest, ctx);
      match (nest)
      {
        | ForceStateChange(n) => GetForceStateChange(n, ctx)
        | State(FsmState(PartOfRegion = Some(r), PartOfSubRegion = Some(sr))) =>
            def reg = GetExecStateName(r, ctx);
            def sreg = get_sub_region_name(sr);
            <[ def st = $body;$reg.$(sreg : usesite) = st; st ]>
        | Fork
        | SubRegion
        | Region
        | State => if (st != null) 
                   if (ctx.IsInEventHandler) <[ fsm.Switch($body) ]> else
                    <[ Switch($body) ]> else 
                    if (ctx.IsInEventHandler) <[ fsm.TrySwitch($body) ]> else <[ TrySwitch($body) ]>
        | Terminate => <[ _ = $body; null]>
        | Join
        | Final(region = FsmState(HaveFinal = true))
        | TransitionExecute
        | JunctionNode
        | NoStateChange => body
        | _ => if (st != null)  if (ctx.IsInEventHandler) <[ fsm.Switch($body) ]> else
                    <[ Switch($body) ]> else 
                    if (ctx.IsInEventHandler) <[ def st = $body;fsm.TrySwitch(st) ]> else <[ def st = $body;TrySwitch(st) ]>
      }
    }
      
  }
}
