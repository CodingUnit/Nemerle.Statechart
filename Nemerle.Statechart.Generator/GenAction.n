using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using System;
using System.Collections.Generic;
using System.Linq;



namespace Nemerle.Statechart
{
  using PathNode;
  using CheckNode;
  
  public variant GenCtx
  {
    | Normal
    | InEventHandler
    
    public IsInEventHandler : bool
    {
      get
      {
        this is InEventHandler
      }
    }
    public mutable HaveActionsAfter : bool;
  }
  
  class GenElement
  {
    public decl_map : Map[string, string];
    
    public name : string;
    //public mutable exec_name : string;
    
    
    //public this(n : string, exec : string, map : Map[string, string])
    //{
    //  name = n;
    //  decl_map = map;
    //  exec_name = if (IsDeclared) decl_map.Get(name) else CreateExecName(exec);
    //}
    
    public this(n : string, map : Map[string, string])
    {
      name = n;
      decl_map = map;
    }

    public ExecName : string
    {
      get
      {
        if (IsDeclared) decl_map.Get(name) else  $"On$name"//CreateExecName(name)
      }
    }

    public IsDestDeclared : bool
    {
      get
      {
        decl_map.Exists((_, x)  => name == x)
      }
    }

    public IsDeclared : bool
    {
      get
      {
        decl_map.Exists((x, _)  => name == x)
      }
    }

    public DeclName : string
    {
      get
      {
        if (decl_map.Contains(name)) decl_map.Get(name) else name
      }
    }
    
    public override ToString() : string
    {
      ExecName
    }
    
  }
  
  /// <summary>
  /// Description of GenAction.
  /// </summary>
  class GenAction : GenElement
  {
    //[Accessor] node : PathNode;
    action : FsmAction;
    util : GenUtil;
    //[Accessor] mutable inlined_actions : list[GenAction] = [];

    public this(act : FsmAction, map : Map[string, string], util : GenUtil)
    {
      base(act.name, map);
      action = act;
      this.util = util
    }
    
    //public this(act : string, map : Map[string, string])
    //{
    //  this(FsmAction(-1, act, []), map)
    //}
    //public this(act : string, node : PathNode, map : Map[string, string])
    //{
    //  base(act);
    //  exec_name = act;
    //  decl_map = map;
    //  this.node = node;
    //  CreateEndName();
    //  TryInline();
    //}

    //public this(act : string, exec_name : string, node : PathNode, map : Map[string, string])
    //{
    //  base(act);
    //  this.exec_name = exec_name;
    //  decl_map = map;
    //  this.node = node;
    //  CreateEndName();
    //  TryInline();
    //}
    
    //public action : string
    //{
    //  get
    //  {
    //    name
    //  }
    //}
    
    [MemoizedCalc]
    public Params : list[PExpr]
    {
      get
      {
        action.parameters.Map(x => <[ $x ]>)
      }
    }
    
    [MemoizedCalc]
    public ExecExpr : PExpr
    {
      get
      {
        <[ $(ExecName : usesite)(..$Params); ]>
      }
    }
    
    [MemoizedCalc]
    public DeclExecExpr : PExpr
    {
      get
      {
        <[ $(DeclName : usesite)(..$Params); ]>
      }
    }
    
    public override ToString() : string
    {
      ExecName
    }
    
    public EventActionCall : PExpr
    {
      get
      {
        <[
            $(DeclName : usesite)?.Invoke()
        ]>
      }
    }
    
    public BodyFunc : PExpr -> PExpr {get;set;}
    
    public Define() : void
    {
      def body = if (BodyFunc != null) BodyFunc(EventActionCall) else EventActionCall;
      
      util.Define(<[decl: public event $(DeclName: usesite) : Action;]>);
      util.Define(<[decl: $(ExecName : usesite)() : void 
                            {
                              $body
                            }]>);
                            

    }
    //public TryInline() : void
    //{
    //  match (node)
    //  {      
    //    | Entry(action = act)
    //    | Exit(action = act) => //def inl = inl.Map((x, _) => x);
    //                            inlined_actions = create_act_name(act, Action(act), decl_map);
    //                                          //inlined_actions = CreateActions(inl, decl_map).Concat(act).NToList();
    //    | _                  => ()
    //  }
    //}
    

  
    //public static GetActions(node : PathNode, map : Map[string, string]) : IEnumerable[GenAction]
    //{
    //  match (node)
    //  {
    //    | PathNode.Action(act)                                 => create_act_name(act, node, map)
    //    | Entry(act, _, st)                                    => GenAction($"$(st)Entry", node, map) :: create_act_name(act, Action(act), map)
    //    | Exit(act, _, st)                                     => GenAction($"$(st)Exit", node, map)  :: create_act_name(act, Action(act), map)
    //    ///| Sequence(lst)                                        => lst.SelectMany(CreateActions(_, map))
    //    | RunDoActivity as n
    //    | StopDoActivity as n                                  => TraverseUtils.SingleElement(GenAction(n.ToString(), node, map))
    //    | _                                                    => Enumerable.Empty()
    //  }
    //}
    
    //public CreateEndName() : void
    //{
    //  end_name = match (node)
    //             {
    //               | Action
    //               | Entry 
    //               | Exit           => CreateExecActionName()
    //               | RunDoActivity
    //               | StopDoActivity => action
    //               | _              => action
    //             }
    //}        

    //static create_act_name(act : Actions, node : PathNode, map : Map[string, string]) : list[GenAction]
    //{      
    //  def names = act.actions.Select(x => (x.name, $"$(x.name)Action"));
    //  names.Map(GenAction(_, _, node, map))
    //}

  }
  
  class GenPath
  {
    map  : Map[string, string];
    node : PathNode;
    util : GenUtil;
    
    public this(map : Map[string, string], node : PathNode, util : GenUtil) 
    {
      this.map = map;
      this.node = node;
      this.util = util
    }
    
    action(name : string) : FsmAction
    {
      FsmAction(-1, name, [])
    }
    
    [MemoizedCalc]
    action_name : FsmAction
    {
      get
      {
        match (node)
        {
          | ClearHistory(hist)                          => def name = hist.HistoryName();
                                                           action($"$(name)Clear")
          | SaveHistory(hist)                           => def name = hist.HistoryName();
                                                           action($"$(name)Save")
          | Action(act)                                 => act
          | Entry(state = st)                           => action($"Entry$st")
          | Exit(state = st)                            => action($"Exit$st")
          | RunDoActivity(state = st)                   => action($"DoActivity$(st)Run")
          | StopDoActivity(state = st)                  => action($"DoActivity$(st)Stop")
        //| Sequence(lst)                               => lst.SelectMany(CreateActions(_, map))
        //| n                                             => TraverseUtils.SingleElement(FsmAction(-1, n.ToString(), []))
        }
      }
    }
    
    [MemoizedCalc]
    gen_action : GenAction
    {
      get
      {
        GenAction(action_name, map, util)
      }
    }
    //public GetActions(node : IEnumerable[PathNode]) : PExpr
    //{
    //  def node = node.Exclude(_ is PathNode.Empty);
      
    //  def get_act(n)
    //  {
        
    //  }
      
    //  def body = node.Map(get_act);
    //  <[ {..$body} ]>
    //}
    
    public ExecExpr : PExpr
    {
      get
      {
        gen_action.DeclExecExpr
        //match (node)
        //{
        //| ClearHistory      => gen_act.ExecExpr
        //| SaveHistory(hist) => gen_act.ExecExpr
        //| RunDoActivity as n
        //| StopDoActivity as n => if (supress_inline) <[ () ]> else <[ $($"$n" : usesite)() ]>;
        //| RegionExit([], reg) => def reg_state = GetExecStateName(reg, GenCtx.Normal());
        //                         <[ $reg_state.Exit(this) ]>
        //| RegionExit(st, reg) => def reg_state = GetExecStateName(reg, GenCtx.Normal());
        //                         def reg_exit = GetSubRegionsExit(st);
        //                         <[ $reg_state.$(reg_exit : usesite)(this) ]>
        //| _  => def act =  GenAction.CreateActions(n, map);
        //        def act = act.Map(x => x.end_name);
        //        def acts = act.Map(x => <[$(x : usesite)();]>);
        //        <[ {..$acts} ]>
        //      }
      }
    }
  }
  
  public partial class StaticGenerator
  {
    public static GetExecStateName(st : string, ctx : GenCtx) : PExpr
    {
      def name = $"State$st";
      if (ctx.IsInEventHandler) <[ $(st : usesite)() ]> else <[ $(name : usesite) ]>
    }
    
    public static GetExecStateName(st : FsmState, ctx : GenCtx) : PExpr
    {
      def name = $"State$st";
      if (ctx.IsInEventHandler)
        if (st.type is StateType.Region) <[ fsm.$(name : usesite) ]> else <[ $(st.Name : usesite)() ]>
       else <[ $(name : usesite) ]>
    }
    
    public static GetSubRegionsExit(reg : IEnumerable[FsmState]) : string
    {
      def pat = FsmState.get_pattern(reg);
      $"Exit$pat"
    }
    
    //public static IsEmpty(node : IEnumerable[PathNode]) : bool
    //{
    //  def implicit = node.All(x => x is Exit || x is Entry);//node is Exit || node is Entry;
    //  node.PathActions().IsEmpty() && !implicit
    //}
        
    
    public static get_sub_region_name(r : FsmState) : string
    {
      $"cur_state$(r.Index)"
    }

    //public GetActions(node : PathNode) : PExpr
    //{
    //  //def node = node.Unsequenced;
    //  GetActions(TraverseUtils.SingleElement(node))
    //}
      
    GetForceStateChange(nest : TransitionDestination, ctx : GenCtx) : PExpr
    {
      def st = nest.ConcreteTo;
      def body = GetDestination(nest, ctx);
      match (nest)
      {
        | ForceStateChange(n) => GetForceStateChange(n, ctx)
        | State(state = st) when st.PartOfRegion.HasValue => 
            
                def r = st.PartOfRegion.Value;
                def sr = st.PartOfSubRegion.Value;
            def reg = GetExecStateName(r, ctx);
            def sreg = get_sub_region_name(sr);
            <[ def st = $body;$reg.$(sreg : usesite) = st; st ]>
            
            
        | Fork
        | SubRegion
        | Region
        | State => if (st != null) 
                   if (ctx.IsInEventHandler) <[ fsm.Switch($body) ]> else
                    <[ Switch($body) ]> else 
                    if (ctx.IsInEventHandler) <[ fsm.TrySwitch($body) ]> else <[ TrySwitch($body) ]>
        | Terminate => <[ _ = $body; null]>
        | Join
        | Final(region = st) when (st.HaveFinal) 
        | TransitionExecute
        //| JunctionNode
        | NoStateChange => body
        | _ => if (st != null)  if (ctx.IsInEventHandler) <[ fsm.Switch($body) ]> else
                    <[ Switch($body) ]> else 
                    if (ctx.IsInEventHandler) <[ def st = $body;fsm.TrySwitch(st) ]> else <[ def st = $body;TrySwitch(st) ]>
      }
    }
      
  }
}
