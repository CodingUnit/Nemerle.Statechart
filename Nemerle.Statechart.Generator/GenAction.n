using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using System;
using System.Collections.Generic;
using System.Linq;



namespace Nemerle.Statechart
{
  using PathNode;
  using CheckNode;
  
  public variant GenCtx
  {
    | Normal
    | InEventHandler
    
    public IsInEventHandler : bool
    {
      get
      {
        this is InEventHandler
      }
    }
    public mutable HaveActionsAfter : bool;
  }
  
  class GenElement
  {
    public decl_map : Map[string, string];
    
    public name : string;
    //public mutable exec_name : string;
    
    
    //public this(n : string, exec : string, map : Map[string, string])
    //{
    //  name = n;
    //  decl_map = map;
    //  exec_name = if (IsDeclared) decl_map.Get(name) else CreateExecName(exec);
    //}
    
    public this(n : string, map : Map[string, string])
    {
      name = n;
      decl_map = map;
    }

    public ExecName : string
    {
      get
      {
        if (IsDeclared) decl_map.Get(name) else  $"On$name"//CreateExecName(name)
      }
    }

    public IsDestDeclared : bool
    {
      get
      {
        decl_map.Exists((_, x)  => name == x)
      }
    }

    public IsDeclared : bool
    {
      get
      {
        decl_map.Exists((x, _)  => name == x)
      }
    }

    public DeclName : string
    {
      get
      {
        if (decl_map.Contains(name)) decl_map.Get(name) else name
      }
    }
    
    public override ToString() : string
    {
      ExecName
    }
    
  }
  
  /// <summary>
  /// Description of GenAction.
  /// </summary>
  class GenAction : GenElement
  {
    //[Accessor] node : PathNode;
    action : FsmAction;
    util : GenUtil;
    //[Accessor] mutable inlined_actions : list[GenAction] = [];

    public this(act : FsmAction, map : Map[string, string], util : GenUtil)
    {
      base(act.name, map);
      action = act;
      this.util = util
    }
    
    //public this(act : string, map : Map[string, string])
    //{
    //  this(FsmAction(-1, act, []), map)
    //}
    //public this(act : string, node : PathNode, map : Map[string, string])
    //{
    //  base(act);
    //  exec_name = act;
    //  decl_map = map;
    //  this.node = node;
    //  CreateEndName();
    //  TryInline();
    //}

    //public this(act : string, exec_name : string, node : PathNode, map : Map[string, string])
    //{
    //  base(act);
    //  this.exec_name = exec_name;
    //  decl_map = map;
    //  this.node = node;
    //  CreateEndName();
    //  TryInline();
    //}
    
    //public action : string
    //{
    //  get
    //  {
    //    name
    //  }
    //}
    
    [Memoized]
    public Params : list[PExpr]
    {
      get
      {
        action.parameters.Map(x => <[ $x ]>)
      }
    }
    
    [Memoized]
    public ExecExpr : PExpr
    {
      get
      {
        <[ $(ExecName : usesite)(..$Params); ]>
      }
    }
    
    [Memoized]
    public DeclExecExpr : PExpr
    {
      get
      {
        <[ $(DeclName : usesite)(..$Params); ]>
      }
    }
    
    public override ToString() : string
    {
      ExecName
    }
    
    public EventActionCall : PExpr
    {
      get
      {
        <[
            $(DeclName : usesite)?.Invoke()
        ]>
      }
    }
    
    public BodyFunc : PExpr -> PExpr {get;set;}
    
    public Define() : void
    {
      def body = if (BodyFunc != null) BodyFunc(EventActionCall) else EventActionCall;
      
      util.Define(<[decl: public event $(DeclName: usesite) : Action;]>);
      util.Define(<[decl: $(ExecName : usesite)() : void 
                            {
                              $body
                            }]>);
                            

    }
    //public TryInline() : void
    //{
    //  match (node)
    //  {      
    //    | Entry(action = act)
    //    | Exit(action = act) => //def inl = inl.Map((x, _) => x);
    //                            inlined_actions = create_act_name(act, Action(act), decl_map);
    //                                          //inlined_actions = CreateActions(inl, decl_map).Concat(act).NToList();
    //    | _                  => ()
    //  }
    //}
    

  
    //public static GetActions(node : PathNode, map : Map[string, string]) : IEnumerable[GenAction]
    //{
    //  match (node)
    //  {
    //    | PathNode.Action(act)                                 => create_act_name(act, node, map)
    //    | Entry(act, _, st)                                    => GenAction($"$(st)Entry", node, map) :: create_act_name(act, Action(act), map)
    //    | Exit(act, _, st)                                     => GenAction($"$(st)Exit", node, map)  :: create_act_name(act, Action(act), map)
    //    ///| Sequence(lst)                                        => lst.SelectMany(CreateActions(_, map))
    //    | RunDoActivity as n
    //    | StopDoActivity as n                                  => TraverseUtils.SingleElement(GenAction(n.ToString(), node, map))
    //    | _                                                    => Enumerable.Empty()
    //  }
    //}
    
    //public CreateEndName() : void
    //{
    //  end_name = match (node)
    //             {
    //               | Action
    //               | Entry 
    //               | Exit           => CreateExecActionName()
    //               | RunDoActivity
    //               | StopDoActivity => action
    //               | _              => action
    //             }
    //}        

    //static create_act_name(act : Actions, node : PathNode, map : Map[string, string]) : list[GenAction]
    //{      
    //  def names = act.actions.Select(x => (x.name, $"$(x.name)Action"));
    //  names.Map(GenAction(_, _, node, map))
    //}

  }
  
}
  
  
  
  

