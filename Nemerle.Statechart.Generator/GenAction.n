using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using System;
using System.Collections.Generic;
using System.Linq;



namespace Nemerle.Statechart
{
  using PathNode;
  using CheckNode;
  
  public variant GenCtx
  {
    | Normal
    | InEventHandler
    
    public IsInEventHandler : bool
    {
      get
      {
        this is InEventHandler
      }
    }
    public mutable HaveActionsAfter : bool;
  }
  
  class GenElement
  {
    public decl_map : Map[string, string];
    
    public name : string;
    //public mutable exec_name : string;
    
    
    //public this(n : string, exec : string, map : Map[string, string])
    //{
    //  name = n;
    //  decl_map = map;
    //  exec_name = if (IsDeclared) decl_map.Get(name) else CreateExecName(exec);
    //}
    
    public this(n : string, map : Map[string, string])
    {
      name = n;
      decl_map = map;
    }

    public ExecName : string
    {
      get
      {
        if (IsDeclared) decl_map.Get(name) else  $"On$name"//CreateExecName(name)
      }
    }

    public IsDestDeclared : bool
    {
      get
      {
        decl_map.Exists((_, x)  => name == x)
      }
    }

    public IsDeclared : bool
    {
      get
      {
        decl_map.Exists((x, _)  => name == x)
      }
    }

    public DeclName : string
    {
      get
      {
        if (decl_map.Contains(name)) decl_map.Get(name) else name
      }
    }
    
    public override ToString() : string
    {
      ExecName
    }
    
  }
  
  /// <summary>
  /// Description of GenAction.
  /// </summary>
  class GenAction : GenElement
  {
    //[Accessor] node : PathNode;
    public action : FsmAction;
    util   : GenUtil;
    //[Accessor] mutable inlined_actions : list[GenAction] = [];

    public this(act : FsmAction, map : Map[string, string], util : GenUtil)
    {
      if (act is FsmAction.Normal(n, _)) base(n, map); else base(null, map);
      action = act;
      this.util = util
    }
    
    [Memoized]
    public Params : list[PExpr]
    {
      get
      {
        match (action)
        {
          | FsmAction.Normal(_, p) => p.Map(x => <[ $(x : usesite) ]>)
          | _                      => []
        }
      }
    }
    
    [Memoized]
    public ExecExpr : PExpr
    {
      get
      {
        match (action)
        {
         | FsmAction.Expr(e)     => e 
         | Normal(name = "send") => <[ PostEvent(..$Params) ]>
         | Normal(name = null)   => <[ () ]>
         | _                     => <[ $(ExecName : usesite)(..$Params) ]>
        }
      }
    }
    
    [Memoized]
    public DeclExecExpr : PExpr
    {
      get
      {
        match (action)
        {
         | FsmAction.Expr(e)     => e 
         | Normal(name = "send") => <[ PostEvent(..$Params) ]>
         | Normal(name = null)   => <[ () ]>
         | _                     => <[ $(DeclName : usesite)(..$Params); ]>
        }
      }
    }
    
    public override ToString() : string
    {
      ExecName
    }
    
    [Memoized]
    public EventActionCall : PExpr
    {
      get
      {
        <[
            $(DeclName : usesite)?.Invoke()
        ]>
      }
    }
    
    public IsExpr : bool
    {
      get
      {
        action is FsmAction.Expr
      }
    }
    
    public BodyFunc : PExpr -> PExpr {get;set;}
    
    public Define() : void
    {
      when (!IsDeclared && !IsExpr)
      {
        def body = if (BodyFunc != null) BodyFunc(EventActionCall) else EventActionCall;
        util.Define(<[decl: public event $(DeclName: usesite) : Action;]>);
        util.Define(<[decl: $(ExecName : usesite)() : void 
                            {
                              $body
                            }]>);
      }

    }

  }
  
}
  
  
  
  

