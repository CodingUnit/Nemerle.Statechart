using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using StateTransition;
  using ListUtils;
  /// <summary>
  /// Description of GenerateTransitions.
  /// </summary>
  public partial class StaticGenerator
  {

    GetTransitionFunction(tran : list[StateTransition]) : list[ClassMember]
    {
      tran.Map(x => <[ decl: $(x.Name : usesite)() : State {$(GetTransitionBody(x, GenCtx.Normal()))} ]>);
    }

    GetTransitionFunction(tran : list[string * StateTransition]) : list[ClassMember]
    {
      tran.Map((x, y) => <[ decl: $(x : usesite)() : State {$(GetTransitionBody(y, GenCtx.Normal()))} ]>);
    }

    //GetActions(act : PathNode, inline_suppress : bool = true) : PExpr
    //{
    //  GetActions(act, action_for, inline_suppress)
    //}

    GetActions(act : IEnumerable[PathNode], inline_suppress : bool = true) : PExpr
    {
      GetActions(act, action_for, inline_suppress)
    }

    public GetDestination(tran : TransitionDestination, ctx : GenCtx = null) : PExpr
    {
      def ctx = ctx ?? GenCtx.Normal();
      match (tran)
      {
        | TransitionDestination.State(st) => 
            def body = GetExecStateName(st, ctx);
            if (ctx.IsInEventHandler) 
            {
                <[
              _ = fsm;
                  $body;
                ]>
            } else body

        | NoStateChange => if (ctx.IsInEventHandler) <[ fsm.cur_state ]> else <[ cur_state ]>
        | Choice(_, tran, Some(st)) => def target = GetExecStateName(st, ctx);
            DefineTransBody(tran, ctx, target)

        | Choice(_, tran, _) => DefineTransBody(tran, ctx)

        | Terminate => 
            def after = if (ctx.HaveActionsAfter) <[ () ]> else <[ null ]>;
            if (ctx.IsInEventHandler) <[ fsm.Terminate();$after ]> else <[ Terminate();$after ]>

        | History(PseudoStateNode.History(default = Some()) as h) => def name = $"$(h.Name)Run";
            if (ctx.IsInEventHandler) <[ fsm.$(name : usesite)();]> else <[ $(name : usesite)();]>

        | History(PseudoStateNode.History(type = t) as h) =>
            //Name = n, state = p
            def p = h.state;
            def n = h.Name;
            def t = if (p.BothHistories) $"$t" else "";
            def name = $"$(t)HistoryFrom$(p.Name)"; // call function of run history
            if (ctx.IsInEventHandler) <[ fsm.$(n : usesite).$(name : usesite)(fsm) ]> else <[ $(n : usesite).$(name : usesite)(this) ]>;

        | SubRegion(reg, st, from) =>
            def regs = reg.PartOfRegionsOf(from).NToList().Rev();
            // TODO: вынести логику генерации, ctx и переходов в отдельный класс

            def enter_region(r)
            {
              | head :: tail => 

                  def other = head.RegionsExcept(st.ToState);
                  def pat = FsmState.get_pattern(other);
                  def reg = GetExecStateName(head, ctx);
                  def name = $"Initial$pat";
                  def refsm = if (ctx.IsInEventHandler) <[fsm]> else <[ this ]>;
                  <[
                    $reg.$(name : usesite)($refsm, $(enter_region(tail)));
                    $reg
                  ]>

              | _ => def body = GetDestination(st, ctx);
                  if (ctx.IsInEventHandler && regs.Length <= 1) 
                    <[ 
                        _ = fsm;
                        $body
                    ]> else body
            }

            // entering in region
            enter_region(regs);

        | Region(reg) => def target = GetExecStateName(reg, ctx);
              <[
                $target.Initial(this);
                $target
              ]>

        | HistoryRestore(h) => <[ $(h.Name : usesite).GetCopy(0) ]>
        | Fork(reg, tran) => def target = GetExecStateName(reg, ctx);
            def sub_region(t)
            {
              match (t.AtLeastTo)
              {
                | FsmState(type = StateType.SubRegion) as st => st
                | x                                          => x.PartOfSubRegion.Value
              }
            }

            def find(trans, x)
            {
              match (trans.Find((y, _) => x : object == y)) 
              {
                | Some((_, t)) => t
                | _ => <[ null ]>
              }
            }

            def trans = tran.Map(x => (sub_region(x), if (ctx.IsInEventHandler) <[ fsm.$(x.Name : usesite)(); ]> else <[ $(x.Name : usesite)(); ]>));
            def def_this = if (ctx.IsInEventHandler) <[ fsm ]> else <[this]>;
            def parms = def_this :: reg.sub_states.Map(find(trans, _));
            <[
              $(target).Initial(..$parms);
              $target
            ]>

        | Join(join = Join(name = n)) => 
            def fname = $"join$n";
            if (ctx.IsInEventHandler) <[ fsm.$(fname : usesite)++;null ]> else <[ $(fname : usesite)++;null ]>

        | Final(st, sr, reg, tran) => 
            def regname = GetExecStateName(reg, ctx);
            def target = GetExecStateName(st, ctx);
            def trans = DefineTransBody(tran, ctx);
            if (reg.HaveFinal)
            {
              def hist = reg.ParticipateInHistory;
              def hist = GetHistoryClear(hist);
            <[
              $regname.$(get_sub_region_name(sr) : usesite) = $target;
              if ($regname.IsFinal) 
              {
                $hist;
                $trans
              } else null
            ]>
            }
            else <[ $target ]>

        | ForceStateChange(nest) => GetForceStateChange(nest, ctx);

        | CheckAfter(check, before, after) =>
            def check = GetCheck(check, ctx);
            def before = GetDestination(before, ctx);
            def nest = GetDestination(after, ctx);
            <[ def st = $before; if ($check) $nest else st ]>
        | JoinedTransition(Join(name = n), tran) => def fname = $"join$n";
            def body = DefineTransBody([tran], ctx);
            <[ $(fname : usesite) = 0;$body ]>
        | EventSend(st, evt)    => 
            if (st.PartOfRegion is Some(r))
            {
              def name = GetExecStateName(r, ctx);
              <[ $name.$(evt.Name : usesite)(this) ]>
            } else
              <[ cur_state.$(evt.Name : usesite)(this) ]>


        //| JunctionNode(j)       => get_junction_body(j, ctx)
        //| ChoiceNode(j)         => get_choice_body(j, ctx)
        | TransitionExecute(tr) => if (ctx.IsInEventHandler) <[ fsm.$(tr.Name : usesite)() ]> else <[ $(tr.Name : usesite)() ]>
        | SubMachine            => throw NotImplementedException();
        | _                     => throw InvalidOperationException("unknown destination")
      }
    }

    
    //GuardNeedBody(GuardNode : GuardNode) : bool
    //{
    //  def expr = get_guard_cond_expr(GuardNode, GenCtx.Normal());
    //  match (expr)
    //  {
    //    |  <[ $(_ : name) ]>
    //    |  PExpr.Call(<[ $(_ : name) ]>, []) => false
    //    | _  => true
    //  }
    //}

    EvalGuardExpr(expr : StateExpr) : PExpr
    {
      def unary_eval(o, a)
      {
        match (o.op)
        {
          | StateUnaryOp.Not => <[ ! $a]>
          | _                => a
        }
      }

      def two_eval(e, a, b)
      {
        match (e.op)
        {
          | StateBinaryOp.Above => <[ $a > $b]>
          | Equal               => <[ $a == $b]>
          | NotEqual            => <[ $a != $b]>
          | AboveEq             => <[ $a >= $b]>
          | Below               => <[ $a < $b]>
          | BelowEq             => <[ $a <= $b]>
          | Or                  => <[ $a || $b]>
          | And                 => <[ $a && $b]>
          | _                   => <[]>
        }
      }

      def method_eval(m)
      {
        def meth = m.m;
        <[ $(meth : usesite)() ]>
      }

      def var_eval(v)
      {
        def var = v.v;
        <[ $(var : usesite) ]>
      }

      def lit_eval(l)
      {
        match (l.lit)
        {
          | StateLit.Double(d) => <[ $d ]> 
          | Integer(i)         => <[ $i ]> 
          | String(s)          => <[ $s ]>
          | Bool(b)            => <[ $b ]>
        }
      }

      expr.Fold(<[ true ]>, unary_eval, two_eval, (_, a) => a, method_eval, var_eval, lit_eval);
      
      //def GuardNode = GenElement(cond, guard_for);
      //def name = GuardNode.exec_name;
      //if (GuardNode.IsDeclared)
      //{
      //  if (!decls.Contains(name)) <[ $(name : usesite)() ]> else
      //    match (decls.Get(name))
      //    {
      //      | Field(ParsedType  =  <[ bool ]>)
      //      | Property(returnType  =  <[ bool ]>)  => <[ $(name : usesite) ]>
      //      | Field(ParsedType  =  <[ void -> bool ]>)
      //      | Property(returnType  =  <[ void -> bool ]>)  => <[ if ($(name : usesite) != null) $(name : usesite)() else false]>
      //      | Function
      //      | _  => <[ $(name : usesite)() ]>
      //    }
      //} else
      //{
      //  def name = GenElement.CreateExecName(g.Name);
      //        <[$(name : usesite)()]>
      //}
    }

    GetGuardCondExpr(g : GuardNode, ctx : GenCtx) : PExpr
    {
      match (g)
      {
        | GuardNode.Expr(cond) => EvalGuardExpr(cond)
        | InState(st) => def st = GetExecStateName(st, ctx);
                         if (ctx.IsInEventHandler) <[ fsm.IsInState($st) ]> else <[ IsInState($st) ]>
        | _ => <[ () ]>
      }
    }

    GetCheck(node : CheckNode, ctx : GenCtx) : PExpr
    {
      match (node)
      {
        | Empty         => <[ () ]>
        | Sequence(lst) => def check = lst.Map(x => GetCheck(x, ctx));
                          MergeExprAnd(check)
        | RegionStates(st) => 

            def get_check(reg, st)
            {

              def check_st = reg.sub_states.Map(x => {
                                                  match (st.Find(y => y.PartOfSubRegion.Value : object == x)) 
                                                  {
                                                    | Some(st) => GetExecStateName(st, ctx) 
                                                    | _        => <[ null ]>
                                                  }});

              def reg_state = GetExecStateName(reg, ctx);
              if (st.All(x => x.Lived && x.LivedSubStatesNested.IsEmpty()))
                <[ $reg_state.IsInStateConcrete(..$check_st) ]>
              else 
                <[ $reg_state.IsInState(..$check_st) ]>
            }

            def reg = st.Map(x => x.PartOfRegion.Value);
            if (reg.ElementsEqual((x, y) => x : object == y))
            {
              get_check(reg.Head, st)
            } else
            {
              def group = st.GroupBy(x => x.PartOfRegion.Value.Name);
              def check = group.Select(x => get_check(x.First().PartOfRegion.Value, x));
              MergeExprAnd(check);
            }

        | Join(Join(name = n, joined_tran = jtran), tran) => 
            def reg = jtran.Map(x => x.FromRegion);
            def idx = reg.FindIndex(tran.FromRegion : object == _);
            def fname = $"join$n";
          <[ $(fname : usesite) == $idx ]>

        | Guard(g) => GetGuards(g, ctx)
        | _        => throw InvalidOperationException("unknown check")
      }
    }

    GetGuards(g : IEnumerable[GuardNode], ctx : GenCtx) : PExpr
    {
      def body = g.Map(GetGuardCondExpr(_, ctx));//(_, ctx));
      MergeExprAnd(body)
    }

    GetGuardedBody(tran : StateTransition, body : PExpr, ctx : GenCtx) : PExpr
    {
      match (tran)
      {
        | StateTransition(executeCheck = check, Guard = g) =>

            def check = GetCheck(check, ctx);
            def check = match (g)
                        {
                          | Some(g) => [GetGuardCondExpr(g, ctx), check]
                          | _ => [check]
                        }
            match (check)
            {
              | [<[ () ]>] => body
              | _ => 
                  def check = MergeExprAnd(check);
                  <[
                  {
                    res:
                    {
                      unless ($check) res(null);
                      $body
                    }
                  }
                  ]>
            }
      }
    }

    GetPostConditions(body : PExpr, post : TransitionPostConditions, ctx : GenCtx = null) : PExpr
    {
      def ctx = ctx ?? GenCtx.Normal();
      //def pre = <[ def st = $body; ]>;
      match (post)
      {
        | RegionCompletion(reg, tr) => 
          def check_reg = CheckNode.RegionStates(tr.Map(x => x.From));
          def check_guard = if (tr.Exists(x => x.guard.HasValue)) CheckNode.Guard(tr.FilterValues(x => x.Guard).NToList()) else CheckNode.Empty();
          def check = check_reg + check_guard;
          def check = GetCheck(check, ctx);
          def name = GetExecStateName(reg, ctx);
          def send_evt = <[ $name.Completion(this) ]>;
          <[
          def st = $body;
          if ($check) $send_evt else st;
          ]>

        | _ => body
      }
    }

    GetBody(tran : StateTransition, ctx : GenCtx) : PExpr
    {
      | (StateTransition(PathNode = acts, Destination = dest, PostConditions = post), _) =>

          GetBody(acts, dest, post, ctx);
    }

    GetBody(acts : IEnumerable[PathNode], dest : TransitionDestination, post : TransitionPostConditions = null, ctx : GenCtx) : PExpr
    {
      def acts = acts.NToList();
      def body = GetActions(acts);
      def target = GetDestination(dest, ctx);
      def body = <[
                  $body;
                    $target
                  ]>;

      if (post != null) 
      {
        GetPostConditions(body, post, ctx)
      } else body
    }

    GetTransitionBody(tran : StateTransition, ctx : GenCtx) : PExpr
    {
      def body = GetBody(tran, ctx);
      GetGuardedBody(tran, body, ctx)
    }

    DefineTransBody(tr : IEnumerable[StateTransition], ctx : GenCtx, alt : PExpr = null) : PExpr
    {
      def get_body(tr)
      {
        def name = tr.Name;
        if (tr.MaybeInlined && IsEmpty(tr.PathNode))
        {
             <[ $(GetTransitionBody(tr, ctx)) ]>
        } else 
          if (ctx.IsInEventHandler) <[ fsm.$(name : usesite)(); ]> else <[ $(name : usesite)();]>
      }

      match (tr.NToList())
      {
        //| [StateTransition(IsCrossed = true) as tr] => 
        //    def body =  get_body(tr);
        //          <[
        //            {
        //            def res =  $body;
        //            if (res != null) res else $(DefineTransBody(tr.ParentCrossed, ctx, alt))
        //            }
        //          ]>
        | [tr]  => def body = get_body(tr);
            if (alt != null) 
            <[
              def res = $body;
              if (res != null) res else $alt
            ]> else body

        | tr :: tail  =>
            def body = get_body(tr);
                  <[
                  {
                    def res =  $body;
                    if (res != null) res else $(DefineTransBody(tail, ctx, alt))
                  }
                  ]>
        |  _  => if (alt != null) alt else <[ null ]>
      } 
    }

    DefineTransBody(tr : StateTransition, ctx : GenCtx, alt : PExpr = null) : PExpr
    {
      def get_body(tr)
      {
        def name = tr.Name;
        if (tr.MaybeInlined && IsEmpty(tr.PathNode))
        {
             <[ $(GetTransitionBody(tr, ctx)) ]>
        } else 
          if (ctx.IsInEventHandler) <[ fsm.$(name : usesite)(); ]> else <[ $(name : usesite)();]>
      }

        def body = get_body(tr);
            if (alt != null) 
            <[
              def res = $body;
              if (res != null) res else $alt
            ]> else body
        
    }
    
    DefineTransitions(ty : TypeBuilder, st : FsmState) : void
    {
      def defs = 


                      //def from_top = <[decl:
                      //                 public override PathFromTop(fsm : $(ChartName : usesite)) : State {$(DefineTransBody([st.PathFromOut], GenCtx.InEventHandler()))}
                      //               ]>;
                      //def def_tran_body(tr)
                      //{
                      //  | StateTransition(Trigger = StateEvent(Name = n)) :: _ =>

                      //      def body = DefineTransBody(tr, GenCtx.InEventHandler());
                      //      if (st.proc_events.Exists(_ == n))
                      //      {
                      //    <[ 
                      //        machine.$(n : usesite);
                      //        when (machine.IsEventDeclined) $body
                      //    ]>
                      //      } else body;

                      //  | _ => DefineTransBody(tr, GenCtx.InEventHandler())
                      //}

                      //if (st.Lived)
                      // {
                      //   st.work_transition_group.MapToList((x, y)  => <[decl: 
                      //     public override $(x : usesite)(fsm : $(ChartName : usesite)) : State {$(def_tran_body(y.NToList()))}]>)
                      // } else [];
                      //from_top :: defs

                      //def from_top = <[decl:
                      //                 public override PathFromTop(fsm : $(ChartName : usesite)) : State {$(DefineTransBody([st.PathFromOut], GenCtx.InEventHandler()))}
                      //               ]>;
                  if (st.IsTopState) 
                  {
                    analyser.Events.Map(x => <[decl: public virtual $(x : usesite)(_ : $(ChartName : usesite)) : State {null}]>);
                  } else
                    if (st.Lived)
                    {
                      def group = st.WorkTransitions.GroupBy(x => x.FriendlyTriggerName).Select(x => (x.Key, x.NToList()));
                      group.MapToList((x, y) => <[decl: 
                            public override $(x : usesite)(fsm : $(ChartName : usesite)) : State {$(DefineTransBody(y, GenCtx.InEventHandler()))}]>)
                    } else 
                    {
                      []
                          //throw NotImplementedException();
                    }
      Define(ty, defs)
    }

    DefineTransitionActions() : void
    {
      def trans = analyser.all_transitions.NToList();
      def trans = trans.RemoveDuplicatesSort((x, y) => StateTransition.Comparer(x, y));
      def (init : list[StateTransition.Initial], trans) = trans.PartitionType();
      def trans = trans.Filter(x => !(x.MaybeInlined && IsEmpty(x.PathNode)));
      def trans = init &+ trans;
      def body = GetTransitionFunction(trans);
      // history paths
      def body_name = analyser.HistoryPaths.FoldLeft([], (x, a) => x.Value.FoldLeft(a, (x, a) => (x.Name, x.transition) :: a));//.Map((x, y) => (x.Name(), y.Map(x => x.transition.Value)));
      //def body = body_name.Map((x, y) => );
      def hist = GetTransitionFunction(body_name);
      Define(hist + body);
    }

  }
}
