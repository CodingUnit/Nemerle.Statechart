using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  using StateTransition;
  using ListUtils;
  /// <summary>
  /// Description of GenerateTransitions.
  /// </summary>
  public partial class StaticGenerator
  {

    GetTransitionFunction(tran : list[Transition]) : list[ClassMember]
    {
      tran.Map(x => <[ decl: $(x.Name : usesite)() : State {$(GetTransitionBody(x))} ]>);
    }

    GetTransitionFunction(tran : list[string * Transition]) : list[ClassMember]
    {
      tran.Map((x, y) => <[ decl: $(x : usesite)() : State {$(GetTransitionBody(y))} ]>);
    }

    //GetActions(act : PathNode, inline_suppress : bool = true) : PExpr
    //{
    //  GetActions(act, action_for, inline_suppress)
    //}

    //GetActions(act : IEnumerable[PathNode], inline_suppress : bool = true) : PExpr
    //{
    //  GetActions(act, action_for, inline_suppress)
    //}

    public GetDestination(tran : TargetDeterminator) : PExpr
    {
      //def ctx = ctx ?? GenCtx.Normal();
      | State(st) =>
            def body = GetExecStateName(st);
            body

        | NoStateChange => <[ cur_state ]>

        | Terminate => <[ Terminate();null ]>

        | History(HPseudoState.History(default = Some()) as h) => def name = $"$(h.Name)Run";
            <[ $(name : usesite)();]>

        | History(HPseudoState.History(type = t) as h) =>
            //Name = n, state = p
            def p = h.state;
            def n = h.Name;
            def t = if (p.history.IsTwo) $"$t" else "";
            def name = $"$(t)HistoryFrom$(p)"; // call function of run history
            //if (ctx.IsInEventHandler) <[ fsm.$(n : usesite).$(name : usesite)(fsm) ]> else 
            <[ $(n : usesite).$(name : usesite)(this) ]>;
        | Completion => <[ cur_state.Completion(this) ]>


        //| Final(st, sr, reg, tran) => 
        //    def regname = GetExecStateName(reg, ctx);
        //    def target = GetExecStateName(st, ctx);
        //    def trans = DefineTransBody(tran, ctx);
        //    if (reg.HaveFinal)
        //    {
        //      def hist = reg.ParticipateInHistory;
        //      def hist = GetHistoryClear(hist);
        //    <[
        //      $regname.$(get_sub_region_name(sr) : usesite) = $target;
        //      if ($regname.IsFinal) 
        //      {
        //        $hist;
        //        $trans
        //      } else null
        //    ]>
        //    }
        //    else <[ $target ]>

        //| EventSend(st, evt)    => 
        //    if (st.PartOfRegion is Some(r))
        //    {
        //      def name = GetExecStateName(r, ctx);
        //      <[ $name.$(evt.Name : usesite)(this) ]>
        //    } else
        //      <[ cur_state.$(evt.Name : usesite)(this) ]>


        //| Junction(j)           => get_junction_body(j, ctx)
        //| ChoiceNode(j)         => get_choice_body(j, ctx)
        //| TransitionExecute(tr) => if (ctx.IsInEventHandler) <[ fsm.$(tr.Name : usesite)() ]> else <[ $(tr.Name : usesite)() ]>
        //| ExitPoint(_)          => <[ null ]>
        //| SubMachine            => throw NotImplementedException();
        | _                     => throw InvalidOperationException("unknown destination")
    }

    EvalGuardExpr(expr : PExpr) : PExpr
    {
      def check_eval(_, after, e)
      {
        if (after)
        match (e)
        {
          | <[ in_state($st) ]>
          | <[ InState($st) ]>   => def st = st.ToString();
                                    def st = GetExecStateName(st);
                                    <[ fsm.IsInState($st) ]>
          | t => t
        } else e
      }

      Macros.TraverseExpr(None(), expr, false, check_eval)
    }

    GetGuardCondExpr(g : GuardNode) : PExpr
    {
      match (g)
      {
        | GuardNode.Expr(cond) => EvalGuardExpr(cond)
        //| InState(st) => 
        | _                    => <[ true ]>
      }
    }

    //GetCheck(node : CheckNode, ctx : GenCtx) : PExpr
    //{
    //  match (node)
    //  {
    //    | Empty         => <[ () ]>
    //    | Sequence(lst) => def check = lst.Map(x => GetCheck(x, ctx));
    //                      MergeExprAnd(check)
    //    | RegionStates(st) => 

    //        def get_check(reg, st)
    //        {

    //          def check_st = reg.sub_states.Map(x => {
    //                                              match (st.Find(y => y.PartOfSubRegion.Value : object == x)) 
    //                                              {
    //                                                | Some(st) => GetExecStateName(st, ctx) 
    //                                                | _        => <[ null ]>
    //                                              }});

    //          def reg_state = GetExecStateName(reg, ctx);
    //          if (st.All(x => x.Lived && x.LivedSubStatesNested.IsEmpty()))
    //            <[ $reg_state.IsInStateConcrete(..$check_st) ]>
    //          else 
    //            <[ $reg_state.IsInState(..$check_st) ]>
    //        }

    //        def reg = st.Map(x => x.PartOfRegion.Value);
    //        if (reg.ElementsEqual((x, y) => x : object == y))
    //        {
    //          get_check(reg.Head, st)
    //        } else
    //        {
    //          def group = st.GroupBy(x => x.PartOfRegion.Value.Name);
    //          def check = group.Select(x => get_check(x.First().PartOfRegion.Value, x));
    //          MergeExprAnd(check);
    //        }

    //    | Join(Join(name = n, joined_tran = jtran), tran) => 
    //        def reg = jtran.Map(x => x.FromRegion);
    //        def idx = reg.FindIndex(tran.FromRegion : object == _);
    //        def fname = $"join$n";
    //      <[ $(fname : usesite) == $idx ]>

    //    | Guard(g) => GetGuards(g, ctx)
    //    | _        => throw InvalidOperationException("unknown check")
    //  }
    //}

    GetGuards(g : GuardNode) : PExpr
    {
      GetGuardCondExpr(g);//(_, ctx));
    }

    //GetGuardedBody(tran : StateTransition, body : PExpr, ctx : GenCtx) : PExpr
    //{
    //  match (tran)
    //  {
    //    | StateTransition(executeCheck = check, guard = g) =>

    //        def check = GetCheck(check, ctx);
    //        def check = match (g)
    //                    {
    //                      | Empty => [check]
    //                      | _     => [GetGuardCondExpr(g, ctx), check]
    //                    }
    //        match (check)
    //        {
    //          | [<[ () ]>] => body
    //          | _ => 
    //              def check = MergeExprAnd(check);
    //              <[
    //              {
    //                res:
    //                {
    //                  unless ($check) res(null);
    //                  $body
    //                }
    //              }
    //              ]>
    //        }
    //  }
    //}

    //GetPostConditions(body : PExpr, post : TransitionPostConditions, ctx : GenCtx = null) : PExpr
    //{
    //  def ctx = ctx ?? GenCtx.Normal();
    //  //def pre = <[ def st = $body; ]>;
    //  match (post)
    //  {
    //    | RegionCompletion(reg, tr) => 
    //      def check_reg = CheckNode.RegionStates(tr.Map(x => x.From));
    //      def guard = tr.FoldLeft(GuardNode.Empty(), (x, a) => a + x.guard);
    //      def check_guard = if (tr.Exists(x => x.guard.NotEmpty)) CheckNode.Guard(guard) else CheckNode.Empty();
    //      def check = check_reg + check_guard;
    //      def check = GetCheck(check, ctx);
    //      def name = GetExecStateName(reg, ctx);
    //      def send_evt = <[ $name.Completion(this) ]>;
    //      <[
    //      def st = $body;
    //      if ($check) $send_evt else st;
    //      ]>

    //    | _ => body
    //  }
    //}

    GetPath(path : PathSequence) : PExpr
    {
      def path = GenTranPath(path, action_for, util, analyser.FsmFlags);
      path.TranBody
    }
    
    GetBody(acts : PathSequence, dest : TargetDeterminator) : PExpr
    {
      def target = GetDestination(dest);
      
      def body = GetPath(acts);
      def body = <[
                    $body;
                    $target
                  ]>;

      body
    }

    GetTransitionBody(tran : Transition) : PExpr
    {
      //get_junction_body(tran.DecisionTree, ctx)
      def body = GetBody(tran.Path, tran.Target);
      
      if (tran.Guard.IsEmpty) body else 
      {
        def guard = GetGuards(tran.Guard);
        <[ if ($guard) $body else null ]>
      }
      
    }

    DefineTransBody(tr : Transition) : PExpr
    {
      def name = tr.Name;
      <[ $(name : usesite)();]>
    }
    
    DefineHandlerTransBody(tr : Transition) : PExpr
    {
      def name = tr.Name;
      <[ fsm.$(name : usesite)();]>
    }
    
    DefineHandlerTransBody(tr : list[Transition], els : PExpr = null) : PExpr
    {
      def get_body(x, a)
      {
          def body = DefineHandlerTransBody(x);
          <[
            def res = $body;
            if (res != null) res else $a
          ]>
      }
      
      match (tr)
      {
        | [tr] => DefineHandlerTransBody(tr)
        | _    => tr.FoldBack(if (els == null) <[ null ]> else els, get_body)
      }
    }

    DefineDeferedEvents() : void
    {
      when (HasDeferedEvents)
      {
        ty.Define(<[decl: mutable defered : List[Event] = List();]>);
        ty.Define(<[decl: CheckDefered() : void
                   {
                     for (mutable i = 0; i < defered.Count; ++i)
                     {
                       def e = defered[i];
                       unless (cur_state.IsDefer(e)) 
                       {
                         Dispatch(e);
                         defered.RemoveAt(i);
                         i--;
                       }
                     }
                   }]>);
        ty.Define(<[decl: Defer(evt : Event) : void
                    {
                      defered.Add(evt)
                    }]>)
      }
    }
    
    DefineDeferedEvents(ty : TypeBuilder, st : ActiveStateConfig) : void
    {
      def evt = st.deffered_events;
      when (!evt.IsEmpty()) 
      {
        def cases = evt.FoldBack([<[case: _ => false ]>], (x, a) => <[case: | Event.$(x.Name : usesite) => true ]> :: a);
        when (HasDeferedEvents)
        {
          def is_defer = <[decl: public override IsDefer(evt : Event) : bool { match (evt) { ..$cases } } ]>;
          Define(ty, is_defer);
        }
        def decls = evt.Map(x => <[ decl: public override $(x.Name : usesite)(fsm : $(ChartName : usesite)) : State { fsm.Defer(Event.$(x.Name : usesite)); null }]>);
        Define(ty, decls)
      }
    }
    
    DefineTransitions(ty : TypeBuilder, st : ActiveStateConfig) : void
    {
      def defs =  {
                      def group = st.transitions.GroupBy(x => x.Trigger.Name).Select(x => (x.Key, x.NToList()));
                      DefineDeferedEvents(ty, st);
                      group.MapToList((x, y) => <[decl: 
                            public override $(x : usesite)(fsm : $(ChartName : usesite)) : State {$(DefineHandlerTransBody(y))}]>)
                    }
      Define(ty, defs)
    }

    DefineTransitionActions() : void
    {
      def body = GetTransitionFunction(transitions);
      // history paths
      //def body_name = analyser.HistoryPaths.FoldLeft([], (x, a) => x.Value.FoldLeft(a, (x, a) => (x.Name, x.transition) :: a));
      //def hist = GetTransitionFunction(body_name);
      Define(body);
    }

  }
}
