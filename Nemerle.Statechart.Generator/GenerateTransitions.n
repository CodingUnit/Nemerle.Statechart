using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  using ListUtils;
  /// <summary>
  /// Description of GenerateTransitions.
  /// </summary>
  public partial class StaticGenerator
  {

    GetGroupTransitionName(from : ActiveStateConfig, trigger : StateEvent) : string
    {
      $"Transition$(from)By$trigger"
    }

    internal GetTransitionFunction(tran : Transition) : ClassMember
    {
      <[ decl: $(tran.Name : usesite)() : State { $(GetTransitionBody(tran)) } ]>
    }

    internal  GetTransitionFunction(name : string, tran : Transition) : ClassMember
    {
      <[ decl: $(name : usesite)() : State { $(GetTransitionBody(tran)) } ]>
    }
    
    internal  GetTransitionFunction(tran : list[string * Transition]) : list[ClassMember]
    {
      tran.Map(GetTransitionFunction)
    }

    GetTransitionName(tran : Transition) : string
    {
      if (tran.Grouped > 1)
      {
        GetGroupTransitionName(tran.Source, tran.Trigger);
      } else tran.Name
    }

    GetTransitionFunction(st : ActiveStateConfig) : list[ClassMember]
    {
      def tran = st.transitions;
      def get_body(x)
      {
        def name = GetTransitionName(x);
        <[ decl: $(name : usesite)() : State { $(GetTransitionBody(x)) } ]>
      }

      tran.Map(get_body);
    }

    public GetDestination(tran : TargetDeterminator) : PExpr
    {
      | State(st)     => GetExecStateName(st);
      | NoStateChange => <[ cur_state ]>
      | Terminate     => <[ Terminate();null ]>
      | History(h) => SingleHistoryEmit.HistoryRestoreCode(h)
      | Completion(st) => match (st.transitions.Find(x => x.Trigger.IsCompletion))
          {
            | Some(tran) => <[ $(tran.Name : usesite)() ]>
            | _          => <[ Terminate();null ]>
          }
      | _                     => throw InvalidOperationException("unknown destination")
    }

    EvalGuardExpr(expr : PExpr) : PExpr
    {
      def check_eval(_, after, e)
      {
        if (after)
          match (e)
          {
            | <[ in_state($st) ]>
            | <[ InState($st) ]>   => def st = st.ToString();
                                    def st = GetExecStateName(st);
                                    <[ fsm.IsInState($st) ]>
            | t => t
          } else e
      }

      Macros.TraverseExpr(None(), expr, false, check_eval)
    }

    GetGuardCondExpr(g : GuardNode) : PExpr
    {
      match (g)
      {
        | GuardNode.Expr(cond) => EvalGuardExpr(cond)
        //| InState(st) => 
        | _                    => <[ true ]>
      }
    }

    GetGuards(g : GuardNode) : PExpr
    {
      GetGuardCondExpr(g);//(_, ctx));
    }

    GetPath(path : PathSequence) : PExpr
    {
      def path = GenTranPath(path, action_for, util, FsmFlags);
      path.TranBody
    }

    GetTransitionBody(tran : Transition) : PExpr
    {
      get_junction_body(tran.DecisionTree);
    }

    DefineTransBody(tr : Transition) : PExpr
    {
      def name = tr.Name;
      <[ $(name : usesite)();]>
    }

    DefineHandlerTransBody(tr : Transition) : PExpr
    {
      def name = GetTransitionName(tr);
      <[ fsm.$(name : usesite)();]>
    }

    DefineDeferedEvents() : void
    {
      when (HasDeferedEvents)
      {
        ty.Define(<[decl: mutable defered : List[Event] = List();]>);
        ty.Define(<[decl: CheckDefered() : void
                  {
                    for (mutable i = 0; i < defered.Count; ++i)
                    {
                      def e = defered[i];
                      unless (cur_state.IsDefer(e)) 
                      {
                        Dispatch(e);
                        defered.RemoveAt(i);
                        i--;
                      }
                    }
                  }]>);
        ty.Define(<[decl: Defer(evt : Event) : void
                    {
                      defered.Add(evt)
                    }]>)
      }
    }

    DefineDeferedEvents(ty : TypeBuilder, st : ActiveStateConfig) : void
    {
      def evt = st.deffered_events;
      when (!evt.IsEmpty()) 
      {
        def cases = evt.FoldBack([<[case: _ => false ]>], (x, a) => <[case: | Event.$(x.Name : usesite) => true ]> :: a);
        when (HasDeferedEvents)
        {
          def is_defer = <[decl: public override IsDefer(evt : Event) : bool { match (evt) { ..$cases } } ]>;
          Define(ty, is_defer);
        }
        def decls = evt.Map(x => <[ decl: public override $(x.Name : usesite)(fsm : $(ChartName : usesite)) : State { fsm.Defer(Event.$(x.Name : usesite)); null }]>);
        Define(ty, decls)
      }
    }

    DefineTransitions(ty : TypeBuilder, st : ActiveStateConfig) : void
    {
      def defs =  {
                  def group = st.transitions;//.GroupBy(_.Trigger).Select(x => (x.Key, x.NToList()));
                  DefineDeferedEvents(ty, st);
                  group.MapToList(x => <[decl: public override $(x.Trigger.Name : usesite)(fsm : $(ChartName : usesite)) : State { $(DefineHandlerTransBody(x)) }]>)
                  }
      Define(ty, defs)
    }

    DefineTransitionActions() : void
    {
      Define(GetTransitionFunction(Initial));
      foreach (st in ActiveStates)
      {
        def body = GetTransitionFunction(st);
      // history paths

        Define(body);
      }
    }

  }
}
