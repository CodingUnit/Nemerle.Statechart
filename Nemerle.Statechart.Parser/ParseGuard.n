using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Peg;

namespace Nemerle.Statechart
{



  public partial class FsmParser
  {
    is_in_state(tok : NToken, name : NameIdentifier) : StateExpr
    {
      def pos = tok.StartPos;
      StateExpr.Method(pos, FsmAction(pos, "InState", [name.FullName]))
    }

    else_guard(tok : NToken) : GuardNode
    {
      GuardNode.Else(tok.StartPos)
    }

    lit_string(s : NToken, id : NToken, _ : NToken) : StateLit
    {
      StateLit.String(s.StartPos, GetText(id))
    }

    lit_double(f : NToken, s : NToken) : StateLit
    {
      def fnum = GetText(f);
      def sec  = GetText(s);
      def num = $"$fnum.$sec";
      StateLit.Double(f.StartPos, double.Parse(num))
    }


    lit_num(f : NToken) : StateLit
    {
      StateLit.Integer(f.StartPos, int.Parse(GetText(f)))
    }

    lit_bool(f : NToken) : StateLit
    {
      StateLit.Bool(f.StartPos, bool.Parse(GetText(f)))
    }

    braces_guard(s : NToken, expr : StateExpr, _ : NToken) : StateExpr
    {
      StateExpr.Braces(s.StartPos, expr)
    }

    var_guard(id : NToken) : StateExpr
    {
      StateExpr.Var(id.StartPos, GetText(id))
    }

    meth_guard(id : FsmAction) : StateExpr
    {
      StateExpr.Method(id.pos, id)
    }

    lit_guard(lit : StateLit) : StateExpr
    {
      StateExpr.Literal(lit.pos, lit)
    }

    two_op_expr(op : NToken) : StateBinaryOp
    {
      def pos = op.StartPos;
      match (GetText(op))
      {
        | "==" => StateBinaryOp.Equal(pos)
        | "!=" => StateBinaryOp.NotEqual(pos)
        | ">"  => StateBinaryOp.Above(pos)
        | ">=" => StateBinaryOp.AboveEq(pos)
        | "<"  => StateBinaryOp.Below(pos)
        | "<=" => StateBinaryOp.BelowEq(pos)
        | "||" => StateBinaryOp.Or(pos)
        | "&&" => StateBinaryOp.And(pos)
        | _    => StateBinaryOp.Error(pos)
      }
    }

    one_op_expr(op : NToken) : StateUnaryOp
    {
      def pos = op.StartPos;
      match (GetText(op))
      {
        | "!" => StateUnaryOp.Not(pos)
        | _   => StateUnaryOp.Error(pos)
      }
    }

    one_op_guard(op : StateUnaryOp, expr : StateExpr) : StateExpr
    {
      StateExpr.UnaryOp(op.pos, op, expr)
    }

    expr_guard(expr : StateExpr) : GuardNode
    {
      GuardNode.Expr(expr.pos, expr)
    }

    process_precedence(expr : StateExpr, exprs : list[StateBinaryOp * StateExpr]) : StateExpr
    {
      def loop(exp, exprs, cont)
      {
        match (exprs)
        {
          | []                          => cont(exp)
          | (op1, e2) :: (((op2, _) :: _) as tail) when (op1.Precedence < op2.Precedence) => 
                                           loop(e2, tail, x => StateExpr.TwoOp(exp.pos, exp, op1, x))
          | (op, e2) :: tail            => loop(StateExpr.TwoOp(exp.pos, exp, op, e2), tail, cont)
        }
      }

      loop(expr, exprs, x => x)

    }


    guard_expr(expr : StateExpr, lst : List[StateBinaryOp * StateExpr]) : StateExpr
    {
      process_precedence(expr, lst.NToList())
    }
  }
}
