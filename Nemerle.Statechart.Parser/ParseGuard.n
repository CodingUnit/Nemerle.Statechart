using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Peg;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{



  public partial class FsmParser
  {
    //is_in_state(tok : NToken, name : NameIdentifier) : GuardExpr
    //{
    //  def pos = tok.StartPos;
    //  GuardExpr.Method(pos, FsmAction(pos, "InState", [name.FullName]))
    //}

    else_guard(tok : NToken) : GuardNode
    {
      GuardNode.Else(tok.StartPos)
    }

    //lit_string(s : NToken, id : NToken, _ : NToken) : StateLit
    //{
    //  StateLit.String(s.StartPos, GetText(id))
    //}

    //lit_double(f : NToken, s : NToken) : StateLit
    //{
    //  def fnum = GetText(f);
    //  def sec  = GetText(s);
    //  def num = $"$fnum.$sec";
    //  StateLit.Double(f.StartPos, double.Parse(num))
    //}


    //lit_num(f : NToken) : StateLit
    //{
    //  StateLit.Integer(f.StartPos, int.Parse(GetText(f)))
    //}

    //lit_bool(f : NToken) : StateLit
    //{
    //  StateLit.Bool(f.StartPos, bool.Parse(GetText(f)))
    //}

    //braces_guard(s : NToken, expr : GuardExpr, _ : NToken) : GuardExpr
    //{
    //  GuardExpr.Braces(s.StartPos, expr)
    //}

    //var_guard(id : NToken) : GuardExpr
    //{
    //  GuardExpr.Var(id.StartPos, GetText(id))
    //}

    //meth_guard(id : FsmAction) : GuardExpr
    //{
    //  GuardExpr.Method(id.pos, id)
    //}

    //lit_guard(lit : StateLit) : GuardExpr
    //{
    //  GuardExpr.Literal(lit.pos, lit)
    //}

    //two_op_expr(op : NToken) : StateBinaryOp
    //{
    //  def pos = op.StartPos;
    //  match (GetText(op))
    //  {
    //    | "==" => StateBinaryOp.Equal(pos)
    //    | "!=" => StateBinaryOp.NotEqual(pos)
    //    | ">"  => StateBinaryOp.Above(pos)
    //    | ">=" => StateBinaryOp.AboveEq(pos)
    //    | "<"  => StateBinaryOp.Below(pos)
    //    | "<=" => StateBinaryOp.BelowEq(pos)
    //    | "||" => StateBinaryOp.Or(pos)
    //    | "&&" => StateBinaryOp.And(pos)
    //    | _    => StateBinaryOp.Error(pos)
    //  }
    //}

    //one_op_expr(op : NToken) : StateUnaryOp
    //{
    //  def pos = op.StartPos;
    //  match (GetText(op))
    //  {
    //    | "!" => StateUnaryOp.Not(pos)
    //    | _   => StateUnaryOp.Error(pos)
    //  }
    //}

    //one_op_guard(op : StateUnaryOp, expr : GuardExpr) : GuardExpr
    //{
    //  GuardExpr.UnaryOp(op.pos, op, expr)
    //}

    guard(_ : NToken, type : GuardNode, _ : NToken) : GuardNode
    {
      type
    }
    
    expr_guard(expr : PExpr) : GuardNode
    {
      GuardNode.Expr(expr.Location.Line, expr)
    }

    //process_precedence(expr : GuardExpr, exprs : list[StateBinaryOp * GuardExpr]) : GuardExpr
    //{
    //  def loop(exp, exprs, cont)
    //  {
    //    match (exprs)
    //    {
    //      | []                          => cont(exp)
    //      | (op1, e2) :: (((op2, _) :: _) as tail) when (op1.Precedence < op2.Precedence) => 
    //                                       loop(e2, tail, x => GuardExpr.TwoOp(exp.pos, exp, op1, x))
    //      | (op, e2) :: tail            => loop(GuardExpr.TwoOp(exp.pos, exp, op, e2), tail, cont)
    //    }
    //  }

    //  loop(expr, exprs, x => x)

    //}


    guard_expr(tok : NToken) : PExpr//expr : GuardExpr, lst : List[StateBinaryOp * GuardExpr]) : GuardExpr
    {
      MainParser.ParseExpr(env, GetText(tok), false)
      //process_precedence(expr, lst.NToList())
    }
  }
}
