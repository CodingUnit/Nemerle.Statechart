using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Peg;

namespace Nemerle.Statechart
{



  public partial class FsmParser
  {
    is_in_state(tok : NToken, name : NameIdentifier) : StateExpr
    {
      def pos = tok.StartPos;
      StateExpr.Method(pos, FsmAction(pos, "InState", [name.FullName]))
    }

    else_guard(tok : NToken) : GuardNode
    {
      GuardNode.Else(tok.StartPos)
    }

    lit_string(s : NToken, id : NToken, _ : NToken) : StateLit
    {
      StateLit.String(s.StartPos, GetText(id))
    }

    lit_double(f : NToken, s : NToken) : StateLit
    {
      def fnum = GetText(f);
      def sec  = GetText(s);
      def num = $"$fnum.$sec";
      StateLit.Double(f.StartPos, double.Parse(num))
    }

    
    lit_num(f : NToken) : StateLit
    {
      StateLit.Integer(f.StartPos, int.Parse(GetText(f)))
    }

    lit_bool(f : NToken) : StateLit
    {
      StateLit.Bool(f.StartPos, bool.Parse(GetText(f)))
    }
    
    braces_guard(s : NToken, expr : StateExpr, _ : NToken) : StateExpr
    {
      StateExpr.Braces(s.StartPos, expr)
    }

    var_guard(id : NToken) : StateExpr
    {
      StateExpr.Var(id.StartPos, GetText(id))
    }

    meth_guard(id : FsmAction) : StateExpr
    {
      StateExpr.Method(id.pos, id)
    }

    lit_guard(lit : StateLit) : StateExpr
    {
      StateExpr.Literal(lit.pos, lit)
    }

    two_op_expr(op : NToken) : StateBinaryOp
    {
      def pos = op.StartPos;
      match (GetText(op))
      {
        | "==" => StateBinaryOp.Equal(pos)
        | "!=" => StateBinaryOp.NotEqual(pos)
        | ">"  => StateBinaryOp.Above(pos)
        | ">=" => StateBinaryOp.AboveEq(pos)
        | "<"  => StateBinaryOp.Below(pos)
        | "<=" => StateBinaryOp.BelowEq(pos)
        | "||" => StateBinaryOp.Or(pos)
        | "&&" => StateBinaryOp.And(pos)
        | _    => StateBinaryOp.Error(pos)
      }
    }
    
    one_op_expr(op : NToken) : StateUnaryOp
    {
      def pos = op.StartPos;
      match (GetText(op))
      {
        | "!" => StateUnaryOp.Not(pos)
        | _   => StateUnaryOp.Error(pos)
      }
    }
    
    one_op_guard(op : StateUnaryOp, expr : StateExpr) : StateExpr
    {
      StateExpr.UnaryOp(op.pos, op, expr)
    }
    
    expr_guard(expr : StateExpr) : GuardNode
    {
      GuardNode.Expr(expr.pos, expr)
    }
    
    process_precedence(expr : StateExpr, lst : List[StateBinaryOp * StateExpr]) : StateExpr
    {
      def (ops, exprs) = lst.NToList().Split();
      def exprs = expr :: exprs;
      
      def loop(op, exp, cont)
      {
        match (op, exp)
        {
          | (op1 :: ((op2 :: _) as t), e1 :: e2 :: etail) when (op1.Precedence >= op2.Precedence) => 
              def eval = StateExpr.TwoOp(e1.pos, e1, op1, e2);
              loop(t, eval :: etail, cont)
          
          | (op :: [], e1 :: e2 :: []) => def eval = StateExpr.TwoOp(e1.pos, e1, op, e2);
                                          loop([], [eval], cont)
                                          
          | (op1 :: t, e1 :: etail)    => loop(t,  etail, x => StateExpr.TwoOp(e1.pos, e1, op1, x))
              
          
              
          | ([], eval :: []) => cont(eval)
          | (_, _)           => StateExpr.Error(expr.pos)
        }
      }
      
      loop(ops, exprs, x => x)
    }
    
    
    guard_expr(expr : StateExpr, lst : List[StateBinaryOp * StateExpr]) : StateExpr
    {
     process_precedence(expr, lst)
    }
  }
}
