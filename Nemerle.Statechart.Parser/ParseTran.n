using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Peg;
using Nemerle;
using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  using StateNode;  
  //using TransitionNode;
  using PseudoStateModelNode;
  using GuardNode;
  using ListUtils;

  public partial class FsmParser
  {

    qualified_target(name : NameIdentifier, _ : NToken) : TargetType
    {
      def pos = name.pos;

      def get_target(n)
      {
        | "history"  with hist = HistoryType.None
        | "H"  with hist = HistoryType.Shallow
        | "h"  with hist = HistoryType.Shallow
        | "h*" with hist = HistoryType.Deep
        | "H*" with hist = HistoryType.Deep => TargetType.PseudoState(pos, PseudoStateModelNode.History(pos, hist, None()))
        | "final"
        | "$0"       => TargetType.Final(pos)
        | "self"
        | "@"        => TargetType.Self(pos)
        | "terminate"
        | "x"
        | "X"        => TargetType.PseudoState(name.pos, PseudoStateModelNode.Terminate(0))
        | x when (x.IndexOf('(') != -1 ) => 
              def n = string(n.Explode().Except(['(', ')']).ToArray());
              TargetType.Named(name.pos, n)
          //| _ => TargetType.Named(name.pos, name.TargetName.Trim('(',')'))
        | _                      => TargetType.Named(name.pos, n)
      }

      match (name)
      {
        | Name(name = n) => get_target(n)
        | QualifiedName(parts = n) => def (tar, lst) = n.SplitLast();
            def st = $<#..$(lst;".")#>;
            TargetType.Qualified(name.pos, st, get_target(tar))//State(st, StateType.State()), 
      }
    }

    exit_point_target(id : NameIdentifier, _ : NToken) : TargetType
    {
      def pos = id.pos;
      TargetType.PseudoState(pos, PseudoStateModelNode.ExitPoint(pos, id.name, None()))
    }
    
    default_transition(act : Actions, target : TargetType) : StateNode.Transition
    {
      def act = if (act.Empty) None() else Some(act);
      StateNode.Transition(target.pos, None(), [], GuardNode.Empty(-1), act, target, TransitionKind.Local)
    }

    events(id : NToken, evt : List[NToken * NToken]) : List[TransitionEvent]
    {
      def evt = evt.Select((_, x : NToken) => x);
      def lst = evt.AddBefore(id);
      lst.Select(create_event).ToList()
    }

    ext_transition(evt : List[TransitionEvent], guard : option[GuardNode], act : Actions, to : TargetType) : StateNode.Transition
    {
      def pos = evt.First().pos;
      def act = if (act.Empty) None() else Some(act);
      def guard = guard.WithDefault(GuardNode.Empty(-1));
      Transition(pos, None(), evt.NToList(), guard, act, to, TransitionKind.Transition)
    }

    local_trans(evt : List[TransitionEvent], guard : option[GuardNode], act : Actions, to : TargetType) : StateNode.Transition
    {
      def pos = evt.First().pos;
      def act = if (act.Empty) None() else Some(act);
      def guard = guard.WithDefault(GuardNode.Empty(-1));
      Transition(pos, None(), evt.NToList(), guard, act, to, TransitionKind.Local)
    }

    internal_trans(evt : List[TransitionEvent], guard : option[GuardNode], acts : Actions) : StateNode.Transition
    {
      def pos = if (evt.Count() != 0) evt.First().pos else -1;
      def guard = guard.WithDefault(GuardNode.Empty(-1));
      Transition(pos, None(), evt.NToList(), guard, Some(acts), TargetType.NoTarget(pos), TransitionKind.Internal)
    }

    deferrable_evts(lst : List[TransitionEvent], tok : NToken, _ : NToken, _ : NToken) : StateNode.Defer
    {
      Defer(tok.StartPos, lst.NToList())
    }
    
    deferred_evts(tok : NToken, _ : NToken, lst : List[TransitionEvent], _ : NToken) : StateNode.Defer
    {
      Defer(tok.StartPos, lst.NToList())
    }
    
    relocate_tran(n : NameIdentifier, _ : NToken, id : NToken, tran : StateNode.Transition) : StateNode
    {
      def from = n.Add(GetText(id));
      StateNode.Transition(n.pos, Some(from), [], GuardNode.Empty(), tran.action, tran.to, TransitionKind.Transition)
    }
  }
}
