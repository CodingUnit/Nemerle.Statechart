using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Peg;
using Nemerle;
using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  using StateNode;  
  //using TransitionNode;
  using PseudoStateModelNode;
  using GuardNode;
  using ListUtils;

  public partial class FsmParser
  {
    fully_qualified(id : NToken, tail : List[NToken]) : NameIdentifier
    {
      def pos = id.StartPos;
      def tail = tail |> GetText(_);
      match (GetText(id), tail)
      {
        | (s, []) => NameIdentifier.Name(pos, s)
        | (s, tail) => def lst = s :: tail;
            def joined = $<#..$(lst;".")#>;
            NameIdentifier.QualifiedName(pos, joined, lst)
      }
    }

    
    simple_target(name : NameIdentifier) : TargetType
    {
      def pos = name.pos;
      
      def get_target(n)
      {
          | "history"  with hist = HistoryType.None
          | "H"  with hist = HistoryType.Shallow
          | "h"  with hist = HistoryType.Shallow
          | "h*" with hist = HistoryType.Deep
          | "H*" with hist = HistoryType.Deep => TargetType.PseudoState(pos, PseudoStateModelNode.History(pos, hist, None()))
          | "final"
          | "$0"       => TargetType.Final(pos)
          | "self"
          | "@"        => TargetType.Self(pos)
          | "terminate"
          | "x"
          | "X"        => TargetType.PseudoState(name.pos, PseudoStateModelNode.Terminate(0))
          | x when (x.IndexOf('(') != -1 ) => 
              def n = string(n.Explode().Except(['(', ')']).ToArray());
              TargetType.Named(name.pos, n)
          //| _ => TargetType.Named(name.pos, name.TargetName.Trim('(',')'))
          | _                      => TargetType.Named(name.pos, n)
      }

      match (name)
      {
        | Name(name = n) => get_target(n)
        | QualifiedName(parts = n) => def (tar, lst) = n.SplitLast();
            def st = $<#..$(lst;".")#>;
            TargetType.Qualified(name.pos, st, get_target(tar))//State(st, StateType.State()), 
      }
    }

    //transition_mark(guard : option[GuardNode], act : option[Actions], target : TargetType) : StateNode.Transition
    //{
    //  StateNode.Transition(guard, act, target)
    //}

    default_transition(act : option[Actions], target : TargetType) : StateNode.Transition
    {
      StateNode.Transition(target.pos, [], None(), act, target, TransitionType.Local)
    }

    events(id : NToken, evt : List[NToken]) : List[TransitionEvent]
    {
      def lst = evt.AddBefore(id);
      lst.Select(create_event).ToList()
    }

    simple_transition(evt : List[TransitionEvent], guard : option[GuardNode], act : option[Actions], to : TargetType) : StateNode.Transition
    {
      def pos = evt.First().pos;
      Transition(pos, evt.NToList(), guard, act, to, TransitionType.Transition)
    }

    local_trans(evt : List[TransitionEvent], guard : option[GuardNode], act : option[Actions], to : TargetType) : StateNode.Transition
    {
      def pos = evt.First().pos;
      Transition(pos, evt.NToList(), guard, act, to, TransitionType.Local)
    }
    
    simple_attrs(attr : List[List[NToken]]) : List[NToken]
    {
      attr.Flatten().ToList()
    }

    attributes(attr : List[NToken]) : List[StateAttribute]
    {
      def get_attr(at)
      {
        match (GetText(at))
        {
          | "Initial" => StateAttribute.Initial(at.StartPos)
          | str       => StateAttribute.Unknown(at.StartPos, str)
        }
      }

      attr.Map(get_attr).ToList()
    }

    trans_act_list(act : NToken, lst : List[FsmAction]) : Actions
    {
      create_action(act, lst)
    }

    block_action_list(start : NToken, _ : NToken, lst : List[FsmAction], _ : NToken) : Actions
    {
      create_action(start, lst)
    }

    //empty_action_list(tok : NToken) : Actions
    //{
    //  Actions(tok.StartPos, [])
    //}

    empty_action(s : NToken, _ : NToken) : FsmAction
    {
      FsmAction(s.StartPos, null, [])
    }
    
    delim_action_list(tok : NToken, lst : List[FsmAction]) : Actions
    {
      create_action(tok, lst)
    }

    entry(attr : option[List[NToken]], key : NToken, acts : option[Actions]) : Entry
    {
      def acts = acts.WithDefault(Actions(key.StartPos, []));
      def attr = attr.WithDefault(Enumerable.Empty());
      def attr = get_action_attr(attr);
      Entry(key.StartPos, attr, acts)
    }

    exit(attr : option[List[NToken]], key : NToken,  acts : option[Actions]) : Exit
    {
      def acts = acts.WithDefault(Actions(key.StartPos, []));
      def attr = attr.WithDefault(Enumerable.Empty());
      def attr = get_action_attr(attr);
      Exit(key.StartPos, attr, acts)
    }

    get_action_attr(attr : IEnumerable[NToken]) : ActionFlags
    {
      def get_attr(at, res)
      {
        match (GetText(at))
        {
          | _ => (ActionFlags.None | res)
        }
      }

      attr.FoldLeft(ActionFlags.None, get_attr)
    }

    do_activity(_attr : option[List[NToken]], key : NToken, acts : Actions) : DoActivity
    {
      //def get_attr(at, res)
      //{
      //  def flag = match (GetText(at))
      //              {
      //                | "Concurrently" => ActivityFlag.Concurrently
      //                | "NoWait"       => ActivityFlag.NoWaitCancel
      //                | "NotLong"      => ActivityFlag.NotLong
      //                | _              => ActivityFlag.None
      //              }
      //  res | flag
      //}

      //def flags = attr.WithDefault(Enumerable.Empty());
      //def flags = flags.FoldLeft(ActivityFlag.None, get_attr);
      DoActivity(key.StartPos, acts, ActivityFlag.None)
    }

    internal_trans(evt : NToken, guard : option[GuardNode], acts : Actions) : StateNode.Transition
    {
      Transition(evt.StartPos, create_event(evt) :: [], guard, Some(acts), TargetType.NoTarget(evt.StartPos), TransitionType.Internal)
    }

    initial(name : NToken, act : option[Actions], to : TargetType) : StateNode.PseudoState
    {
      def pos = name.StartPos;
      //Enumerable.Empty(), guard, act, to, TransitionType.Initial
      PseudoState(pos, PseudoStateModelNode.Initial(pos, StateNode.Transition(pos, [], None(), act, to, TransitionType.Local)))
    }

    flags(s : NToken, tok : List[NToken]) : StateNode
    {
      def err = List();
      
      def proc_tok(tok, flag)
      {
        def nflag= match (GetText(tok))
                    {
                      | "debug"                        => MachineFlag.Debug
                      | "auto_initial"                 => MachineFlag.AutoInitial
                      | "local_default"                => MachineFlag.LocalDefault
                      | "transition_completed_events"  => MachineFlag.TransitionCompleted
                      //| "completion_strict"            => MachineFlag.CompletionStrict
                      | "only_analyse"                 => MachineFlag.OnlyAnalyse
                      | "auto_entry_exit"              => MachineFlag.AutoEntryExitActions
                      | "testing"                      => MachineFlag.TestingFeatures
                      | x                              => err.Add(x);
                                                          MachineFlag.None
                    }
        nflag |  flag
      }

      def flags = tok.FoldLeft(MachineFlag.None, proc_tok);
      //def flags = if (flags & MachineFlag.TestingFeatures != 0) flags | MachineFlag.AutoEntryExitActions else flags; 
      def flags = MachineFlags(flags, err.NToList());
      StateNode.Flags(s.StartPos, flags)
    }

    history_deep(tok : NToken, tran : option[StateNode.Transition]) : StateNode
    {
      def_history(HistoryType.Deep, tok, tran)
    }

    history_shallow(tok : NToken, tran : option[StateNode.Transition]) : StateNode
    {
      def_history(HistoryType.Shallow, tok, tran)
    }

    history_long(type : NToken, tran : option[StateNode.Transition]) : StateNode
    {
      match (GetText(type))
      {
        | "Deep"
        | "deep"     => def_history(HistoryType.Deep, type, tran)
        | "Shallow"
        | "shallow"  => def_history(HistoryType.Shallow, type, tran)
        | _          => StateNode.Error(type.StartPos, def_history(HistoryType.None, type, tran))
      }
    }

    terminate_node(tok : NToken) : PseudoState
    {
      StateNode.PseudoState(tok.StartPos, PseudoStateModelNode.Terminate(tok.StartPos))
    }

    join(tok : NToken, name : NToken, target : TargetType) : PseudoState
    {
      StateNode.PseudoState(tok.StartPos, PseudoStateModelNode.Join(tok.StartPos, GetText(name), target))
    }

    //junction_target(node : List[TargetType]) : TargetType
    //{
    //  def pos = if (node.Count() != 0) node.First().pos else 0;
    //  TargetType.PseudoState(pos, Junction(pos, null, node.NToList(), JunctionType.Junction))
    //}

    //junction(tok : NToken, name : NToken, node : List[TargetType]) : PseudoState
    //{
    //  def pos = tok.StartPos;
    //  PseudoState(pos, Junction(pos, GetText(name), node.NToList(), JunctionType.Junction))
    //}

    //create_junc_node(tran : StateNode.Transition) : TargetType
    //{
    //    | Transition(guard = g, action = a, to = t) => TargetType.PseudoState(PseudoStateAstNode.Junction(0, null, t))
    //}

    //junction_body(body : List[StateNode.Transition]) : List[TargetType]
    //{
    //  body.Select(create_junc_node).ToList()
    //  //GeneralTree()
    //  //body.FoldBack(null, ((g, a, t), n) => create_junc_node(g, a, t, n))
    //}

    //choice_target(tok : NToken, node : List[TargetType]) : TargetType
    //{
    //  def pos = tok.StartPos;
    //  TargetType.PseudoState(pos, Junction(pos, null, node.NToList(), JunctionType.Choice))
    //}

    //choice(tok : NToken, name : NToken, _ : NToken, node : List[TargetType]) : StateNode.PseudoState
    //{
    //  def pos = tok.StartPos;
    //  PseudoState(pos, Junction(pos, GetText(name), node.NToList(), JunctionType.Choice))
    //}

    //merge(tok : NToken, name : NToken, tran : StateNode.Transition) : StateNode.PseudoState
    //{
    //  def pos = tok.StartPos;
    //  PseudoState(pos, Junction(pos, GetText(name), create_junc_node(tran) :: [], JunctionType.Merge))
    //}

    //trans_target(tar : TargetType, targets : List[TargetType]) : TargetType
    //{
    //  if (targets.Count() == 0) tar else 
    //  {
    //    def targets = tar :: targets.NToList();
    //    TargetType.PseudoState(0, PseudoStateAstNode.Fork(0, targets))
    //  }
    //}

    //inlined_fsm(nkey : NToken, name : NToken, _ : NToken, type : NToken, body : List[StateNode]) : StateNode
    //{
    //  def pos = nkey.StartPos;
    //  def name = GetText(name);
    //  CreateState(pos, name, [], body, StateType.InlinedSubMachine(GetText(type)), None());
    //}

    statemachine(tok : NToken, name : NToken, parent : option[NameIdentifier], decls : List[StateNode]) : StateNode
    {
      def decls = decls.NToList();
      def (trans, decls) = decls.PartitionType();
      def (pseudo, other) = decls.PartitionType();
      def name = GetText(name);
      def type = if (parent is Some(p)) p.FullName else name;
      def errors = other.Map(x => StateNode.Error(x.pos, x));
      State(tok.StartPos, name, parent.Map(x => x.FullName), [], [], [], trans, [], [], pseudo, StateType.SubMachine(type), errors)
    }


    region(beg : NToken, _ : NToken) : StateNode
    {
      StateNode.Region(beg.StartPos)
      //State(beg.StartPos, StateType.SubRegion())
    }
    
    parameters(lst : List[NToken]) : List[string]
    {
      lst.Select(GetText).ToList()
    }
    
    tran_action(n : NToken, pars : option[List[string]]) : FsmAction
    {
      FsmAction(n.StartPos, GetText(n), pars.MapDefault(x => x.NToList(), []))
    }
    
    method_action(n : NToken, pars : List[string]) : FsmAction
    {
      FsmAction(n.StartPos, GetText(n), pars.NToList())
    }
    
  }

}
