using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Peg;
using Nemerle;
using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  using StateNode;  
  //using TransitionNode;
  using PseudoStateModelNode;
  using GuardNode;
  using ListUtils;

  public partial class FsmParser
  {
    fully_qualified(id : NToken, tail : List[NToken * NToken]) : NameIdentifier
    {
      def pos = id.StartPos;
      def tail = tail.Map((_, x) => GetText(x));
      match (GetText(id), tail)
      {
        | (s, []) => NameIdentifier.Name(pos, s)
        | (s, tail) => def lst = s :: tail;
            def joined = $<#..$(lst;".")#>;
            NameIdentifier.QualifiedName(pos, joined, lst)
      }
    }
    
    
    simple_attrs(attr : List[NToken * List[NToken * NToken] * NToken]) : List[NToken]
    {
      attr.SelectMany((_, x, _) => x.Map((x, _) => x)).ToList()
    }

    attributes(attr : List[NToken]) : List[StateAttribute]
    {
      def get_attr(at)
      {
        match (GetText(at))
        {
          | "Initial" => StateAttribute.Initial(at.StartPos)
          | str       => StateAttribute.Unknown(at.StartPos, str)
        }
      }

      attr.Map(get_attr).ToList()
    }



    get_action_attr(attr : IEnumerable[NToken]) : ActionFlags
    {
      def get_attr(at, res)
      {
        match (GetText(at))
        {
          | _ => (ActionFlags.None | res)
        }
      }

      attr.FoldLeft(ActionFlags.None, get_attr)
    }

    do_activity(attr : option[List[NToken]], key : NToken, acts : Actions) : StateNode.DoActivity
    {
      def get_attr(at, res)
      {
        def flag = match (GetText(at))
                    {
                      | "NoWait"       => ActivityFlag.NoCancel
                      | _              => ActivityFlag.None
                    }
        res | flag
      }

      def flags = attr.WithDefault(Enumerable.Empty());
      def flags = flags.FoldLeft(ActivityFlag.None, get_attr);
      DoActivity(key.StartPos, acts, flags)
    }

    flags(s : NToken, tok : List[NToken * NToken], _ : NToken) : StateNode
    {
      def err = List();
      
      def proc_tok((tok, _), flag)
      {
        def nflag= match (GetText(tok))
                    {
                      | "debug"                        => MachineFlag.Debug
                      | "auto_initial"                 => MachineFlag.AutoInitial
                      | "local_default"                => MachineFlag.LocalDefault
                      | "property_state_change"        => MachineFlag.PropertyStateChanged
                      | "only_analyse"                 => MachineFlag.OnlyAnalyse
                      | "auto_entry_exit"              => MachineFlag.AutoEntryExitActions
                      | "testing"                      => MachineFlag.TestingFeatures
                      | "transition_completed"         => MachineFlag.TransitionCompleted
                      | x                              => err.Add(x);
                                                          MachineFlag.None
                    }
        nflag |  flag
      }

      def flags = tok.FoldLeft(MachineFlag.None, proc_tok);
      //def flags = if (flags & MachineFlag.TestingFeatures != 0) flags | MachineFlag.AutoEntryExitActions else flags; 
      def flags = MachineFlags(flags, err.NToList());
      StateNode.Flags(s.StartPos, flags)
    }

   using_mach(tok : NToken, id : NToken, from : NameIdentifier, _ : NToken) : StateNode.Using
   {
     StateNode.Using(tok.StartPos, GetText(id), from.FullName)
   }


    //trans_target(tar : TargetType, targets : List[TargetType]) : TargetType
    //{
    //  if (targets.Count() == 0) tar else 
    //  {
    //    def targets = tar :: targets.NToList();
    //    TargetType.PseudoState(0, PseudoStateAstNode.Fork(0, targets))
    //  }
    //}

    //inlined_fsm(nkey : NToken, name : NToken, _ : NToken, type : NToken, body : List[StateNode]) : StateNode
    //{
    //  def pos = nkey.StartPos;
    //  def name = GetText(name);
    //  CreateState(pos, name, [], body, StateType.InlinedSubMachine(GetText(type)), None());
    //}

    //statemachine(tok : NToken, name : NToken, parent : option[NameIdentifier], decls : List[StateNode]) : StateNode
    //{
    //  def decls = decls.NToList();
    //  def (trans, decls) = decls.PartitionType();
    //  def (pseudo, other) = decls.PartitionType();
    //  def name = GetText(name);
    //  def type = if (parent is Some(p)) p.FullName else name;
    //  def errors = other.Map(x => StateNode.Error(x.pos, x));
    //  State(tok.StartPos, name, parent.Map(x => x.FullName), [], [], [], trans, [], [], pseudo, StateType.SubMachine(type), errors)
    //}

    region(_ : NToken, beg : NToken, _ : NToken, _ : NToken) : StateNode
    {
      StateNode.Region(beg.StartPos)
    }
    
  }

}
