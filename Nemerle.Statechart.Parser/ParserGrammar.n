using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Peg;
using Nemerle;
using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using Nemerle.Compiler.Parsetree;
using System.Text;
using System.IO;

namespace Nemerle.Statechart
{

    using StateNode;
    using PseudoStateModelNode;
    //using TransitionNode;
    /*

<#
  flags : no_auto_initial,  local_default,  auto_initial

  state NManager
  {
      $> Action // entry alternative
      $< Action2 // exit alternative

    initial  => Working
    0  => Working // another initial

    event => terminate; // terminate pseudo state

    event => X;

    [local]
    state NotConnected
    {
        (H)  => Working
    [local]
    Connect  => Working
    Connect2 / Action
    Connect4 ( => Working // local transition syntax
    Connect5 ) => Working // external transition syntax
    Connect3
     {
         Action
         Action2
     }
    }

    [Initial]
    state ClosingPort
    {
        (H*)
        entry / action

        event1  => final
        completion  => State2
        _  => State2 // another completion syntax

        SelfEvent  =>@ // self transition
        SelfEvent2  => self // self transition

        Event1,  Event2  => Working  // many events for one transition
    }

    state Working
    {

     history : Deep  => ABC
     entry
     exit
     {
     Something2
     Something3
     }
        (H*)

      junction j1
      {
      guard1 => a;
      guard2 => b;
      }

     // junction syntax
      a => {guard1 / A1 => b;
             guard2 / A2 => c;
             guard3 / A3 => {
                             guard4 / A4 => e;
                             guard5 / A5=> (j1);
                             else => f;
                             }
             else => d;
            }
            
      merge m1 => A; // merge syntax
      // choice syntax
      a => ${guard1 / A1 => b;
             guard2 / A2 => c;
             guard3 / A3 => {
                             guard4 / A4 => e;
                             guard5 / A5=> (j1);
                             else => f;
                             }
             else => d;
            }
       
            state AnotherSyntax : A
            {
              a => B; //
            }
   }
 }
   #>
    */

  [PegGrammar(Options  =  EmitDebugSources, stateMachine,
  grammar
  {
      any                                             =  ['\u0000'..'\uFFFF'];
      newLine                                         =  "\r\n" / '\n' / '\r' / '\u2028' / '\u2029' / '\u0085';
      singleLineComment                               =  "//" (!('\n' / '\r') [Any])* newLine?;
      delimitedComment                                =  "/*" (!"*/" [Any])* "*/";
      comment                                         =  singleLineComment / delimitedComment;
      spaces_def                                      =  (' ' / '\t' / '\u000B' / '\u000C' / newLine / comment)*;
      spaces : void                                   =  spaces_def;
      letter                                          =  [Lu,  Ll,  Lt,  Lm,  Lo,  Nl,  Nd] / '_' / '-' / '@' / '*' / '$';
      //target_letter                                   =  letter / '(' / ')' / '[' / ']';
      //end_symb  : void                                =  ';'s;
      delimiter : void                                =  ',' / spaces_def;
      s : void                                        =  spaces;
      identifier                                      =  letter+;
      qualified_id                                    =  (letter / '.')+;
      target_id                                       =  identifier;//target_letter+;
      //open_brace  : void                              =  "{"s;
      //close_brace : void                              =  "}"s;
      //slash       : void                              =  '/'s;
      //dollar                                          = '$'s;
      numeric                                         = [Nl,  Nd]+;
      
      goto        : void                              =   "=>"s;
      entry_key                                       =  ("entry" / "$>")s;
      exit_key                                        =  ("exit" / "$<")s;
      state_key   : void                              =  "state"s;
      
      //flags_key   : void                              =  "flags"s;
      //history_key : void                              =  "history"s;
      //attr_begin  : void                              =  '['s;
      //attr_end    : void                              =  ']'s;
      //colon       : void                              =  ':'s;
      //point       : void                              =  '.'s;
      //comma       : void                              =  ','s;
      equal      : void                               =  '='s;
      open_round_brace : void                         =  '('s;
      close_round_brace : void                        =  ')'s;
      initial_key                                     =  ("initial" / "0")s;
      // terminal rules
      // guards
      
      else_guard         : GuardNode                  =  "else"s;
      guard_type         : GuardNode                  =  else_guard / expr_guard;
      syntax_delim       : void                       =  (':' / '=') s;
      
      guard_expr         : PExpr                      =  (!']' [Any])* s;//simple_guard_expr (two_op_expr s simple_guard_expr)*;
      
      guard              : GuardNode                  =  '['s guard_type ']'s;
      expr_guard         : GuardNode                  =  guard_expr;
      
      fully_qualified    : NameIdentifier             =  target_id ('.'s target_id)* s;
      simple_attrs       : List[NToken]               =  ('['s (identifier s (','s)?)+ ']'s)+;

      attributes         : List[StateAttribute]       =  simple_attrs;
      
      //block_action_list  : Actions                    =  '/'s "{"s (!close_brace action delimiter?)+ "}"s;
      
      //action_expr        : ActionExpr                 =  guard_expr;
      
      long_expr_action   : Actions                    =  '/'s "${"s (!"}$" [Any])+ "}$"s;
      expr_act_action    : Actions                    =  (long_expr_action / expr_action) ';'s;
      delim_action_list  : Actions                    =  '/'s (!';' action delimiter?)+ s ';'s;
      
      empty_act_list     : Actions                    =  ';'s;
      action_list        : Actions                    =  empty_act_list / delim_action_list / expr_act_action;
      parameters         : List[string]               =  (!close_round_brace identifier s (','s)?)*;
      empty_action       : FsmAction                  =  '('s ')'s;
      //method_action      : FsmAction                  =  identifier s (open_round_brace parameters close_round_brace);
      tran_action        : FsmAction                  =  identifier s (open_round_brace parameters close_round_brace)?;
      action             : FsmAction                  =  empty_action / tran_action;
      
      entry              : StateNode                  =  simple_attrs? "entry"s action_list;
      exit               : StateNode                  =  simple_attrs? "exit"s action_list;
      do_activity        : StateNode                  =  simple_attrs? "do"s action_list;
      
      terminate_node     : StateNode                  =  ("terminate" / "X" / "x") s ';'s;
      initial            : StateNode                  =  initial_key s guard? ext_trans_act_list simple_target ';'s;
      pseudo_state       : StateNode                  =  initial / history / terminate_node / join / junction / choice / merge;
      join               : StateNode                  =  "join"s identifier s goto transition_target;
      junction           : StateNode                  =  "junction"s identifier s junction_body;
      junc_tran_body     : StateNode.Transition       =  guard_type? ext_trans_act_list transition_target;
      junction_body      : List[JunctionNode]         =  "{"s (!'}' junc_tran_body)+ "}"s;
      junction_target    : TargetType                 =  junction_body;
      choice             : StateNode                  =  "choice"s identifier s '$'? junction_body;
      choice_target      : TargetType                 =  '$' junction_body;
      merge              : StateNode                  =  "merge"s identifier junc_tran_body;
      simple_target      : TargetType                 =  fully_qualified;
      //fork_trans_target  : TargetType                 =  simple_target s simple_target s (!end_symb simple_target s delimiter)* end_symb;
      transition_target  : TargetType                 =  choice_target / junction_target / simple_target;
      
      expr_action        : Actions                    = '/'s (!(';' / any_goto) [Any])* s;
      expr_tran_action   : Actions                    = long_expr_action / expr_action;
      expr_ext_tran_action  : Actions                 = expr_tran_action ext_goto;
      expr_loc_tran_action  : Actions                 = expr_tran_action local_goto;
      
      any_goto                                        =  local_goto / ext_goto;
      empty_ext_act_list : Actions                    =  ext_goto;
      empty_loc_act_list : Actions                    =  local_goto;
      ext_trans_act_list : Actions                    =  empty_ext_act_list / ext_act_list / expr_ext_tran_action;
      loc_trans_act_list : Actions                    =  empty_loc_act_list / loc_act_list / expr_loc_tran_action;
      //transition_mark    : StateNode.Transition       =  s guard? trans_act_list? goto transition_target;
      default_transition : StateNode.Transition       =  s ext_trans_act_list transition_target ';'? s;// s end_symb?;
      internal_trans     : StateNode                  =  identifier s guard? action_list;
      ext_act_list       : Actions                    = '/'s (!ext_goto action s delimiter?)+ ext_goto;
      loc_act_list       : Actions                    = '/'s (!local_goto action s delimiter?)+ local_goto;
      
      events             : List[TransitionEvent]      =  identifier s (!('[' / '=' / '/') ','s identifier s)* s;
      transitions        : List[StateNode]            =  simple_transition*;
      local_goto                                      =  "(=>"s;
      ext_goto                                        =  ")=>"s / "=>"s;
      
      simple_transition  : StateNode                  =  events guard? ext_trans_act_list transition_target ';'s;
      local_trans        : StateNode                  =  events guard? loc_trans_act_list transition_target ';'s; // / local_goto)
      transition         : StateNode                  =  internal_trans / local_trans / simple_transition;
       
      history_deep       : StateNode                  =  "(H*)"s default_transition?;
      history_shallow    : StateNode                  =  "(H)"s default_transition?;
      history_short      : StateNode                  =  history_deep / history_shallow;
      history_long       : StateNode                  =  "history"s ':'s identifier s default_transition? (';'s)?;
      history            : StateNode                  =  history_long / history_short;

      //machine_decls      : StateNode                  =  simple_transition;
      //machine_body       : List[StateNode]            =  '{'s machine_decls* '}'s;
      //statemachine       : StateNode                  =  "statemachine"s identifier s parent? machine_body;
      //inlined_fsm        : StateNode                  =  "new"s fsm_key identifier s ':'s identifier s stateBody;
      stateDecl          : StateNode                  =  flags / name / region / pseudo_state / entry / exit / do_activity / transition / state;// / statemachine;// / inlined_fsm / statemachine;
      stateBody          : List[StateNode]            =  '{'s stateDecl* '}'s;
      parent             : NameIdentifier             =  ':'s fully_qualified;
      state              : StateNode                  =  attributes? state_key identifier s parent? stateBody;

      region             : StateNode                  =  '['s "---" '-'* ']'s;
      flags              : StateNode                  =  "flags"s syntax_delim (identifier s (','s)?)+ ';'s;
      name               : StateNode                  =  "name"s syntax_delim? identifier s ';'s;
      stateMachine       : StateMachine               =  s stateDecl+ s;

  })]
  public partial class FsmParser
  {
    public env : GlobalEnv {get;set;}
  }

}


