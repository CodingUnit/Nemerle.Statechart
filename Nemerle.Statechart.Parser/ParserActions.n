using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Peg;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using Nemerle.Compiler;

namespace Nemerle.Statechart
{

  using StateNode;
  using ListUtils;
  using GuardNode;
  /// <summary>
  /// Description of ParserActions.
  /// </summary>
  public partial class FsmParser
  {
    create_event(tok : NToken) : TransitionEvent
    {
      def name = GetText(tok);
      
      def name = match (name)
                 {
                   | "completion" 
                   | "_"            => null
                   | n              => n
                 }
      TransitionEvent(name, tok.StartPos)
    }

    //create_guard(tok : NToken) : GuardNode
    //{
    //  def cond = GetText(tok);
    //  def pos = tok.StartPos;
    //  match (cond)
    //  {
    //   | "else" => Else(pos)
    //   | _      => Guard(pos, cond)
    //  }
    //}
    
    //trans_act_list(lst : Actions) : Actions
    //{
    //  create_action(act, lst)
    //}

    //block_action_list(start : NToken, _ : NToken, lst : List[FsmAction], _ : NToken) : Actions
    //{
    //  create_action(start, lst)
    //}

    //empty_action_list(tok : NToken) : Actions
    //{
    //  Actions(tok.StartPos, [])
    //}

    empty_action(s : NToken, _ : NToken) : FsmAction.Normal
    {
      FsmAction.Normal(s.StartPos, null, [])
    }
    
    delim_action_list(tok : NToken, lst : List[FsmAction.Normal]) : Actions
    {
      def lst = lst.Where(x => x.name != null).NToList();
      Actions(lst, tok.StartPos)
    }

    entry(attr : option[List[NToken]], key : NToken, acts : option[Actions]) : Entry
    {
      def acts = acts.WithDefault(Actions([], key.StartPos));
      def attr = attr.WithDefault(Enumerable.Empty());
      def attr = get_action_attr(attr);
      Entry(key.StartPos, attr, acts)
    }

    exit(attr : option[List[NToken]], key : NToken,  acts : option[Actions]) : Exit
    {
      def acts = acts.WithDefault(Actions([], key.StartPos));
      def attr = attr.WithDefault(Enumerable.Empty());
      def attr = get_action_attr(attr);
      Exit(key.StartPos, attr, acts)
    }
    
    expr_action(tok : NToken, text : NToken) : Actions
    {
      def pos = tok.StartPos;
      def text = GetText(text);
      def expr = MainParser.ParseExpr(env, text);
      def act = FsmAction.Expr(pos, expr);
      Actions(act :: [], pos)
    }

    expr_tran_action(p : NToken, tok : NToken) : Actions
    {
      def pos = p.StartPos;
      def text = GetText(tok);
      def expr = MainParser.ParseExpr(env, text);
      def act = FsmAction.Expr(pos, expr);
      Actions(act :: [], pos)
    }
    
    parameters(lst : List[NToken * NToken]) : List[string]
    {
      lst.Select((x, _) => GetText(x)).ToList()
    }
    
    tran_action(n : NToken, pars : option[List[string]]) : FsmAction.Normal
    {
      FsmAction.Normal(n.StartPos, GetText(n), pars.MapDefault(x => x.NToList(), []))
    }
    
    norm_act_list(tok : NToken, lst : List[FsmAction.Normal]) : Actions
    {
      Actions(lst.Map(_ : FsmAction), tok.StartPos)
    }
  }
}
