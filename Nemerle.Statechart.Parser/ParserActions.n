using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Peg;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using StateNode;
  using ListUtils;
  using GuardNode;
  /// <summary>
  /// Description of ParserActions.
  /// </summary>
  public partial class FsmParser
  {
    create_event(tok : NToken) : TransitionEvent
    {
      def name = GetText(tok);
      
      def name = match (name)
                 {
                   | "completion" 
                   | "_"            => null
                   | n              => n
                 }
      TransitionEvent(name, tok.StartPos)
    }

    //create_guard(tok : NToken) : GuardNode
    //{
    //  def cond = GetText(tok);
    //  def pos = tok.StartPos;
    //  match (cond)
    //  {
    //   | "else" => Else(pos)
    //   | _      => Guard(pos, cond)
    //  }
    //}
    
    create_action(start : NToken, lst : List[FsmAction]) : Actions
    {
      def lst = lst.Where(x => x.name != null).NToList();
      Actions(start.StartPos, lst)
    }

    CreateState(pos : int, name : string, attr : IEnumerable[StateAttribute], decls : IEnumerable[StateNode], type : StateType, parent : option[NameIdentifier]) : StateNode.State
    {
      def get_decls(decls) 
      {
        def (en, decls)       = decls.PartitionType();
        def (ex, decls)       = decls.PartitionType();
        def (states, decls)   = decls.PartitionType();
        def (trans, decls)    = decls.PartitionType();
        //def (trans, other)    = trans.Partition(x => x.type == TransitionType.Transition);
        //def (in_trans, other) = other.Partition(x => x.type == TransitionType.Internal);
        //def (init, _)         = other.Partition(x => x.type == TransitionType.Initial);
        def (do_act, decls)   = decls.PartitionType();
        
        def (pseudo, decls) = decls.PartitionType();
        
        (en, ex, states, trans, do_act, pseudo, decls)
      } 
      
      def create_sub_regions(reg)
      {
        def (en, ex, states, trans, do_act, pseudo, _) = get_decls(reg);
        State(0, null, None(), [], en, ex, trans, do_act, states, pseudo, StateType.SubRegion(), [])
      }
      
      def decls = decls.OrderBy(_.pos).NToList();
      def (reg_trans, reg) = decls.Partition(_ is StateNode.Transition);
      def regions = reg.FindDelimited(_ is State(type = StateType.SubRegion)); // split list by regions
      def (regions, decls) = if (regions.IsEmpty()) ([], decls) else (regions.Map(create_sub_regions), reg_trans); // create regions
      def (en, ex, states, trans, do_act, pseudo, decls) = get_decls(decls);
      def (states, type) = if (regions.IsEmpty()) (states, type) else (regions, StateType.Region());
      def parent = parent.Map(_.FullName);
      State(pos, name, parent, attr.NToList(), en, ex, trans, do_act, states, pseudo, type, decls.Map(x => Error(x.pos, x)))
      }

    def_history(hist : HistoryType, tok : NToken, tran : option[StateNode.Transition]) : StateNode
    {
      def pos = tok.StartPos;
      StateNode.PseudoState(pos, PseudoStateAstNode.History(pos, hist, tran))
    }
    
  }
}
