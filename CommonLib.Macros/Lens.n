using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CommonLib.Macros
{
  public module LensUtils
  {
    public static @>>[T, T2, T3, TR] (l1 : Lens[T, T2], l2 : Lens[T3, TR]) : PartialLens[T, TR] where T3 : T2
    {
      def optset(x : T2, r)
      {
        match (x)
        {
          | y is T3 => l2.Set(y, r) : T2
          | _       => x
        }
      }
      
      def get = l1.Get >> (x => Some(l2.Get(x :> T3)));
      def set = (a, r) => l1.Update(a, optset(_, r));//l2.Set >> l1.Update;

      PartialLens(get, set)
    }
    
    public static @>>[T, T2, T3, TR] (l1 : Lens[T, IEnumerable[T2]], l2 : Lens[T3, TR]) : EnumerableLens[T, TR] where T3 : T2
    {
      def get(x)
      {
        def lst = l1.Get(x);
        if (lst.IsEmpty())
        {
          Enumerable.Empty()
        } else
        {
          match (lst.First())
          {
            | _ is T3 => lst.Select(x => l2.Get(x :> T3))
            | _       => Enumerable.Empty()
          }
        }
      }                  
      
      def set(a, r)
      {
        def value = a |> l1.Get;
        if (value.IsEmpty())
        {
          a
        } else
        {
          match (value.First())
          {
            | _ is T3 => def value = value.Select(_ :> T3);
                         def zip = value.ZipLazy(r);
                         def value = zip.Map(l2.Set);
                         l1.Set(a, value)
            | _       => a
          }
        }
      }
      
      EnumerableLens(get, set)
    }
    
    public static @>>[T, T2, TR] (l1 : PartialLens[T, T2], l2 : PartialLens[T2, TR]) : PartialLens[T, TR]
    {
      def get(x)
      {
        match (l1.Get(x))
        {
          | Some(x) => l2.Get(x)
          | _       => None()
        }
      }
      
      def set = (a, r) => l1.Update(a, l2.Set(_, r));
      
      PartialLens(get, set)
    }
    
    public static @>>[T, T2, TR] (l1 : PartialLens[T, T2], l2 : Lens[T2, TR]) : PartialLens[T, TR]
    {
      def get = x => l1.Get(x).Map(l2.Get);
      def set = (a, r) => l1.Update(a, l2.Set(_, r));
      
      PartialLens(get, set)
    }
    
    public static @>>[T, T2, TR] (l1 : Lens[T, T2], l2 : PartialLens[T2, TR]) : PartialLens[T, TR]
    {
      def get = l1.Get >> l2.Get;
      def set = (a, r) => l1.Update(a, l2.Set(_, r));
      PartialLens(get, set)
    }
    
    public static @>>[T, T2, TR] (l1 : Lens[T, T2], l2 : Lens[T2, TR]) : Lens[T, TR]
    {
      def get = l1.Get >> l2.Get;
      def set = (a, r) => l1.Update(a, l2.Set(_, r));//l2.Set >> l1.Update;
      Lens(get, set)
    }
    
    public static @>>[T, T2, TR] (l1 : Lens[T, list[T2]], l2 : Lens[T2, TR]) : EnumerableLens[T, TR]
    {
      def get = x => l1.Get(x).Select(l2.Get);
      def set = (a, r) => l1.Update(a, x => x.ZipLazy(r).Map(l2.Set));
      EnumerableLens(get, set)
    }
    
    //public static @>>[T, T2, TR] (l1 : ListLens[T, T2], l2 : Lens[T2, TR]) : Lens[T, IEnumerable[TR]]
    //{
    //  def get = x => l1.Get(x).Select(l2.Get);
    //  def set = (a, r) => l1.Update(a, x => x.ZipLazy(r).Map(l2.Set));
    //  Lens(get, set)
    //}
  }
  /// <summary>
  /// Description of Lens.
  /// </summary>
  [Record]
  public class Lens[T, Res]
  {
    public Get : T -> Res;
    public Set : T * Res -> T;
    
    public type Type = T;
    
    public Update(a : T, f : Res -> Res) : T
    {
      def value = a     |> Get;
      def value  = value |> f;
      Set(a, value)
    }
    
  }

  [Record]
  public class PartialLens[T, Res]
  {
    public Get : T -> option[Res];
    public Set : T * Res -> T;
    
    public Update(a : T, f : Res -> Res) : T
    {
      def value = a     |> Get;
      if (value is Some(v)) 
      {
        Set(a, v |> f)
      } else a
    }
  }

  /// <summary>
  /// Description of Lens.
  /// </summary>
  [Record]
  public class ListLens[T, Res] : Lens[T, list[Res]]
  {
    
    public Map(a : T, f : Res -> Res) : T
    {
      def value = a |> Get;
      def value  = value.Map(f);
      Set(a, value)
    }
    
  }
  
  [Record]
  public class EnumerableLens[T, Res] : Lens[T, IEnumerable[Res]]
  {
    
    public Map(a : T, f : Res -> Res) : T
    {
      def value = a |> Get;
      def value  = value.Select(f);
      Set(a, value)
    }
    
  }
}
