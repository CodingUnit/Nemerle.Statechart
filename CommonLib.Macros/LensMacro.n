using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace CommonLib.Macros
{
  //[MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class)]
  //macro NeedChange(typeBuilder : TypeBuilder, params pars : list[PExpr])
  //{
  //  NeedChangeImpl.DoTransform(Macros.ImplicitCTX(), typeBuilder, pars)
  //}

  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class)]
  macro Lens(typeBuilder : TypeBuilder, params pars : list[PExpr])
  {
    LensImpl.DoTransform2(Macros.ImplicitCTX(), typeBuilder, pars)
  }
  
  //[MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Field)]
  //macro NeedChange(typeBuilder : TypeBuilder, field : FieldBuilder, params pars : list[PExpr])
  //{
  //  NeedChangeImpl.DoTransform(Macros.ImplicitCTX(), typeBuilder, field, pars)
  //}
  
  partial module LensImpl
  {

    //public GetChangeFields(type : TypeBuilder) : IEnumerable[IField]
    //{
    //  def get_base_change_fields(t)
    //  {
    //    def fields = t.tycon.GetFields(BindingFlags.NonPublic | BindingFlags.Instance);
    //    fields.Where(x => x.attr_func(x => x.Exists(_ is <[ NeedChange ]>)));
    //  }
    //  def fields = type.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
    //  def fields = fields.Filter(x => !x.Name.StartsWith("_N_cached_value_") && !x.Name.StartsWith("_N_is_cached_"));
    //  def base_fields = type.GetDirectSuperTypes().SelectMany(get_base_change_fields);
    //  fields.Concat(base_fields)
    //}

    //public DoTransform2(_ : Typer, typeBuilder : TypeBuilder, field : FieldBuilder) : void
    //{
    //  def defined(type, fields)
    //  {
    //    def constr = type.GetConstructors();
    //    constr.Exists(c => c.Header.Parameters.Equals(fields.NToList(), (x, y) => x.Name == StrToLower(y.Name)))
    //  }

    //  def def_constr(type)
    //  {

    //    def fields = GetChangeFields(type);
    //    when (!defined(type, fields))
    //    {
    //      def (this_type, base_type) = fields.PartitionLazy(x => x.DeclaringType.Name == type.Name);
    //      def body = this_type.Map(x => <[ this.$(x.Name : usesite) = $(StrToLower(x.Name) : usesite) ]>);
    //      def pars = fields.Map(f => <[ parameter: $(StrToLower(f.Name) : usesite) : $(f.GetMemType() : typed) ]>);
    //      def base_cons = base_type.Map(x => <[ $(StrToLower(x.Name) : usesite) = $(StrToLower(x.Name) : usesite) ]>);
    //      def base_type = if (base_cons is []) <[]> else <[ base(..$base_cons) ]>;
    //      _ = type.DefineWithSource(<[decl: public this(..$pars)
    //                          {
    //                            $base_type;
    //                            {..$body}
    //                          } ]>);
    //    }
    //  }

    //  //assert2(false);
    //  when (field.attr_func(x => x.Exists(_ is <[ RecordIgnore ]>) && x.Exists(_ is <[ NeedChange ]>)))
    //    match (typeBuilder.GetVariantOptions())
    //    {
    //      | []  => def_constr(typeBuilder)
    //      | lst => def_constr(typeBuilder);
    //              lst.Iter(def_constr);
    //    }
    //}

    public DoTransform2(_typer : Typer, typeBuilder : TypeBuilder, aliases : list[PExpr]) : void
    {
     // assert2(false);
      
      def gen_fields(t)
      {
        def fields = t.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
        def fields = fields.Filter(x => !x.Name.StartsWith("_N_cached_value_") && !x.Name.StartsWith("_N_is_cached_"));
        foreach (f in fields)
        {
          | FieldBuilder as f => create_cons(t, f, aliases)
          | _                 => ()
        }
      }
      
      def opts = typeBuilder.GetVariantOptions();
      match (opts)
      {
        | []   => gen_fields(typeBuilder)
                  
        | opts =>
        
          foreach (o in opts)
          {
            gen_fields(o)
          }
      }
    }
    
    //public DoTransform(typer : Typer, typeBuilder : TypeBuilder, aliases : list[PExpr]) : void
    //{
    //  //assert2(false);
      
    //  def gen_field(f)
    //  {
    //    when (!f.ParsedAttributsAndModifiers.CustomAttributes.Exists(x => x is <[ NeedChange ]>))
    //         f.AddCustomAttribute(<[ NeedChange ]>)
    //  }
      
    //  def opts = typeBuilder.GetVariantOptions();
    //  match (opts)
    //  {
    //    | [] => def fields = typeBuilder.GetParsedMembers();
    //            foreach (f in fields)
    //            {
    //              | ClassMember.Field as f => gen_field(f)
    //              | _ => ()
    //            }
    //    | _ =>  foreach (o in opts)
    //            {
    //              def fields = o.GetParsedMembers();
    //              foreach (f in fields)
    //              {
    //                | ClassMember.Field as f => gen_field(f)
    //                | _ => ()
    //              }    
    //            }
    //  }
      
      
    //}
    
    create_cons(t : TypeBuilder, f : IField, aliases : list[PExpr]) : void
    {
      //def fields = t.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy).Rev();
      //def fields = fields.Exclude(have_record_ignore);
      //def fields = f :: fields.Filter(x => aliases.Exists(y => y.ToString() == x.Name));
        
      //def names = fields.Map(x => (x.Name, x.GetMemType()));
      //def cnames = names.Map((x, _) => ToCamel(x));
      def fname = $<#$(f.Name)#>;
      def fnameup = NeedChangeImpl.ToCamel(fname);
      def change_name = $"Change$fnameup";
      def name = $"$(fname)_lens";
      //def sname = names.Map((x, y) => (get_short_name(x), y));
      //def sname = sname.Map((x, t) => <[ parameter: $(x : usesite) : $(t : typed) ]>);
      //def chlist = names.Map((x, y) => (x.TrimStart('_'), get_short_name(x), y));
      def type = t.GetMemType();
      def ftype = f.GetMemType();
      def type = <[ Lens[$(type : typed), $(ftype : typed)] ]>;
      //def clist = chlist.Map((x, y, _) => (x, y));
      //def body = CreateNewInst(t, null, clist);
      //def chlist = names.Map((x, y) => (x, get_short_name(x), y));
      //def check_list = chlist.Map((x, y, t) => if (t.IsValueType) <[ ! $(x : usesite).Equals($(y : usesite)) ]> else <[ $(x : usesite) : object != $(y : usesite) ]>);
      //def check = check_list.Reduce((x, a) => <[ $x || $a ]>);
      _ = t.DefineWithSource(<[ decl: public static $(name : usesite) : $(type) = Lens(_.$(fname : usesite), _.$(change_name : usesite)(_))]>);
    }
      
    
  }
}
