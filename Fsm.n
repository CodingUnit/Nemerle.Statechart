using System;
using System.Collections.Generic;
using System.Diagnostics;
using Nemerle.Statechart;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;
using System.IO;
using System.Linq;

namespace Nemerle.Statechart
{

/*TODO:  
  + shallow history
  + deep history
  - default history transitions  
  + guards
  + guards in fsm class,  properties,  functions
  - reset history by final (check spec)
  + приоритет переходов вложенных классов  
  + несколько типов историй в одном состоянии
  + final is not pseudostate
  + initial - псевдосостояние
  + terminate pseudostate
  + do activity  
  + Action вместо EventHandler 
  + thread pool tasks  
  + warning при неиспользовании элементов (истории и тп)
  - partial машины, разделяющие описание по нескольким классам
  - приоритет действий вложенных классов
  - flag not set long activity
  - можно не блокировать до завершения задачи, это надо решать флагами
  + prevent the recursion overflow of transition paths  
  - internal transition разные guard но один action => ошибка, разные action - норма но разные имена  
  - переходы с одинаковым началом и концом и событием, но с разными guard, 
    если один action у всех то это ошибка, если разный то надо создавать для каждого свой метод  
  - встраивание действий в выходные и входные обработчики
  + переход из начального сразу в history  
  - что делать если другие состояния реагируют на события join, и надо следить есть ли такие если нет то не 
    надо генерить для них код
  - fork and join pseudostates
  - orthogonal regions
  + final в верхнем классе это terminate
  - вложенные состояние в подрегионах
  - исправить 3 региона и fork
  - history clear, save and restore in concurrent states
  - junction
  - ошибки junction
  - оптимизировать junction
  - junction отдельно объявленный
  - branch/choice
  - junction объединения
  - junction без guard
  - merge
  + guard in state
  + сделать поддержку синтаксиса : parent
  - empty junctions
  - множественные guard_for
  - проверить region в sub_region
  - полное имя внутри экземпляра inlined sub machine
  - region in inline statemachine
  + нахождение неверного target перехода
  - если выход join из разных подрегионов и подрегион внутри другого региона
  - разный синтаксис для разных переходов во вне и внутри
  - пров. переходы в параллельное состояние в одно из вложенных псевдосостояний (fork в history)
  + переходы в final не должны быть из других подсостояний
  - сделать чтобы переопределять любые обработчики в том числе entry и exit  
  - сигнализировать в парсере о неверных аттрибутах 
  - состояния с одинаковыми именами
  - точка входа и выхода
  - встраиваемые автоматы
  - у fork могут быть guard на начальных переходах
  - synch state
  - Transition redefinition has been added to standart, in order to express if a transition of a general state machine can be redefined or not.
  - local and external transitions
  - auto initial attribute for state
  - deffered events
  - events with parameters
  + sync and async events (eg queue)
  - time events (after 10s)
  - change event (when (exp is true))
  - call event
  - events hierarchy
  - change events (like properties)
  - Extern => Incomplete(Lab2 TermProject FinalTest); объединение полной квалификации имени для fork
  - else guard
  - переход без события но запускающийся по гуарду
  - генерация в с++ код микроконтроллера
  - генерация таблицы переходов
  - импорт из нарисованной модели
  - экспорт в State Chart Xml
  - импорт в State Chart Xml
  - indentation синтаксис
  - оптимизация повторяющихся действий
  - there is no more reaction to events within the region if the final state is active
  - completion запускается сразу если нет активности по стандарту (надо задавать флагами если мы не хотим этого)    
  + сложные выражения в guards
  - history не нужно делать GetCopy для простых состояний не регионов
  - The history state may not have incoming transitions from other states within the composite state because it is already active
  - !!! state machine должна быть в своем контексте, поиск узлов как terminate, должна идти в своей машине, история должна относится к машине как к целому а не так же как и к другим комп. состояниям
  - не блокировать поток во время обработки синхронного события
  - fork must check to go to states through junctions or choices
  - встроенные actions без вызова метода, в выражениях
  */

  module FsmHelper
  {
    static GetLoc(this parser : FsmParser, pos : int, loc : Location, macro_col : int) : Location
    {
      def line = parser.ParsingSource.GetSourceLine(pos);
      def (line, col) = line.StartLineColumn;
      def line = loc.Line + line;
      def col = col + macro_col;
      Location(loc, line, col);
    }

    Parse(env : GlobalEnv, body : string, attr_loc : Location, loc : Location) : StateNode.StateMachine
    {
      def parser = FsmParser();
      parser.env = env;
      def macro_col = attr_loc.Column;

      def get_loc(pos)
      {
        parser.GetLoc(pos, loc, macro_col);
      }

      def text = body.Trim();
      if (!text.IsEmpty()) 
      {
        def (pos, ast) = parser.TryParse(body);
        if (pos > 0) 
        {
          def len = body.Length;
          when (pos < len)
          {
            def loc = get_loc(pos);
            Message.Error(loc, $"Not full text is parsed, parsing stopped at $(loc.Line):$(loc.Column).");
          }
          ast
        }
        else
        {
          def (pos,  ids)  =  parser.GetMaxRollbackPosAndNames();
          def loc = get_loc(pos);
          Message.Error(loc, $"Error in input at $(loc.Line):$(loc.Column). Expected: ..$(ids;\r\n    )");
          null
        }
      } else null
    }

    GetParsedResult(ty : TypeBuilder) : StateNode.StateMachine
    {
      def data = ty.Manager.UserData;
      //def name = ty.Name;
      if (data.Contains(key)) 
      {
        def data = data[key] :> data_type;
        if (data.Find((x, _) => x == ty.Name) is Some((_, d))) d else null
      } else null
    }

    key = "statechart";
    type data_type = list[string * StateNode.StateMachine];

    Memoize(ty : TypeBuilder, tree : StateNode.StateMachine) : void
    {
      def storage = ty.Manager.UserData;
      def name = ty.Name;
      def data = if (storage.Contains(key))
                  {
                    storage[key] :> data_type;
                  } else [];
      def data = (name, tree) :: data;
      storage[key] = data
    }

    Parse(env : GlobalEnv, attr : AttributesAndModifiers) : StateNode.StateMachine
    {
      match (attr.ParsedCustomAttributes.Find(x => x is <[ statechart($_) ]>))
      {
        | Some(<[ statechart($x) ]>) => 
            match (x)
            {
              | <[ $(str : string) ]> => Parse(env, str, attr.Location, x.Location);
                                          //Memoize(ty, fsm);
              | _                     => Message.Error(attr.Location, "Body expression must be a string");null
            }
        | _ => null
      }

    }

    ParseAll(ty : TypeBuilder) : void
    {
      def types = ty.Manager.Hierarchy.TopTypeBuilders();
      foreach (ty in types)
      {
        def types = ty.AstParts;
        def parsed = types.Map(x => Parse(ty.GlobalEnv, x.ParsedAttributsAndModifiers));
        def parsed = parsed.Filter(_ != null);
        match (parsed)
        {
          | []  => ()
          | [p] => Memoize(ty, p)
          | lst => def fsm = MergePartial(lst);
                   Memoize(ty, fsm)
        }
      }
    }

    MergePartial(fsm : list[StateNode.StateMachine]) : StateNode.StateMachine
    {
      def merge_states(a, b)
      {
        def entry = a.entry + b.entry;
        def exit = a.exit + b.exit;
        def tran = a.transitions + b.transitions;
        def doact = a.do_activity + b.do_activity;
        def err = a.errors + b.errors;
        def defer = a.defer + b.defer;
        def pseudo = a.pseudo_states + b.pseudo_states;
        def sub = a.sub_states + b.sub_states;
        def pos = Math.Min(a.pos, b.pos);
        StateNode.State(pos, null, None(), [], entry, exit, tran, doact, defer, sub, pseudo, StateType.State, err)
      }

      def merge(a, b)
      {
        def pos = Math.Min(a.pos, b.pos);
        def flags = MachineFlags(a.flags.flags | b.flags.flags, a.flags.errors + b.flags.errors);
        def aname = a.name ?? "";
        def bname = b.name ?? "";
        def name = if (aname.Length > bname.Length) aname else bname;
        def state = merge_states(a.state, b.state);
        StateNode.StateMachine(pos, flags, name, state, a.usings + b.usings)
      }


      fsm.Reduce(merge)
    }

    public ParseAndGenerate(ty : TypeBuilder, _ : PExpr) : void
    {

      def process()
      {
        def res = GetParsedResult(ty);
        def fsm = if (res != null) res else 
                   {
                     ParseAll(ty);
                     GetParsedResult(ty)
                   }

        //def loc = ty.Ast.ParsedAttributsAndModifiers.ParsedCustomAttributes.First(_ is <[ statechart($_)]>).Location;
        //def fsm = if (res != null) res else Parse(ty, val, loc, body.Location);
        if (fsm != null)
        {
          when (fsm.flags.Debug) assert2(false);
          def mach = ty.Manager.UserData[key] :> data_type;
          def analyser = FsmAnalyser(fsm, ty.Name, mach);
          analyser.Analyse();
          def warn = analyser.Warnings;
          def warn_file = $"$(ty.Name)Warnings.log";
          if (!warn.IsEmpty()) 
          {
            warn.Iter(Message.Warning);
            when (fsm.flags.Debug) File.WriteAllLines(warn_file, warn);
          } else when (fsm.flags.Debug) File.Delete(warn_file);
          def err_file = $"$(ty.Name)errors.log";
          if (analyser.Error)
          {
            def err = analyser.Errors;
            when (fsm.flags.Debug) System.IO.File.WriteAllLines(err_file, err);
            err.Iter(Message.Error)
          } else
          {
            when (fsm.flags.Debug) File.Delete(err_file);

            when (!fsm.flags.OnlyAnalyse) 
            {
              if (analyser.Complete)
              {
                def gen = StaticGenerator(analyser, ty);
                gen.Generate();
                ty.UserData[key] = true;
              } else Message.Warning("No Statechart to generate")
            }
          }
        } else Message.Warning("No Statechart parsed")
      }
      
      //assert2(false);
      // if typebuilder already built skip it
      if (ty.UserData.Contains(key))
      {
        unless (ty.UserData[key] :> bool) process()
      } else process()
      
    }
    
  }

}
