using System;
using System.Collections.Generic;
using System.Diagnostics;
using Nemerle.Statechart;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;
using System.IO;

namespace Nemerle.Statechart
{


  public module FsmHelper
  {

    public CheckEventClasses(ty : TypeBuilder, typer : Typer) : void
    {
      match (FsmBuilder.GetParsedResult(ty))
      {
        | null    => ()
        | b       => b.CheckEventClasses(typer)
      }
    }
    
    public ParseFilesAndBuildGraph(params files : array[string]) : void
    {
      //def types = ty.Manager.Hierarchy.TopTypeBuilders();
      
      def builders = files.MapToList(x => File.ReadAllText(x) |> FsmBuilder(x |> Path.GetFileNameWithoutExtension, _));
      def builder = builders.Head;
      def other = builders.Tail;
      builders.Iter(_.Parse());
        //def parsed = builders.Filter(x => x.fsm != null);
      match (builder.Fsm)
      {
        | null  => Message.Warning("No Statechart parsed")
        | _     => builder.BuildGraph(other)
        //| fsm => def fsm = MergePartial(lst.Map(_.Fsm));
        //         Memoize(ty, FsmBuilder(ty, typer, lst.Head.top, fsm))
      }
    }
    
    public ParseAndGenerate(ty : TypeBuilder, typer : Typer, _ : PExpr, other : array[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      
      def process()
      {
        def res = FsmBuilder.GetParsedResult(ty);
        def fsm = if (res != null) res else
                   {
                     when (!other.IsEmpty()) assert2(false); 
                     FsmBuilder.ParseAll(ty, typer);
                     FsmBuilder.GetParsedResult(ty)
                   }
        if (fsm != null)
        {
          fsm.Build()
        } else
        {
          Message.Warning("No Statechart parsed")
        }
      }

      //assert2(false);
      // if typebuilder already built skip it
      if (ty.UserData.Contains(FsmBuilder.key))
      {
        unless (ty.UserData[FsmBuilder.key] :> bool) process()
      } else process()

    }

  }

}
