using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  /// <summary>
  /// List utilities
  /// </summary>
  public module ListUtils
  {

    /// <summary>
    /// Elements to first finded if not found returns all
    /// </summary>
    public FirstElems[T](this n : list[T],pred : T -> bool) : list[T]
    {
      def loop(n, acc)
      {
        match (n)
        {
          | head :: _ when pred(head) => acc.Rev()
          | head :: tail => loop(tail, head :: acc)
          |_ => acc.Rev()
        }

      }
      loop(n, []);
    }

    public SplitFind[T](this n : list[T], pred : T -> bool) : list[T] * list[T]
    {      
      def loop(n, acc)
      {
        match (n)
        {
          |  head :: tail  => def res = head :: acc;
              if (pred(head)) (res.Rev(), tail) else loop(tail, res);
          | _  => (acc.Rev(), [])
        }

      }

      loop(n, [])
    }

    /// <summary>
    /// Removes duplicates defined with equality predicate
    /// </summary>
    /// <param name = "lst">list</param>
    /// <param name = "eq_pred">Function that shows equality of two elements</param>
    public RemoveDuplicates[T](this lst : list [T], eq_pred : T * T -> bool) : list [T]
    {
      def loop (lst,  acc)
      {
        match (lst)
        {
          |  []  => acc.Reverse ();
          |  [x]  => (x :: acc).Reverse ();
          |  x :: ((y :: _) as xs)  =>
              if (eq_pred(x,  y)) loop (xs,  acc)
              else loop (xs,  x :: acc)
        }
      }

      loop (lst,  [])
    } 

    /// <summary>
    /// Removes duplicates defined with equality predicate with auto sorting
    /// </summary>
    /// <param name = "lst">list</param>
    /// <param name = "eq_pred">Function that shows equality of two elements</param>
    public RemoveDuplicatesSort[T](this lst : list [T], comp : T * T -> int) : list [T]
    {
      def sorted = lst.Sort(comp); // sort
      sorted.RemoveDuplicates((x1, x2)  => comp(x1, x2) == 0); // remove duplicates
    }

    /// <summary>
    /// Return from list only correspond to result type with partition of others
    /// </summary>
    /// <param name = "lst">list</param>
    /// <returns>result * left elements</returns>
    public PartitionType[T, TRes](this lst : list[T]) : list[TRes] * list[T]
    {      
      def loop(lst : list[T], res, acc)
      {
        match (lst)
        {
          | (head is TRes) :: tail => loop(tail, head :: res, acc)
          | head :: tail  => loop(tail, res, head :: acc)
          | _  => (res.Rev(), acc.Rev())
        }
      }
      loop(lst, [], [])

    }

    public PartitionAround[T](this lst : list[T], pred : T -> bool) : list[T] * list[T]
    {
      def loop(lst, res)
      {
        match (lst)
        {
          | head :: tail => if (pred(head)) (res.Rev(), tail) else loop(tail, head :: res)
          | _ => (res.Rev(), [])
        }
      }

      loop(lst, [])
    }

    public PartitionFirst[T](this lst : list[T], pred : T -> bool) : list[T] * list[T]
    {
      def loop(lst, res)
      {
        match (lst)
        {
          | head :: tail => if (pred(head)) (res.Rev(), lst) else loop(tail, head :: res)
          | _ => (res.Rev(), [])
        }
      }

      loop(lst, [])
    }

    public FilterType[T,TRes](this lst : list[T]) : list[TRes]
    {
      def loop(val : T, res)
      {
        match (val)
        {
          | val is TRes => val :: res
          | _ => res
        }
      }

      lst.FoldLeft([], loop).Rev()
    }

    /// <summary>
    /// Find first element corresponds to result type
    /// </summary>
    /// <param name = "lst">список</param>
    /// <returns>результат * оставшиеся элементы</returns>
    public FindType[T, TRes](this lst : list[T]) : option[TRes] * list[T]
    {
      def loop(lst : list[T], res)
      {
        match (lst)
        {
          | (head is TRes) :: tail  => (Some(head), res.Rev() + tail)
          | head :: tail  => loop(tail, head :: res);
          | _  => (None(), res.Rev())
        }
      }

      loop(lst, []);
    }

    /// <summary>
    /// Find first element corresponds to result type
    /// </summary>
    /// <param name = "lst">список</param>
    /// <returns>результат * оставшиеся элементы</returns>
    public FindType[T, TRes](this lst : IEnumerable[T]) : option[TRes]
    {
      def loop(lst : IEnumerator[T])
      {
        if (lst.MoveNext())
        {
          match (lst.Current)
          {
           | cur is TRes => Some(cur)
           | _ => loop(lst)
         }
        } else None()
      }

      loop(lst.GetEnumerator())
    }
    
    public FilterValues[T, TRes](this lst : list[T], pred : T -> option[TRes]) : list[TRes]
    {
      def loop(head, res)
      {
        match (pred(head))
        {
          | Some(val)  => val :: res
          | _  => res
        }
      }

      lst.FoldLeft([], loop).Rev()
    } 

    public FilterValues[T, TRes](this lst : IEnumerable[T], pred : T -> option[TRes]) : list[TRes]
    {
      def loop(head, res)
      {
        match (pred(head))
        {
          | Some(val)  => val :: res
          | _  => res
        }
      }

      lst.FoldLeft([], loop).Rev()
    } 

    /// <summary>
    /// Excludes elements from list that not exist in second list
    /// </summary>
    /// <param name = "lst">list</param>
    /// <param name = "lst2">list 2</param>
    /// <param name = "eq">comparator</param>
    /// <returns>result</returns>
    public Exclude[T, T2](this lst : list[T], lst2 : list[T2], eq : T * T2 -> bool) : list[T]
    {
      lst.Filter(x  => !lst2.Exists(y  => eq(x, y)))
    }

    public MapIndex[T, TRes](this lst : list[T], conv : (T * int) -> TRes) : list[TRes]
    {
      def loop(lst, idx, res)
      {
        match (lst)
        {
          | head :: tail  => loop(tail, idx + 1, conv(head, idx) :: res)
          | _  => res.Rev()
        }
      }

      loop(lst, 0, [])
    }

    public FindSingle[T, T2](this lst : list[T * list[T2]], pred : T2 -> bool) : option[T * T2]
    {
      def loop(lst)
      {
        | (x, lst) :: tail  => 
            match (lst.Find(pred)) 
            {
              | Some(v)  => Some((x, v))
              | _  => loop(tail)
            }
        | _  => option.None()
      }

      loop(lst)
    }

    public FindSingleList[T, T2](this lst : list[T * list[T2]], pred : T2 -> bool) : list[T * T2]
    {
      def loop((x, lst), res)
      { 
        match (lst.Find(pred)) 
        {
          | Some(val)  => (x, val) :: res
          | _  => res
        }
      }

      lst.FoldLeft([], loop).Rev()
    }

    public MapDefault[T, T2](this opt : option[T], conv : T -> T2, default : T2) : T2
    {
      match (opt)
      {
        | Some(val)  => conv(val)
        | _  => default
      }
    }

    public static @%+[T, T2](this lst : list[T], lst2 : list[T2]) : list[T] where T2 : T
    {
      lst + lst2.Map(_ : T)
    }

    public static @&+[T, T2, T3](this lst : list[T2], lst2 : list[T3]) : list[T] where T2 : T where T3 : T
    {
      lst.Map(_ : T) + lst2.Map(_ : T)
    }

    /// <summary>
    /// Returns duplicates according to comparator
    /// </summary>
    /// <param name = "lst">list</param>
    /// <param name = "comp">comparator</param>
    /// <returns>duplicates</returns>
    public Duplicates[T](this lst : list[T], comp : T * T -> int) : list[T]
    {
      def sorted = lst.Sort(comp);

      def loop (lst,  acc)
      {
        def eq(x)
        {
          (!acc.IsEmpty() && comp(x, acc.Head) == 0)
        }
        match (lst)
        {
          |  []
          |  [_]  => acc.Reverse()
          |  x :: ((y :: _) as xs)  => 
              if (comp(x,  y) == 0 || eq(x)) loop (xs,  x :: acc)
              else loop (xs,  acc)
        }
      }

      loop(sorted,  [])
    }

    public DuplicatesPartition[T](this lst : list[T], comp : T * T -> int) : list[T] * list[T]
    {
      def sorted = lst.Sort(comp);

      def loop (lst,  acc, res)
      {
        def eq(x)
        {
          (!acc.IsEmpty() && comp(x, acc.Head) == 0)
        }
        match (lst)
        {
          | []  => (acc.Rev(), res.Rev())
          | [x]  => (acc.Rev(), (x :: res).Rev())
          | x :: ((y :: _) as xs)  =>
              if (comp(x,  y) == 0 || eq(x)) loop (xs,  x :: acc, res)
              else loop (xs,  acc, x :: res)
        }
      }

      loop (sorted,  [], [])
    }

    public FindDelimited[T](this lst : list[T], pred : T -> bool) : list[list[T]]
    {
      def loop(lst, res, subres)
      {
        match (lst)
        {
          | head :: tail  => if (pred(head)) loop(tail, subres.Rev() :: res, []) else loop(tail, res, head :: subres)
          | _  => if (res.IsEmpty()) [] else (subres.Rev() :: res).Rev()
        }
      }

      loop(lst, [], [])
    }

    public ElementsEqual[T](this lst : list[T], pred : (T * T) -> bool) : bool
    {
      def loop(lst)
      {
        |  []
        |  [_]  => true
        |  x :: ((y :: _) as xs)  => if (pred(x, y)) loop(xs) else false
      }

      loop(lst)
    }

    public ChopLastN[T](this lst : list[T], num : int) : list[T]
    {
      def num = lst.Length - num;

      def loop(lst, res, n)
      {
        match (lst)
        {
          | head :: tail => if (n != 0) loop(tail, head :: res, n - 1) else res.Rev()
          | _ => res.Rev()
        }
      }

      loop(lst, [], num)
    }

    public Exclude[T](this lst : list[T], pred : T -> bool) : list[T]
    {
      def loop(elem, res)
      {
        if (pred(elem)) res else elem :: res;
      }

      lst.FoldLeft([], loop).Rev()
    }

    public FindIndex[T](this lst : list[T], pred : T -> bool) : int
    {
      def loop(e, i)
      {
        match (e)
        {
          | head :: tail => if (pred(head)) i else loop(tail, i + 1)
          | _ => -1
        }
      }

      loop(lst, 0)
    }

    public Exclude[T](this lst : list[T], lst2 : list[T]) : list[T]
    {
      lst.Filter(x => !lst2.Contains(x))
    }

    public Exclude[T](this lst : array[T], lst2 : list[T]) : array[T]
    {
      lst.FilterToArray(x => !lst2.Contains(x))
    }

    public Exclude[T](this lst : array[T], lst2 : list[T], eq : T * T -> bool) : array[T]
    {
      lst.FilterToArray(x => !lst2.Exists(eq(x, _)))
    }

    public Remove[T](this lst : array[T], eq : T -> bool) : array[T]
    {
      lst.FilterToArray(eq)
    }

    public static @%::[T](opt : option[T], lst : list[T]) : list[T]
    {
      match (opt)
      {
        | Some(v) => v :: lst
        | _ => lst
      }
    }

    not_empty_err = "list must be not empty";

    public SplitLast[T](this lst : list[T]) : T * list[T]
    {
      def loop(lst, res)
      {
        match (lst)
        {
          | [] => throw ArgumentException(not_empty_err)
          | [head] => (head, res.Rev())
          | head :: tail => loop(tail, head :: res)
        }
      }

      loop(lst, [])
    }

    public Last[T](this lst : list[T]) : T
    {
      def loop(lst)
      {
        | [] => throw ArgumentException(not_empty_err)
        | [head] => head
        | _ :: tail => loop(tail)
      }

      loop(lst)
    }

    public RemoveDupFirst[T](this lst : list[T], lst2 : list[T], eq_pred : T * T -> bool) : list[T] * list[T]
    {
      def loop(lst, lst2)
      {
        | (head :: tail, head2 :: tail2) when (eq_pred(head, head2)) => loop(tail, tail2)
        | (_, _) => (lst, lst2)
      }

      loop(lst, lst2)
    }

    public Map[T, T2, T3](this tuple : T * T2, map : (T * T2) -> T3) : T3
    {
      map(tuple)
    }

    public MapThrough[T, T2, T3](this lst : list[T], init : T2, map : T * T2 -> T * T2) : list[T] * T2
    {
      lst.FoldLeft(([], init), (x, (l, a)) => map(x, a).Map((x, y) => (x :: l, y)))
    }

    public FoldLeft[TAcc, T](this opt : option[T], init : TAcc, fold : T * TAcc -> TAcc) : TAcc
    {
      match (opt)
      {
        | Some(o) => fold(o, init)
        | _       => init
      }
    }

    public Unfold[T, TResult](start : T, generator : T -> option[TResult * T]) : list[TResult]
    {
      def loop(next, res)
      {
        match (generator(next))
        {
          | Some((r, n)) => loop(n, r :: res)
          | _            => res.Rev()
        }
      }

      loop(start, [])
    }

    public UnfoldLazy[T, TResult](start : T, generator : T -> option[TResult * T]) : IEnumerable[TResult]
    {
      def loop(next)
      {
        match (generator(next))
        {
          | Some((r, n)) => yield r; loop(n)
          | _            => ()
        }
      }

      loop(start)
    }
    
    public Pop[T](this lst : SCG.Stack[T], len : int) : list[T]
    {
      def loop(acc, len)
      {
        if (len != 0) 
        {
          loop(lst.Pop() :: acc, len - 1)
        } else acc.Rev()
      }
      
      loop([], len)
    }
    
    public FoldBack[T, TOut](this l : IEnumerable[T], acc : TOut, f : T * TOut -> TOut) : TOut 
    {
      def buffer = SCG.Stack();
      foreach (x in l) buffer.Push(x);
      mutable result = acc;
      foreach (x in buffer) result = f(x, result);
      result
    }
    
    public MapCont[T, TRes, TOut](this lst : list[T], map : T -> TRes) : list[TRes]
    {
      def loop(l, cont)
      {
        match (l)
        {
          | []      => cont([])
          | x :: xs => loop(xs, ys => cont(map(x) :: ys))
        }
      }
//: /// Create a list containing results of calling 
// 2: /// the function 'f' on all elements of the input 'list'
// 3: let map f list =
// 4:   /// Inner recursive function that uses
// 5:   /// continuation argument to construct list
// 6:   let rec mapAux cont list =
// 7:     match list with
// 8:     | x :: xs -> mapAux (fun ys -> (f x)::ys |> cont) xs
// 9:     | [] -> cont []
//10:   mapAux id list   
      
//let contMap f l cont = 
  //let rec loop acc l cont =
  //  match l with
  //  | [] -> cont acc |> List.rev
  //  | x::xs -> f x (fun x' -> loop (x'::acc) xs cont)
  //loop [] l cont      
  //let r = List.map (fun x -> x*2) [ 1 .. 3 ]

// Continuation-based version
//contMap (fun x c -> c(x*2)) [ 1 .. 3 ] (fun r -> ... )
      
      loop(lst, x => x)
    }
    
  }

}