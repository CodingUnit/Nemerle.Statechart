using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
/// <summary>
/// List utilities
/// </summary>
  public module ListUtils
  {

    /// <summary>
    /// Elements to first finded if not found returns all
    /// </summary>
    public FirstElems[T](this n : list[T], pred : T -> bool) : list[T]
    {
      def loop(n, acc)
      {
        match (n)
        {
          | head :: _ when pred(head) => acc.Rev()
          | head :: tail              => loop(tail, head :: acc)
          |_                          => acc.Rev()
        }
      }
      
      loop(n, [])
    }

    public SplitFind[T](this n : list[T], pred : T -> bool) : list[T] * list[T]
    {      
      def loop(n, acc)
      {
        match (n)
        {
          |  head :: tail  => def res = head :: acc;
            if (pred(head)) (res.Rev(), tail) else loop(tail, res);
          | _  => (acc.Rev(), [])
        }

      }

      loop(n, [])
    }

    /// <summary>
    /// Removes duplicates defined with equality predicate
    /// </summary>
    /// <param name = "lst">list</param>
    /// <param name = "eq_pred">Function that shows equality of two elements</param>
    public RemoveDuplicates[T](this lst : list [T], eq_pred : T * T -> bool) : list [T]
    {
      def loop (lst,  acc)
      {
        match (lst)
        {
          |  []  => acc.Reverse ();
          |  [x]  => (x :: acc).Reverse ();
          |  x :: ((y :: _) as xs)  =>
              if (eq_pred(x,  y)) loop (xs,  acc)
              else loop (xs,  x :: acc)
        }
      }

      loop (lst,  [])
    } 

    /// <summary>
    /// Removes duplicates defined with equality predicate with auto sorting
    /// </summary>
    /// <param name = "lst">list</param>
    /// <param name = "eq_pred">Function that shows equality of two elements</param>
    public RemoveDuplicatesSort[T](this lst : list [T], comp : T * T -> int) : list [T]
    {
      def sorted = lst.Sort(comp); // sort
      sorted.RemoveDuplicates((x1, x2)  => comp(x1, x2) == 0); // remove duplicates
    }

    /// <summary>
    /// Return from list only correspond to result type with partition of others
    /// </summary>
    /// <param name = "lst">list</param>
    /// <returns>result * left elements</returns>
    public PartitionType[T, TRes](this lst : list[T]) : list[TRes] * list[T]
    {      
      def loop(lst : list[T], res, acc)
      {
        match (lst)
        {
          | (head is TRes) :: tail => loop(tail, head :: res, acc)
          | head :: tail  => loop(tail, res, head :: acc)
          | _  => (res.Rev(), acc.Rev())
        }
      }
      
      loop(lst, [], [])
    }

    public PartitionType[T, TRes](this lst : IEnumerable[T]) : IEnumerable[TRes] * IEnumerable[T]
    {
      def acc = List();
      def res = List();

      def loop(lst : IEnumerator[T])
      {
        if (lst.MoveNext())
        {
          def elem = lst.Current;
          match (elem)
          {
            | elem is TRes => res.Add(elem)
            | _            => acc.Add(elem)
          }
          loop(lst)
        } else ()
      }

      loop(lst.GetEnumerator());
      (res.AsEnumerable(), acc.AsEnumerable())
    }

    public PartitionLazy[T](this lst : IEnumerable[T], pred : T -> bool) : IEnumerable[T] * IEnumerable[T]
    {
      (lst.Where(pred), lst.Where(x => !pred(x)))
    }

    public PartitionAround[T](this lst : list[T], pred : T -> bool) : list[T] * list[T]
    {
      def loop(lst, res)
      {
        match (lst)
        {
          | head :: tail => if (pred(head)) (res.Rev(), tail) else loop(tail, head :: res)
          | _            => (res.Rev(), [])
        }
      }

      loop(lst, [])
    }

    public PartitionFirst[T](this lst : list[T], pred : T -> bool) : list[T] * list[T]
    {
      def loop(lst, res)
      {
        match (lst)
        {
          | head :: tail => if (pred(head)) (res.Rev(), lst) else loop(tail, head :: res)
          | _            => (res.Rev(), [])
        }
      }

      loop(lst, [])
    }

    public FilterType[T, TRes](this lst : list[T]) : list[TRes]
    {
      def loop(val : T, res)
      {
        match (val)
        {
          | val is TRes => val :: res
          | _ => res
        }
      }

      lst.FoldBack([], loop)
    }

    public FilterType[T, TRes](this lst : IEnumerable[T]) : IEnumerable[TRes]
    {
      def lst = lst.GetEnumerator();

      def loop()
      {
        if (lst.MoveNext())
        {
          match (lst.Current)
          {
            | val is TRes => yield val;
            | _           => ()
          }
          loop()
        } else ()
      }

      loop()
    }

    /// <summary>
    /// Find first element corresponds to result type
    /// </summary>
    /// <param name = "lst">список</param>
    /// <returns>результат * оставшиеся элементы</returns>
    public FindTypeRes[T, TRes](this lst : list[T]) : option[TRes] * list[T]
    {
      def loop(lst : list[T], res)
      {
        match (lst)
        {
          | (head is TRes) :: tail  => (Some(head), res.Rev() + tail)
          | head :: tail  => loop(tail, head :: res);
          | _  => (None(), res.Rev())
        }
      }

      loop(lst, []);
    }

    /// <summary>
    /// Find first element corresponds to result type
    /// </summary>
    /// <param name = "lst">список</param>
    /// <returns>результат * оставшиеся элементы</returns>
    public FindType[T, TRes](this lst : list[T]) : option[TRes]
    {
      def loop(lst : list[T])
      {
        | (head is TRes) :: _  => Some(head)
        | _ :: tail            => loop(tail)
        | _                    => None()
      }
      
      loop(lst)
    }
    
    /// <summary>
    /// Find first element corresponds to result type
    /// </summary>
    /// <param name = "lst">список</param>
    /// <returns>результат * оставшиеся элементы</returns>
    public FindType[T, TRes](this lst : IEnumerable[T]) : option[TRes]
    {
      def loop(lst : IEnumerator[T])
      {
        if (lst.MoveNext())
        {
          match (lst.Current)
          {
            | cur is TRes => Some(cur)
            | _ => loop(lst)
          }
        } else None()
      }

      loop(lst.GetEnumerator())
    }

    public FilterValues[T, TRes](this lst : list[T], pred : T -> option[TRes]) : list[TRes]
    {
      def loop(head, res)
      {
        match (pred(head))
        {
          | Some(val)  => val :: res
          | _          => res
        }
      }

      lst.FoldBack([], loop)
    } 

    public FilterType[T, TRes](this lst : IEnumerable[T], pred : T -> TRes) : IEnumerable[TRes] where TRes : class
    {
      def en = lst.GetEnumerator();

      def loop()
      {
        if (en.MoveNext())
        {
          def elem = en.Current;
          match (pred(elem))
          {
            | null  => ()
            | val   => yield val
          }
          loop()
        } else ()
      }

      loop()
    //lst.FoldLeft([], loop).Rev()
    } 
    
    public FilterValues[T, TRes](this lst : IEnumerable[T], pred : T -> option[TRes]) : IEnumerable[TRes]
    {
      def en = lst.GetEnumerator();

      def loop()
      {
        if (en.MoveNext())
        {
          def elem = en.Current;
          match (pred(elem))
          {
            | Some(val)  => yield val
            | _          => ()
          }
          loop()
        } else ()
      }

      loop()
    //lst.FoldLeft([], loop).Rev()
    } 


    /// <summary>
    /// Excludes elements from list that not exist in second list
    /// </summary>
    /// <param name = "lst">list</param>
    /// <param name = "lst2">list 2</param>
    /// <param name = "eq">comparator</param>
    /// <returns>result</returns>
    public Exclude[T, T2](this lst : list[T], lst2 : list[T2], eq : T * T2 -> bool) : list[T]
    {
      lst.Filter(x  => !lst2.Exists(y  => eq(x, y)))
    }

    public Exclude[T, T2](this lst : IEnumerable[T], lst2 : IEnumerable[T2], eq : T * T2 -> bool) : IEnumerable[T]
    {
      lst.Where(x  => !lst2.Exists(y  => eq(x, y)))
    }

    public MapIndex[T, TRes](this lst : list[T], conv : (T * int) -> TRes) : list[TRes]
    {
      def loop(lst, idx, res)
      {
        match (lst)
        {
          | head :: tail  => loop(tail, idx + 1, conv(head, idx) :: res)
          | _  => res.Rev()
        }
      }

      loop(lst, 0, [])
    }

    public FindSingle[T, T2](this lst : list[T * list[T2]], pred : T2 -> bool) : option[T * T2]
    {
      def loop(lst)
      {
        | (x, lst) :: tail  => 
            match (lst.Find(pred)) 
            {
              | Some(v)  => Some((x, v))
              | _  => loop(tail)
            }
        | _  => option.None()
      }

      loop(lst)
    }

    public FindSingleList[T, T2](this lst : list[T * list[T2]], pred : T2 -> bool) : list[T * T2]
    {
      def loop((x, lst), res)
      { 
        match (lst.Find(pred)) 
        {
          | Some(val)  => (x, val) :: res
          | _          => res
        }
      }

      lst.FoldBack([], loop)
    }

    public MapDefault[T, T2](this opt : option[T], conv : T -> T2, default : T2) : T2
    {
      match (opt)
      {
        | Some(val)  => conv(val)
        | _          => default
      }
    }

    public WithDefault[T, T2](this opt : option[T], default : T2) : T2 where T : T2 
    {
      match (opt)
      {
        | Some(val)  => val : T2
        | _          => default
      }
    }

    public static @%+[T, T2](this lst : list[T], lst2 : list[T2]) : list[T] where T2 : T
    {
      lst + lst2.Map(_ : T)
    }

    public static @&+[T, T2, T3](this lst : list[T2], lst2 : list[T3]) : list[T] where T2 : T where T3 : T
    {
      lst.Map(_ : T) + lst2.Map(_ : T)
    }

    /// <summary>
    /// Returns duplicates according to comparator
    /// </summary>
    /// <param name = "lst">list</param>
    /// <param name = "comp">comparator</param>
    /// <returns>duplicates</returns>
    public Duplicates[T](this lst : list[T], comp : T * T -> int) : list[T]
    {
      def sorted = lst.Sort(comp);

      def loop (lst,  acc)
      {
        match (lst)
        {
          | []
          | [_]  => acc.Reverse()
          | x :: ((y :: _) as xs)  => 
              if (comp(x,  y) == 0) loop (xs,  x :: acc)
              else loop (xs,  acc)
        }
      }

      loop(sorted,  [])
    }


    public DuplicatesPartition[T](this lst : list[T], comp : T * T -> int) : list[T] * list[T]
    {
      def sorted = lst.Sort(comp);

      def loop (lst,  acc, res)
      {
        def eq(x)
        {
          (!acc.IsEmpty() && comp(x, acc.Head) == 0)
        }
        match (lst)
        {
          | []  => (acc.Rev(), res.Rev())
          | [x]  => (acc.Rev(), (x :: res).Rev())
          | x :: ((y :: _) as xs)  =>
              if (comp(x,  y) == 0 || eq(x)) loop (xs,  x :: acc, res)
              else loop (xs,  acc, x :: res)
        }
      }

      loop (sorted,  [], [])
    }

    public DuplicatesPartition[T, TKey](this lst : IEnumerable[T], comp : T -> TKey) : IEnumerable[T] * IEnumerable[T]
    {
      def sorted = lst.OrderBy(comp);

      def acc = List();
      def res = List();
      def comparer = Comparer.Default;

      def en = sorted.GetEnumerator();

      def loop(elem1)
      {
        if (en.MoveNext()) 
        {
          def elem = en.Current;
          if (comparer.Compare(comp(elem1), comp(elem)) == 0) res.Add(elem1); else acc.Add(elem1);
          loop(elem);
        } else ()
      }

      when (en.MoveNext()) loop(en.Current);
      (res, acc)
    }

    public FindDelimited[T](this lst : list[T], pred : T -> bool) : list[list[T]]
    {
      def loop(lst, res, subres)
      {
        match (lst)
        {
          | head :: tail  => if (pred(head)) loop(tail, subres.Rev() :: res, []) else loop(tail, res, head :: subres)
          | _  => if (res.IsEmpty()) [] else (subres.Rev() :: res).Rev()
        }
      }

      loop(lst, [], [])
    }

    public FindDelimited[T](this lst : IEnumerable[T], pred : T -> bool) : IEnumerable[IEnumerable[T]]
    {
      def acc = List();
      def res = List();

      def lst = lst.GetEnumerator();

      def loop()
      {
        if (lst.MoveNext())
        {
          def head = lst.Current;
          if (pred(head)) res.Add(acc.AsEnumerable()) else 
          {
            acc.Add(head);
          }
          loop()
        } else ()

      }

      loop();
      res
    }

    public ElementsEqual[T](this lst : list[T], pred : (T * T) -> bool) : bool
    {
      def loop(lst)
      {
        |  []
        |  [_]  => true
        |  x :: ((y :: _) as xs)  => if (pred(x, y)) loop(xs) else false
      }

      loop(lst)
    }

    public ElementsEqual[T](this lst : IEnumerable[T], pred : (T * T) -> bool) : bool
    {
      def en = lst.GetEnumerator();


      def loop(acc)
      {
        if (en.MoveNext()) 
        {
          def elem = en.Current;
          if (pred(acc, elem)) loop(elem) else false
        } else true
      }

      if (en.MoveNext()) loop(en.Current) else true
    }

    public ChopLastN[T](this lst : list[T], num : int) : list[T]
    {
      def num = lst.Length - num;

      def loop(lst, res, n)
      {
        match (lst)
        {
          | head :: tail => if (n != 0) loop(tail, head :: res, n - 1) else res.Rev()
          | _ => res.Rev()
        }
      }

      loop(lst, [], num)
    }

    public ChopLast[T](this lst : IEnumerable[T]) : IEnumerable[T] where T : class
    {
      def lst = lst.GetEnumerator();
      
      def loop(prev)
      {
        if (lst.MoveNext())
        {
          yield prev;
          def elem = lst.Current;
          loop(elem);
        } else ()
      }

      if (lst.MoveNext()) loop(lst.Current) else ()
    }
    
    public Exclude[T](this lst : list[T], pred : T -> bool) : list[T]
    {
      def loop(elem, res)
      {
        if (pred(elem)) res else elem :: res;
      }

      lst.FoldBack([], loop)
    }

    public FindIndex[T](this lst : list[T], pred : T -> bool) : int
    {
      def loop(e, i)
      {
        match (e)
        {
          | head :: tail => if (pred(head)) i else loop(tail, i + 1)
          | _ => -1
        }
      }

      loop(lst, 0)
    }

    public Exclude[T](this lst : list[T], lst2 : list[T]) : list[T]
    {
      lst.Filter(x => !lst2.Contains(x))
    }

    public Exclude[T](this lst : array[T], lst2 : list[T]) : array[T]
    {
      lst.FilterToArray(x => !lst2.Contains(x))
    }

    public Exclude[T](this lst : array[T], lst2 : list[T], eq : T * T -> bool) : array[T]
    {
      lst.FilterToArray(x => !lst2.Exists(eq(x, _)))
    }

    public Remove[T](this lst : array[T], eq : T -> bool) : array[T]
    {
      lst.FilterToArray(eq)
    }

    public static @%::[T](opt : option[T], lst : list[T]) : list[T]
    {
      if (opt is Some(v)) v :: lst else lst
    }

    not_empty_err = "list must be not empty";

    public SplitLast[T](this lst : list[T]) : T * list[T]
    {
      def loop(lst, res)
      {
        match (lst)
        {
          | [] => throw ArgumentException(not_empty_err)
          | [head] => (head, res.Rev())
          | head :: tail => loop(tail, head :: res)
        }
      }

      loop(lst, [])
    }

    public Last[T](this lst : list[T]) : T
    {
      def loop(lst)
      {
        | [] => throw ArgumentException(not_empty_err)
        | [head] => head
        | _ :: tail => loop(tail)
      }

      loop(lst)
    }

    public RemoveDupFirst[T](this lst : list[T], lst2 : list[T], eq_pred : T * T -> bool) : list[T] * list[T]
    {
      def loop(lst, lst2)
      {
        | (head :: tail, head2 :: tail2) when (eq_pred(head, head2)) => loop(tail, tail2)
        | (_, _) => (lst, lst2)
      }

      loop(lst, lst2)
    }

    public Map[T, T2, T3](this tuple : T * T2, map : (T * T2) -> T3) : T3
    {
      map(tuple)
    }

    //public MapThrough[T, T2, T3](this lst : list[T], init : T2, map : T * T2 -> T * T2) : list[T] * T2
    //{
    //  lst.FoldLeft(([], init), (x, (l, a)) => map(x, a).Map((x, y) => (x :: l, y)))
    //}

    public FoldLeft[TAcc, T](this opt : option[T], init : TAcc, fold : T * TAcc -> TAcc) : TAcc
    {
      match (opt)
      {
        | Some(o) => fold(o, init)
        | _       => init
      }
    }

    public Unfold[T, TResult](start : T, generator : T -> option[TResult * T]) : list[TResult]
    {
      def loop(next, res)
      {
        match (generator(next))
        {
          | Some((r, n)) => loop(n, r :: res)
          | _            => res.Rev()
        }
      }

      loop(start, [])
    }

    public UnfoldLazy[T, TResult](start : T, generator : T -> option[TResult * T]) : IEnumerable[TResult]
    {
      def loop(next)
      {
        match (generator(next))
        {
          | Some((r, n)) => yield r; loop(n)
          | _            => ()
        }
      }

      loop(start)
    }

    public Init[T](len : int, init : int -> T) : IEnumerable[T]
    {
      def loop(idx)
      {
        if (idx == len) () else 
        {
          yield init(idx);
          loop(idx + 1)
        }
      }
      
      loop(0)
    }
    
    public UnfoldLazy[T, TResult](start : T, generator : T -> option[TResult] * option[T]) : IEnumerable[TResult]
    {
      def loop(next)
      {
        match (generator(next))
        {
          | (Some(r), Some(n)) => yield r; loop(n)
          | (Some(r), _)       => yield r;
          | (_      , Some(n)) => loop(n)
          | _                  => ()
        }
      }

      loop(start)
    }
    
    public Pop[T](this lst : SCG.Stack[T], len : int) : list[T]
    {
      def loop(acc, len)
      {
        if (len != 0) 
        {
          loop(lst.Pop() :: acc, len - 1)
        } else acc.Rev()
      }

      loop([], len)
    }

    public FoldBack[T, TOut](this l : IEnumerable[T], acc : TOut, f : T * TOut -> TOut) : TOut 
    {
      def buffer = SCG.Stack();
      foreach (x in l) buffer.Push(x);
      mutable result = acc;
      foreach (x in buffer) result = f(x, result);
      result
    }

    public Exclude[T](this lst : IEnumerable[T], pred : T -> bool) : IEnumerable[T]
    {
      lst.FilterLazy(x => !pred(x))
    }

    public MapIndex[T, TRes](this lst : IEnumerable[T], conv : (T * int) -> TRes) : IEnumerable[TRes]
    {
      def lst = lst.GetEnumerator();

      def loop(idx)
      {
        if (lst.MoveNext())
        {
          yield conv(lst.Current, idx);
          loop(idx + 1)
        } else ()
      }

      loop(0)
    }

    public Pop[T, T2](this lst : SCG.Stack[T], lencoll : IEnumerable[T2]) : IEnumerable[T]
    {
      def loop(en, len)
      {
        while (len.MoveNext())
        {
          if (en.MoveNext())
          {
            yield en.Current;
          } else throw InvalidOperationException("Collection does not contain needed number of element");
        }
      }

      loop(lst.GetEnumerator(), lencoll.GetEnumerator())
    }

    public PopRev[T, T2](this lst : SCG.Stack[T], lencoll : IEnumerable[T2]) : list[T]
    {
      def loop(en, len, res)
      {
        if (len.MoveNext())
        {
          if (!en.IsEmpty())
          {
            def cur = en.Pop();
            loop(en, len, cur :: res);
          } else throw InvalidOperationException("Collection does not contain needed number of element");
        } else res
      }

      loop(lst, lencoll.GetEnumerator(), [])
    }

    public PopRev[T, T2](this lst : SCG.Stack[T], len : int) : list[T]
    {
      def loop(len, res)
      {
        if (len == 0) res else
        {
          def cur = lst.Pop();
          loop(len - 1, cur :: res)
        }
      }

      loop(len, [])
    }

    public PopRev[T](this lst : list[T], len : int) : list[T] * list[T]
    {
      def loop(lst, len, res)
      {
        if (len == 0) (res, lst) else
        {
          match (lst)
          {
            | head :: tail => loop(tail, len - 1, head :: res)
            | _            => throw InvalidOperationException("collection does not have enough elements")
          }
        }
      }

      loop(lst, len, [])
    }

    public PopRevLazy[T](this lst : list[T], len : int) : IEnumerable[T]
    {
      
      def loop(lst, len, res)
      {
        if (len == 0) res else
        {
          match (lst)
          {
            | head :: tail => loop(tail, len - 1, head :: res)
            | _            => throw InvalidOperationException("collection does not have enough elements")
          }
        }
      }

      def lst = loop(lst, len, []);
      foreach (a in lst) yield a;
    }
    
        //public Concat[T](this lst : IEnumerable[T], elem : T) : IEnumerable[T]
    //{
    //  lst.Concat(TraverseUtils.SingleElement(elem))
    //}

    //public Concat[T](this lst : IEnumerable[T], elem1 : T, elem2 : T) : IEnumerable[T]
    //{
    //  lst.Concat(TraverseUtils.DoubleElement(elem1, elem2))
    //}

    public IsSingle[T](this lst : IEnumerable[T]) : bool
    {
      def en = lst.GetEnumerator();
      en.MoveNext() && !en.MoveNext()
    }

    public IsMoreThanOne[T](this lst : IEnumerable[T]) : bool
    {
      def en = lst.GetEnumerator();
      en.MoveNext() && en.MoveNext()
    }

    public AddBefore[T](this lst : IEnumerable[T], elem : T) : IEnumerable[T]
    {
      yield elem;
      foreach (elem in lst) yield elem;
      //TraverseUtils.SingleElement(elem).Concat(lst)
    }

    public HeadAppend[T](this lst : list[T], lst2 : IEnumerable[T]) : list[T]
    {
      lst2.FoldLeft(lst, _ :: _)
    }

    public Duplicates[T, TKey](this lst : IEnumerable[T], comp : T -> TKey) : IEnumerable[T]
    {
      def sorted = lst.OrderBy(comp);

      def comparer = Comparer.Default;

      def en = sorted.GetEnumerator();

      def loop(elem1)
      {
        if (en.MoveNext()) 
        {
          def elem = en.Current;
          when (comparer.Compare(comp(elem1), comp(elem)) == 0) yield elem1;
          loop(elem);
        } else ()
      }

      when (en.MoveNext()) loop(en.Current);
    }

    public RemoveDuplicatesSort[T, TKey](this lst : IEnumerable[T], comp : T -> TKey) : list[T]
    {
      def sorted = lst.OrderBy(comp);
      def comparer = Comparer.Default;

      def loop(elem1, acc)
      {
        match (acc)
        {
          | head :: _ => if (comparer.Compare(comp(elem1), comp(head)) != 0) elem1 :: acc else acc
          | _         => elem1 :: acc
        }
      }

      sorted.FoldBack([], loop)
      //when (en.MoveNext()) loop(en.Current);
    }

    public Append[T](this lst : IEnumerable[T], elem : T) : IEnumerable[T]
    {
      foreach (elem in lst) yield elem;
      yield elem;
    }

    public Append[T](this lst : IEnumerable[T], elem : option[T]) : IEnumerable[T]
    {
      match (elem)
      {
        | Some(e) => lst.Append(e)
        | _       => lst
      }
    }

    public FoldLeft2[T, TAcc1, TAcc2](this lst : IEnumerable[T], init1 : TAcc1, init2 : TAcc2, fold : T * TAcc1 * TAcc2 -> TAcc1 * TAcc2) : TAcc1 * TAcc2
    {
      def en = lst.GetEnumerator();

      def loop(acc1, acc2)
      {
        if (en.MoveNext())
        {
          def elem = en.Current;
          loop(fold(elem, acc1, acc2))
        } else (acc1, acc2)
      }

      loop(init1, init2)
    }

    public FoldLeft3[T, TAcc1, TAcc2, TAcc3](this lst : IEnumerable[T], init1 : TAcc1, init2 : TAcc2, init3 : TAcc3, fold : T * TAcc1 * TAcc2 * TAcc3 -> TAcc1 * TAcc2 * TAcc3) : TAcc1 * TAcc2 * TAcc3
    {
      def en = lst.GetEnumerator();

      def loop(acc1, acc2, acc3)
      {
        if (en.MoveNext())
        {
          def elem = en.Current;
          loop(fold(elem, acc1, acc2, acc3))
        } else (acc1, acc2, acc3)
      }

      loop(init1, init2, init3)
    }
    
    //public FoldList[T, TAcc1, TAcc2](this lst : IEnumerable[T], init1 : list[TAcc1], init2 : TAcc2, fold : T * TAcc2 -> TAcc1 * TAcc2) : list[TAcc1] * TAcc2
    //{
    //  def en = lst.GetEnumerator();

    //  def loop(acc1, acc2)
    //  {
    //    if (en.MoveNext())
    //    {
    //      def elem = en.Current;
    //      def (r, a) = fold(elem, acc2);
    //      loop(r :: init1, a)
    //    } else (acc1, acc2)
    //  }

    //  loop(init1, init2)
    //}

    public PushLength[T](this lst : SCG.Stack[T], en : IEnumerable[T]) : int
    {
      def en = en.GetEnumerator();

      def loop(len)
      {
        if (en.MoveNext())
        {
          lst.Push(en.Current);
          loop(len + 1)
        } else len
      }

      loop(0)
    }

    public Fold2[T, T2, TAcc](this lst : IEnumerable[T], lst2 : IEnumerable[T2], init : TAcc, fold : (T * T2 * TAcc) -> TAcc) : TAcc
    {
      def en1 = lst.GetEnumerator();
      def en2 = lst2.GetEnumerator();

      def loop(acc)
      {
        if (en1.MoveNext())
        {
          if (en2.MoveNext())
          {
            loop(fold(en1.Current, en2.Current, acc))
          } else throw InvalidOperationException("second enumerable must have enough elements")
        } else acc
      }

      loop(init)
    }

    public TakeTwo[T](this lst : IEnumerable[T]) : T * T
    {
      def dothrow() { throw InvalidOperationException("no elements") }

      def en = lst.GetEnumerator();
      if (en.MoveNext())
      {
        def first = en.Current;
        if (en.MoveNext())
        {
          def sec = en.Current;
          (first, sec)
        } else dothrow()
      } else dothrow()
    }

    public IndexOf[T](this lst : IEnumerable[T], pred : T -> bool) : int
    {
      def en = lst.GetEnumerator();

      def loop(i)
      {
        if (en.MoveNext()) 
        {
          if (pred(en.Current)) i else loop(i + 1)
        } else -1
      }

      loop(0)
    }
    
    public Reduce[T, TAcc](this lst : IEnumerable[T], folder : T * T -> T) : T
    {
      def en = lst.GetEnumerator();

      def loop(a)
      {
        if (en.MoveNext())
        {
          loop(folder(en.Current, a))
        } else a
      }

      when (!en.MoveNext()) throw ArgumentException("Enumerable is empty");
      loop(en.Current)
    }

    public Reduce[T, TAcc](this lst : IEnumerable[T], init : TAcc, folder : T * T * TAcc -> T * TAcc) : T * TAcc
    {
      def en = lst.GetEnumerator();

      def loop(a, a2)
      {
        if (en.MoveNext())
        {
          loop(folder(en.Current, a, a2))
        } else (a, a2)
      }

      when (!en.MoveNext()) throw ArgumentException("Enumerable is empty");
      loop(en.Current, init)
    }
    
    public Reduce2[T, T2](this lst : IEnumerable[T], lst2 : IEnumerable[T2], folder : (T * T2 * T) -> T) : T
    {
      def en1 = lst.GetEnumerator();
      def en2 = lst2.GetEnumerator();

      def loop(acc)
      {
        def res = folder(en1.Current, en2.Current, acc);
        if (en1.MoveNext())
        {
          if (en2.MoveNext())
          {
            loop(res)
          } else throw InvalidOperationException("second enumerable must have enough elements")
        } else res
      }

      def res1 = en1.MoveNext();
      def res2 = en2.MoveNext();
      when (!res1 || !res2) throw ArgumentException("Enumerable is empty");
      loop(en1.Current)
    }

    public OptionFromObj[T](this obj : T) : option[T] where T : class
    {
      if (obj == null) None() else Some(obj)
    }
  }

}
