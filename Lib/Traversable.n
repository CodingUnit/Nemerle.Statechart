using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{

  partial module TraversableImpl
  {


    public DoCheckTraverse(typer : Typer, typeBuilder : TypeBuilder, expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      def opts = typeBuilder.GetVariantOptions();
      def name = typeBuilder.Name;
      //assert2(false);
      
      def get_type(t, a)
      {
        match (t)
        {
          | <[ All ]>         => a
          | <[ $(x : name) ]> => x.Id :: a
          | _                 => a
        }
      }

      def map_types(t, a)
      {
        match (opts.Find(y => y.Name.EndsWith(t)))
        {
          | Some(s) => s :: a
          | _       => a
        }
      }

      def ttype = typeBuilder.GetFreshType();
      def types = expr.FoldBack([], get_type);
      def types = types.FoldBack([], map_types);
      def is_all = expr is [<[ All ]>];
      def types = if (types is []) [typeBuilder] else types;


      def get_members(f, e)
      {
        def is_traversable(f, a)
        {

          def is_that_type(ty, tt, type, cont)
          {
            cont.TryRequire(ty) && tt.TryRequire(type)
          }
          
          def is_enum(ty, tt, t)
          {
            def type = t.GetFreshType();
            def cont = <[ ttype: IEnumerable[_] ]>;
            is_that_type(ty, tt, type, cont)
          }

          def is_opt(ty, tt, t)
          {
            def type = t.GetFreshType();
            def cont = <[ ttype: option[_] ]>;
            is_that_type(ty, tt, type, cont)
          }

          match (f.GetMemType())
          {
            | FixedType.Class(_, [t]) as ty => def ret = if (types.Exists(is_enum(ty, t, _))) TreeType.Enumerable else
                                               if (types.Exists(is_opt(ty, t, _))) TreeType.Option else TreeType.Unknown;
                                               if (ret == TreeType.Unknown) a else (f, ret) :: a
            | FixedType.Class as ty         => if (types.Exists(x => ty.TryRequire(x.GetFreshType()))) (f, TreeType.Type) :: a else a
            | _                             => a
          }

        }

        def get_fields()
        {
          
          def get_name(e)
          {
            | <[ $e.$b ]>       => get_name(e) + [b.GetName().Id]
            | <[ $(e : name) ]> => [e.Id]
            | _                 => throw InvalidOperationException("invalid type specified")
          }
          
          match (e)
          {
           | <[ $_($_ = $e(_)) ]> => def name = get_name(e);
                                     match (typer.Env.LookupType(name))
                                     {
                                       | Some(t) => t.GetFields(BindingFlags.Public | BindingFlags.Instance)
                                       | _       => throw InvalidOperationException("invalid type specified")
                                     }
           | _                     => f.GetFields(BindingFlags.Public | BindingFlags.Instance);
          }
        }
        
        
        def fields = get_fields();
        def fields_incl = fields.Filter(x => x.attr_func(x => x.Exists(_ is <[ TraverseInclude ]>)));
        def fields = if (fields_incl is []) fields.Exclude(x => x.attr_func(x => x.Exists(_ is <[ TraverseIgnore ]>))); else fields_incl;
        (f, e, fields.FoldBack([], is_traversable))
      }

      def to_lower(s)
      {
        def idx = s.IndexOf(char.IsUpper);
        if (idx == -1) s else 
        {
          def str = s.Substring(0, idx);
          def low = char.ToLower(s[idx]);
          def nstr = s.Substring(idx + 1);
          if (str.IsEmpty()) $"$low$(to_lower(nstr))" else $"$(str)_$low$(to_lower(nstr))"
        }
      }

      def create_iterator_data(t, e, f)
      {
        def get_name(e)
        {
          | <[ $(n : name) = $_]> 
          | <[ $(n : name)($_)]>   => n.Id
          | _                      => t.Name
        }

        def name = get_name(e);
        def name = to_lower(name);
        (t, f, name, e)
      }

      
      def traverse = CollectTraverseOpt(opts, is_all);
      def traverse = if (traverse is []) opts.Map(x => (x, <[ ]>)) else traverse;

      def traversable = traverse.Map(get_members);
      def data = traversable.Map(create_iterator_data);
      

      def env = typer.Manager.CoreEnv.EnterIntoNamespace(typeBuilder.NamespaceNode.Parent);

      def create_iter(data, 
                      name, 
                      tp, 
                      ntp, 
                      create_type, 
                      it_type, 
                      run_body_func, 
                      vis_types, 
                      ret_type, 
                      fold, 
                      reduce, 
                      reduce_create, 
                      red_par : list[PParameter * PExpr], 
                      red_name, 
                      is_single,
                      exec_expr = null)
      {
        def ntp = <[ $(ttype : typed) ]> :: ntp;
        def builder = env.Define(<[decl: public class $(name : usesite)[..$tp] : $it_type[..$ntp] {}]>);

        def create_param(f)
        {
          | [(t, n)]          => [<[ parameter: $(n : usesite) : $t ]>]
          | f => f.Map((t, n) => if (is_single) <[ parameter: $(n : usesite) : $t ]> else <[ parameter: $(n : usesite) : $t = null ]>)
        }

        def create_param_cons(f)
        {
          f.Map((t, n) => <[ parameter: $(n : usesite) : $t ]>)
        }
        
        def fld_data = data.Map((b, f, n, _) => (create_type(b, f), n));
        fld_data.Iter((t, n) => _ = builder.DefineWithSource(<[ decl: public $(n : usesite) : $t ]>));
        def pars = create_param(fld_data);
        def assign = fld_data.Map((_, n) => <[ this.$(n : usesite) = $(n : usesite) ]>);
        def npars = fld_data.Map((_, n) => <[ $(n : usesite) ]>);
        def pars_cons = create_param_cons(fld_data);
        def cons = if (is_single) <[ base() ]> else <[ base(..$npars) ]>;
        _ = builder.DefineWithSource(<[ decl: public this (..$pars_cons)
                        {
                          $cons;
                          { ..$assign }
                        } ]>);

        def run_body = run_body_func(data); 
        def param = <[ parameter: obj : $(ttype : typed) ]> :: vis_types;
        //def expr = if (exec_expr != null) exec_expr(run_body) else ;
        _ = builder.DefineWithSource(<[ decl: public override Visit(..$param) : $ret_type
                        {
                          $run_body
                        } ]>);
        when (fold)
        {
          def fold = <[ parameter: this obj : $(ttype : typed) ]> :: <[ parameter: init : T ]> :: pars;
          _ = builder.DefineWithSource(<[ decl: public static Fold(..$fold) : $ret_type
                          {
                            obj.FoldDo(init, $(name : usesite)(..$npars))
                          } ]>);
        }
        when (reduce != null)
        {
          def fld_data = data.Map((b, f, n, _) => (reduce_create(b, f), n));
          def pars = create_param(fld_data);
          def (rpar, rpare) = red_par.Split();
          def pars = pars.HeadAppend(rpar);
          def npars = <[ $(name : usesite)(..$npars) ]> :: [];
          def npars = npars.HeadAppend(rpare);
          
          def pars = <[ parameter: this obj : $(ttype : typed) ]> :: pars;
          _ = builder.DefineWithSource(<[decl: public static $(red_name : usesite)(..$pars) : $reduce
                          {
                            obj.ReduceDo(..$npars)
                          } ]>);
        }
        builder.Compile();
      }

      def create_case((b, c, n, e), add, a, opts, create_case)
        {
          def acc = create_case(c, add);
          def type = b.ParsedName;
          def expr = opts(c, e);
          def e = match (e, expr)
          {
            | (<[]>, <[]>) => <[ case: | $(type : name) as obj     => this.$(n : usesite)(..$acc) ]>
            | (_, <[ $_ = $_ ]> as ex)
            | (_, <[ $_($f = $t(_)) ]>) with ex = <[ $f = $t ]>
            | (_, <[ $_($ex) ]>)        => <[ case: | $(type : name)($ex) as obj => this.$(n : usesite)(..$acc) ]>
            | (_, _)                   => throw InvalidOperationException("invalid pattern")
          }
          e :: a
        }

        def def_opts(c, e)
        {
          match (c)
          {
                        | [(f, TreeType.Option)] 
                        | [(_, TreeType.Type), (f, TreeType.Option)] 
                        | [(f, TreeType.Option), (_, TreeType.Type)] => <[ $(f.Name : usesite) = n ]>;
                        | _                                          => e
           }
        }
        
      def run_body_func(data, default, add, opts, create_case_par)
      {
        def sorted = SortCases(data, x => x[3]);
        def cases = sorted.FoldLeft([default], create_case(_, add, _, opts, create_case_par));
        <[ match (obj)
          {
            ..$cases
          }
        ]>
      }

      def make_type(b, f, type, end, ret)
      {

        def make_ftype(_, t)
        {
          match (t)
          {
            | TreeType.Enumerable => <[ IEnumerable[$type] ]>
            | Option              => <[ option[$type] ]>
            | Type                => <[ $type ]>
            | Unknown             => <[ ]>
          }
        }

        def ftype = f.FoldBack(end, (x, a) => make_ftype(x) :: a);
        def ftype = <[ $(b.GetMemType() : typed) ]> :: ftype;
        match (ftype)
        {
          | [fld] => <[ $fld -> $ret ]>
          | _     => <[ @*(..$ftype) -> $ret ]>
        }
        
      }

      def create_case_param(c, add)
      {
        match (c)
        {
          | []                                       => <[ obj ]> :: add
          | [(_, TreeType.Type)]                     => <[ obj ]> :: <[ acc.First() ]> :: add
          | [(_, TreeType.Option)]                   => def acc1 = <[ obj ]> :: <[ Some(a) ]> :: add;
                                                        def acc2 = <[ obj ]> :: <[ None() ]> :: add;
                                                        <[
                                                            if (n.HasValue) 
                                                            {
                                                              def a = acc.First();
                                                              (..$acc1) 
                                                            } else (..$acc2)
                                                        ]> :: []
          | [(_, TreeType.Enumerable)]               => <[ obj ]> :: <[ acc ]> :: add
          | [(_, TreeType.Type), (_, TreeType.Type)] => def acc = <[ obj ]> :: <[ a ]> :: <[ b ]> :: add;
                                                        <[ def (a, b) = acc.TakeTwo();
                                                           (..$acc) ]> :: []
          | [(_, TreeType.Option), (_, TreeType.Type)] => def acc1 = <[ obj ]> :: <[ Some(a) ]> :: <[ b ]> :: add;
                                                          def acc2 = <[ obj ]> :: <[ None() ]> :: <[ b ]> :: add;
                                                          <[
                                                            if (n.HasValue)
                                                            {
                                                              def (a, b) = acc.TakeTwo();
                                                              (..$acc1)
                                                            } else
                                                            {
                                                              def b = acc.First();
                                                              (..$acc2)
                                                            }
                                                          ]> :: []
          | [(_, TreeType.Type), (_, TreeType.Option)] => def acc1 = <[ obj ]> :: <[ a ]> :: <[ Some(b) ]> :: add;
                                                          def acc2 = <[ obj ]> :: <[ a ]> :: <[ None() ]> :: add;
                                                          <[
                                                            if (n.HasValue)
                                                            {
                                                              def (a, b) = acc.TakeTwo();
                                                              (..$acc1)
                                                            } else
                                                            {
                                                              def a = acc.First();
                                                              (..$acc2)
                                                            }
                                                          ]> :: []
          | _                                          => throw InvalidOperationException("unknown pattern")
        }
      }

      def create_acc_case_param(_, _) { [<[ obj ]>, <[ acc ]>] }

      def make_reduce_type(b, f)
      {
        make_type(b, f, <[ $(ttype : typed) ]>, [], <[ $(ttype : typed) ]>)
      }

      def make_reduce_type2(b, f)
      {
        make_type(b, f, <[ $(ttype : typed) ]>, [<[ T ]>], <[ $(ttype : typed) * T ]>)
      }

      def run_body_func_single(data, add, create_case_par)
      {
        def (_, c, n, _) = data.Head;
        def acc = create_case_par(c, add);
        <[ this.$(n : usesite)(..$acc) ]>
      }

      def run_body_func_reduce(data, run_body_func, pars)
      {
        def body = run_body_func(data);
        def tup_pat = pars.MapI((i, _) => <[ res[$i] ]>);
        def cnv = <[ res[0] : ITraversable[$(name : usesite)] ]>;
        def pars = cnv :: tup_pat.Tail;
        def tup = <[ (..$pars) ]>;
        <[ def res = $body;
           $tup
        ]>
      }
      
      create_iter(data, $"$(name)IteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>], 
                  make_type(_, _, <[ T ]>, [], <[ T ]>), 
                  <[ IIteratorContext ]>, 
                  run_body_func(_, <[case: | _ => default(T) ]>, [], def_opts, create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: [], 
                  <[ T ]>, 
                  true,
                  null,
                  null,
                  null,
                  null,
                  false);

      create_iter(data, 
                  $"$(name)ReduceIteratorContext", 
                  [], 
                  [], 
                  make_reduce_type, 
                  <[ IReduceIteratorContext ]>, 
                  run_body_func(_, <[case: | _ => null ]>, [], def_opts, create_case_param), 
                  <[ parameter: acc : IEnumerable[$(ttype : typed)] ]> :: [], 
                  <[ ITraversable[$(ttype : typed)] ]>, 
                  false,
                  <[ $(ttype : typed) ]>,
                  make_reduce_type,
                  [],
                  "Reduce",
                  false);
                  
      create_iter(data, $"$(name)AccIteratorContext",
                  [Splicable.Name(<[ T ]>)],
                  [<[ T ]>],
                  (b, _) => make_type(b, [], <[ ]>, [<[ T ]>], <[ T ]>),
                  <[ IAccIteratorContext ]>,
                  run_body_func(_, <[case: | _ => acc ]>, [], (_, e) => e, create_acc_case_param), 
                  <[ parameter: acc : T ]> :: [],
                  <[ T ]>,
                  true,
                  null,
                  null,
                  null,
                  null,
                  false);

      create_iter(data, $"$(name)TwoAccIteratorContext", 
                  [Splicable.Name(<[ T ]>), Splicable.Name(<[ TAcc ]>)], 
                  [<[ T ]>, <[ TAcc ]>], 
                  make_type(_, _, <[ T ]>, [<[ TAcc ]>], <[ T * TAcc ]>), 
                  <[ ITwoAccIteratorContext ]>, 
                  run_body_func(_, <[case: | _ => (default(T), acc2) ]>, [<[ acc2 ]>], def_opts, create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: <[ parameter: acc2 : TAcc ]> :: [], 
                  <[ T * TAcc ]>, 
                  false,
                  null,
                  null,
                  null,
                  null,
                  false);

      create_iter(data, $"$(name)ReduceTwoAccIteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>], 
                  make_reduce_type2, 
                  <[ IReduceTwoAccIteratorContext ]>, 
                  run_body_func_reduce(_, run_body_func(_, <[case: | _ => (null, acc2) ]>, [<[ acc2 ]>], def_opts, create_case_param), [<[$(ttype : typed)]>, <[ T ]>]), 
                  <[ parameter: acc : IEnumerable[$(ttype : typed)] ]> :: <[ parameter: acc2 : T ]> :: [], 
                  <[ ITraversable[$(ttype : typed)] * T ]>, 
                  false,
                  <[ $(ttype : typed) * T ]>,
                  make_reduce_type2,
                  (<[ parameter: init : T ]>, <[ init ]>) :: [],
                  "Reduce",
                  false);
                  
      def compare_types(x, y)
      {
        x :> int - y :> int
      }

      def flds = data.FoldLeft([], (x, a) => a.HeadAppend(x[1]));
      def dups = flds.Group((x, y) => x[0].Name.CompareTo(y[0].Name) + compare_types(x[1], y[1]));
      def f = dups.MapFiltered(x => x.Length == data.Length, _.Head);
      def f = if (f is []) [(null, TreeType.Enumerable)] else f;
      def data = (typeBuilder, f, to_lower(name), <[]>);


      create_iter([data], 
                  $"$(name)SingleIteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>], 
                  make_type(_, _, <[ T ]>, [], <[ T ]>), 
                  <[ IIteratorContext ]>,
                  run_body_func_single(_, [], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: [], 
                  <[ T ]>, 
                  true,
                  null,
                  null,
                  null,
                  null,
                  false);

      create_iter([data], $"$(name)TwoAccSingleIteratorContext", 
                  [Splicable.Name(<[ T ]>), Splicable.Name(<[ TAcc ]>)], 
                  [<[ T ]>, <[ TAcc ]>], 
                  make_type(_, _, <[ T ]>, [<[ TAcc ]>], <[ T * TAcc ]>), 
                  <[ ITwoAccIteratorContext ]>, 
                  run_body_func_single(_, [<[ acc2 ]>], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: <[ parameter: acc2 : TAcc ]> :: [], 
                  <[ T * TAcc ]>, 
                  false,
                  null,
                  null,
                  null,
                  null,
                  false);

      create_iter([data], 
                  $"$(name)ReduceSingleIteratorContext", 
                  [], 
                  [], 
                  make_reduce_type, 
                  <[ IReduceIteratorContext ]>,
                  run_body_func_single(_, [], create_case_param), 
                  <[ parameter: acc : IEnumerable[$(ttype : typed)] ]> :: [], 
                  <[ ITraversable[$(ttype : typed)] ]>, 
                  false,
                  <[ $(ttype : typed) ]>,
                  make_reduce_type,
                  [],
                  "ReduceSingle",
                  true);

      create_iter([data], $"$(name)ReduceTwoAccSingleIteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>],
                  make_reduce_type2, 
                  <[ IReduceTwoAccIteratorContext ]>, 
                  run_body_func_reduce(_, run_body_func_single(_, [<[ acc2 ]>], create_case_param), [<[ $(ttype : typed) ]>, <[ T ]>]), 
                  <[ parameter: acc : IEnumerable[$(ttype : typed)] ]> :: <[ parameter: acc2 : T ]> :: [], 
                  <[ ITraversable[$(ttype : typed)] * T ]>, 
                  false,
                  <[ $(ttype : typed) * T ]>,
                  make_reduce_type2,
                  (<[parameter: init : T ]>, <[ init ]>) :: [],
                  "ReduceSingle",
                  true);
                  
    }

  }
}
