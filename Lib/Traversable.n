using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro Traverse(_typeBuilder : TypeBuilder, params _expr : list[PExpr])
  {
  }

  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Field)]
  macro TraverseIgnore(_typeBuilder : TypeBuilder, _ : ParsedField)
  {
  }

  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Field)]
  macro TraverseInclude(_typeBuilder : TypeBuilder, _ : ParsedField)
  {
  }

  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro Traversable(typeBuilder : TypeBuilder, params expr : list[PExpr])
  {
    TraversableImpl.DoTransformCached(Macros.ImplicitCTX(), typeBuilder, expr)
  }  

  [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class)]
  macro Traversable(typeBuilder : TypeBuilder, params expr : list[PExpr])
  {
    TraversableImpl.DoTransformCached2(Macros.ImplicitCTX(), typeBuilder, expr)
  }  

  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class)]
  macro Traversable(typeBuilder : TypeBuilder, params expr : list[PExpr])
  {
    TraversableImpl.DoCheckTraverse(Macros.ImplicitCTX(), typeBuilder, expr)
  }  


  enum TreeType
  {
    | Unknown
    | Type
    | Enumerable
    | Option
  }

  module TraversableImpl
  {

    public DoTransformCached(typer : Typer, typeBuilder : TypeBuilder, _expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      def name = typeBuilder.Name;
      typeBuilder.AddImplementedInterface(<[ ICachedTraversable[$(name : usesite)] ]>);
      typeBuilder.Define(<[decl: [NeedChange] [RecordIgnore] cached_iter : IEnumerable[ITraversable[$(name : usesite)]] * IEnumerable[int]; ]>);
      typeBuilder.Define(<[decl: [NeedChange] [RecordIgnore] cached_level_iter : IEnumerable[$(name : usesite)]; ]>);
    }


    public DoTransformCached2(typer : Typer, typeBuilder : TypeBuilder, _expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      def name = typeBuilder.Name;

      def is_get_code(x)
      {
        | ClassMember.Function(Name = "GetCode", header = PFunHeader where (Parameters = [])) => true
        | _                                                                                   => false
      }

      typeBuilder.Define(<[decl: public Current : $(name : usesite) { get { this } }]>);

      typeBuilder.Define(<[decl: public CachedIterator : IEnumerable[ITraversable[$(name : usesite)]] * IEnumerable[int] { get { cached_iter } } ]>);
      typeBuilder.Define(<[decl: public CachedLevelIterator : IEnumerable[$(name : usesite)] { get { cached_level_iter } } ]>);
      typeBuilder.Define(<[decl: public CreateIterator() : $(name : usesite)
                          {
                              ChangeCachedIter(LengthIterator())
                          } ]>);


      typeBuilder.Define(<[decl: public CreateLevelIterator() : $(name : usesite)
                          {
                              ChangeCachedLevelIter(LevelOrderIterator())
                          } ]>);
      def create_cases((t, e, i), a)
      {
          def e = match (e)
          {
            | <[]> => <[ case: | $(t.ParsedName : name)     => $i ]>
            | _    => <[ case: | $(t.ParsedName : name)($e) => $i ]>
          } 
          e :: a
      }

      when (!typeBuilder.GetParsedMembers().Exists(is_get_code))
      {
        def body = match (CollectTraverseOpt(typeBuilder.GetVariantOptions()))
                    {
                      | []   => <[ _N_GetVariantCode() ]>
                      | lst  => 
                          def lst = lst.MapIndex(((x, y), i) => (x, y, i));
                          def sorted = SortCases(lst, x => x[1]);
                          def cases = sorted.FoldLeft([<[ case: | _ => -1 ]>], create_cases);
                          <[ match (this)
                            {
                              ..$cases
                            }
                          ]>
                    }
        typeBuilder.Define(<[decl: public GetCode() : int { $body }]>);
      }

    }

    SortCases[T](data : list[T], expr : T -> PExpr) : list[T]
    {
      def case_sorter(x, y)
      {
        | (<[]>, <[]>)         => 0
        | (<[ $_ = $_]>, <[]>) => 1
        | (<[]>, <[ $_ = $_]>) => -1
        | _                    => 0
      }


      data.Sort((x, y) => case_sorter(expr(x), expr(y)));
    }

    CollectTraverseOpt(opts : list[TypeBuilder]) : list[TypeBuilder * PExpr]
    {
      def collect_trav_opts(t, x, a)
      {
        match (x)
        {
          | <[ Traverse($r) ]> => (t, r) :: a
          | <[ Traverse ]>     => (t, <[]>) :: a
          | _                  => a
        }
      }

      opts.FoldLeft([], (x, a) => x.GetModifiers().GetMacroAttributes().FoldLeft(a, collect_trav_opts(x, _, _))).Rev();
    }

    public DoCheckTraverse(typer : Typer, typeBuilder : TypeBuilder, _expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      //assert2(false);
      def opts = typeBuilder.GetVariantOptions();

      def get_type(t, a)
      {
        match (t)
        {
          | <[ $(x : name) ]> => x.Id :: a
          | _                 => a
        }
      }

      def map_types(t, a)
      {
        match (opts.Find(y => y.Name.EndsWith(t)))
        {
          | Some(s) => s :: a
          | _       => a
        }
      }

      def types = _expr.FoldLeft([], get_type).Rev();
      def types = types.FoldLeft([], map_types).Rev();
      def types = if (types is []) [typeBuilder] else types;


      def get_members(f, e)
      {
        def is_traversable(f, a)
        {
          def ty = f.GetMemType();

          def is_enum(t)
          {
            def type = t.GetFreshType();
            def type = <[ ttype: IEnumerable[$type] ]>;
            ty.TryUnify(type)
          }

          def is_opt(t)
          {
            def type = t.GetFreshType();
            def opt = <[ ttype: option[$type] ]>;
            ty.TryUnify(opt)
          }

          def ret = if (types.Exists(x => ty.TryRequire(x.GetFreshType()))) TreeType.Type else
                      if (types.Exists(is_enum)) TreeType.Enumerable else
                        if (types.Exists(is_opt)) TreeType.Option else TreeType.Unknown;

          if (ret == TreeType.Unknown) a else (f, ret) :: a
        }

        def fields = f.GetFields(BindingFlags.Public);
        def fields_incl = fields.Filter(x => x.attr_func(x => x.Exists(_ is <[ TraverseInclude ]>)));
        def fields = if (fields_incl is []) fields.Exclude(x => x.attr_func(x => x.Exists(_ is <[ TraverseIgnore ]>))); else fields_incl;
        (f, e, fields.FoldLeft([], is_traversable).Rev())
      }

      def to_lower(s)
      {
        def idx = s.IndexOf(char.IsUpper);
        if (idx == -1) s else 
        {
          def str = s.Substring(0, idx);
          def low = char.ToLower(s[idx]);
          def nstr = s.Substring(idx + 1);
          if (str.IsEmpty()) $"$low$(to_lower(nstr))" else $"$(str)_$low$(to_lower(nstr))"
        }
      }

      def create_iterator_data(t, e, f)
      {
        def get_name(e)
        {
          | <[ $(n : name) = $_]> => n.Id
          | _                     => t.Name
        }

        def name = get_name(e);
        def name = to_lower(name);
        (t, f, name, e)
      }

      def traverse = CollectTraverseOpt(opts);
      def traverse = if (traverse is []) opts.Map(x => (x, <[]>)) else traverse;

      def traversable = traverse.Map(get_members);
      def data = traversable.Map(create_iterator_data);

      def single = data.ElementsEqual((x, y) => x[1].Equals(y[1], ((f, t) , (f2, t2)) => f.Name == f2.Name && t == t2 ));
      def ttype = typeBuilder.GetMemType();

      def env = typer.Manager.CoreEnv.EnterIntoNamespace(typeBuilder.NamespaceNode.Parent);

      def create_params(_, _, t, n, _)
      {
        <[ parameter: $(n : usesite) : $t ]>
      }

      def make_reduce_ftype(_, t)
      {
        match (t)
        {
          | TreeType.Enumerable => <[ IEnumerable[$(ttype : typed)] ]>
          | Option              => <[ option[$(ttype : typed)] ]>
          | Type                => <[ ITraversable[$(ttype : typed)] ]>
          | Unknown             => <[ ]>
        }
      }        

      def make_reduce_type(b, f)
      {
        def ftype = f.Map(make_reduce_ftype);
        def ftype = <[ $(b.GetMemType() : typed) ]> :: ftype;
          <[ @*(..$ftype) -> $(ttype : typed) ]>
      }


      def create_assign(n : string)
      {
          <[ this.$(n : usesite) = $(n : usesite) ]>
      }

      def create_case((b, c, _, n, e), add, a)
        {
          def type = b.ParsedName;
          def acc = match (c)
          {
            | []                                       => <[ t ]> :: add
            | [(_, TreeType.Type)]                     => <[ t ]> :: <[ acc.First() ]> :: add
            | [(_, TreeType.Enumerable)]               => <[ t ]> :: <[ acc ]> :: add
            | [(_, TreeType.Type), (_, TreeType.Type)] => def acc = <[ t ]> :: <[ a ]> :: <[ b ]> :: add;
                                                          <[ def (a, b) = acc.TakeTwo(); ]> :: <[ (..$acc) ]> :: []
            | _                                        => throw InvalidOperationException("unknown pattern")
          }
          def e = match (e)
          {
            | <[]> => <[ case: | $(type : name) as t     => this.$(n : usesite)(..$acc) ]>
            | _    => <[ case: | $(type : name)($e) as t => this.$(n : usesite)(..$acc) ]>
          } 
          e :: a
        }


      def make_single_type(b, f)
      {

        def make_ftype(_, t)
        {
          match (t)
          {
            | TreeType.Enumerable => <[ IEnumerable[T] ]>
            | Option              => <[ Option[T] ]>
            | Type                => <[ T ]>
            | Unknown             => <[ ]>
          }
        }

        if (f is [])
        {
            <[ $(b.GetMemType() : typed) -> T ]>
        } else
        {
          def ftype = f.Map(make_ftype);
          def ftype = <[ $(b.GetMemType() : typed) ]> :: ftype;
            <[ @*(..$ftype) -> T ]>
        }
      }

      def create_iterator(data)
      {


////def make//_type(b, f)
        //{


        //  def make_ftype(_, t)
        //  {
        //    match (t)
        //    {
        //      | TreeType.Enumerable => <[ IEnumerable[T] ]>
        //      | Option              => <[ Option[T] ]>
        //      | Type                => <[ T ]>
        //      | Unknown             => <[ ]>
        //    }
        //  }

        //  if (f is [])
        //  {
        //    <[ $(b.GetMemType() : typed) -> T ]>
        //  } else
        //  {
        //    def ftype = f.Map(make_ftype);
        //    def ftype = <[ $(b.GetMemType() : typed) ]> :: ftype;
        //    <[ @*(..$ftype) -> T ]>
        //  }
        //}

        def name = $"$(typeBuilder.Name)IteratorContext";

        def builder = env.Define(<[decl: public class $(name : usesite)[T] : IIteratorContext[$(ttype : typed), T] {}]>);
        def data = data.Map((b, f, n, e) => (b, f, make_single_type(b, f), n, e));
        data.Iter((_, _, t, n, _) => builder.Define(<[ decl: public $(n : usesite) : $t; ]>));
        def pars = data.Map(create_params);
        def assign = data.Map(x => create_assign(x[3]));
        def npars = data.Map((_, _, _, n, _) => <[ $(n : usesite) ]>);
        builder.Define(<[ decl: public this (..$pars)
                        {
                          base(..$npars);
                          { ..$assign }
                        } ]>);

        def sorted = SortCases(data, x => x[4]);
        def cases = sorted.FoldLeft(<[case: | _ => default(T) ]> :: [], create_case(_, [], _));

        builder.Define(<[ decl: public override Visit(obj : $(ttype : typed), acc : IEnumerable[T]) : T
                        {
                          match (obj)
                          {
                            ..$cases
                          }
                        } ]>);    
        def fold = <[ parameter: this obj : $(ttype : typed) ]> :: <[ parameter: init : T ]> :: pars;
        _ = builder.DefineWithSource(<[ decl: public static Fold(..$fold) : T
                        {
                          obj.FoldDo(init, $(name : usesite)(..$npars))
                        } ]>);
        def pars_data_ = data.Map((b, f, _, n, e) => (b, f, make_reduce_type(b, f), n, e));
        def pars = pars_data_.Map(create_params);
        def fold_this = <[ parameter: this obj : $(ttype : typed) ]> :: pars;
        _ = builder.DefineWithSource(<[decl: public static Reduce(..$fold_this) : $(ttype : typed)
                        {
                          obj.ReduceDo($(name : usesite)(..$npars))
                        } ]>);


        def make_type(b)
        {
          <[ $(b.GetMemType() : typed) * T -> T ]>
        }

        def name = $"$(typeBuilder.Name)AccIteratorContext";
        def data = data.Map((b, f, _, n, e) => (b, f, make_type(b), n, e));
        def pars = data.Map(create_params);
        def fold = <[ parameter: this obj : $(ttype : typed) ]> :: <[ parameter: init : T ]> :: pars;
        _ = builder.DefineWithSource(<[ decl: public static Fold(..$fold) : T
                        {
                          obj.FoldDo(init, $(name : usesite)(..$npars))
                        } ]>);

        def make_reduce_type(b, f)
        {
          def ftype = f.FoldLeft([<[ T ]>], (x, a) => make_reduce_ftype(x) :: a);
          def type  = b.GetMemType();
          def ftype = <[ $(type : typed) ]> :: ftype;
          <[ @*(..$ftype) -> $(ttype : typed) * T ]>
        }

        def name = $"$(typeBuilder.Name)ReduceAccIteratorContext";                
        def data = data.Map((b, f, _, n, e) => (b, f, make_reduce_type(b, f), n, e));
        def pars = data.Map(create_params);
        def fold_this = <[ parameter: this obj : $(ttype : typed) ]> :: <[ parameter: init : T ]> :: pars;
        _ = builder.DefineWithSource(<[decl: public static Reduce(..$fold_this) : $(ttype : typed) * T
                        {
                          obj.ReduceDo(init, $(name : usesite)(..$npars))
                        } ]>);


        when (single)
        {
          def data = data.First();
          def (_, f, _, n, e) = data;
          def b = typeBuilder;
          //def t = make_single_type(b, f);
          def (_, f, _, _, e) as data = (b, f, make_single_type(b, f), n, e);
          def n = to_lower(typeBuilder.Name);
          def name = $"$(typeBuilder.Name)SingleIteratorContext";
          def pars = create_params(data) :: [];
          def fold = <[ parameter: this obj : $(ttype : typed) ]> :: <[parameter: init : T ]> :: pars;
          _ = builder.DefineWithSource(<[ decl: public static Fold(..$fold) : T
                          {
                            obj.FoldDo(init, $(name : usesite)(..$npars))
                          } ]>);
          def fold_this = <[ parameter: this obj : $(ttype : typed) ]> :: pars;
          _ = builder.DefineWithSource(<[decl: public static Reduce(..$fold_this) : $(ttype : typed)
                          {
                            obj.ReduceDo($(name : usesite)(..$npars))
                          } ]>);

          def pars_data = (b, f, make_reduce_type(b, f), n, e);
          def pars = create_params(pars_data);
          def fold_this = <[ parameter: this obj : $(ttype : typed) ]> :: <[ parameter: init : T ]> :: pars :: [];
          _ = builder.DefineWithSource(<[decl: public static Reduce(..$fold_this) : $(ttype : typed) * T
                          {
                            obj.ReduceDo(init, $(name : usesite)(..$npars))
                          } ]>);

                          
        }               
        //def fold = <[ parameter: this obj : $(ttype : typed) ]> :: <[parameter: init : T]> :: pars;
        //_ = builder.DefineWithSource(<[ decl: public static Fold(..$fold) : T
        //                {
        //                  obj.FoldDo(init, $(name : usesite)(..$npars))
        //                } ]>);

        builder.Compile();

      }

      def create_acc_iterator(data)
      {
        //def make_type(b)
        //{
        //  <[ $(b.GetMemType() : typed) * T -> T ]>
        //}

        def create_case((b, _, _, n, e), a)
        {
          def type = b.ParsedName;
          def e = match (e)
          {
            | <[]> => <[ case: | $(type : name) as t     => this.$(n : usesite)(t, acc) ]>
            | _    => <[ case: | $(type : name)($e) as t => this.$(n : usesite)(t, acc) ]>
          } 
          e :: a
        }

        def name = $"$(typeBuilder.Name)AccIteratorContext";

        def builder = env.Define(<[decl: public class $(name : usesite)[T] : IAccIteratorContext[$(ttype : typed), T] {}]>);

        def make_type(b)
        {
          <[ $(b.GetMemType() : typed) * T -> T ]>
        }

        def data = data.Map((b, f, n, e) => (b, f, make_type(b), n, e));
        foreach ((_, _, t, n, _) in data)
        {
          builder.Define(<[ decl: public $(n : usesite) : $t; ]>);
        }
        def pars = data.Map(create_params);
        def assign = data.Map(x => create_assign(x[3]));
        def npars = data.Map((_, _, _, n, _) => <[ $(n : usesite) ]>);
        builder.Define(<[decl: public this (..$pars)
                        {
                          base(..$npars);
                          { ..$assign }
                        } ]>);

        def sorted = SortCases(data, x => x[4]);
        def cases = sorted.FoldLeft(<[case: | _ => acc ]> :: [], create_case);

        builder.Define(<[decl: public override Visit(obj : $(ttype : typed), acc : T) : T
                        {
                          match (obj)
                          {
                            ..$cases
                          }
                        } ]>);    
        builder.Compile();
      }

      def create_reduce_iterator(data)
      {

        def make_reduce_type(b, f)
        {
          def ftype = f.FoldLeft([<[ T ]>], (x, a) => make_reduce_ftype(x) :: a);
          def ftype = <[ $(b.GetMemType() : typed) ]> :: ftype;
          <[ @*(..$ftype) -> $(ttype : typed) * T ]>
        }

        def name = $"$(typeBuilder.Name)ReduceAccIteratorContext";

        def builder = env.Define(<[decl: public class $(name : usesite)[T] : IReduceAccIteratorContext[$(ttype : typed), T] {}]>);
        def data = data.Map((b, f, n, e) => (b, f, make_reduce_type(b, f), n, e));
        foreach (d in data)
        {
          def n = d[3];
          def t = d[2];
          //def (b : TypeBuilder, _ : list[_], t : PExpr.Call, n : string, e : PExpr) = d;
          _ = builder.DefineWithSource(<[ decl: public $(n : usesite) : $t; ]>);
        }
        def pars = data.Map(create_params);
        def assign = data.Map(x => create_assign(x[3]));
        def npars = data.Map((_, _, _, n, _) => <[ $(n : usesite) ]>);
        builder.Define(<[decl: public this (..$pars)
                        {
                          base(..$npars);
                          { ..$assign }
                        } ]>);

        def sorted = SortCases(data, x => x[4]);
        def cases = sorted.FoldLeft(<[case: | _ => (null, acc2) ]> :: [], create_case(_, [<[ acc2 ]>], _));

        _ = builder.DefineWithSource(<[decl: public override Visit(obj : $(ttype : typed), acc : IEnumerable[$(ttype : typed)], acc2 : T) : $(ttype : typed) * T
                        {
                          match (obj)
                          {
                            ..$cases
                          }
                        } ]>);
        builder.Compile();
      }

      def create_single_iterator(data)
      {

        def name = $"$(typeBuilder.Name)SingleIteratorContext";

        def builder = env.Define(<[decl: public class $(name : usesite)[T] : ISingleIteratorContext[$(ttype : typed), T] {}]>);
        def data = data.First();
        def (_, f, _, e) = data;
        def b = typeBuilder;
        def n = to_lower(typeBuilder.Name);
        def (_, _, t, n, _) as data = (b, f, make_single_type(b, f), n, e);

        builder.Define(<[ decl: public $(n : usesite) : $t; ]>);
        def pars = create_params(data) :: [];
        def assign = create_assign(data[3]);
        def npars = <[ $(n : usesite) ]> :: [];
        builder.Define(<[ decl: public this (..$pars)
                        {
                          base(..$npars);
                          $assign;
                        } ]>);

        def cases = create_case(data, [], <[case: | _ => default(T) ]> :: []);

        builder.Define(<[ decl: public override Visit(obj : $(ttype : typed), acc : IEnumerable[T]) : T
                        {
                          match (obj)
                          {
                            ..$cases
                          }
                        } ]>);    


        builder.Compile();

      }

      create_iterator(data);
      create_acc_iterator(data);
      create_reduce_iterator(data);
      when (single) 
        create_single_iterator(data);
      //traversable
    }

  }
}
