using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{

  partial module TraversableImpl
  {


    public DoCheckTraverse(typer : Typer, typeBuilder : TypeBuilder, expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      assert2(false);
      def opts = typeBuilder.GetVariantOptions();
      def name = typeBuilder.Name;

      def get_type(t, a)
      {
        match (t)
        {
          | <[ All ]>         => a
          | <[ $(x : name) ]> => x.Id :: a
          | _                 => a
        }
      }

      def map_types(t, a)
      {
        match (opts.Find(y => y.Name.EndsWith(t)))
        {
          | Some(s) => s :: a
          | _       => a
        }
      }

      def ttype = typeBuilder.GetFreshType();
      def types = expr.FoldBack([], get_type);
      def types = types.FoldBack([], map_types);
      def is_all = expr is [<[ All ]>];
      def types = if (types is []) [typeBuilder] else types;


      def get_members(f, e)
      {
        def is_traversable(f, a)
        {

          def is_that_type(ty, tt, type, cont)
          {
            if (cont.TryRequire(ty))
            {
                tt.TryRequire(type)
            } else false
            
          }
          
          def is_enum(ty, tt, t)
          {
            def type = t.GetFreshType();
            def cont = <[ ttype: IEnumerable[_] ]>;
            is_that_type(ty, tt, type, cont)
          }

          def is_opt(ty, tt, t)
          {
            def type = t.GetFreshType();
            def cont = <[ ttype: option[_] ]>;
            is_that_type(ty, tt, type, cont)
          }

          match (f.GetMemType())
          {
            | FixedType.Class(_, [t]) as ty => def ret = if (types.Exists(is_enum(ty, t, _))) TreeType.Enumerable else
                                               if (types.Exists(is_opt(ty, t, _))) TreeType.Option else TreeType.Unknown;
                                               if (ret == TreeType.Unknown) a else (f, ret) :: a
            | FixedType.Class as ty         => if (types.Exists(x => ty.TryRequire(x.GetFreshType()))) (f, TreeType.Type) :: a else a
            | _                             => a
          }

        }

        def fields = f.GetFields(BindingFlags.Public | BindingFlags.Instance);
        def fields_incl = fields.Filter(x => x.attr_func(x => x.Exists(_ is <[ TraverseInclude ]>)));
        def fields = if (fields_incl is []) fields.Exclude(x => x.attr_func(x => x.Exists(_ is <[ TraverseIgnore ]>))); else fields_incl;
        (f, e, fields.FoldBack([], is_traversable))
      }

      def to_lower(s)
      {
        def idx = s.IndexOf(char.IsUpper);
        if (idx == -1) s else 
        {
          def str = s.Substring(0, idx);
          def low = char.ToLower(s[idx]);
          def nstr = s.Substring(idx + 1);
          if (str.IsEmpty()) $"$low$(to_lower(nstr))" else $"$(str)_$low$(to_lower(nstr))"
        }
      }

      def create_iterator_data(t, e, f)
      {
        def get_name(e)
        {
          | <[ $(n : name) = $_]> 
          | <[ $(n : name)($_)]>   => n.Id
          | _                     => t.Name
        }

        def name = get_name(e);
        def name = to_lower(name);
        (t, f, name, e)
      }

      
      def traverse = CollectTraverseOpt(opts, is_all);
      def traverse = if (traverse is []) opts.RevMap(x => (x, <[ ]>)) else traverse;

      def traversable = traverse.Map(get_members);
      def data = traversable.Map(create_iterator_data);
      

      def env = typer.Manager.CoreEnv.EnterIntoNamespace(typeBuilder.NamespaceNode.Parent);

      def create_iter(data, name, tp, ntp, create_type, it_type, run_body_func, vis_types, ret_type, fold, reduce, reduce_create, red_par)
      {
        def ntp = <[ $(ttype : typed) ]> :: ntp;
        def builder = env.Define(<[decl: public class $(name : usesite)[..$tp] : $it_type[..$ntp] {}]>);

        def create_param(f)
        {
          f.Map((t, n) => <[ parameter: $(n : usesite) : $t ]>)
        }

        def fld_data = data.Map((b, f, n, _) => (create_type(b, f), n));
        fld_data.Iter((t, n) => _ = builder.DefineWithSource(<[ decl: public $(n : usesite) : $t; ]>));
        def pars = create_param(fld_data);
        def assign = fld_data.Map((_, n) => <[ this.$(n : usesite) = $(n : usesite) ]>);
        def npars = fld_data.Map((_, n) => <[ $(n : usesite) ]>);
        _ = builder.DefineWithSource(<[ decl: public this (..$pars)
                        {
                          base(..$npars);
                          { ..$assign }
                        } ]>);

        def run_body = run_body_func(data); 
        def param = <[ parameter: obj : $(ttype : typed) ]> :: vis_types;
        _ = builder.DefineWithSource(<[ decl: public override Visit(..$param) : $ret_type
                        {
                          $run_body
                        } ]>);
        when (fold)
        {
          def fold = <[ parameter: this obj : $(ttype : typed) ]> :: <[ parameter: init : T ]> :: pars;
          _ = builder.DefineWithSource(<[ decl: public static Fold(..$fold) : $ret_type
                          {
                            obj.FoldDo(init, $(name : usesite)(..$npars))
                          } ]>);
        }
        when (reduce != null)
        {
          def fld_data = data.Map((b, f, n, _) => (reduce_create(b, f), n));
          def pars = create_param(fld_data);
          def (rpar, rpare) = red_par.Split();
          def pars = pars.HeadAppend(rpar);
          def npars = <[ $(name : usesite)(..$npars) ]> :: [];
          def npars = npars.HeadAppend(rpare);
          def pars = <[ parameter: this obj : $(ttype : typed) ]> :: pars;
          _ = builder.DefineWithSource(<[decl: public static Reduce(..$pars) : $reduce
                          {
                            obj.ReduceDo(..$npars)
                          } ]>);
        }
        builder.Compile();
      }

      def create_case((b, c, n, e), add, a, create_case)
        {
          def acc = create_case(c, add);
          def type = b.ParsedName;
          def expr = match (c)
                      {
                        | [(f, TreeType.Option)] 
                        | [(_, TreeType.Type), (f, TreeType.Option)] 
                        | [(f, TreeType.Option), (_, TreeType.Type)] => <[ $(f.Name : usesite) = n ]>;
                        | _                                          => e
                      }
          def e = match (e, expr)
          {
            | (<[]>, <[]>) => <[ case: | $(type : name) as obj     => this.$(n : usesite)(..$acc) ]>
            | (_, <[ $_ = $_ ]> as ex)
            | (_, <[ $_($ex) ]>)       => <[ case: | $(type : name)($ex) as obj => this.$(n : usesite)(..$acc) ]>
            | (_, _)                   => throw InvalidOperationException("invalid pattern")
          }
          e :: a
        }

      def run_body_func(data, default, add, create_case_par)
      {
        def sorted = SortCases(data, x => x[3]);
        def cases = sorted.FoldLeft([default], create_case(_, add, _, create_case_par));
        <[ match (obj)
          {
            ..$cases
          }
        ]>
      }

      def make_type(b : TypeBuilder, f, type, end, ret)
      {

        def make_ftype(_, t)
        {
          match (t)
          {
            | TreeType.Enumerable => <[ IEnumerable[$type] ]>
            | Option              => <[ option[$type] ]>
            | Type                => <[ $type ]>
            | Unknown             => <[ ]>
          }
        }

        def ftype = f.FoldBack(end, (x, a) => make_ftype(x) :: a);
        def ftype = <[ $(b.GetMemType() : typed) ]> :: ftype;
        <[ @*(..$ftype) -> $ret ]>
      }

      def create_case_param(c, add)
      {
        match (c)
        {
          | []                                       => <[ obj ]> :: add
          | [(_, TreeType.Type)]                     => <[ obj ]> :: <[ acc.First() ]> :: add
          | [(_, TreeType.Option)]                   => def acc1 = <[ obj ]> :: <[ Some(a) ]> :: add;
                                                        def acc2 = <[ obj ]> :: <[ None() ]> :: add;
                                                        <[
                                                            match (n)
                                                            {
                                                              | Some(n) => def a = acc.First();
                                                                           (..$acc1)
                                                              | _       => (..$acc2)
                                                            }
                                                        ]> :: []
          | [(_, TreeType.Enumerable)]               => <[ obj ]> :: <[ acc ]> :: add
          | [(_, TreeType.Type), (_, TreeType.Type)] => def acc = <[ obj ]> :: <[ a ]> :: <[ b ]> :: add;
                                                        <[ def (a, b) = acc.TakeTwo();
                                                           (..$acc) ]> :: []
          | [(_, TreeType.Option), (_, TreeType.Type)] => def acc1 = <[ obj ]> :: <[ Some(a) ]> :: <[ b ]> :: add;
                                                          def acc2 = <[ obj ]> :: <[ None() ]> :: <[ b ]> :: add;
                                                          <[
                                                            match (n)
                                                            {
                                                              | Some(n) => def (a, b) = acc.TakeTwo();
                                                                           (..$acc1)
                                                              | _       => def b = acc.First();
                                                                           (..$acc2)
                                                            }
                                                          ]> :: []
          | [(_, TreeType.Type), (_, TreeType.Option)] => def acc1 = <[ obj ]> :: <[ a ]> :: <[ Some(b) ]> :: add;
                                                          def acc2 = <[ obj ]> :: <[ a ]> :: <[ None() ]> :: add;
                                                          <[
                                                            match (n)
                                                            {
                                                              | Some(n) => def (a, b) = acc.TakeTwo();
                                                                           (..$acc1)
                                                              | _       => def a = acc.First();
                                                                           (..$acc2)
                                                            }
                                                          ]> :: []
          | _                                          => throw InvalidOperationException("unknown pattern")
        }
      }

      def create_acc_case_param(_, _) { [<[ obj ]>, <[ acc ]>] }

      def make_reduce_type(b, f)
      {
        make_type(b, f, <[ $(ttype : typed) ]>, [], <[ $(ttype : typed) ]>)
      }

      def make_reduce_type2(b, f)
      {
        make_type(b, f, <[ $(ttype : typed) ]>, [<[ TAcc ]>], <[ $(ttype : typed) * TAcc ]>)
      }

      def run_body_func_single(data, add, create_case_par)
      {
        def (_, c, n, _) = data.Head;
        def acc = create_case_par(c, add);
        <[ this.$(n : usesite)(..$acc) ]>
      }

      create_iter(data, $"$(name)IteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>], 
                  make_type(_, _, <[ T ]>, [], <[ T ]>), 
                  <[ IIteratorContext ]>, 
                  run_body_func(_, <[case: | _ => default(T) ]>, [], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: [], 
                  <[ T ]>, 
                  true,
                  <[ $(ttype : typed) ]>,
                  make_reduce_type,
                  []);

      create_iter(data, $"$(name)AccIteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>], 
                  (b, _) => make_type(b, [], <[ ]>, [<[ T ]>], <[ T ]>), 
                  <[ IAccIteratorContext ]>, 
                  run_body_func(_, <[case: | _ => acc ]>, [], create_acc_case_param), 
                  <[ parameter: acc : T ]> :: [], 
                  <[ T ]>, 
                  true,
                  null, 
                  null,
                  null);

      create_iter(data, $"$(name)TwoAccIteratorContext", 
                  [Splicable.Name(<[ T ]>), Splicable.Name(<[ TAcc ]>)], 
                  [<[ T ]>, <[ TAcc ]>], 
                  make_type(_, _, <[ T ]>, [<[ TAcc ]>], <[ T * TAcc ]>), 
                  <[ ITwoAccIteratorContext ]>, 
                  run_body_func(_, <[case: | _ => (default(T), acc2) ]>, [<[ acc2 ]>], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: <[ parameter: acc2 : TAcc ]> :: [], 
                  <[ T * TAcc ]>, 
                  false,
                  <[ $(ttype : typed) * TAcc ]>,
                  make_reduce_type2,
                  [(<[parameter: init : TAcc; ]>, <[ init ]>)]);

      def compare_types(x, y)
      {
        x :> int - y :> int
      }

      def flds = data.FoldLeft([], (x, a) => a.HeadAppend(x[1]));
      def dups = flds.Group((x, y) => x[0].Name.CompareTo(y[0].Name) + compare_types(x[1], y[1]));
      def f = dups.MapFiltered(x => x.Length == data.Length, _.Head);
      def f = if (f is []) [(null, TreeType.Enumerable)] else f;
      def data = (typeBuilder, f, to_lower(name), <[]>);


      create_iter([data], 
                  $"$(name)SingleIteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>], 
                  make_type(_, _, <[ T ]>, [], <[ T ]>), 
                  <[ IIteratorContext ]>,
                  run_body_func_single(_, [], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: [], 
                  <[ T ]>, 
                  true,
                  <[ $(ttype : typed) ]>,
                  make_reduce_type,
                  []);

      create_iter([data], $"$(name)TwoAccSingleIteratorContext", 
                  [Splicable.Name(<[ T ]>), Splicable.Name(<[ TAcc ]>)], 
                  [<[ T ]>, <[ TAcc ]>], 
                  make_type(_, _, <[ T ]>, [<[ TAcc ]>], <[ T * TAcc ]>), 
                  <[ ITwoAccIteratorContext ]>, 
                  run_body_func_single(_, [<[ acc2 ]>], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: <[ parameter: acc2 : TAcc ]> :: [], 
                  <[ T * TAcc ]>, 
                  false,
                  <[ $(ttype : typed) * TAcc ]>,
                  make_reduce_type2,
                  [(<[parameter: init : TAcc; ]>, <[ init ]>)]);

    }

  }
}
