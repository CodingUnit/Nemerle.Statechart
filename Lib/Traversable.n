using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{

  partial module TraversableImpl
  {


    public DoCheckTraverse(typer : Typer, typeBuilder : TypeBuilder, _expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      //assert2(false);
      def opts = typeBuilder.GetVariantOptions();
      def name = typeBuilder.Name;
      
      def get_type(t, a)
      {
        match (t)
        {
          | <[ $(x : name) ]> => x.Id :: a
          | _                 => a
        }
      }

      def map_types(t, a)
      {
        match (opts.Find(y => y.Name.EndsWith(t)))
        {
          | Some(s) => s :: a
          | _       => a
        }
      }

      def types = _expr.FoldBack([], get_type);
      def types = types.FoldBack([], map_types);
      def types = if (types is []) [typeBuilder] else types;


      def get_members(f, e)
      {
        def is_traversable(f, a)
        {
          def ty = f.GetMemType();

          def is_enum(t)
          {
            def type = t.GetFreshType();
            def type = <[ ttype: IEnumerable[$type] ]>;
            ty.TryUnify(type)
          }

          def is_opt(t)
          {
            def type = t.GetFreshType();
            def opt = <[ ttype: option[$type] ]>;
            ty.TryUnify(opt)
          }

          def ret = if (types.Exists(x => ty.TryRequire(x.GetFreshType()))) TreeType.Type else
                      if (types.Exists(is_enum)) TreeType.Enumerable else
                        if (types.Exists(is_opt)) TreeType.Option else TreeType.Unknown;

          if (ret == TreeType.Unknown) a else (f, ret) :: a
        }

        def fields = f.GetFields(BindingFlags.Public | BindingFlags.Instance);
        def fields_incl = fields.Filter(x => x.attr_func(x => x.Exists(_ is <[ TraverseInclude ]>)));
        def fields = if (fields_incl is []) fields.Exclude(x => x.attr_func(x => x.Exists(_ is <[ TraverseIgnore ]>))); else fields_incl;
        (f, e, fields.FoldBack([], is_traversable))
      }

      def to_lower(s)
      {
        def idx = s.IndexOf(char.IsUpper);
        if (idx == -1) s else 
        {
          def str = s.Substring(0, idx);
          def low = char.ToLower(s[idx]);
          def nstr = s.Substring(idx + 1);
          if (str.IsEmpty()) $"$low$(to_lower(nstr))" else $"$(str)_$low$(to_lower(nstr))"
        }
      }

      def create_iterator_data(t, e, f)
      {
        def get_name(e)
        {
          | <[ $(n : name) = $_]> => n.Id
          | _                     => t.Name
        }

        def name = get_name(e);
        def name = to_lower(name);
        (t, f, name, e)
      }

      def traverse = CollectTraverseOpt(opts);
      def traverse = if (traverse is []) opts.MapRev(x => (x, <[]>)) else traverse;

      def traversable = traverse.Map(get_members);
      def data = traversable.Map(create_iterator_data);

      def ttype = typeBuilder.GetMemType();

      def env = typer.Manager.CoreEnv.EnterIntoNamespace(typeBuilder.NamespaceNode.Parent);

      def create_iter(data, name, tp, ntp, create_type, it_type, run_body_func, vis_types, ret_type, fold : bool, reduce, reduce_create, red_par)
      {
        def ntp = <[ $(ttype : typed) ]> :: ntp;
        def builder = env.Define(<[decl: public class $(name : usesite)[..$tp] : $it_type[..$ntp] {}]>);

        def create_param(f)
        {
          f.Map((t, n) => <[ parameter: $(n : usesite) : $t ]>)
        }
        
        def fld_data = data.Map((b, f, n, _) => (create_type(b, f), n));
        fld_data.Iter((t, n) => builder.Define(<[ decl: public $(n : usesite) : $t; ]>));
        def pars = create_param(fld_data);
        def assign = fld_data.Map((_, n) => <[ this.$(n : usesite) = $(n : usesite) ]>);
        def npars = fld_data.Map((_, n) => <[ $(n : usesite) ]>);
        builder.Define(<[ decl: public this (..$pars)
                        {
                          base(..$npars);
                          { ..$assign }
                        } ]>);

        def run_body = run_body_func(data); 
        def param = <[ parameter: obj : $(ttype : typed) ]> :: vis_types;
        _ = builder.DefineWithSource(<[ decl: public override Visit(..$param) : $ret_type
                        {
                          $run_body
                        } ]>);
        when (fold)
        {
          def fold = <[ parameter: this obj : $(ttype : typed) ]> :: <[ parameter: init : T ]> :: pars;
          _ = builder.DefineWithSource(<[ decl: public static Fold(..$fold) : $ret_type
                          {
                            obj.FoldDo(init, $(name : usesite)(..$npars))
                          } ]>);
        }
        when (reduce != null)
        {
          def fld_data = data.Map((b, f, n, _) => (reduce_create(b, f), n));                
          def pars = create_param(fld_data);
          def (rpar, rpare) = red_par.Split();
          def pars = pars.HeadAppend(rpar);
          def npars = <[ $(name : usesite)(..$npars) ]> :: [];
          def npars = npars.HeadAppend(rpare);
          def pars = <[ parameter: this obj : $(ttype : typed) ]> :: pars;
          _ = builder.DefineWithSource(<[decl: public static Reduce(..$pars) : $reduce
                          {
                            obj.ReduceDo(..$npars)
                          } ]>);
        }
        builder.Compile();
      }
      
      //create_iterator(data);
      //create_acc_iterator(data);
      //create_reduce_iterator(data);
      //create_single_iterator(data);
  
      def create_case((b, c, n, e), add, a, create_case)
        {
          def acc = create_case(c, add);
          def type = b.ParsedName;
          def e = match (e)
          {
            | <[]> => <[ case: | $(type : name) as obj     => this.$(n : usesite)(..$acc) ]>
            | _    => <[ case: | $(type : name)($e) as obj => this.$(n : usesite)(..$acc) ]>
          } 
          e :: a
        }

      //    {
      //      | <[]> => <[ case: | $(type : name) as t     => this.$(n : usesite)(t, acc) ]>
      //      | _    => <[ case: | $(type : name)($e) as t => this.$(n : usesite)(t, acc) ]>
      //    } 
      def run_body_func(data, default, add, create_case_par)
      {
        def sorted = SortCases(data, x => x[3]);
        def cases = sorted.FoldLeft([default], create_case(_, add, _, create_case_par));
        <[ match (obj)
           {
             ..$cases
           }
        ]>
      }

      def make_type(b : TypeBuilder, f, type, end, ret)
      {

        def make_ftype(_, t)
        {
          match (t)
          {
            | TreeType.Enumerable => <[ IEnumerable[$type] ]>
            | Option              => <[ Option[$type] ]>
            | Type                => <[ $type ]>
            | Unknown             => <[ ]>
          }
        }

        def ftype = f.FoldBack(end, (x, a) => make_ftype(x) :: a);
        def ftype = <[ $(b.GetMemType() : typed) ]> :: ftype;
        <[ @*(..$ftype) -> $ret ]>
      }
      
      def create_case_param(c, add)
      {
        match (c)
        {
          | []                                       => <[ obj ]> :: add
          | [(_, TreeType.Type)]                     => <[ obj ]> :: <[ acc.First() ]> :: add
          | [(_, TreeType.Enumerable)]               => <[ obj ]> :: <[ acc ]> :: add
          | [(_, TreeType.Type), (_, TreeType.Type)] => def acc = <[ obj ]> :: <[ a ]> :: <[ b ]> :: add;
                                                        <[ def (a, b) = acc.TakeTwo(); ]> :: <[ (..$acc) ]> :: []
          | _                                        => throw InvalidOperationException("unknown pattern")
        }
      }

      def create_acc_case_param(_, _) { [<[ obj ]>, <[ acc ]>] }

      def make_reduce_type(b, f)
      {
        make_type(b, f, <[ $(ttype : typed) ]>, [], <[ $(ttype : typed) ]>)
      }
      
      def make_reduce_type2(b, f)
      {
        make_type(b, f, <[ $(ttype : typed) ]>, [<[ TAcc ]>], <[ $(ttype : typed) * TAcc ]>)
      }
      
      def run_body_func_single(data, add, create_case_par)
      {
        def (_, c, n, _) = data.Head;
        //def n = data[0].
        def acc = create_case_par(c, add);
        <[ this.$(n : usesite)(..$acc) ]>
      }
      
      create_iter(data, $"$(name)IteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>], 
                  make_type(_, _, <[ T ]>, [], <[ T ]>), 
                  <[ IIteratorContext ]>, 
                  run_body_func(_, <[case: | _ => default(T) ]>, [], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: [], 
                  <[ T ]>, 
                  true,
                  <[ $(ttype : typed) ]>,
                  make_reduce_type,
                  []);
      
      //def make_type(b, _) { <[ $(b.GetMemType() : typed) * T -> T ]> }
        
      create_iter(data, $"$(name)AccIteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>], 
                  (b, _) => make_type(b, [], <[ ]>, [<[ T ]>], <[ T ]>), 
                  <[ IAccIteratorContext ]>, 
                  run_body_func(_, <[case: | _ => acc ]>, [], create_acc_case_param), 
                  <[ parameter: acc : T ]> :: [], 
                  <[ T ]>, 
                  true,
                  null, 
                  null,
                  null);
                  
      create_iter(data, $"$(name)TwoAccIteratorContext", 
                  [Splicable.Name(<[ T ]>), Splicable.Name(<[ TAcc ]>)], 
                  [<[ T ]>, <[ TAcc ]>], 
                  make_type(_, _, <[ T ]>, [<[ TAcc ]>], <[ T * TAcc ]>), 
                  <[ ITwoAccIteratorContext ]>, 
                  run_body_func(_, <[case: | _ => (default(T), acc2) ]>, [<[ acc2 ]>], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: <[ parameter: acc2 : TAcc ]> :: [], 
                  <[ T * TAcc ]>, 
                  false,
                  <[ $(ttype : typed) * TAcc ]>,
                  make_reduce_type2,
                  [(<[parameter: init : TAcc; ]>, <[ init ]>)]);

        def compare_types(x, y)
        {
          x :> int - y :> int
        }
                  
        def flds = data.FoldLeft([], (x, a) => a.HeadAppend(x[1]));
        def dups = flds.Group((x, y) => x[0].Name.CompareTo(y[0].Name) + compare_types(x[1], y[1]));
        def f = dups.MapFiltered(x => x.Length == data.Length, _.Head);
        def f = if (f is []) [(null, TreeType.Enumerable)] else f;
        def data = (typeBuilder, f, to_lower(name), <[]>);
      
                  
      create_iter([data], 
                  $"$(name)SingleIteratorContext", 
                  [Splicable.Name(<[ T ]>)], 
                  [<[ T ]>], 
                  make_type(_, _, <[ T ]>, [], <[ T ]>), 
                  <[ IIteratorContext ]>,
                  run_body_func_single(_, [], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: [], 
                  <[ T ]>, 
                  true,
                  <[ $(ttype : typed) ]>,
                  make_reduce_type,
                  []);
                  
      create_iter([data], $"$(name)TwoAccSingleIteratorContext", 
                  [Splicable.Name(<[ T ]>), Splicable.Name(<[ TAcc ]>)], 
                  [<[ T ]>, <[ TAcc ]>], 
                  make_type(_, _, <[ T ]>, [<[ TAcc ]>], <[ T * TAcc ]>), 
                  <[ ITwoAccIteratorContext ]>, 
                  run_body_func_single(_, [<[ acc2 ]>], create_case_param), 
                  <[ parameter: acc : IEnumerable[T] ]> :: <[ parameter: acc2 : TAcc ]> :: [], 
                  <[ T * TAcc ]>, 
                  false,
                  <[ $(ttype : typed) * TAcc ]>,
                  make_reduce_type2,
                  [(<[parameter: init : TAcc; ]>, <[ init ]>)]);
                  
    }

  }
}
