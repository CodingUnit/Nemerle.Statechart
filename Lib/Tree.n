using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using ListUtils;
  
  public enum TreeTraversalType
  {
    | PreOrder
    | PostOrder
    | BreadthFirst
  }

    [Record]
    public class TreePostOrderEnumerable[T] : IEnumerable[T]
    {
      tree : T;            
      child_func : T -> IEnumerable[T];
      
      public GetEnumerator() : System.Collections.Generic.IEnumerator[T] { TreePostOrderEnumerator(tree, child_func) }
        
      public static Test() : bool
      {
        def map = Hashtable();
        map['a'] = ['b', 'c', 'j'];
        map['b'] = ['d', 'e'];
        map['h'] = ['i'];
        map['f'] = ['h', 'g'];
        map['c'] = ['f'];
        map['j'] = ['k'];
        
        
        def it = TreePostOrderEnumerable('a', x => if (map.ContainsKey(x)) map[x] else Enumerable.Empty());
        def res = it.NToList();
        ListUtils.EqualsValue(res, ['d', 'e', 'b', 'i', 'h', 'g', 'f', 'c', 'k', 'j', 'a']);
      }
    }

    enum PostOrderState 
    {
      | TraverseStart
      | Current
      | End
    } 
    
    class TreePostOrderEnumerator[T] : IEnumerator[T]
    {
      tree : T;            
      child_func : T -> IEnumerable[T];
      
      mutable current : Node;
      mutable state : PostOrderState;
      
      
      public this(tree : T, func : T -> IEnumerable[T])
      {
        this.tree = tree;
        child_func = func;
        state = PostOrderState.TraverseStart;
      }
      
      Top : Node
      {
        [Memoize]
        get
        {
          Node(tree, Enumerable.Empty().GetEnumerator(), null, child_func)
        }
      }
      
      [Record]
      class Node
      {
        public Elem : T; // element
        public Iter : IEnumerator[T]; // neighbours iterator
        public Up   : Node; // parent
        child_func : T -> IEnumerable[T]; // func for get childs of this node
        
        public Child : Node
        {
          [Memoize] // memoize result for future to not recalc
          get
          {
            def childs = child_func(Elem).GetEnumerator();
            if (childs.MoveNext()) // if move next have childs
            {
              Node(childs.Current, childs, this, child_func) // create node with it as parent and its neighbours
            } else
            {
              null // return null
            }
          }
        }
        
        public Neighbour : Node
        {
          [Memoize]
          get
          {
            if (Iter.MoveNext()) // get next elem from iterator
            {
              Node(Iter.Current, Iter, Up, child_func) // create neigbour node with current, iterator and parent
            } else null // else return null
          }
        }
      }
      
     
      
      public Dispose() : void{  }
      
      public MoveNext() : bool
      { 
        def traverse_below(cur)
        {
          if (cur.Child != null)
            traverse_below(cur.Child) 
          else cur;
        }
            
        match (state)
        {
          | TraverseStart => current = traverse_below(Top);
                             state = PostOrderState.Current;
                             true
          | Current       => match (current.Neighbour)
                             {
                               | null => match (current.Up)
                                         {
                                           | null => state = PostOrderState.End;
                                                     false
                                           | node => current = node;
                                                     true
                                         }
                               | node => current = traverse_below(node);
                                         true
                             }
          | End           => false
             
        }
        /*
        traverse_start: have_childs       => traverse_start(childs[0])
        traverse_start: else, cur         => current
        current: have_neighbour           => traverse_start(cur.next)
        current: have_upper, cur.up       => current(cur.up)
        current: else                     => end
        */
      }
      
      
      
      public Reset() : void{ state = PostOrderState.TraverseStart }
      
      public Current : T { get{ current.Elem } }
      
    }
    
  public interface IGeneralTree[T]
  {
    Current : T {get;}
    ChildNodes : IEnumerable[IGeneralTree[T]] {get;}
  }
  /// <summary>
  /// Description of Tree.
  /// </summary>
  public module TreeUtils
  {
    
    public GetPreOrderEnumerable[T](this tree : IGeneralTree[T]) : IEnumerable[T]
    {
      GetPreOrderEnumerable(tree, _.ChildNodes).Select(x => x.Current)
    }
    
    public GetPostOrderEnumerable[T](this tree : IGeneralTree[T]) : IEnumerable[T]
    {
      GetPostOrderEnumerable(tree, _.ChildNodes).Select(x => x.Current)
    }

    public GetPostOrderIter[T](this tree : IGeneralTree[T]) : IEnumerable[IGeneralTree[T]]
    {
      GetPostOrderEnumerable(tree, _.ChildNodes)
    }
    
    public  GetBreadthFirstEnumerable[T](this tree : IGeneralTree[T]) : IEnumerable[T]
    {
      GetBreadthFirstEnumerable(tree, _.ChildNodes).Select(x => x.Current)
    }
    
    public GetEnumerable[T](tree : T, childs : T -> IEnumerable[T], TraversalType : TreeTraversalType) : IEnumerable[T]
    {
      match (TraversalType)
      {
        | TreeTraversalType.PreOrder     => GetPreOrderEnumerable(tree, childs)
        | TreeTraversalType.BreadthFirst => GetBreadthFirstEnumerable(tree, childs)
        | TreeTraversalType.PostOrder    => GetPostOrderEnumerable(tree, childs)
      }
    }

    public GetPreOrderEnumerable[T](tree : T, childs : T -> IEnumerable[T]) : IEnumerable[T]
    {
      def stack = SCG.Stack();
      stack.Push(tree);

      def loop()
      {
        if (stack.Count != 0)
        {
          def current = stack.Pop();
          def childs = childs(current);
          foreach (c in childs)
          {
            stack.Push(c)
          }
          yield current;
        } else ()
      }

      loop()
    }

    
      
   
    
    public GetPostOrderEnumerable[T](tree : T, childs : T -> IEnumerable[T]) : IEnumerable[T]
    {
//       assert2(false);
       TreePostOrderEnumerable(tree, childs)
      //def child = SCG.Stack();
      //def parent = SCG.Stack();

      //child.Push(tree);

      //while (child.Count != 0)
      //{
      //  def curr = child.Pop();
      //  parent.Push(curr);
      //  def childs = childs(curr);
      //  foreach (s in childs) child.Push(s);
      //}
      //parent
    }

    public GetBreadthFirstEnumerable[T](tree : T, childs : T -> IEnumerable[T]) : IEnumerable[T]
    {
      def queue = SCG.Queue();
      queue.Enqueue(tree);

      while (queue.Count != 0)
      {
        def node = queue.Dequeue();
        yield node;
        def childs = childs(node);
        foreach (s in childs) queue.Enqueue(s)
      }
    }

    public Fold[T, TAcc](this node : IGeneralTree[T], init : TAcc, folder : T * TAcc -> TAcc) : TAcc
    {
      Fold(node, init, x => x.ChildNodes, (x, a) => folder(x.Current, a))
    }
    
    public Fold[T, TAcc](node : T, init : TAcc, childs : T -> IEnumerable[T], folder : T * TAcc -> TAcc) : TAcc
    {
      //def fold(n, acc)
      //{
      //  folder(n, acc)// :: tail
      //}

      //GetPostOrderEnumerable(node, childs).FoldLeft(init, fold)
      
      def loop(n, acc)
      {
        def acc = childs(n).Fold(acc, loop);
        folder(n, acc)
      }
      //def loop(n, acc)
      //{
      //  def (chacc, tail) = acc.PopRev(childs(n).Count());
      //  folder(n, chacc) :: tail;
      //}
      
      //GetPostOrderEnumerable(node, childs).FoldLeft([init], loop).Head
      loop(node, init)
    }
    
    public FoldTree[T, TAcc](this node : IGeneralTree[T], init : TAcc, folder : T * IEnumerable[TAcc] -> TAcc) : TAcc
    {
      FoldTree(node, init, x => x.ChildNodes, (x, a) => folder(x.Current, a))
    }
    
    public FoldTree[T, TAcc](node : T, init : TAcc, childs : T -> IEnumerable[T], folder : T * IEnumerable[TAcc] -> TAcc) : TAcc
    {
      def loop(n, acc)
      {
        def acc = childs(n).Select(loop(_, acc));
        folder(n, acc)
      }
      //def loop(n, acc)
      //{
      //  def (chacc, tail) = acc.PopRev(childs(n).Count());
      //  folder(n, chacc) :: tail;
      //}
      
      //GetPostOrderEnumerable(node, childs).FoldLeft([init], loop).Head
      loop(node, init)
    }
    
    public Reduce[T](this tree : IGeneralTree[T], folder : T * IEnumerable[T] -> T) : T
    {

      def fold_func(x)
      {
        def childs = x.ChildNodes.Select(fold_func);
        folder(x.Current, childs)
        //chacc.
        //def len = x.ChildNodes.Count();
        //def (child, lst) = chacc.PopRev(len);
        //def acc = folder(x.Current, child);
        //deque.Add(acc);
        //acc :: lst
      }

      fold_func(tree)
      //tree.GetPostOrderIter().FoldLeft([], fold_func).Head
    }
    
    public Reduce[T](this tree : T, childs : T -> IEnumerable[T], folder : T * IEnumerable[T] -> T) : T
    {

      def fold_func(x)
      {
        def childs = childs(x).Select(fold_func);
        folder(x, childs)
        //chacc.
        //def len = x.ChildNodes.Count();
        //def (child, lst) = chacc.PopRev(len);
        //def acc = folder(x.Current, child);
        //deque.Add(acc);
        //acc :: lst
      }

      fold_func(tree)
      //tree.GetPostOrderIter().FoldLeft([], fold_func).Head
    }
  }
}
