using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  public enum TreeTraversalType
  {
    | PreOrder
    | PostOrder
    | BreadthFirst
  }
  
  public interface IGeneralTree[T]
  {
    Current : T {get;}
    ChildNodes : IEnumerable[IGeneralTree[T]] {get;}
  }
  /// <summary>
  /// Description of Tree.
  /// </summary>
  public module TreeUtils
  {
    
    
    
    public GetPreOrderEnumerable[T](this tree : IGeneralTree[T]) : IEnumerable[T]
    {
      GetPreOrderEnumerable(tree, _.ChildNodes).Select(x => x.Current)
    }
    
    public GetPostOrderEnumerable[T](this tree : IGeneralTree[T]) : IEnumerable[T]
    {
      GetPostOrderEnumerable(tree, _.ChildNodes).Select(x => x.Current)
    }
    
    public  GetBreadthFirstEnumerable[T](this tree : IGeneralTree[T]) : IEnumerable[T]
    {
      GetBreadthFirstEnumerable(tree, _.ChildNodes).Select(x => x.Current)
    }
    
    
    
    public GetEnumerable[T](tree : T, childs : T -> IEnumerable[T], TraversalType : TreeTraversalType) : IEnumerable[T]
    {
      match (TraversalType)
      {
        | TreeTraversalType.PreOrder     => GetPreOrderEnumerable(tree, childs)
        | TreeTraversalType.BreadthFirst => GetBreadthFirstEnumerable(tree, childs)
        | TreeTraversalType.PostOrder    => GetPostOrderEnumerable(tree, childs)
      }
    }

    public GetPreOrderEnumerable[T](tree : T, childs : T -> IEnumerable[T]) : IEnumerable[T]
    {
      def stack = SCG.Stack();
      stack.Push(tree);

      def loop()
      {
        if (stack.Count != 0)
        {
          def current = stack.Pop();
          def childs = childs(current);
          foreach (c in childs)
          {
            stack.Push(c)
          }
          yield current;
        } else ()
      }

      loop()
    }

    public GetPostOrderEnumerable[T](tree : T, childs : T -> IEnumerable[T]) : IEnumerable[T]
    {
      def child = SCG.Stack();
      def parent = SCG.Stack();

      child.Push(tree);

      while (child.Count != 0)
      {
        def curr = child.Pop();
        parent.Push(curr);
        def childs = childs(curr);
        foreach (s in childs) child.Push(s);
      }
      parent
    }

    public  GetBreadthFirstEnumerable[T](tree : T, childs : T -> IEnumerable[T]) : IEnumerable[T]
    {
      def queue = SCG.Queue();
      queue.Enqueue(tree);

      while (queue.Count != 0)
      {
        def node = queue.Dequeue();
        yield node;
        def childs = childs(node);
        foreach (s in childs) queue.Enqueue(s)
      }
    }

    

    //public Reduce[T](this node : GeneralTree[T], manual_rebuild : bool, folder : GeneralTree[T] * list[GeneralTree[T]] -> GeneralTree[T]) : GeneralTree[T]
    //{
    //  def loop(n, acc)
    //  {
    //    def (chacc, tail) = acc.PopRev(n.ChildNodes.Count());
    //    def res = folder(n, acc);
    //    def acc = if (res == null || !manual_rebuild)  
    //               {
    //                 def acc = (n ?? res);
    //                 def res = GeneralTree(acc.Data);
    //                 acc.AddRange(chacc);
    //                 res
    //               } else res;
    //    acc :: tail
    //  }

    //  node.GetPostOrderEnumerable().FoldLeft(null, loop).Head
    //}

    public Fold[T, TAcc](this node : IGeneralTree[T], init : TAcc, folder : T * TAcc -> TAcc) : TAcc
    {
      Fold(node, init, x => x.ChildNodes, (x, a) => folder(x.Current, a))
    }
    
    public Fold[T, TAcc](node : T, init : TAcc, childs : T -> IEnumerable[T], folder : T * TAcc -> TAcc) : TAcc
    {
      def fold(n, acc)
      {
        folder(n, acc)// :: tail
      }

      GetPostOrderEnumerable(node, childs).FoldLeft(init, fold)
    }
    
    public FoldTree[T, TAcc](this node : IGeneralTree[T], init : TAcc, folder : T * IEnumerable[TAcc] -> TAcc) : TAcc
    {
      FoldTree(node, init, x => x.ChildNodes, (x, a) => folder(x.Current, a))
    }
    
    public FoldTree[T, TAcc](node : T, init : TAcc, childs : T -> IEnumerable[T], folder : T * IEnumerable[TAcc] -> TAcc) : TAcc
    {
      def loop(n, acc)
      {
        def (chacc, tail) = acc.PopRev(childs(n).Count());
        folder(n, chacc) :: tail;
      }
      
      GetPostOrderEnumerable(node, childs).FoldLeft([init], loop).Head
    }
    
    
    

    //public Reduce[T, TAcc](this node : BinaryTree[T], init : TAcc, folder : BinaryTree[T] * BinaryTree[T] * BinaryTree[T] * TAcc -> BinaryTree[T] * TAcc) : BinaryTree[T] * TAcc
    //{
    //  def fold(n, (ch, acc : TAcc))
    //  {
    //    match (n.Left, n.Right, ch )
    //    {
    //      | (null, null, tail)          => def (n, acc) = folder(n, null, null, acc);
    //                                    (n :: tail, acc)
    //      | (null, _, a :: tail)     => def (n, acc) = folder(n, null, a, acc);
    //                                    (n :: tail, acc)
    //      | (_, null, a :: tail)     => def (n, acc) = folder(n, a, null, acc);
    //                                    (n :: tail, acc)
    //      | (_, _, ll :: rr :: tail) => def (n, acc) = folder(n, ll, rr, acc);
    //                                    (n :: tail, acc)
    //      | _                        => (ch, acc)
    //    }
    //  }

    //  def (res, acc) = node.GetPostOrderEnumerable().FoldLeft(([node], init), fold);
    //  (res.Head, acc)
    //  //(a.Head, b)
    //  //node.GetBreadthFirstEnumerable().Iter(reduce)
    //}

    //public Unfold[T](this node : GeneralTree[T], func : T -> IEnumerable[T]) : void
    //{
    //  def unfold(n)
    //  {
    //    def childs = func(n.Data);
    //    def nodes = childs.Select(GeneralTree);
    //    n.AddRange(nodes);
    //    nodes
    //  }

    //  def lst = SCG.Queue();

    //  def loop()
    //  {
    //    if (lst.IsEmpty()) () else 
    //    {
    //      def node = lst.Dequeue();
    //      def childs = node.GetBreadthFirstEnumerable().SelectMany(unfold);
    //      childs.Iter(lst.Enqueue);
    //      loop()
    //    }
    //  }

    //  lst.Enqueue(node);
    //  loop()
    //}

    
    //public Clone[T](this node : GeneralTree[T]) : GeneralTree[T]
    //{
    //  def clone(n, c)
    //  {
    //    def tree = GeneralTree(n.Data);
    //    tree.AddRange(c);
    //    tree
    //  }

    //  node.Reduce(true, clone)
    //}

    //public Unfold[T](this node : GeneralTree[T], func : T -> IEnumerable[GeneralTree[T]]) : void
    //{
    //  def unfold(n)
    //  {
    //    def childs = func(n.Data);
    //    //def nodes = childs.Select(GeneralTree);
    //    n.AddRange(childs);
    //    childs
    //  }

    //  def lst = SCG.Queue();

    //  def loop()
    //  {
    //    if (lst.IsEmpty()) () else 
    //    {
    //      def node = lst.Dequeue();
    //      def childs = node.GetBreadthFirstEnumerable().SelectMany(unfold);
    //      childs.Iter(lst.Enqueue);
    //      loop()
    //    }
    //  }

    //  lst.Enqueue(node);
    //  loop()
    //}

    //public Unfold[T](this node : BinaryTree[T], func : T -> list[T], merge : list[T] -> BinaryTree[T]) : void
    //{

    //  def loop(acc)
    //  {
    //    | []           => ()
    //    | head :: tail =>

    //        def tail = match (func(head.Data))
    //        {
    //        | []  => tail
    //        | lst => def new_node = merge(lst);
    //                head.Right = new_node;
    //                new_node :: tail
    //        }

    //        loop(tail)
    //    //childs.Iter(lst.Enqueue);
    //    //childs.FoldBack(null, (x, a) => BinaryTree(x, a, null));
    //  }

    //  loop(node :: [])

    //}
  }
}
