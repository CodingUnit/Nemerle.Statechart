using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro Traverse(_typeBuilder : TypeBuilder, params _expr : list[PExpr])
  {
  }

  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Field)]
  macro TraverseIgnore(_typeBuilder : TypeBuilder, _ : ParsedField)
  {
  }

  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro TraverseIgnore(_typeBuilder : TypeBuilder)
  {
  }

  
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Field)]
  macro TraverseInclude(_typeBuilder : TypeBuilder, _ : ParsedField)
  {
  }

  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro Traversable(typeBuilder : TypeBuilder, params expr : list[PExpr])
  {
    TraversableImpl.DoTransformCached(Macros.ImplicitCTX(), typeBuilder, expr)
  }  

  [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class)]
  macro Traversable(typeBuilder : TypeBuilder, params expr : list[PExpr])
  {
    TraversableImpl.DoTransformCached2(Macros.ImplicitCTX(), typeBuilder, expr)
  }  

  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class)]
  macro Traversable(typeBuilder : TypeBuilder, params expr : list[PExpr])
  {
    TraversableImpl.DoCheckTraverse(Macros.ImplicitCTX(), typeBuilder, expr)
  }  

  enum TreeType
  {
    | Unknown
    | Type
    | Enumerable
    | Option
  }

  partial module TraversableImpl
  {
    public DoTransformCached(typer : Typer, typeBuilder : TypeBuilder, _expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      def name = typeBuilder.Name;
      typeBuilder.AddImplementedInterface(<[ ICachedTraversable[$(name : usesite)] ]>);
      typeBuilder.Define(<[decl: [NeedChange] [RecordIgnore] tree_pos : int = -1; ]>);
      typeBuilder.Define(<[decl: [NeedChange] [RecordIgnore] child_count : int = -1; ]>);
      typeBuilder.Define(<[decl: [NeedChange(child_count)] [RecordIgnore] cached_iter : IEnumerable[$(name : usesite)]; ]>);
      typeBuilder.Define(<[decl: [NeedChange] [RecordIgnore] cached_level_iter : IEnumerable[$(name : usesite)]; ]>);
    }

    public DoTransformCached2(typer : Typer, typeBuilder : TypeBuilder, expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      def name = typeBuilder.Name;
      
      typeBuilder.Define(<[decl: public Current : $(name : usesite) { get { this } }]>);
      typeBuilder.Define(<[decl: public ChildCount : int { get { if (child_count != -1)  child_count else GetChild().Count() } } ]>);
      typeBuilder.Define(<[decl: public TreePos : int { get { tree_pos } } ]>);
      typeBuilder.Define(<[decl: public CachedIterator : IEnumerable[$(name : usesite)] { get { cached_iter } } ]>);
      typeBuilder.Define(<[decl: public CachedLevelIterator : IEnumerable[$(name : usesite)] { get { cached_level_iter } } ]>);
      typeBuilder.Define(<[decl: public MakeIter(iter : IEnumerable[$(name : usesite)], len : int) : $(name : usesite) {  ChangeCachedIterChildCount(iter, len)  } ]>);
      typeBuilder.Define(<[decl: public SetTreePos(pos : int) : $(name : usesite) {  ChangeTreePos(pos)  } ]>);
      //typeBuilder.Define(<[decl: public CreateIterator() : $(name : usesite)
      //                    {
      //                        ChangeCachedIter(LengthIterator())
      //                    } ]>);

      //typeBuilder.Define(<[decl: public CreateLevelIterator() : $(name : usesite)
      //                    {
      //                        ChangeCachedLevelIter(LevelOrderIterator())
      //                    } ]>);
      def create_cases((t, e, i), a)
      {
        def e = match (e)
                 {
                   | <[ ]>       => <[ case: | $(t.ParsedName : name)    => $i ]>
                   | <[ $_($f = $t(_))]> with e = <[ $f = $t ]>
                   | <[ $_($e)]>
                   | e           => <[ case: | $(t.ParsedName : name)($e) => $i ]>
                 } 
        e :: a
      }

      def lst = CollectTraverseOpt(typer, typeBuilder, expr);
      def mems = typeBuilder.GetParsedMembers();
      when (!mems.Exists(_ is ClassMember.Function(Name = "GetCode", header = PFunHeader(Parameters = [])))) 
      {
        match (lst)
        {
          | []   => typeBuilder.Define(<[decl: public GetCode() : int { _N_GetVariantCode() }]>);

          | lst  => def lst = lst.MapIRev((i, (x, y, _)) => (x, y, i));
                    def sorted = SortCases(lst, x => x[1]);
                    def cases = sorted.FoldLeft([<[ case: | _ => -1 ]>], create_cases);
                    _ = typeBuilder.DefineWithSource(<[decl: public GetCode() : int 
                                                             { 
                                                               match (this)
                                                               {
                                                                 ..$cases
                                                               } 
                                                             }]>);
        }

      }
      //when (!mems.Exists(_ is ClassMember.Property(Name = "ChildCount")))
      //{
      //  typeBuilder.Define(<[decl: ChildCount : int { get; private set; } ]>);
      //}
      
    }

    SortCases[T](data : list[T], expr : T -> PExpr) : list[T]
    {
      def case_sorter(x, y)
      {
        | (<[]>, <[]>)         => 0
        | (<[ $_ ]>, <[]>)     => 1
        | (<[]>, <[ $_ ]>)     => -1
        | _                    => 0
      }


      data.Sort((x, y) => case_sorter(expr(x), expr(y)));
    }

    CollectTraverseOpt(typer : Typer, type : TypeBuilder, expr : list[PExpr]) : list[TypeBuilder * PExpr * list[IField * TreeType]]
    {
      def opts = type.GetVariantOptions();
      def opts = opts.Filter(x => !x.GetModifiers().GetMacroAttributes().Exists(_ is <[ TraverseIgnore ]>));
      
      def get_type(t, a)
      {
        match (t)
        {
          | <[ All ]>         => a
          | <[ $(x : name) ]> => x.Id :: a
          | _                 => a
        }
      }

      def map_types(t, a)
      {
        match (opts.Find(y => y.Name.EndsWith(t)))
        {
          | Some(s) => s :: a
          | _       => a
        }
      }

      def types = expr.FoldBack([], get_type);
      def types = types.FoldBack([], map_types);
      def types = if (types is []) [type] else types;
      
      def collect_trav_opts(t, x, a)
      {
        match (x, expr)
        {
          | (<[ Traverse($expr) ]>, _)
          | (_, [<[ All ]>])        with expr = <[]>
          | (<[ Traverse ]>, _)     with expr = <[]>
          | (_, <[ $(n : name) ]> :: []) when (n.Id == t.Name) with expr = <[]>
          | (_, [])                 with expr = <[]> => get_members(typer, t, expr, types) :: a
          | (_, _ :: [])            with expr = <[]> => match (get_members(typer, t, expr, types))
                                                        {
                                                          | (_, _, []) => a
                                                          | x          => x :: a
                                                        }
          | _ => a
        }
      }
      
      opts.FoldLeft([], (x, a) => x.GetModifiers().GetMacroAttributes().FoldLeft(a, collect_trav_opts(x, _, _)))
    }

  }
}
