using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using SCG = System.Collections.Generic;
using System.Diagnostics;

namespace Nemerle.Statechart
{

  public interface ITraversable[T]
  {
    Current : T { get; }
    GetCode() : int;
    Rebuild(child : IEnumerable[T]) : T;
    GetChild() :  IEnumerable[ITraversable[T]];
  }

  public class IIteratorContextBase[T]
  {
    setted : BitArray;

    public this() {}
    public this(params lst : array[object])
    {
      setted = if (lst.IsMoreThanOne()) BitArray(lst.MapToArray(_ != null)) else null;
    }

    public IsSet(node : ITraversable[T]) : bool
    {
      def code = node.GetCode();
      if (setted != null) setted[code] else true
    }
  }

  public abstract class IIteratorContext[T, TAcc] : IIteratorContextBase[T]
  {
    public this() {}
    public this(params lst : array[object])
    {
      base(lst)
    }

    public abstract Visit(obj : T, acc : IEnumerable[TAcc]) : TAcc;
  }

  public abstract class IReduceIteratorContext[T] : IIteratorContextBase[T]
  {
    public this() {}
    public this(params lst : array[object])
    {
      base(lst)
    }

    public abstract Visit(obj : T, acc : IEnumerable[T]) : T;
  }
  
  public abstract class IAccIteratorContext[T, TAcc] : IIteratorContextBase[T]
  {
    public this() {}
    
    public this(params lst : array[object])
    {
      base(lst)
    }

    public abstract Visit(obj : T, acc : TAcc) : TAcc;
  }

  public abstract class ITwoAccIteratorContext[T, TAcc, TAcc2] : IIteratorContextBase[T]
  {
    public this(params lst : array[object])
    {
      base(lst)
    }

    public abstract Visit(obj : T, acc : IEnumerable[TAcc], acc2 : TAcc2) : TAcc * TAcc2;
  }
  
  public abstract class IReduceTwoAccIteratorContext[T, TAcc] : IIteratorContextBase[T]
  {
    public this() {}
    
    public this(params lst : array[object])
    {
      base(lst)
    }

    public abstract Visit(obj : T, acc : IEnumerable[T], acc2 : TAcc) : T * TAcc;
  }
  
  public interface ICachedTraversable[T] : ITraversable[T]
  {
    CachedIterator : IEnumerable[ITraversable[T]] * IEnumerable[int] { get; }
    CachedLevelIterator : IEnumerable[T] { get; }
  }

  /// <summary>
  /// Description of Traverse.
  /// </summary>
  public module TraverseUtils
  {

    public TIterator[T](this obj : ICachedTraversable[T]) : IEnumerable[ITraversable[T]]
    {
      def iter = obj.CachedIterator[0];
      if (iter == null) 
      {
        TIterator(obj : ITraversable[T])
      } else iter
    }

    public Iterator[T](this obj : ICachedTraversable[T]) : IEnumerable[T]
    {
      def iter = obj.CachedIterator[0];
      if (iter == null) 
      {
        Iterator(obj : ITraversable[T])
      } else iter.Select(x => x.Current)
    }

    public FoldDo[T, TAcc](this obj : ICachedTraversable[T], init : TAcc, fold : T * IEnumerable[TAcc] * TAcc -> TAcc) : TAcc
    {
      def stack = SCG.Stack();

      def fold_func(x, l, a)
      {
        def child = stack.PopRev(l);
        def acc = fold(x.Current, child, a);
        stack.Push(acc);
        acc
      }

      def (lst, len) = obj.LengthIterator(); 
      lst.Fold2(len, init, fold_func)
    }

    public FoldDo[T, TAcc](this obj : ICachedTraversable[T], init : TAcc, ctx : IIteratorContext[T, TAcc]) : TAcc
    {
      def stack = SCG.Stack();

      def fold_func(x, l, a)
      {
        def child = stack.PopRev(l);
        def acc = if (ctx.IsSet(x)) ctx.Visit(x.Current, child) else a;
        stack.Push(acc);
        acc
      }

      def (lst, len) = obj.LengthIterator(); 
      lst.Fold2(len, init, fold_func)
    }

    public FoldDo[T, TAcc](this obj : ICachedTraversable[T], init : TAcc, ctx : IAccIteratorContext[T, TAcc]) : TAcc
    {
      def fold_func(x, a)
      {
        if (ctx.IsSet(x)) ctx.Visit(x.Current, a) else a
      }

      def lst = obj.TIterator(); 
      lst.FoldLeft(init, fold_func)
    }

    public ReduceDo[T, TAcc](this obj : ICachedTraversable[T], init : TAcc, ctx : IReduceTwoAccIteratorContext[T, TAcc]) : T * TAcc where T : class, ITraversable[T]
    {
      def stack = SCG.Stack();

      def fold_func(x, l, acc2)
      {
        def child = stack.PopRev(l);
        def (acc, acc2) = if (ctx.IsSet(x)) 
                          {
                            ctx.Visit(x.Current, child, acc2);
                          } else (x.Rebuild(child), acc2);
        def acc = acc ?? x.Rebuild(child);
        stack.Push(acc);
        acc2
      }

      def (lst, len) = obj.LengthIterator();
      def acc2= lst.Fold2(len, init, fold_func);
      def acc = stack.Pop();
      (acc, acc2)
    }

    public ReduceDo[T](this obj : ICachedTraversable[T], ctx : IReduceIteratorContext[T]) : T where T : class, ITraversable[T]
    {
      def stack = SCG.Stack();

      def fold_func(x, l, _)
      {
        def child = stack.PopRev(l);
        def acc = if (ctx.IsSet(x)) 
                  {
                    ctx.Visit(x.Current, child)
                  } else x.Rebuild(child);
        def acc = acc ?? x.Rebuild(child);
        stack.Push(acc);
        acc
      }

      def (lst, len) = obj.LengthIterator();
      lst.Reduce2(len, fold_func).Current
    }

    public LengthIterator[T](this obj : ICachedTraversable[T]) : IEnumerable[ITraversable[T]] * IEnumerable[int]
    {
      def (iter, len) = obj.CachedIterator;
      if (iter == null) 
      {
        LengthIterator(obj : ITraversable[T])
      } else (iter, len)
    }

    
    public LengthIterator[T](this obj : ITraversable[T]) : IEnumerable[ITraversable[T]] * IEnumerable[int]
    {
      def child = SCG.Stack();
      def parent = SCG.Stack();
      def length = SCG.Stack();

      def loop_init()
      {
        if (child.IsEmpty()) () else 
        {
          def curr = child.Pop();
          parent.Push(curr);
          def len = child.PushLength(curr.GetChild());
          length.Push(len);
          loop_init()
        }
      }

      child.Push(obj);
      loop_init();
      (parent, length)
    }

    public TIterator[T](this obj : ITraversable[T]) : IEnumerable[ITraversable[T]]
    {
      def child = SCG.Stack();
      def parent = SCG.Stack();

      def loop_init()
      {
        if (child.IsEmpty()) () else 
        {
          def curr = child.Pop();
          parent.Push(curr);
          foreach (c in curr.GetChild()) child.Push(c);
          loop_init()
        }
      }

      child.Push(obj);
      loop_init();
      parent
    }

    public Iterator[T](this obj : ITraversable[T]) : IEnumerable[T]
    {
      def child = SCG.Stack();
      def parent = SCG.Stack();

      def loop_init()
      {
        if (child.IsEmpty()) () else 
        {
          def curr = child.Pop();
          parent.Push(curr.Current);
          foreach (c in curr.GetChild()) child.Push(c);
          loop_init()
        }
      }

      child.Push(obj);
      loop_init();
      parent
    }
    
    public static LevelOrderIterator[T](this obj : ICachedTraversable[T]) : IEnumerable[T]
    {
      def iter = obj.CachedLevelIterator;
      if (iter == null) 
      {
        LevelOrderIterator(obj : ITraversable[T])
      } else iter
    }

    public static LevelOrderIterator[T](this obj : ITraversable[T]) : IEnumerable[T]
    {
      def queue = SCG.Queue();
      queue.Enqueue(obj);

      def loop()
      {
        if (queue.IsEmpty()) () else
        {
          def node = queue.Dequeue();
          yield node.Current;
          foreach (s in node.GetChild()) queue.Enqueue(s);
          loop()
        }
      }

      loop()
    }

    public SingleElement[T](elem : T) : IEnumerable[T]
    {
      yield elem
    }

    public DoubleElement[T](elem1 : T, elem2 : T) : IEnumerable[T]
    {
      yield elem1;
      yield elem2;
    }

  }


}
