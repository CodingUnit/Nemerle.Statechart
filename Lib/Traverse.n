using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using SCG = System.Collections.Generic;
using System.Diagnostics;

namespace Nemerle.Statechart
{

  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro Traverse(_typeBuilder : TypeBuilder, params _expr : list[PExpr])
  {
    //TraversableImpl.DoCheckTraverse(Macros.ImplicitCTX(), typeBuilder, expr)
  }

  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  macro Traversable(typeBuilder : TypeBuilder, params expr : list[PExpr])
  {
    TraversableImpl.DoTransformCached(Macros.ImplicitCTX(), typeBuilder, expr)
  }  

  [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class)]
  macro Traversable(typeBuilder : TypeBuilder, params expr : list[PExpr])
  {
    TraversableImpl.DoTransformCached2(Macros.ImplicitCTX(), typeBuilder, expr)
  }  

  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class)]
  macro Traversable(typeBuilder : TypeBuilder, params expr : list[PExpr])
  {
    TraversableImpl.DoCheckTraverse(Macros.ImplicitCTX(), typeBuilder, expr)
  }  
  
  //[MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class)]
  //macro CachedTraversable(typeBuilder : TypeBuilder)
  //{
  //  TraversableImpl.DoTransformCached3(Macros.ImplicitCTX(), typeBuilder)
  //}  

  module TraversableImpl
  {

    public DoTransformCached(typer : Typer, typeBuilder : TypeBuilder, _expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      def name = typeBuilder.Name;
      typeBuilder.AddImplementedInterface(<[ ICachedTraversable[$(name : usesite)] ]>);
      typeBuilder.Define(<[decl: [NeedChange] [RecordIgnore] public cached_iter : IEnumerable[ITraversable[$(name : usesite)]] * IEnumerable[int]; ]>);
      typeBuilder.Define(<[decl: [NeedChange] [RecordIgnore] public cached_level_iter : IEnumerable[$(name : usesite)]; ]>);
    }


    public DoTransformCached2(typer : Typer, typeBuilder : TypeBuilder, _expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      def name = typeBuilder.Name;
      def is_get_code(x)
      {
        | ClassMember.Function(Name = "GetCode", header = PFunHeader where (Parameters = [])) => true
        | _                                                                                   => false
      }

      typeBuilder.Define(<[decl: public Current : $(name : usesite) { get { this } }]>);
      when (!typeBuilder.GetParsedMembers().Exists(is_get_code)) typeBuilder.Define(<[decl: public GetCode() : int { _N_GetVariantCode() }]>);
      typeBuilder.Define(<[decl: public CachedIterator : IEnumerable[ITraversable[$(name : usesite)]] * IEnumerable[int] { get { cached_iter } } ]>);
      typeBuilder.Define(<[decl: public CachedLevelIterator : IEnumerable[$(name : usesite)] { get { cached_level_iter } } ]>);
      typeBuilder.Define(<[decl: public CreateIterator() : $(name : usesite)
                          {
                              ChangeCachedIter(LengthIterator())
                          } ]>);


      typeBuilder.Define(<[decl: public CreateLevelIterator() : $(name : usesite)
                          {
                              ChangeCachedLevelIter(LevelOrderIterator())
                          } ]>);
                          
      //DoCheckTraverse(typer, typeBuilder);                    

    }

    public DoCheckTraverse(typer : Typer, typeBuilder : TypeBuilder, _expr : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      assert2(false);
      def opts = typeBuilder.GetVariantOptions();
      //def name = typeBuilder.Name;
      def get_type(t, a)
      {
        match (t)
        {
          | <[ $(x : name) ]> => x.Id :: a
          | _                 => a
        }
      }
      
      def map_types(t, a)
      {
        match (opts.Find(y => y.Name.EndsWith(t)))
        {
          | Some(s) => s :: a
          | _       => a
        }
      }
      
      def types = _expr.FoldLeft([], get_type);
      def types = types.FoldLeft([], map_types);
      //def type = typeBuilder.GetFreshType();
      
      
      def collect_trav_opts(t, x, a)
      {
        match (x)
        {
          | <[ Traverse($_) ]> as x => (t, x) :: a
          | <[ Traverse ]>     as x => (t, x) :: a
          | _                       => a
        }
      }

      def get_members(f, _)
      {
        def is_traversable(f, a)
        {
          def ty = f.GetMemType();
          
          def is_enum(t)
          {
            def type = t.GetFreshType();
            def type = <[ ttype: IEnumerable[$type] ]>;
            ty.TryUnify(type)
          }
          
          def is_opt(t)
          {
            def type = t.GetFreshType();
            def opt = <[ ttype: option[$type] ]>;
            ty.TryUnify(opt)
          }
          
          def any_of_super = types.Exists(x => ty.TryRequire(x.GetFreshType()));
          def any_of_ienum = types.Exists(is_enum);
          def any_of_opt = types.Exists(is_opt);
          
          if (any_of_super || any_of_ienum || any_of_opt) f :: a else a
        }
        
        def fields = f.GetFields();
        fields.FoldLeft([], is_traversable)
      }
      
      def traverse = opts.FoldLeft([], (x, a) => x.GetModifiers().GetMacroAttributes().FoldLeft(a, collect_trav_opts(x, _, _)));
      def a = traverse.Map(get_members);
      foreach (t in a)
      {
        Debug.Print($"..$t")
      }
    }
    
  }

  public interface ITraversable[T]
  {
    Current : T { get; }
    GetCode() : int;
    Rebuild(child : IEnumerable[T]) : T;
    GetChild() : IEnumerable[ITraversable[T]];
  }

  public class IIteratorContextBase[T]
  {
    setted : BitArray;

    public this(params lst : array[object])
    {
      setted = BitArray(lst.MapToArray(_ != null));
    }

    public IsSet(node : ITraversable[T]) : bool
    {
      setted[node.GetCode()]
    }
  }

  public abstract class IIteratorContext[T, TAcc] : IIteratorContextBase[T]
  {
    public this(params lst : array[object])
    {
      base(lst)
    }

    public abstract Visit(obj : T, acc : IEnumerable[TAcc]) : TAcc;
  }

  public abstract class IAccIteratorContext[T, TAcc] : IIteratorContextBase[T]
  {
    public this(params lst : array[object])
    {
      base(lst)
    }

    public abstract Visit(obj : T, acc : TAcc) : TAcc;
  }

  public abstract class ISingleIteratorContext[T, TAcc] : IIteratorContext[T, TAcc]
  {
    public this(params lst : array[object])
    {
      base(lst)
    }

    //public abstract Visit(obj : T, acc : IEnumerable[TAcc]) : TAcc;
  }

  public interface ICachedTraversable[T] : ITraversable[T]
  {
    CachedIterator : IEnumerable[ITraversable[T]] * IEnumerable[int] { get; }
    CachedLevelIterator : IEnumerable[T] { get; }
  }

  /// <summary>
  /// Description of Traverse.
  /// </summary>
  public module TraverseUtils
  {

    //public CachedIterator[T](this obj : ITraversable[T]) : IEnumerable[T] where T : class
    //{
    //  if (obj.Cached == obj.Current : object)
    //  {
    //    obj.CachedIt
    //  } else
    //  {
    //    def iter = Iterator(obj);
    //    obj.CachedIt = iter;
    //    obj.Cached = obj.Current;
    //    iter
    //  }
    //}

    public Iterator[T](this obj : ICachedTraversable[T]) : IEnumerable[ITraversable[T]]
    {
      def iter = obj.CachedIterator[0];
      if (iter == null) 
      {
        Iterator(obj : ITraversable[T])
      } else iter
    }

    public Fold[T, TAcc](this obj : ICachedTraversable[T], init : TAcc, fold : T * IEnumerable[TAcc] * TAcc -> TAcc) : TAcc
    {
      def stack = SCG.Stack();

      def fold_func(x, l, a)
      {
        def child = stack.PopRev(l);
        def acc = fold(x.Current, child, a);
        stack.Push(acc);
        acc
      }

      def (lst, len) = obj.LengthIterator(); 
      lst.Fold2(len, init, fold_func)
    }

    public Fold[T, TAcc](this obj : ICachedTraversable[T], init : TAcc, ctx : IIteratorContext[T, TAcc]) : TAcc
    {
      def stack = SCG.Stack();

      def fold_func(x, l, a)
      {
        def child = stack.PopRev(l);
        def acc = if (ctx.IsSet(x)) ctx.Visit(x.Current, child) else a;
        stack.Push(acc);
        acc
      }

      def (lst, len) = obj.LengthIterator(); 
      lst.Fold2(len, init, fold_func)
    }

    //public Fold[T, TAcc](this obj : ICachedTraversable[T], init : TAcc, ctx : ISingleIteratorContext[T, TAcc]) : TAcc
    //{
    //  def stack = SCG.Stack();

    //  def fold_func(x, l, a)
    //  {
    //    def child = stack.PopRev(l);
    //    def acc = if (ctx.IsSet(x)) x.Visit(ctx, child) else a;
    //    stack.Push(acc);
    //    acc
    //  }

    //  def (lst, len) = obj.LengthIterator();
    //  lst.Fold2(len, init, fold_func)
    //}

    public Fold[T, TAcc](this obj : ICachedTraversable[T], init : TAcc, ctx : IAccIteratorContext[T, TAcc]) : TAcc
    {
      def fold_func(x, a)
      {
        if (ctx.IsSet(x)) ctx.Visit(x.Current, a) else a
      }

      def lst = obj.Iterator(); 
      lst.FoldLeft(init, fold_func)
    }

    public FoldThis[T, TAcc](this obj : ICachedTraversable[T], init : TAcc, fold : ITraversable[T] * IEnumerable[T] * TAcc -> T * TAcc) : T * TAcc where T : class
    {
      def stack = SCG.Stack();

      def fold_func(x, l, a)
      {
        def child = stack.PopRev(l);
        def (f, acc) = fold(x, child, a);
        def f = if (f == null) x.Rebuild(child) else f;
        stack.Push(f);
        acc
      }

      def (lst, len) = obj.LengthIterator();
      def acc = lst.Fold2(len, init, fold_func);
      def st = stack.Pop();
      (st, acc)
    }

    public FoldThis[T, TAcc](this obj : ICachedTraversable[T], fold : ITraversable[T] * IEnumerable[T] -> T) : T where T : class
    {
      def stack = SCG.Stack();

      def fold_func(x, l, _)
      {
        def child = stack.PopRev(l);
        def acc = fold(x, child);
        def acc = if (acc == null) x.Rebuild(child) else acc;
        stack.Push(acc);
        acc
      }

      def (lst, len) = obj.LengthIterator();
      lst.Fold2(len, null, fold_func)
    }

    public FoldThis[T](this obj : ICachedTraversable[T], init : T, ctx : IIteratorContext[T, T]) : T where T : class
    {
      def stack = SCG.Stack();

      def fold_func(x, l, _)
      {
        def child = stack.PopRev(l);
        def acc = if (ctx.IsSet(x)) ctx.Visit(obj.Current, child); else null;
        def acc = if (acc != null) acc else x.Rebuild(child);
        stack.Push(acc);
        acc
      }

      def (lst, len) = obj.LengthIterator();
      lst.Fold2(len, init, fold_func)
    }

    //public FoldThis[T](this obj : ICachedTraversable[T], init : T, ctx : ISingleIteratorContext[T]) : T where T : class
    //{
    //  def stack = SCG.Stack();

    //  def fold_func(x, l, _)
    //  {
    //    def child = stack.PopRev(l);
    //    def acc = if (ctx.IsSet(x)) obj.Visit(ctx, child); else null;
    //    def acc = if (acc != null) acc else x.Rebuild(child);
    //    stack.Push(acc);
    //    acc
    //  }

    //  def (lst, len) = obj.LengthIterator();
    //  lst.Fold2(len, init, fold_func)
    //}

    public LengthIterator[T](this obj : ICachedTraversable[T]) : IEnumerable[ITraversable[T]] * IEnumerable[int]
    {
      def (iter, len) = obj.CachedIterator;
      if (iter == null) 
      {
        LengthIterator(obj : ITraversable[T])
      } else (iter, len)
    }

    public LengthIterator[T](this obj : ITraversable[T]) : IEnumerable[ITraversable[T]] * IEnumerable[int]
    {
      def child = SCG.Stack();
      def parent = SCG.Stack();
      def length = SCG.Stack();

      def loop_init()
      {
        if (child.IsEmpty()) () else 
        {
          def curr = child.Pop();
          parent.Push(curr);
          def len = child.PushLength(curr.GetChild());
          length.Push(len);
          //foreach (c in curr.GetChild()) child.Push(c);
          loop_init()
        }
      }

      child.Push(obj);
      loop_init();
      (parent, length)
    }

    public Iterator[T](this obj : ITraversable[T]) : IEnumerable[ITraversable[T]]
    {
      def child = SCG.Stack();
      def parent = SCG.Stack();

      def loop_init()
      {
        if (child.IsEmpty()) () else 
        {
          def curr = child.Pop();
          parent.Push(curr);
          foreach (c in curr.GetChild()) child.Push(c);
          loop_init()
        }
      }

      child.Push(obj);
      loop_init();
      parent
    }

    public static LevelOrderIterator[T](this obj : ICachedTraversable[T]) : IEnumerable[T]
    {
      def iter = obj.CachedLevelIterator;
      if (iter == null) 
      {
        LevelOrderIterator(obj : ITraversable[T])
      } else iter
    }

    public static LevelOrderIterator[T](this obj : ITraversable[T]) : IEnumerable[T]
    {
      def queue = SCG.Queue();
      queue.Enqueue(obj);

      def loop()
      {
        if (queue.IsEmpty()) () else
        {
          def node = queue.Dequeue();
          yield node.Current;
          foreach (s in node.GetChild()) queue.Enqueue(s);
          loop()
        }
      }

      loop()
    }

    public SingleElement[T](elem : T) : IEnumerable[T]
    {
      yield elem
    }

    public DoubleElement[T](elem1 : T, elem2 : T) : IEnumerable[T]
    {
      yield elem1;
      yield elem2;
    }

  }

  public variant Tree[T]
  {
    | Item {item : T;}
    | Section {sect : list[Tree[T]];}
  }

  public variant Path[T]
  {
    | Top
    | Node {node : list[Tree[T]]; path : Path[T]; tree : list[Tree[T]];}
  }

  [Record]
  public class Loc[T]
  {
    public tree : Tree[T];
    public path : Path[T];

    public Left() : Loc[T] 
    {
      match (path)
      {
        | Top => throw InvalidOperationException("left at top")
        | Node(l :: left, up, right) => Loc(l, Path.Node(left, up, tree :: right))
        | Node([], _, _) => throw InvalidOperationException("left of first")
      }
    }

    public Right() : Loc[T]
    {
      match (path)
      {
        | Top => throw InvalidOperationException("right at top")
        | Node(left, up, r :: right) => Loc(r, Path.Node(tree :: left , up, right))
        | _ => throw InvalidOperationException("right of last")
      }
    }

    public Up() : Loc[T]
    {

      match (path)
      {
        | Top => throw InvalidOperationException("up at top")
        | Node(left, up, right) => Loc(Tree.Section(left.Rev() + (tree :: right)), up)
      } 
    }

    public Down() : Loc[T]
    {
      match (tree)
      {
        | Item => throw InvalidOperationException("down with item")
        | Section(t1 :: trees) => Loc(t1, Path.Node([], path, trees))
        | _ => throw InvalidOperationException("down of empty")
      } 
    }

    public static Zipper(tree : Tree[T]) : Loc[T]
    {
      Loc(tree, Path.Top())
    }

    public Root : Tree[T]
    {
      get
      {
        def loop(l)
        {
          | Loc where (t, Path.Top) => t
          | _                       => loop(l.Up())
        }

        loop(this)
      }
    }

    public Change(t : Tree[T]) : Loc[T]
    {
      Loc(t, path)
    }

    public InsertRight(t : Tree[T]) : Loc[T]
    {
      match (path)
      {
        | Path.Top              => throw InvalidOperationException("insert at top")
        | Node(left, up, right) => Loc(t, Path.Node(left, up, t :: right))
      }
    }

    public InsertLeft(t : Tree[T]) : Loc[T]
    {
      match (path)
      {
        | Path.Top              => throw InvalidOperationException("insert at top")
        | Node(left, up, right) => Loc(t, Path.Node(t :: left, up, right))
      }
    }

    public InsertDown(t : Tree[T]) : Loc[T]
    {
      match (tree)
      {
        | Item       => throw InvalidOperationException("down with item")
        | Section(s) => Loc(t, Path.Node([], path, s))
      }
    }

    public Delete() : Loc[T]
    {
      match (path)
      {
        | Path.Top                   => throw InvalidOperationException("delete at top")
        | Node(left, up, r :: right) => Loc(r, Path.Node(left, up, right))
        | Node(l :: left, up, [])    => Loc(l, Path.Node(left, up, []))
        | Node([], up, [])           => Loc(Tree.Section([]), up)
      }
    }


  }

}
