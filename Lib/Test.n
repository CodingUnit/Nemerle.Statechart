using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of Test.
  /// </summary>
  public module Test
  {
    public module Tree
    {
      [Record]
      class Node[T]
      {
        public node : T;
        public childs : list[Node[T]];
        
        public override ToString() : string
        {
          $"$node, [..$childs]"
        }
      }
      
      public ReduceTest() : bool
      {
        def h = Node('h', [Node('i', [])]);
        def f = Node('f', [h, Node('g', [])]);
        def c = Node('c', [f]);
        def b = Node('b', [Node('d', []), Node('e', [])]);
        def tree = Node('a', [b, c, Node('j', [Node('k', [])])]);
        
        
        
        //def it = TreePostOrderEnumerable('a', x => if (map.ContainsKey(x)) map[x] else Enumerable.Empty());
        //def res = it.NToList();
        def modify_node(tree, childs)
        {
          Node((tree.node :> int + 1) :> char, childs.NToList())
        }
        
        def res = TreeUtils.Reduce(tree, _.childs, modify_node);
        def ok = res.ToString() == "b, [c, [e, [], f, []], d, [g, [i, [j, []], h, []]], k, [l, []]]";
        //ListUtils.EqualsValue(res, ['d', 'e', 'b', 'i', 'h', 'g', 'f', 'c', 'k', 'j', 'a']);
        
        ok
      }
    } 
  }
}
