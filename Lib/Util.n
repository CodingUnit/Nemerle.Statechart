using System;
using System.Diagnostics;
using Nemerle;
using Nemerle.Macros;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using System.ComponentModel;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  macro single_func(block)
  syntax ("single_func", block)
  {
    Utils.CreateSingleFunc(block)
  }

  macro wildcard()
  syntax ("__")
  {
    <[ ]>
  }


  macro @=.(first, second)
  syntax (first, "=.", second)
  {
    def (assign, end) = Utils.GetRetExpr(first, second);
    <[ 
    $assign;
      $end
    ]>
  }

  macro @%??(first, second)
  syntax (first, "%??", second)
  {
      <[ $first.WithDefault($second)]>
  }

  macro @obj_assign(obj, expr)
  syntax ("obj_assign", "(", obj, ")", expr)
  {
    Utils.CreateAssign(obj, expr)
  }

  module Utils
  {

    public attr_func(this f : IField, func : list[PExpr] -> bool) : bool
    {
      if (f is LibraryReference.ExternalFieldInfo) false else
      {
        def attr = f.GetModifiers().GetMacroAttributes();
        func(attr)
      }
    }

    public attr_func(this f : ClassMember.Field, func : list[PExpr] -> bool) : bool
    {
        def attr = f.ParsedAttributsAndModifiers.GetMacroAttributes();
        func(attr)
    }
    
    public CreateAssign(obj : PExpr, expr : PExpr) : PExpr
    {

      match (expr)
      {
        | <[ {..$expr} ]> => <[ {..$(expr.Map(CreateAssign(obj, _)))} ]>
        | <[ $(_ : name) ]> as f => <[ $f = $obj.$f ]>
        | _ => Message.Error("element must be PExpr.Ref"); <[ () ]>
      }
    }

    public CreateSingleFunc(block : PExpr) : PExpr
    {
      def create_res(x)
      {
        | <[ def $_ = $_ ]> => x
        | x => <[ def res = $x ]>
      }

      def process(_, after, expr)
      {
        match (after, expr)
        {
          | (true, <[ {..$lst} ]>) => def (last, lst) = lst.SplitLast();
              def lst = lst.Map(create_res) + [last];
                                      <[ {..$lst}]>
          | (true, PExpr.MacroCall(name = Name where (Id = "__"))) => <[ res ]>
          | (_, x) => x
        }
      }

      Macros.TraverseExpr(None(), block, false, process)
    }

    public GetRetExpr(first : PExpr, second : PExpr) : PExpr * PExpr
    {
      def assign = <[ $first = $second ]>;
      match (first, second)
      {
        | (_, <[ $(_ : name) ]>) => (assign, second)
        | (<[ $(_ : name) ]>, _) => (assign, first)
        | _ => def assign = <[
                             def res = $second;
                              $first = res;
                            ]>;
            (assign, <[ res ]>)
      }
    }

    public CreateConstrBody(type : string, pars : list[string], parms : list[string * string]) : PExpr
    {
      def inst_par(p, pars)
      {
        def ep = char.ToLower(p[0]).ToString() + p.Substring(1);
        match (pars.Find((x, _) => p == x))
        {
          | Some((_, n)) => <[ $(ep : usesite) = $(n : usesite) ]>
          | _            => <[ $(ep : usesite) = $(p : usesite) ]>
        }
      }

      def expr = pars.Map(inst_par(_, parms));
      <[ $(type : usesite)(..$expr) ]>
    }

    public CreateNewInst(typebuilder : TypeBuilder, type : PExpr, parms : PExpr) : PExpr
    {
      def split(p)
      {
        | <[ $(x : name) = $(y : name) ]> => (x.Id, y.Id)
        | _             => Message.Error(p.Location, "Unknown expression for new_inst assignment"); ("", "")
      }

      def unseq(p)
      {
        match (p)
        {
          | <[ {..$seq} ]> 
          | <[ (..$seq) ]> => seq
          | x              => [x]
        }
      }


      def have_record_ignore(f : IField)
      {
        f.attr_func(x => x.Exists(_ is <[ RecordIgnore ]>))
      }



      def def_constr(cur_type)
      {
        def opt = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
        def fields = cur_type.GetFields(opt);
        def fields = fields.Exclude(x => attr_func(x, x => x.Exists(_ is <[ RecordIgnore ]>) && !x.Exists(_ is <[ NeedChange ]>)));
        def pars = fields.Map(_.Name);
        def parms = unseq(parms);
        def parms = parms.Map(split);
        CreateConstrBody(cur_type.Name, pars, parms)
      }

      //assert2(false);
      def cur_type = typebuilder;
      def type = type?.ToString();
      match (cur_type.GetVariantOptions())
      {
        | [] => def cur_type = if (type == null) cur_type else
                                {
                                  if (cur_type.Name == type) cur_type else 
                                  {
                                    def cur_type = cur_type.GetVariantOptionParent();
                                    if (type == cur_type.Name) cur_type else 
                                      match (cur_type.GetVariantOptions().Find(x => x.Name == type))
                                      {
                                        | Some(t) => t
                                        | _       => Message.Error($"Cannot find the '$type' type");null
                                      }
                                  }
                                }

            if (cur_type != null) def_constr(cur_type) else <[]>

        | lst => 

            def def_opts(o)
            {
              def opt = BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.NonPublic;
              def fields = o.GetFields(opt);
              def fields = fields.Exclude(have_record_ignore);
              def names = fields.Map(x => <[ $(x.Name : usesite) ]>);
              def body = def_constr(o);
              <[case: | $(o.Name : usesite)(..$names) => $body ]>
            }

            def expr = lst.Map(def_opts);
            <[
            match (this)
            {
              ..$expr
            }
            ]>
      }     
    }
  }


  macro @^&(type, parms)
  syntax (type, "^&", "(", parms,")")
  {
    //assert2(false);
    Utils.CreateNewInst(Macros.ImplicitCTX().CurrentTypeBuilder, type, parms)
  }

}
