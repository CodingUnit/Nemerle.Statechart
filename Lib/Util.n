using System;
using System.Diagnostics;
using Nemerle;
using Nemerle.Macros;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using System.ComponentModel;

namespace Nemerle.Statechart
{

  macro single_func(block)
  syntax ("single_func", block)
  {
    Utils.CreateSingleFunc(block)
  }

  macro wildcard()
  syntax ("__")
  {
    <[ ]>
  }
  
  
  macro @=.(first, second)
  syntax (first, "=.", second)
  {
    def (assign, end) = Utils.GetRetExpr(first, second);
    <[ 
    $assign;
      $end
    ]>
  }

  macro @%??(first, second)
  syntax (first, "%??", second)
  {
      <[ $first.WithDefault($second)]>
  }

  macro @obj_assign(obj, expr)
  syntax ("obj_assign", "(", obj, ")", expr)
  {
    Utils.CreateAssign(obj, expr)
  }
  
  module Utils
  {
   
    public CreateAssign(obj : PExpr, expr : PExpr) : PExpr
    {
      
      match (expr)
      {
        | <[ {..$expr} ]> => <[ {..$(expr.Map(CreateAssign(obj, _)))} ]>
        | <[ $(_ : name) ]> as f => <[ $f = $obj.$f ]>
        | _ => Message.Error("element must be PExpr.Ref"); <[ () ]>
      }
    }
    
    public CreateSingleFunc(block : PExpr) : PExpr
    {
      def create_res(x)
      {
        | <[ def $_ = $_ ]> => x
        | x => <[ def res = $x ]>
      }
      
      def process(_, after, expr)
      {
        match (after, expr)
        {
          | (true, <[ {..$lst} ]>) => def (last, lst) = lst.SplitLast();
              def lst = lst.Map(create_res) + [last];
                                      <[ {..$lst}]>
          | (true, PExpr.MacroCall(name = Name where (Id = "__"))) => <[ res ]>
          | (_, x) => x
        }
      }
      
      Macros.TraverseExpr(None(), block, false, process)
    }
    
    public GetRetExpr(first : PExpr, second : PExpr) : PExpr * PExpr
    {
      def assign = <[ $first = $second ]>;
      match (first, second)
      {
        | (_, <[ $(_ : name) ]>) => (assign, second)
        | (<[ $(_ : name) ]>, _) => (assign, first)
        | _ => def assign = <[
                              def res = $second;
                              $first = res;
                            ]>;
            (assign, <[ res ]>)
      }
    }
    
    public CreateConstrBody(type : string, pars : list[string], parms : list[string * string]) : PExpr
    {
      def inst_par(p, pars)
      {
        def ep = char.ToLower(p[0]).ToString() + p.Substring(1);
        match (pars.Find((x, _) => p == x))
        {
          | Some((_, n)) => <[ $(ep : usesite) = $(n : usesite) ]>
          | _            => <[ $(ep : usesite) = $(p : usesite) ]>
        }
      }
      
      def expr = pars.Map(inst_par(_, parms));
      <[ $(type : usesite)(..$expr) ]>
    }
    
    public CreateNewInst(typebuilder : TypeBuilder, type : PExpr, parms : list[PExpr]) : PExpr
    {
      def split(p)
      {
        | <[ $(x : name) = $(y : name) ]> => (x.Id, y.Id)
        | _             => Message.Error(p.Location, "Unknown expression for new_inst assignment"); ("", "")
      }

      def unseq(p)
      {
        | <[ {..$seq} ]> => seq
        | <[ (..$seq) ]> => seq
        | x              => [x]
      }
      
      def def_constr(cur_type)
      {
        //def constr = cur_type.GetConstructors();
        def opt = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
        def fields = cur_type.GetFields(opt);
        //match (constr.Find(x => x.GetParameters().Length == fields.Length))
        //{
              def pars = fields.Map(_.Name);//c.GetParameters().Map(_.Name);
              def parms = parms.Map(unseq).Flatten();
              def parms = parms.Map(split);
              CreateConstrBody(cur_type.Name, pars, parms)
          //| _ => Message.Error("Cannot find right constructor for new_inst");
                 //<[ () ]>
        //}
      }
      
      //assert2(false);
      def cur_type = typebuilder;
      def type = type?.ToString();
      match (cur_type.GetVariantOptions())
      {
        | [] => def cur_type = if (type == null) cur_type else
                {
                  if (cur_type.Name == type) cur_type else 
                  {
                    def cur_type = cur_type.GetVariantOptionParent();
                    if (type == cur_type.Name) cur_type else 
                    match (cur_type.GetVariantOptions().Find(x => x.Name == type))
                      {
                        | Some(t) => t
                        | _       => Message.Error($"Cannot find the '$type' type");null
                      }
                  }
                }
                
            if (cur_type != null) def_constr(cur_type) else <[]>
            
        | lst => 
        
            def def_opts(o)
            {
              def opt = BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.NonPublic;
              def fields = o.GetFields(opt);
              def names = fields.Map(x => <[ $(x.Name : usesite) ]>);
              def body = def_constr(o);
              <[case: | $(o.Name : usesite)(..$names) => $body ]>
            }
        
            def expr = lst.Map(def_opts);
            <[
            match (this)
            {
              ..$expr
            }
            ]>
      }     
    }
  }
  
  public variant Tree[T]
  {
    | Item {item : T;}
    | Section {sect : list[Tree[T]];}
  }
  
  public variant Path[T]
  {
    | Top
    | Node {node : list[Tree[T]]; path : Path[T]; tree : list[Tree[T]];}
  }
  
  [Record]
  public class Loc[T]
  {
    tree : Tree[T];
    path : Path[T];
    
    
    public left() : Loc[T] 
    {
      match (path)
      {
        | Top => throw InvalidOperationException("left at top")
        | Node(l :: left, up, right) => Loc(l, Path.Node(left, up, tree :: right))
        | Node([], _, _) => throw InvalidOperationException("left of first")
      }
    }
 
    public right() : Loc[T]
    {
      match (path)
      {
        | Top => throw InvalidOperationException("right at top")
        | Node(left, up, r :: right) => Loc(r, Path.Node( tree :: left , up, right))
        | _ => throw InvalidOperationException("right of last")
      }
    }
    
    public up() : Loc[T]
    {
 
      match (path)
      {
        | Top => throw InvalidOperationException("up at top")
        | Node(left, up, right) => Loc(Tree.Section(left.Rev() + (tree :: right)), up)
      } 
    }
    
    public down() : Loc[T]
    {
      match (tree)
      {
        | Item => throw InvalidOperationException("down with item")
        | Section(t1 :: trees) => Loc(t1, Path.Node([], path, trees))
        | _ => throw InvalidOperationException("down of empty")
      } 
    }
    
  }
  
  
  macro @^&(type, params parms : list[PExpr])
  syntax (type, "^&", "(", parms,")")
  {
    //assert2(false);
    Utils.CreateNewInst(Macros.ImplicitCTX().CurrentTypeBuilder, type, parms)
  }
}
