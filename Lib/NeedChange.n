using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Field)]
  macro NeedChange(typeBuilder : TypeBuilder, field : FieldBuilder, params pars : list[PExpr])
  {
    NeedChangeImpl.DoTransform(Macros.ImplicitCTX(), typeBuilder, field, pars)
  }
  
  module NeedChangeImpl
  {
    public DoTransform(typer : Typer, typeBuilder : TypeBuilder, field : FieldBuilder, aliases : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      //assert2(false);
      
      //def constr = typeBuilder.GetConstructors();
      
      def get_short_name(name)
      {
        def len = name.Length;
        def end = match (len)
        {
          | 1 => 1
          | 2 => 1
          | x when x > 4 => 4
          | _ => 2
        }
        name.Substring(0, end)
      }
      
      def to_camel(s)
      {
        def str = Char.ToUpper(s[0]).ToString() + s.Substring(1);
        def idx = str.IndexOf('_');
        if (idx != -1)
        {
          def rem = str.Substring(idx, 2);
          def rep = Char.ToUpper(rem[1]).ToString();
          str.Replace(rem, rep)
        } else str
      }

      
      
      def create_cons(t, f : IField)
      {
        
        def fields = t.GetFields(BindingFlags.Public | BindingFlags.Instance).Rev();
        def fields = f :: fields.Filter(x => aliases.Exists(y => y.ToString() == x.Name));
        def names = fields.Map(_.Name);
        def cnames = names.Map(to_camel);
        def fname = string.Join("", cnames);
        def name = $"Change$fname";
        def sname = fields.Map(x => (get_short_name(x.Name), x.GetMemType()));
        def sname = sname.Map((x, t) => <[ parameter: $(x : usesite) : $(t : typed) ]>);
        def clist = names.Map(x => (x, get_short_name(x)));
        def type = t.GetMemType();
        def clist = clist.Map((x, y) => <[ $(x : usesite) = $(y : usesite) ]>);
        def body = Utils.CreateNewInst(t, null, clist);
                  t.Define(<[ decl: public $(name : usesite)(..$sname) : $(type : typed)
                      {
                        $body
                      }]>);
        
      }
      //match (constr.Find(x => x.GetParameters().Map(x => x.Name).Equals(fields, (x, y) => string.Compare(x, y.Name, StringComparison.CurrentCultureIgnoreCase) == 0)))
      //{
        //| Some => 
                  
                  
                  //def pars = c.GetParameters().Map(_.Name);
                  def opt = typeBuilder.GetVariantOptions();
                  
                  match (opt)
                  {
                    | [] => create_cons(typeBuilder, field)
                    | lst => 
                      create_cons(typeBuilder, field);
                      lst.Iter(create_cons(_, field))
                  }
                  
        //| _ => Message.Error("Cannot find right constructor for NeedChange")
      //}
      
      // TODO: Add implementation here.
      _ = typeBuilder; _ = field;
    }
  }
}
