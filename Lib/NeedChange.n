using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Field)]
  macro NeedChange(typeBuilder : TypeBuilder, field : FieldBuilder, params pars : list[PExpr])
  {
    NeedChangeImpl.DoTransform(Macros.ImplicitCTX(), typeBuilder, field, pars)
  }

  module NeedChangeImpl
  {
    public DoTransform(typer : Typer, typeBuilder : TypeBuilder, field : FieldBuilder, aliases : list[PExpr]) : void
    {
      Macros.DefineCTX(typer);
      //assert2(false);

      def get_short_name(name)
      {
        def len = name.Length;
        def end = match (len)
                   {
                     | 1 => 1
                     | 2 => 1
                     | x when x > 4 => 4
                     | _ => 2
                   }
        name.Substring(0, end)
      }

      def to_camel(s)
      {
        def str = Char.ToUpper(s[0]).ToString() + s.Substring(1);
        def idx = str.IndexOf('_');
        if (idx != -1)
        {
          def nstr =  str.Substring(idx + 1);
          str.Substring(0, idx) + to_camel(nstr)
        } else str
      }


      def have_record_ignore(f : IField)
      {
        if (f is LibraryReference.ExternalFieldInfo) false else
        {
          def attr = f.GetModifiers().GetMacroAttributes();
          attr.Exists(_ is <[ RecordIgnore ]>);
        }
      }
      
      //def define_explicit_constr(_f)
      {
        //def _ = field :: f.Exclude(x => have_record_ignore(x));
        //CreateConstrBody(cur_type.Name, pars, parms)
        
      //match (typeBuilder.GetVariantOptions())
      //{
      //  | [] => def cur_type = if (type == null) cur_type else
      //          {
      //            if (cur_type.Name == type) cur_type else 
      //            {
      //              def cur_type = cur_type.GetVariantOptionParent();
      //              if (type == cur_type.Name) cur_type else 
      //              match (cur_type.GetVariantOptions().Find(x => x.Name == type))
      //              {
      //                | Some(t) => t
      //                | _       => Message.Error($"Cannot find the '$type' type");null
      //              }
      //            }
      //          }
                
      //      if (cur_type != null) def_constr(cur_type) else <[]>
            
      //  | lst => 
        
      //      def def_opts(o)
      //      {
      //        def opt = BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.NonPublic;
      //        def fields = o.GetFields(opt);
      //        def names = fields.Map(x => <[ $(x.Name : usesite) ]>);
      //        def body = def_constr(o);
      //        <[case: | $(o.Name : usesite)(..$names) => $body ]>
      //      }
        
      }
      
      def create_cons(t, f : IField)
      {

        def fields = t.GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic).Rev();
        def fields = fields.Exclude(have_record_ignore);
        def fields = f :: fields.Filter(x => aliases.Exists(y => y.ToString() == x.Name));
        def names = fields.Map(x => (x.Name, x.GetMemType()));
        def cnames = names.Map((x, _) => to_camel(x));
        def fname = string.Join("", cnames);
        def name = $"Change$fname";
        def sname = names.Map((x, y) => (get_short_name(x), y));
        def sname = sname.Map((x, t) => <[ parameter: $(x : usesite) : $(t : typed) ]>);
        def chlist = names.Map((x, y) => (x, get_short_name(x), y));
        def type = t.GetMemType();

        def clist = chlist.Map((x, y, _) => <[ $(x : usesite) = $(y : usesite) ]>);
        def body = Utils.CreateNewInst(t, null, <[ {..$clist} ]>);
        def check_list = chlist.Map((x, y, t) => if (t.IsValueType) <[ $(x : usesite) != $(y : usesite) ]> else <[ $(x : usesite) : object != $(y : usesite) ]>);
        def check = check_list.FoldLeft(<[ false ]>, (x, a) => <[ $x || $a ]>);
        t.Define(<[ decl: public $(name : usesite)(..$sname) : $(type : typed)
            {
              if ($check) $body else this
            }]>);
        //when (have_record_ignore(f))    
        //{
        //  define_explicit_constr(fields)
        //}
      }
      
      match (typeBuilder.GetVariantOptions())
      {
        | [] => create_cons(typeBuilder, field)
        | lst => 
            create_cons(typeBuilder, field);
            lst.Iter(create_cons(_, field))
      }

      // TODO: Add implementation here.
      _ = typeBuilder; _ = field;
    }
  }
}
