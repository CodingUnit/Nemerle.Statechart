
rule CreateTranPath()
{
	src:ActiveState -t:StateTransition-> tar:ActiveState;

	//src:State -t:StateTransition-> tar:State;

	//if {t.id == t2.id;}

	 def lca : State;
	
	 yield {yield lca = t.lca.peek(0);}
	// lca : State;
	// :LCA(src, tar, lca);
	ex:ExitNodes(src, CalcTranNodes(src, lca));

	modify
	{		
		def res : Path;
		
		src -t->! nlca:Lca -:TransitionPath-> tar;
		
		eval
		{
			nlca.name = lca.name;
		}
		
		ex(nlca, yield res);
	}






}

pattern GetActive(var id : set<int>, var idx : int, def ret : set<ActiveState>)
{
	(
	
		if {idx == id.size();}
	|
		if {idx != id.size();}
		
		st:ActiveState;
		if {st.id == id;}
		
		modify
		{
			eval
			{
				ret.add(st);
			}
		}
	)
	
}

function CalcTranNodes(src : ActiveState, lca : State) : set<int>
{
	def ref res : set<int> = set<int>{};
	emit("res", res);
	def ref in_tran_nodes : set<State> = src.contains & lca.sub_states;
	emit("in_tran_nodes", in_tran_nodes);
	for (st : State in in_tran_nodes)
	{
		emit("st", st);
		res.add(st.id);
	}
	emit("res", res);
	return (res);
}

pattern ExitNodes(st : ActiveState, ref nodes : set<int>) modify(parent : Path, def res : Path)
{
	if {st.id in nodes;}
	
	iterated
	{
		st -:And-> child:ActiveState;
		
		t:ExitNodes(child, nodes);
		
		modify
		{
			t(e, yield res);
		}
		
	}
	
	modify
	{
		e:StateExit@(name = st.name) -:TransitionPath-> parent;
		
		eval
		{
			yield res = e;
		}
	}
}




