rule CreateLcaTran()
{
	src:ActiveState -t:StateTransition \ ActiveStateTransition-> tar:ActiveState;
	
	//if {!t.lca.empty();}
	if {typeof(t) != GroupConfigTransition;}
	def lca : State;
	def ref src_lca_conf : set<ActiveState> = set<ActiveState>{};
	def ref tar_lca_conf : set<ActiveState> = set<ActiveState>{};
	
	
	yield {yield lca 		  = t.lca.peek(0);}
	yield {yield src_lca_conf = FindActiveState(src, lca);}
	yield {yield tar_lca_conf = FindActiveState(tar, lca);}
		
	//:FindActiveState(src, t.lca.peek(0), yield lca_conf);
	//:FindActiveState(tar, lca.id, yield tar_lca_conf);
	
	modify
	{
		src -tr:ActiveStateTransition<t>-> tar;

		eval
		{			
			if (!tar_lca_conf.empty() && !src_lca_conf.empty())
			{
				def ssrc_lca : ActiveState = src_lca_conf.peek(0);
				def ttar_lca : ActiveState = tar_lca_conf.peek(0);
				tr.lca_conf = ssrc_lca.sub_conf | ttar_lca.sub_conf;
			}
			
		}
	}
}


function FindActiveState(src : ActiveState, find : State) : set<ActiveState>
{
	for (st : ActiveState in reachableOutgoing(src, And))
	{
		if (st.id == find.id)
		{
			return (set<ActiveState>{st});
		}
	}
	return (set<ActiveState>{});
}

rule CreateTranPath()
{
	src:ActiveState -t:ActiveStateTransition-> tar:ActiveState;

	//src:State -t:StateTransition-> tar:State;

	//if {t.id == t2.id;}

	def lca : State;
	def ref lca_conf : set<ActiveState>;
	yield {yield lca = t.lca.peek(0);yield lca_conf = t.lca_conf;}
	// lca : State;
	// :LCA(src, tar, lca);
	//ex:ExitNodes(src, t.lca_conf);	
	
	modify
	{		
		//def res : Path;
		nlca:Lca@(name = lca.name);
		
		
		// eval
		// {
			// nlca.name = lca.name;
		// }
		
		def first : Path;
		def last : Path;
		evalhere
		{			
			def ref exit_nodes  : set<ActiveState> 	  = src.contains_conf & t.lca_conf;
			def ref entry_nodes  : set<ActiveState>   = tar.contains_conf & t.lca_conf;
			def ref sorted_exit : array<ActiveState>  = SortByDepthAsc(exit_nodes);
			def ref sorted_entry : array<ActiveState> = SortByDepthAsc(entry_nodes);
			(yield first) = AddPath(nlca, sorted_exit, false);
			(yield last) = AddPath(nlca, sorted_entry, true);
		}
		//emit("prev", prev);
		src -t->! first;
		last -:Next-> tar;
		//delete(t);
		
		/*

int tmp;
bool noSwap;

for (int i = N - 1; i >= 0; i--)
{
    noSwap = 1;
    for (int j = 0; j < i; j++)
    {
        if (mass[j] > mass[j + 1])
        {
            tmp = mass[j];
            mass[j] = mass[j + 1];
            mass[j + 1] = tmp;
            noSwap = 0;
        }
    }
    if (noSwap == 1)
        break;
}
		*/
	}






}

procedure AddPath(src : Path, ref nodes : array<ActiveState>, var from : boolean) : (Path)
{
	def prev : Path = src;
	for (st : ActiveState in nodes)
	{
		//e:StateExit@(name = st.name) -:TransitionPath-> prev;
		def n : Path;
		if (from)
		{
			(n) = add(StateEntry);
			add(Next, prev, n);		
		} else
		{
			(n) = add(StateExit);
			add(Next, n, prev);		
		}
		n.name = st.name;
		prev = n;
		//emit("prev", prev);
	}
	//emit("prev", prev);
	return (prev);
}

function SortByDepthDesc(ref data : set<ActiveState>) : array<ActiveState>
{
	def ref res : array<ActiveState> = data.asArray();
	
	def tmp : ActiveState;
	def var noSwap : boolean;

	for (i : ActiveState in res)
	{
		noSwap = true;
		for (j : int -> s : ActiveState in res)
		{
			if (j != res.size() - 1)
			{
				if (res[j].depth < res[j + 1].depth)
				{
					tmp = res[j];
					res[j] = res[j + 1];
					res[j + 1] = tmp;
					noSwap = false;
				}
			}
		}
		if (noSwap)
		{
			return (res);
		}
	}
	return (res);
}

function SortByDepthAsc(ref data : set<ActiveState>) : array<ActiveState>
{
	def ref res : array<ActiveState> = data.asArray();
	
	def tmp : ActiveState;
	def var noSwap : boolean;

	for (i : ActiveState in res)
	{
		noSwap = true;
		for (j : int -> s : ActiveState in res)
		{
			if (j != res.size() - 1)
			{
				if (res[j].depth > res[j + 1].depth)
				{
					tmp = res[j];
					res[j] = res[j + 1];
					res[j + 1] = tmp;
					noSwap = false;
				}
			}
		}
		if (noSwap)
		{
			return (res);
		}
	}
	return (res);
}

pattern AddActionLca(path : Path, var action : string)
{
	(
		l:Lca<path>;
		path -e:Next-> p:Node \ StateAction;
		
		modify
		{
			path -e->! a:StateAction -:Next-> p;
			eval {a.name = action;}
			//@(name = action)
		}		
	|
		~(:Lca<path>;)
		path -:Next-> next:Path;
		
		t:AddActionLca(next, action);
		
		modify
		{
			t();
		}
	)
	
	modify {}
}

rule AddActions()
{
		src:ActiveState -t:ActiveStateTransition-> path:Path;
		
		if {t.action.length() != 0;}
			
		add:AddActionLca(path, t.action);
		
		modify
		{
			add();
		}
}

rule AddGuards()
{
	src:ActiveState -t:ActiveStateTransition-> path:Path \ GuardCheck;
	if {t.guard.length() != 0;}
		
	modify
	{
		src -t->! :GuardCheck@(name = t.guard) -:True-> path;		
	}
}


