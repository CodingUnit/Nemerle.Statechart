
rule CreateTranPath()
{
	src:ActiveState -t:StateTransition-> tar:ActiveState;

	//src:State -t:StateTransition-> tar:State;

	//if {t.id == t2.id;}


	lca : State;
	:LCA(src, tar, lca);


	modify
	{		
		src -t->! lca -:TransitionPath-> tar;
	}






}


pattern ExitNodes(st : ActiveState, ref nodes : set<int>, parent : Path) modify(def res : Path)
{
	if {st.id in nodes;}
	
	iterated
	{
		st -:And-> child:ActiveState;
		
		t:ExitNodes(child, nodes, e);
		
		modify
		{
			t(yield res);
		}
		
	}
	
	modify
	{
		e:StateExit@(name = st.name) -:TransitionPath-> parent;
		
		eval
		{
			yield res = e;
		}
	}
}




