rule CreateLcaTran()
{
	src:ActiveState -t:StateTransition \ ActiveStateTransition-> tar:ActiveState;
	
	//if {!t.lca.empty();}
	if {typeof(t) != GroupConfigTransition;}
	def lca : State;
	def ref src_lca_conf : set<ActiveState> = set<ActiveState>{};
	def ref tar_lca_conf : set<ActiveState> = set<ActiveState>{};
	
	
	yield {yield lca 		  = t.lca.peek(0);}
	yield {yield src_lca_conf = FindActiveState(src, lca);}
	yield {yield tar_lca_conf = FindActiveState(tar, lca);}
		
	//:FindActiveState(src, t.lca.peek(0), yield lca_conf);
	//:FindActiveState(tar, lca.id, yield tar_lca_conf);
	
	modify
	{
		src -tr:ActiveStateTransition<t>-> tar;

		eval
		{			
			if (!tar_lca_conf.empty() && !src_lca_conf.empty())
			{
				def ssrc_lca : ActiveState = src_lca_conf.peek(0);
				def ttar_lca : ActiveState = tar_lca_conf.peek(0);
				tr.lca_conf = ssrc_lca.sub_conf | ttar_lca.sub_conf;
			}
			
		}
	}
}


function FindActiveState(src : ActiveState, find : State) : set<ActiveState>
{
	for (st : ActiveState in reachableOutgoing(src, And))
	{
		if (st.id == find.id)
		{
			return (set<ActiveState>{st});
		}
	}
	return (set<ActiveState>{});
}

rule CreateTranPath()
{
	src:ActiveState -t:ActiveStateTransition-> tar:ActiveState;

	//src:State -t:StateTransition-> tar:State;

	//if {t.id == t2.id;}

	def lca : State;
	def ref lca_conf : set<ActiveState>;
	yield {yield lca = t.lca.peek(0);yield lca_conf = t.lca_conf;}
	// lca : State;
	// :LCA(src, tar, lca);
	//ex:ExitNodes(src, t.lca_conf);
	
	modify
	{		
		//def res : Path;
		nlca:Lca@(name = lca.name);
		
		
		// eval
		// {
			// nlca.name = lca.name;
		// }
		
		def first : Path;
		def last : Path;
		evalhere
		{			
			def ref exit_nodes  : set<ActiveState> 	  = src.contains_conf & t.lca_conf;
			def ref entry_nodes  : set<ActiveState>   = tar.contains_conf & t.lca_conf;
			def ref sorted_exit : array<ActiveState>  = SortByDepthAsc(exit_nodes);
			def ref sorted_entry : array<ActiveState> = SortByDepthAsc(entry_nodes);
			(yield first) = AddPath(nlca, sorted_exit, false);
			(yield last) = AddPath(nlca, sorted_entry, true);
		}
		//emit("prev", prev);
		src -t->! first;
		last -:Next-> tar;
		//delete(t);
		
		/*

int tmp;
bool noSwap;

for (int i = N - 1; i >= 0; i--)
{
    noSwap = 1;
    for (int j = 0; j < i; j++)
    {
        if (mass[j] > mass[j + 1])
        {
            tmp = mass[j];
            mass[j] = mass[j + 1];
            mass[j + 1] = tmp;
            noSwap = 0;
        }
    }
    if (noSwap == 1)
        break;
}
		*/
	}






}

procedure AddPath(src : Path, ref nodes : array<ActiveState>, var from : boolean) : (Path)
{
	def prev : Path = src;
	for (st : ActiveState in nodes)
	{
		//e:StateExit@(name = st.name) -:TransitionPath-> prev;
		def n : Path;
		if (from)
		{
			(n) = add(StateEntry);
			add(Next, prev, n);		
		} else
		{
			(n) = add(StateExit);
			add(Next, n, prev);		
		}
		n.name = st.name;
		prev = n;
		emit("prev", prev);
	}
	emit("prev", prev);
	return (prev);
}

function SortByDepthDesc(ref data : set<ActiveState>) : array<ActiveState>
{
	def ref res : array<ActiveState> = data.asArray();
	
	def tmp : ActiveState;
	def var noSwap : boolean;

	for (i : ActiveState in res)
	{
		noSwap = true;
		for (j : int -> s : ActiveState in res)
		{
			if (j != res.size() - 1)
			{
				if (res[j].depth < res[j + 1].depth)
				{
					tmp = res[j];
					res[j] = res[j + 1];
					res[j + 1] = tmp;
					noSwap = false;
				}
			}
		}
		if (noSwap)
		{
			return (res);
		}
	}
	return (res);
}

function SortByDepthAsc(ref data : set<ActiveState>) : array<ActiveState>
{
	def ref res : array<ActiveState> = data.asArray();
	
	def tmp : ActiveState;
	def var noSwap : boolean;

	for (i : ActiveState in res)
	{
		noSwap = true;
		for (j : int -> s : ActiveState in res)
		{
			if (j != res.size() - 1)
			{
				if (res[j].depth > res[j + 1].depth)
				{
					tmp = res[j];
					res[j] = res[j + 1];
					res[j + 1] = tmp;
					noSwap = false;
				}
			}
		}
		if (noSwap == true)
		{
			return (res);
		}
	}
	return (res);
}
// pattern GetActive(var id : set<int>, var idx : int, def ret : set<ActiveState>)
// {
	// (
	
		// if {idx == id.size();}
	// |
		// if {idx != id.size();}
		
		// st:ActiveState;
		// if {st.id == id;}
		
		// modify
		// {
			// eval
			// {
				// ret.add(st);
			// }
		// }
	// )
	
// }

function CalcTranNodes(src : ActiveState, lca : State) : set<int>
{
	def ref res : set<int> = set<int>{};
	emit("res", res);
	def ref in_tran_nodes : set<State> = src.contains & lca.sub_states;
	emit("in_tran_nodes", in_tran_nodes);
	for (st : State in in_tran_nodes)
	{
		emit("st", st);
		res.add(st.id);
	}
	emit("res", res);
	return (res);
}

// pattern ExitNodes(st : ActiveState, ref nodes : set<ActiveState>) modify(parent : Path, def res : Path)
// {
	// iterated
	// {
		// st -:And-> child:ActiveState;
		
		// t:ExitNodes(child, nodes);
		
		// modify
		// {
			// t(res, yield res);
		// }
		
	// }
		
	// (
		// ~(if {st in nodes;})
		
		
		
		// modify
		// {
			// //e:StateExit@(name = st.name) -:TransitionPath-> parent;
			
			// // eval
			// // {
				// // //yield cur = e;
				// // yield res = e;
			// // }
		// }
	// |
		// if {st in nodes;}
		
		// //def cur : ActiveState;
		
		// // iterated
		// // {
			// // st -:And-> child:ActiveState;
			
			// // t:ExitNodes(child, nodes);
			
			// // modify
			// // {
				// // t(res, yield res);
			// // }
			
		// // }
		
		// modify
		// {
			// e:StateExit@(name = st.name) -:TransitionPath-> parent;
			
			// eval
			// {
				// //yield cur = e;
				// yield res = e;
			// }
		// }
	// )
	
	// modify
	// {
	// }
// }




