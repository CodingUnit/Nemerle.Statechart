rule CreateLcaTran()
{
	src:ActiveState -t:StateTransition-> tar:ActiveState;
	
	//if {!t.lca.empty();}
	if {typeof(t) != ActiveStateTransition && typeof(t) != GroupConfigTransition;}
	def lca : State;
	def ref lca_conf : set<ActiveState> = set<ActiveState>{};
	def ref tar_lca_conf : set<ActiveState> = set<ActiveState>{};
	
	
	yield {yield lca 		  = t.lca.peek(0);}
	yield {yield lca_conf 	  = FindActiveState(src, lca);}
	yield {yield tar_lca_conf = FindActiveState(tar, lca);}
		
	//:FindActiveState(src, t.lca.peek(0), yield lca_conf);
	//:FindActiveState(tar, lca.id, yield tar_lca_conf);
	
	modify
	{
		src -tr:ActiveStateTransition<t>-> tar;

		
		eval
		{
			def ref src_lca : set<ActiveState> = set<ActiveState>{};
			def ref tar_lca : set<ActiveState> = set<ActiveState>{};
			if (!tar_lca_conf.empty() && !lca_conf.empty())
			{
				def ssrc_lca : ActiveState = lca_conf.peek(0);
				def ttar_lca : ActiveState = tar_lca_conf.peek(0);
				//src_lca.contains_conf | tar_lca.contains_conf;
				src_lca = ssrc_lca.contains_conf;
				tar_lca = ttar_lca.contains_conf;
			}
			tr.lca_conf = src_lca | tar_lca;
		}
	}
}


function FindActiveState(src : ActiveState, find : State) : set<ActiveState>
{
	for (st : ActiveState in reachableOutgoing(src, And))
	{
		if (st.id == find.id)
		{
			return (set<ActiveState>{st});
		}
	}
	return (set<ActiveState>{});
	// (
		// if {src.id == st.id;}
		
		// yield {yield ret = src;}
	// |
		// if {src.id != st.id;}
		
		// src -:And-> child:ActiveState;
		
		// :FindActiveState(src, st, yield ret);
	// )
}

rule CreateTranPath()
{
	src:ActiveState -t:ActiveStateTransition-> tar:ActiveState;

	//src:State -t:StateTransition-> tar:State;

	//if {t.id == t2.id;}

	def lca : State;
	def ref lca_conf : set<State>;
	yield {yield lca = t.lca.peek(0);lca_conf = t.lca_conf;}
	// lca : State;
	// :LCA(src, tar, lca);
	//ex:ExitNodes(src, t.lca_conf);

	modify
	{		
		//def res : Path;
		
		src -t->! nlca:Lca -:TransitionPath-> tar;
		
		eval
		{
			nlca.name = lca.name;
		}
		
		
		eval
		{
			def prev : Path = nlca;
			for (st : ActiveState in lca_conf)
			{
				//e:StateExit@(name = st.name) -:TransitionPath-> prev;
				add(StateExit);
				add();
				prev = e;
			}
		}
		//ex(nlca, yield res);
		/*
		ЦИКЛ ДЛЯ J=1 ДО N-1 ШАГ 1                       FOR J=1 TO N-1 STEP 1
   F=0                                             F=0 
   ЦИКЛ ДЛЯ I=1 ДО N-J ШАГ 1                       FOR I=1 TO N-J STEP 1 
     ЕСЛИ A[I] > A[I+1] ТО ОБМЕН A[I],A[I+1]:F=1     IF A[I]>A[I+1] THEN SWAP A[I],A[I+1]:F=1
   СЛЕДУЮЩЕЕ I                                     NEXT I  
   ЕСЛИ F=0 ТО ВЫХОД ИЗ ЦИКЛА                      IF F=0 THEN EXIT FOR
 СЛЕДУЮЩЕЕ J                                     NEXT J
		*/
	}






}

// pattern GetActive(var id : set<int>, var idx : int, def ret : set<ActiveState>)
// {
	// (
	
		// if {idx == id.size();}
	// |
		// if {idx != id.size();}
		
		// st:ActiveState;
		// if {st.id == id;}
		
		// modify
		// {
			// eval
			// {
				// ret.add(st);
			// }
		// }
	// )
	
// }

function CalcTranNodes(src : ActiveState, lca : State) : set<int>
{
	def ref res : set<int> = set<int>{};
	emit("res", res);
	def ref in_tran_nodes : set<State> = src.contains & lca.sub_states;
	emit("in_tran_nodes", in_tran_nodes);
	for (st : State in in_tran_nodes)
	{
		emit("st", st);
		res.add(st.id);
	}
	emit("res", res);
	return (res);
}

pattern ExitNodes(st : ActiveState, ref nodes : set<ActiveState>) modify(parent : Path, def res : Path)
{
	if {st in nodes;}
	
	//def cur : ActiveState;
	
	iterated
	{
		st -:And-> child:ActiveState;
		
		t:ExitNodes(child, nodes);
		
		modify
		{
			t(res, yield res);
		}
		
	}
	
	modify
	{
		e:StateExit@(name = st.name) -:TransitionPath-> parent;
		
		eval
		{
			//yield cur = e;
			yield res = e;
		}
	}
}




