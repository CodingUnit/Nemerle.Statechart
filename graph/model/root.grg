// graph rewrite rule file, shows how to define a model to use, and how a rule looks like,
// with the pattern to match and the rewrite to apply, with lhs and rhs elements being indentified by their name

#using "StateMachine.gm"

// find final state in parent of this node
rule FindFinalState(state : State) : (FinalState)
{
	final:FinalState <-:Contains- parent:State -:Contains-> state;
	//parent -:Contains-> final:FinalState;
	hom(parent, state);
	//hom(parent, final);
	modify
	{
	  parent -:Contains-> final;
	  return (final);
	}	
}

// find qualified target state.substate or state.pseudo syntax
test FindQualified(var state : string, var tar : string) : (StateMachineNode)
{
  st:State -:Contains-> t:NamedNode;  
  hom(st, t);  
  
  if { nameof(st) == state && t.name == tar;}
   
  return (t);  
}

// find qualified target state.substate or state.pseudo syntax
test FindQualifiedNode(state : State, var tar : string) : (StateMachineNode)
{
  state -:Contains-> t:NamedNode;  
  hom(state, t);  
  
  if { t.name == tar;}
   
  return (t);  
}

/*
// find qualified target state.substate or state.pseudo syntax
test FindQualified(var state : string, var tar : tpseudo) : (StateMachineNode)
{
  st:State -:Contains-> t:StateMachineNode;
  st -:Contains-> tnamed:NamedNode;
  hom(st, t);
  hom(st, tnamed);
  
  if { nameof(st) == state; }
  if { nameof(t) == tar || tnamed.name == tar;}
   
  return (t);  
}*/

// find qualified target state.substate or state.pseudo syntax
test FindNamed(var name : string) : (NamedNode)
{
  t:NamedNode;  
  
  if { t.name == name; }   
  return (t);
}
