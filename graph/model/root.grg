// graph rewrite rule file, shows how to define a model to use, and how a rule looks like,
// with the pattern to match and the rewrite to apply, with lhs and rhs elements being indentified by their name

#using "StateMachine.gm"

// find or create element in parent of type 
rule FindOrCreate(parent : Node, type : Node) : (Node)
{
  alternative
  {
    found
	{
	// search for parent contains node of that type
	  parent -:Contains-> t:typeof(type);
	  hom(parent, t);
	  modify
	  {
	  // return to rhs part
		eval { yield ret = t; }
	  }
	}
	not_found
	{
	  negative
	  {
	    // if not found
		parent -:Contains-> t:typeof(type);
		hom(parent, t);
	  }
	  modify
	  {
	   // create
		parent -:Contains-> t:typeof(type);
		eval { yield ret = t; } // return to rhs part
	  }
	}
  }
  
  modify
  {	
    def ret:Node;	
	return (ret); 
  }
}

rule CreateNode(parent : Node, type : Node, var name : string) : (Node)
{
  (
      if { typeof(type) >= NamedNode; }
	  
	  modify
	  {
		parent -:Contains-> t:typeof(type);
		
		eval 
		{ 
			def named : NamedNode = (NamedNode)t; 
			named.name = name; 
			yield ret = t;
		}
	  } 
	| 
	
	  negative { if {typeof(type) >= NamedNode;}  }
	//t:Node<type>;
	  
	  modify
	  {
		parent -:Contains-> t:typeof(type);
		
		eval {yield ret = t;}
	  }
  )
  
  modify
  {
    def ret : Node;
	return (ret);
  }
  
}

test ParentOf(elem : Node) : (State)
{
  parent:State -:Contains-> elem;
  
  return (parent);
}

rule MoveSubstateToParent()
{
  state:State -p:Parent-> parent:State;
  
  modify
  {
    delete(p);
    state <-:Substate- parent;
  }
}

// find qualified target state.substate or state.pseudo syntax
test FindQualifiedPath(ref tar : array<string>) : (StateMachineNode)
{  
  def n:StateMachineNode;  
  
  :QualifiedRec(null, tar, 0, yield n);  
  return (n);
}

pattern QualifiedRec(state : NamedNode, ref tar : array<string>, var idx : int, def ret : StateMachineNode)
{
	alternative
	{	   
	    first // first entry
		{
		    st:NamedNode; // search for named node
		    if { idx == 0; } // at index 0 of path
            if { st.name == tar[0]; } // name equal to this first name		  
		    :QualifiedRec(st, tar, 1, yield ret);  // recursive call next index with that node
		}
		next
	    {
			negative
			{
			   if {idx == 0 || idx == tar.size();} // is not at 0 index or at end of array
			}
			state -:Contains-> t:NamedNode; // find named node contained in state
			if { t.name == tar[idx];} // if name of this child equal current path at index
			
		    :QualifiedRec(t, tar, idx + 1, yield ret); // recursive search for path at next index
	    }
	    end
	    {
			if {idx == tar.size();}        // index at end of array 
			yield { yield ret = state; } // yield result
	    }	   
	}
}

// find qualified target state.substate or state.pseudo syntax
test FindQualifiedType(state : State, tar : StateMachineNode) : (StateMachineNode)
{
  state -:Contains-> t:typeof(tar);
  hom(state, t);  
  return (t);  
}

// find qualified target state.substate or state.pseudo syntax
test FindHistory(state : State, hist : History) : (StateMachineNode)
{
  def ret : StateMachineNode;
  
  :FindRecHierarchy(state, hist, null, yield ret);
  return (ret);    
}

pattern FindRecHierarchy(state : State, type : StateMachineNode, var name : string, def ret : StateMachineNode)
{
	alternative
	{
	  found_hist
	  {
	    state -:Contains-> h:History; // search for history in state
		
		//if {typeof(type) >= History;}
		if {typeof(h) >= typeof(type);} // if type is above or equal to external type
		
		yield { yield ret = h; } // yield to output
		
	  }
	  found
	  {
		negative
		{
			if {typeof(type) >= History;}
		}
		state -:Contains-> n:NamedNode; // search for history in state
		if {typeof(n) == typeof(type);}
		if {n.name == name;}
		//if {typeof(n) >= typeof(hist);} // if type is above or equal to external type
		
		yield { yield ret = n; } // yield to output 
	  }
	  not_found
	  {
	    parent:State -:Contains-> state; // get parent of state	    
			
		negative
		{
		  state -:Contains-> n:typeof(type); // search for history in state
		}
		:FindRecHierarchy(parent, type, name, yield ret); // recursive search for history in parent
	  }
	}
}

pattern HistoryFindRec(state : State, hist : History, def ret : History)
{
	alternative
	{
	  found
	  {
	    state -:Contains-> h:History; // search for history in state
		
		if {typeof(h) >= typeof(hist);} // if type is above or equal to external type
		
		yield
		{
			yield ret = h; // yield to output
		}					
		
	  }
	  not_found
	  {
	    parent:State -:Contains-> state; // get parent of state
		
	    negative
		{
			state -:Contains-> h:History; // it does not contain history
		}
				
		:HistoryFindRec(parent, hist, yield ret); // recursive search for history in parent
	  }
	}
}
// find qualified target state.substate or state.pseudo syntax
test FindNamed(var name : string) : (NamedNode)
{
  t:NamedNode;  
  
  if { t.name == name; }   
  return (t);
}

// find qualified target state.substate or state.pseudo syntax
test FindNamedHierarchy(st : State, type : StateMachineNode, var name : string) : (StateMachineNode)
{
  def t:StateMachineNode;  
  
  //if { t.name == name; }   
  :FindRecHierarchy(st, type, name, yield t);
  return (t);
}

// resolve unresolved nodes
rule TryResolveNames()
{  
  alternative
  {
    forward
	{
		resolved:NamedNode; // contain resolved node
		st:Node -n:Edge-> not_resolved:Unresolved; // node that points to unresolved
		hom(st, not_resolved);
		
		negative
		{
			if { not_resolved.name.indexOf(".") != -1; } // it is not qualified
		}
		if {not_resolved.name == resolved.name;} // with name that equal unresolved
		
		modify
		{
			st -:copy<n>-> resolved; // create edge to resolved			
			delete(not_resolved); // delete unresolved	
		}
	}
	back
	{
		resolved:NamedNode; // contain resolved node
		st:Node <-n:Edge- not_resolved:Unresolved; // node that points to unresolved
		hom(st, not_resolved);
		negative
		{
			if { not_resolved.name.indexOf(".") != -1; } // it is not qualified
		}
		if {not_resolved.name == resolved.name;} // with name that equal unresolved
		
		modify
		{
			st <-:copy<n>- resolved; // create edge to resolved		
			delete(not_resolved); // delete unresolved				
		}
	}
	qualified
	{
	   st:Node -n:Edge-> not_resolved:Unresolved; // node that points to unresolved
	   hom(st, not_resolved);
	   
	   if { not_resolved.name.indexOf(".") != -1; } // if name is path with points eq name.sub.sub
	  	
	   // search for qualified path node, return last node of that path
       def res:StateMachineNode;			   
	   :QualifiedRec(null, not_resolved.name.asArray("."), 0, yield res);
	   
	   modify
	   {	        
			st -:copy<n>-> res; // create edge to resolved
			delete(not_resolved); // delete unresolved	
	   }
	}
  }
}

// replace target node with source with nested containment
procedure Replace(src : NamedNode, target : NamedNode)
{	    
	(def instance : NamedNode) = insertInduced(reachableOutgoing(src, Contains), src);	 // create sub graph clone contained in src node
	instance.name = target.name; // set instance name to target
	merge(instance, target); // merge instance to target
	return;
}

// delete node with nested containment
procedure Delete(src : Node)
{
    def ref nodes : set<Node> = reachableOutgoing(src, Contains);
	for (n:Node in nodes) // for all contained nodes
	{
		rem(n); // remove from graph
	}
	rem(src); // remove root
	return;
}

// create instance edges for submachines
rule MarkSubMachines()
{
	st:SubMachineState; // search for sub machine state
	submachine_type : State \ SubMachineState; // some state except sub machine
	if { st.typename == submachine_type.name; } // if typename equals submachine_type name
	
    negative
	{
		submachine_type -:SubMachineInstance-> st; // not contained instance edge
	}
	
	modify
    {
		submachine_type -:SubMachineInstance-> st; // create instance edge
	}
}

rule MergeSubmachine1()
{
	-:SubMachineInstance-> st:State; // search for type and instances  
	
	multiple
	{
		st -:Contains-> n1:ExitPoint;
		st -:Contains-> n2:ExitPoint;

		if {n1.name == n2.name;}

		modify
		{
			st -:Contains-> :ExitPoint<n1, n2>;		 
		}
	}
	
}

rule MergeSubmachine2()
{
	-:SubMachineInstance-> st:State; // search for type and instances  
	
	multiple
	{
		st -:Contains-> n1:EntryPoint;
		st -:Contains-> n2:EntryPoint;

		if {n1.name == n2.name;}

		modify
		{
			st -:Contains-> :EntryPoint<n1, n2>;		 
		}
	}
	
}
// instatiate sub machines
rule InstanceSubMachines()
{
  submachine_type:State -e:SubMachineInstance-> st:SubMachineState; // search for type and instances  
  
  modify
  {
	eval
	{
	  Replace(submachine_type, st);	  	  // instantiate from type, create copy	  	  
	}
  }
}

// delete sub machine types already instantiated
rule DeleteSubMachineTypes()
{
  submachine:State; // search for submachine
  
  negative
  {
	-:Contains-> submachine;
  }
		  
  multiple
  {
	submachine -e:SubMachineInstance->; // contained more than 0 instance edges
	
	modify { }
  }
		   
  modify
  {
	eval { Delete(submachine); }	// delete it
  }
}

rule ClearSubMachines()
{  
  submachine:State;
  
  multiple
  {
	submachine -e:SubMachineInstance->; // contained more than 0 instance edges
	
	modify { delete(e); }
  }
		   
}

rule CheckSelfTargets()
{    	
	alternative
	{
	  state
	  {
	    state:State -e:Transition-> t:SelfTarget;
		
		modify
		{
		  state -:copy<e>-> state;
		  delete(t);
		}
	  }
	  pseudo
	  {
		state:PseudoState -e:Transition-> t:SelfTarget;
		def src : State;
		
		:FindSourceState(state, yield src);
		
		modify
		{
		  state -:copy<e>-> src;
		  delete(t);
		}
	  }
	}
}

//TODO: кэширование

rule CreateDepth()
{
  -:TopState-> top:State;
  
  t:CreateDepthRec(top, 0);
  
  modify
  {
    t();
  }
  
}

pattern CreateDepthRec(n : StateMachineNode, var depth : int)
{
  iterated
  {
	n -:Contains-> child:StateMachineNode;
	
	t:CreateDepthRec(child, depth + 1);
	
	modify
	{	  
	  t();
	}
  }
  
  modify
  {
    eval { n.depth = depth; }
  }
}

// procedure LCA(u : Node, v : Node) : (Node)
// {
	// var h1 : int = countReachableIncoming(u, Contains);
	// var h2 : int = countReachableIncoming(v, Contains);
	// return 
// }

pattern LCArec(u : Node, v : Node, var h1 : int, var h2 : int, def lca : Node)
{	
	(
		 if { h1 == h2; }
		 yield { yield lca = u; }
	 
	 | 
	     if { h1 > h2;}
		 parent:Node -:Contains-> u;
		 :LCArec(parent, v, h1 - 1, h2, yield lca);
	 | 
	     if { h1 < h2;}
		 parent:Node -:Contains-> v;
		 :LCArec(u, parent, h1, h2 - 1, yield lca);
	)
	
}

/*
Процедура LCA(u, v):
    h1 := depth(u)          // depth(x) = глубина вершины x
    h2 := depth(v)
  
    while h1 != h2:
       if h1 > h2:
          u := parent(u)
          h1 := h1 - 1
       else:
          v := parent(v)
          h2 := h2 - 1
  
    while u != v:
       u := parent(u)       // parent(x) = непосредственный предок вершины x
       v := parent(v)
  
    return u
*/
pattern FindSourceState(st : PseudoState, def source : State) 
{
  alternative
  {
    found
	{
		state:State --> st;
	   
		yield { yield source = state; }
	}
	not_found
	{
		state:PseudoState --> st;		
		
		:FindSourceState(state, yield source);
	}
  }
  
}