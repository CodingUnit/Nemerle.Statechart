// graph rewrite rule file, shows how to define a model to use, and how a rule looks like,
// with the pattern to match and the rewrite to apply, with lhs and rhs elements being indentified by their name

//#using "StateMachine.gm"
#include "find.grg"

rule CreateNode(parent : Node, type : Node, var name : string) : (Node)
{
  (
      if { typeof(type) >= NamedNode; }
	  
	  modify
	  {
		parent -:Contains-> t:typeof(type);
		
		eval 
		{ 
			def named : NamedNode = (NamedNode)t; 
			named.name = name; 
			yield ret = t;
		}
	  } 
	| 
	
	  negative { if {typeof(type) >= NamedNode;}  }
	//t:Node<type>;
	  
	  modify
	  {
		parent -:Contains-> t:typeof(type);
		
		eval {yield ret = t;}
	  }
  )
  
  modify
  {
    def ret : Node;
	return (ret);
  }
  
}


rule MoveSubstateToParent()
{
  state:State -p:Parent-> parent:State;
  
  modify
  {
    delete(p);
    state <-:Substate- parent;
  }
}


/*
// find qualified target state.substate or state.pseudo syntax
test FindQualifiedPath(ref tar : array<string>) : (StateMachineNode)
{  
  def n:StateMachineNode;  
  
  :QualifiedRec(null, tar, 0, yield n);  
  return (n);
}*/

rule ResolveTypes()
{
	parent:State -e:Contains-> t:NotResolved <-tran:Transition- n:Node;
	
	(
		not_resolved:UnresolvedFinalState<t>;
	  
	    alternative
		{
		   found
		   {
			parent -:Contains-> final:FinalState;
			
			modify
			{
			  eval {yield ret = final;}
			}
			
		   } 
			
		   not
		   {
			 negative
			 {
				parent -:Contains-> final:FinalState;
			 }
			
			 modify
			 {
			   parent -:Contains-> final:FinalState;
			  
			   eval {yield ret = final;}
			 }
		   }
		}		

		modify
		{			
			delete(not_resolved);
		}
	
	 | 
	    //parent -e-> t:UnresolvedHistory <-tran:Transition- n:Node;
		not_resolved:UnresolvedHistory<t>;		
		
		if {not_resolved.name == null;}
				
		:HistoryFindRec(parent, not_resolved.type, yield ret);
		modify
		{            
			delete(not_resolved);
		}
		
	 | 
	    //parent -e-> t:UnresolvedHistory <-tran:Transition- n:Node;		
		not_resolved:UnresolvedHistory<t>;		
		
		if {not_resolved.name != null;}
		
		def path : Node;
		:FindQualified(not_resolved.name.asArray("."), yield path);
		
		path -:Contains-> h:History;
		
		modify
		{		     
			eval {yield ret = h;}
			delete(not_resolved);
		}
	  | 
	     //parent -e-> t:UnresolvedTypeHierarchy <-tran:Transition- n:Node;
		 not_resolved:UnresolvedExitPoint<t>;
		 //if {typeof(t) == UnresolvedTypeHierarchy;}
		 
		 find:FindOrCreateHierarchy(parent, ExitPoint);
		 modify
		 {
			find(yield ret);
			delete(not_resolved);
		 } 		
   )
    modify
    {
	    def ret : Node;
		n -:copy<tran>-> ret;
		//delete(t);
    }
}



// resolve unresolved nodes
rule TryResolveNames()
{  
  
	   
  alternative
  {
    forward
	{
	   st:Node -n:Edge-> not_resolved:Unresolved; // node that points to unresolved
	
	// search for qualified path node, return last node of that path
	  def res:StateMachineNode;			   
	  :FindQualified(not_resolved.name.asArray("."), yield res);	
	  
	   modify
	   {	        
			st -:copy<n>-> res; // create edge to resolved			
			delete(not_resolved); // delete unresolved	
	   }
	}
	back
	{
	  st:Node <-n:Edge- not_resolved:Unresolved; // node that points to unresolved
	
	// search for qualified path node, return last node of that path
	  def res:StateMachineNode;			   
	  :FindQualified(not_resolved.name.asArray("."), yield res);	
	  
	   modify
	   {	        
			st <-:copy<n>- res; // create edge to resolved
			delete(not_resolved); // delete unresolved	
	   }
	}
  }
  
	modify
	{
		
	}
	// qualified
	// {
	   // st:Node -n:Edge-> not_resolved:Unresolved; // node that points to unresolved
	   // hom(st, not_resolved);
	   
	   // if { not_resolved.name.indexOf(".") != -1; } // if name is path with points eq name.sub.sub
	  	
	   // // search for qualified path node, return last node of that path
       // def res:StateMachineNode;			   
	   // :QualifiedRec(null, not_resolved.name.asArray("."), 0, yield res);
	   
	   // modify
	   // {	        
			// st -:copy<n>-> res; // create edge to resolved
			// delete(not_resolved); // delete unresolved	
	   // }
	// }
}

// replace target node with source with nested containment
procedure Replace(src : NamedNode, target : NamedNode)
{	    
	(def instance : NamedNode) = insertInduced(reachableOutgoing(src, Contains), src);	 // create sub graph clone contained in src node
	instance.name = target.name; // set instance name to target
	merge(instance, target); // merge instance to target
	return;
}

// delete node with nested containment
procedure Delete(src : Node)
{
    def ref nodes : set<Node> = reachableOutgoing(src, Contains);
	for (n:Node in nodes) // for all contained nodes
	{
		rem(n); // remove from graph
	}
	rem(src); // remove root
	return;
}

// create instance edges for submachines
rule MarkSubMachines()
{
	st:SubMachineState; // search for sub machine state
	submachine_type : State \ SubMachineState; // some state except sub machine
	if { st.typename == submachine_type.name; } // if typename equals submachine_type name
	
    negative
	{
		submachine_type -:SubMachineInstance-> st; // not contained instance edge
	}
	
	modify
    {
		submachine_type -:SubMachineInstance-> st; // create instance edge
	}
}

rule MergeSubmachine1()
{
	-:SubMachineInstance-> st:State; // search for type and instances  
	
	multiple
	{
		st -:Contains-> n1:ExitPoint;
		st -:Contains-> n2:ExitPoint;

		if {n1.name == n2.name;}

		modify
		{
			st -:Contains-> :ExitPoint<n1, n2>;		 
		}
	}
	
}

rule MergeSubmachine2()
{
	-:SubMachineInstance-> st:State; // search for type and instances  
	
	multiple
	{
		st -:Contains-> n1:EntryPoint;
		st -:Contains-> n2:EntryPoint;

		if {n1.name == n2.name;}

		modify
		{
			st -:Contains-> :EntryPoint<n1, n2>;		 
		}
	}
	
}
// instatiate sub machines
rule InstanceSubMachines()
{
  submachine_type:State -e:SubMachineInstance-> st:SubMachineState; // search for type and instances  
  
  modify
  {
	eval
	{
	  Replace(submachine_type, st);	  	  // instantiate from type, create copy	  	  
	}
  }
}

// delete sub machine types already instantiated
rule DeleteSubMachineTypes()
{
  submachine:State; // search for submachine
  
  negative
  {
	-:Contains-> submachine;
  }
		  
  multiple
  {
	submachine -e:SubMachineInstance->; // contained more than 0 instance edges
	
	modify { }
  }
		   
  modify
  {
	eval { Delete(submachine); }	// delete it
  }
}

rule ClearSubMachines()
{  
  submachine:State;
  
  multiple
  {
	submachine -e:SubMachineInstance->; // contained more than 0 instance edges
	
	modify { delete(e); }
  }
		   
}

rule CheckSelfTargets()
{    	
	alternative
	{
	  state
	  {
	    state:State -e:Transition-> t:SelfTarget;
		
		modify
		{
		  state -:copy<e>-> state;
		  delete(t);
		}
	  }
	  pseudo
	  {
		state:PseudoState -e:Transition-> t:SelfTarget;
		def src : State;
		
		:FindSourceState(state, yield src);
		
		modify
		{
		  state -:copy<e>-> src;
		  delete(t);
		}
	  }
	}
}

//TODO: кэширование

rule CreateDepth()
{
  -:TopState-> top:State;
  
  t:CreateDepthRec(top, 0);
  
  modify
  {
    t();
  }
  
}

pattern CreateDepthRec(n : StateMachineNode, var depth : int)
{
  iterated
  {
	n -:Contains-> child:StateMachineNode;
	
	t:CreateDepthRec(child, depth + 1);
	
	modify
	{	  
	  t();
	}
  }
  
  modify
  {
    eval { n.depth = depth; }
  }
}

