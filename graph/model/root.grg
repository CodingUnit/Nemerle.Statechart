// graph rewrite rule file, shows how to define a model to use, and how a rule looks like,
// with the pattern to match and the rewrite to apply, with lhs and rhs elements being indentified by their name

#using "StateMachine.gm"

/*
rule FindOrCreate(parent : StateMachineNode, type : StateMachineNode) : (StateMachineNode)
{
  def n:StateMachineNode;
  alternative
  {
    found
	{
	  parent -:Contains-> t:typeof(type);
	  hom(parent, t);
	  eval
	  {
		yield n = t;
	  }
	}
	not_found
	{
	  negative
	  {
		parent -:Contains-> t:typeof(type);
		hom(parent, t);
	  }
	  modify
	  {
		parent -:Contains-> t:typeof(type);
		eval
		{
			yield n = t;
		}
	  }
	}
  }
  // for (n:namednode in nodes(namednode))
  // {
    // if (n.name == name) return (n);
  // }
  // (def n:namednode) = add(namednode);
  // return (n);
  modify
  {	
	return (n);
  }
}*/

// rule Create(parent : StateMachineNode, name : string, type : StateMachineNode) : StateMachineNode
// {
// }

// create final state in parent of this node
rule CreateFinalState(state : State) : (FinalState)
{
	parent:State -:Contains-> state; // parent of state		
	hom(parent, state);
	
	negative
	{
	  parent -:Contains-> :FinalState; // if parent contains final state	  
	}
	// create another if has'nt
	modify
	{
	  parent -:Contains-> final:FinalState;
	  return (final);
	}	
}

// find teminate in top state
test FindTerminate() : (Terminate)
{
    -:TopState-> top:State;
	top -:Contains-> term:Terminate;
	
	return (term);
		
}
// create final state in parent of this node
rule CreateTerminate() : (Terminate)
{	
	-:TopState-> top:State;
	
	negative
	{
	  :Terminate; // if top contains teminate
	}
	// create new if has'nt
	modify
	{
	  top -:Contains-> term:Terminate;
	  return (term);
	}	
}

// find final state in parent of this node
test FindFinalState(state : State) : (FinalState)
{
	parent:State -:Contains-> state; // parent of state		
	parent -:Contains-> final:FinalState; // if parent contains final state	  
	hom(parent, state);
		
	return (final);
}

test ParentOf(elem : Node) : (State)
{
  parent:State -:Contains-> elem;
  
  return (parent);
}
/*
rule CreateFinalState(state : State) : (FinalState)
{
	parent:State -:Contains-> state;	
	hom(parent, state);
	
	negative
	{
		parent -:Contains-> :FinalState;		
	}	
	
	modify
	{
	  parent -:Contains-> final:FinalState;
	  return (final);
	}	
}*/

// find qualified target state.substate or state.pseudo syntax
test FindQualified(var state : string, var tar : string) : (StateMachineNode)
{
  st:State -:Contains-> t:NamedNode;  
  hom(st, t);  
  
  if { nameof(st) == state && t.name == tar;}
   
  return (t);  
}

// find qualified target state.substate or state.pseudo syntax
test FindQualifiedPath(ref tar : array<string>, var sz : int) : (StateMachineNode)
{
  st:State -:Contains-> t:NamedNode;    
  hom(st, t);  
  iterated
  {	
    if { st.name == tar[0] && t.name == tar[1];}  
	
    :QualifiedRec(t, tar, 2, sz);
	
  }
  return (t);
}

pattern QualifiedRec(state : NamedNode, ref tar : array<string>, var idx : int, var sz : int)
{
	optional
	{
		state -:Contains-> t:NamedNode;		
		if { idx != tar.size() && t.name == tar[idx];}  
		:QualifiedRec(t, tar, idx + 1, sz);
	}
}
// find qualified target state.substate or state.pseudo syntax
test FindQualifiedNode(state : State, var tar : string) : (StateMachineNode)
{
  state -:Contains-> t:NamedNode;  
  hom(state, t);  
  
  if { t.name == tar;}
   
  return (t);  
}


// find qualified target state.substate or state.pseudo syntax
test FindQualifiedType(state : State, tar : StateMachineNode) : (StateMachineNode)
{
  state -:Contains-> t:typeof(tar);
  hom(state, t);  
  return (t);  
}

// find qualified target state.substate or state.pseudo syntax
test FindQualifiedHistory(state : State, tar : History) : (History)
{
  state -:Contains-> h:History;
  if {typeof(tar) <= typeof(h);}
      
  return (h);  
}

// find qualified target state.substate or state.pseudo syntax
test FindNamed(var name : string) : (NamedNode)
{
  t:NamedNode;  
  
  if { t.name == name; }   
  return (t);
}
