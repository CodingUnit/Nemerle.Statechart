// graph rewrite rule file, shows how to define a model to use, and how a rule looks like,
// with the pattern to match and the rewrite to apply, with lhs and rhs elements being indentified by their name

#using "StateMachine.gm"

/*
rule FindOrCreate(parent : Node, type : Node) : (Node)
{
  alternative
  {
    found
	{
	  parent -:Contains-> t:typeof(type);
	  hom(parent, t);
	  modify
	  {
		eval { yield ret = t; }
	  }
	}
	not_found
	{
	  negative
	  {
		parent -:Contains-> t:typeof(type);
		hom(parent, t);
	  }
	  modify
	  {
		parent -:Contains-> t:typeof(type);
		eval { yield ret = t; }
	  }
	}
  }
  
  
  
  modify
  {	
    def n:StateMachineNode;
	:FindOrCreate(parent, type, yield n);	
	return (n);
  }
}

pattern FindOrCreate(parent : Node, type : Node, def ret : Node)
{    
  
}*/

// create final state in parent of this node
rule CreateFinalState(state : State) : (FinalState)
{
	parent:State -:Contains-> state; // parent of state		
	hom(parent, state);
	
	negative
	{
	  parent -:Contains-> :FinalState; // if parent contains final state	  
	}
	// create another if has'nt
	modify
	{
	  parent -:Contains-> final:FinalState;
	  return (final);
	}	
}

// find teminate in top state
test FindTerminate() : (Terminate)
{
    -:TopState-> top:State;
	top -:Contains-> term:Terminate;
	
	return (term);
		
}
// create final state in parent of this node
rule CreateTerminate() : (Terminate)
{	
	-:TopState-> top:State;
	
	negative
	{
	  :Terminate; // if top contains teminate
	}
	// create new if has'nt
	modify
	{
	  top -:Contains-> term:Terminate;
	  return (term);
	}	
}

// find final state in parent of this node
test FindFinalState(state : State) : (FinalState)
{
	parent:State -:Contains-> state; // parent of state		
	parent -:Contains-> final:FinalState; // if parent contains final state	  
	hom(parent, state);
		
	return (final);
}

test ParentOf(elem : Node) : (State)
{
  parent:State -:Contains-> elem;
  
  return (parent);
}

rule MoveSubstateToParent()
{
  state:State -p:Parent-> parent:State;
  
  modify
  {
    delete(p);
    state <-:Substate- parent;
  }
}

// find qualified target state.substate or state.pseudo syntax
test FindQualifiedPath(ref tar : array<string>) : (StateMachineNode)
{  
  def n:StateMachineNode;  
  st : NamedNode;
  :QualifiedRec(st, tar, 0, yield n);  
  return (n);
}

pattern QualifiedRec(state : NamedNode, ref tar : array<string>, var idx : int, def ret : StateMachineNode)
{
	alternative
	{	   
	    first
		{
		  st:State; 
		  if { idx == 0; }
          if { st.name == tar[0]; }
		  
		  yield
   		  {
			yield ret = t;
		  }
		  :QualifiedRec(st, tar, 1, yield ret);  
		}
		next
	    {
			negative
			{
			   if {idx == 0 || idx == tar.size();}
			}
			state -:Contains-> t:NamedNode;
			
			if { t.name == tar[idx];}
			yield
			{
				yield ret = t;
			}	
		    :QualifiedRec(t, tar, idx + 1, yield ret);
	    }
	    end
	    {
			if {idx == tar.size();}         
	    }	   
	}
}

// find qualified target state.substate or state.pseudo syntax
test FindQualifiedType(state : State, tar : StateMachineNode) : (StateMachineNode)
{
  state -:Contains-> t:typeof(tar);
  hom(state, t);  
  return (t);  
}

// find qualified target state.substate or state.pseudo syntax
test FindHistory(state : State, hist : History) : (History)
{
  def ret : History;
  
  :HistoryFindRec(state, hist, yield ret);
  return(ret);    
}

pattern HistoryFindRec(state : State, hist : History, def ret : History)
{
	alternative
	{
	  found
	  {
	    state -:Contains-> h:History; // search for history in state
		
		if {typeof(h) >= typeof(hist);} // if type is above or equal to external type
		
		yield
		{
			yield ret = h; // yield to output
		}					
		
	  }
	  not_found
	  {
	    parent:State -:Contains-> state; // get parent of state
		
	    negative
		{
			state -:Contains-> h:History; // it does not contain history
		}
				
		:HistoryFindRec(parent, hist, yield ret); // recursive search for history in parent
	  }
	}
}
// find qualified target state.substate or state.pseudo syntax
test FindNamed(var name : string) : (NamedNode)
{
  t:NamedNode;  
  
  if { t.name == name; }   
  return (t);
}

// resolve unresolved nodes
rule TryResolveNames()
{  
  alternative
  {
    forward
	{
		resolved:NamedNode; // contain resolved node
		st:Node -n:Edge-> not_resolved:Unresolved; // node that points to unresolved
		hom(st, not_resolved);
		
		negative
		{
			if { not_resolved.name.indexOf(".") != -1; } // with name that equal unresolved
		}
		if {not_resolved.name == resolved.name;} // with name that equal unresolved
		
		modify
		{
			st -:copy<n>-> resolved; // create edge to resolved
			delete(not_resolved);    // delete unresolved
		}
	}
	back
	{
		resolved:NamedNode; // contain resolved node
		st:Node <-n:Edge- not_resolved:Unresolved; // node that points to unresolved
		hom(st, not_resolved);
		negative
		{
			if { not_resolved.name.indexOf(".") != -1; } // with name that equal unresolved
		}
		if {not_resolved.name == resolved.name;} // with name that equal unresolved
		
		modify
		{
			st <-:copy<n>- resolved; // create edge to resolved
			delete(not_resolved); // delete unresolved	
		}
	}
	qualified
	{
	   //var ref path : array<string>;	   
	   
	   st:Node -n:Edge-> not_resolved:Unresolved; // node that points to unresolved
	   hom(st, not_resolved);
	   
	   if { not_resolved.name.indexOf(".") != -1; } // with name that equal unresolved
	   //yield { yield path = not_resolved.name.asArray("."); }
	  	
       def res:StateMachineNode;		
	   :QualifiedRec(not_resolved, not_resolved.name.asArray("."), 0, yield res);
			
	   modify
	   {
	        //def resolved1:Node; // contain resolved node
			//exec( (r) = FindQualifiedPath(path) ;> yield resolved1 = r );			
			
			st -:copy<n>-> res; // create edge to resolved
			delete(not_resolved); // delete unresolved	
	   }
	}
  }
}

procedure Replace(src : Node, target : Node)
{
	def ref nodes : set<Node> = reachableOutgoing(src, Contains);
	(def instance : Node) = insertInduced(nodes, src);
	merge(instance, target);
	return;
}

procedure Delete(src : Node)
{
	def ref nodes : set<Node> = reachableOutgoing(src, Contains);
	//emitdebug(nodes);
	for (n:Node in nodes)
	{
		rem(n);
	}
	rem(src);
	return;
}

/*
rule InstanceSubMachinesInstance()
{
  sub_machine_state:State -e:SubMachineInstance-> st:SubMachineState;
  //submachine 		      -:TopState-> sub_machine_state:State;
  //def sub_machine_state : State;
  //if { st.type == submachine.name; }
  
  alternative
  {
    normal
	{	
	  st 				 <-:SubMachineInstance- submachine;	
	  :SubMachineState   <-:SubMachineInstance- submachine;	  
	  	
      modify
      {
	  }	  
	}
    last
	{	  
	  
	  negative
	  {
	    st 				 <-:SubMachineInstance- submachine;
		:SubMachineState <-:SubMachineInstance- submachine;
	  }
	  
	  modify
	  {		
	    delete(submachine);
	  }
	}
  }  
    
  modify
  {
	eval
	{
	  Replace(sub_machine_state, st);
	}
	delete(e);
  }
}*/

rule MarkSubMachines()
{
	st:SubMachineState;
	submachine_type : State \ SubMachineState;
	if { st.typename == submachine_type.name; }
	
    negative
	{
		submachine_type -:SubMachineInstance-> st;
	}
	
	modify
    {
		submachine_type -:SubMachineInstance-> st;
	}
}

rule InstanceSubMachines()
{
  submachine_type:State -e:SubMachineInstance-> st:SubMachineState;
	    
  def var name : string;  
  yield { yield name = st.name; }
  
  modify
  {
    
    eval { emitdebug(name); }
	eval
	{
	  Replace(submachine_type, st);	  
	  st.name = name;
	}	
  }
}

rule DeleteSubMachineTypes()
{
  submachine:State;
  
  multiple
  {
    submachine -e:SubMachineInstance->;
	
	modify
	{
	  
	}
  }
  
  modify
  {
    eval { Delete(submachine); }
	//delete(submachine_type);
  }
}