// graph rewrite rule file, shows how to define a model to use, and how a rule looks like,
// with the pattern to match and the rewrite to apply, with lhs and rhs elements being indentified by their name

//#using "StateMachine.gm"
#include "find.grg"

rule CreateNode(parent : Node, type : Node, var name : string) : (Node)
{
  (
      :NamedNode<type>;
	  
	  modify
	  {
		def var uname : string;
		//eval { uname = UniqueName(name); }
		t:typeof(type)@($ = uname);
		parent -:Contains-> t;
		//n:N@($="foo", i=42, s="Hallo Welt");
		
		eval 
		{ 
			def named : NamedNode = (NamedNode)t; 
			named.name = name; 
			yield ret = t;
		}
	  } 
	| 
	
	  negative {  :NamedNode<type>;  }
	//t:Node<type>;
	  
	  modify
	  {
		parent -:Contains-> t:typeof(type);
		
		eval {yield ret = t;}
	  }
  )
  
  modify
  {
    def ret : Node;
	return (ret);
  }
  
}

 // pattern UniqueName(var name : string, def var ret : string)
 // {
    // (
		// n:Node{@(name)};
		
		// :UniqueNameRec(name, 0, yield ret);
    // |
	    // negative {n:Node{@(name)};}
		// yield {yield ret = name;}
	// )
// }

 // pattern UniqueNameRec(var name : string, var idx : int, def var ret : string)
 // {
	// //def var nn : string;
	// //yield {yield nn = name + (string)idx;}
	// alternative
	// {
		// found
		// {
	     
		 // //n:Node{@(name)};
		 // if{ nodeByName(name) != null; }
		
		 // :UniqueNameRec(name, idx + 1, yield ret);
		// }
		// not_found
		// {
	// //|
	     // negative {if{ nodeByName(name) != null; }}
		 // yield {yield ret = name;}
		// }
	// //)
	// }
 // }

rule InitConcurrent()
{
	
	state:ConcurrentState;

	iterated it
    {
		state -:Region->;
		
		modify
		{
		}
	}
	
	modify
	{
		eval { state.regions = count(it); }
	}
}

rule MoveSubstateToParent()
{
  (
	state:State -p:Parent-> parent:State \ ConcurrentState;
		
	replace
    { 
		//delete(p);
		state <-:Substate- parent;
    }
  |
	state:State -p:Parent-> parent:ConcurrentState;
	
	iterated it
	{
		parent -:Region->;
		
		modify {}
	}
	
	modify
    { 
    //delete(p);
	    def var name : string;
		def var idx : int;
		evalhere {yield idx = count(it); yield name = parent.name + "_SubRegion" + (string)idx;}
	    delete(p);
		parent -:Region-> sub:SubRegion@($=name, name = name, idx = idx) -:Substate-> state;
		//eval {sub.name = name;}
		
    }
  )
  
}


/*
// find qualified target state.substate or state.pseudo syntax
test FindQualifiedPath(ref tar : array<string>) : (StateMachineNode)
{  
  def n:StateMachineNode;  
  
  :QualifiedRec(null, tar, 0, yield n);  
  return (n);
}*/
rule ResolveHistory()
{
	n:Node -tran:Transition-> not_resolved:UnresolvedHistory;
	parent:NamedNode -:Contains-> not_resolved;
	hom(n, parent);
	
	def hist : Node;	
	
	(	    
		:UnresolvedDeepHistory<not_resolved>;
		if {not_resolved.name.length() == 0;}
		
		//if {not_resolved.type == history_type::deep;}
		h:DeepHistory;				
		:FindHierarchy(parent, h, yield hist);//not_resolved.type
		modify {delete(not_resolved);}
	| 
	    //parent:Node -:Contains-> not_resolved;
		:UnresolvedShallowHistory<not_resolved>;
		if {not_resolved.name.length() == 0;}
		
		//if {not_resolved.type == history_type::shallow;}
		h:ShallowHistory;				
		:FindHierarchy(parent, h, yield hist);//not_resolved.type
		modify {delete(not_resolved);}
	| 
		//parent:Node -:Contains-> not_resolved;		
		if {typeof(not_resolved) == UnresolvedHistory;}
		if {not_resolved.name.length() == 0;}
		
		//if {not_resolved.type == history_type::any;}
		h:History;
		///parent -:Contains-> h:History;
		:FindHierarchy(parent, h, yield hist);//not_resolved.type
		modify {delete(not_resolved);}
	|			
		
		if {not_resolved.name.length() != 0;}
		//def ret : History;
		h:History;		
		:FindQualifiedType(not_resolved.name.asArray("."), h, yield hist);
		
		modify {delete(not_resolved);}
	)
	
	modify
	{            
		n -:copy<tran>-> hist;
		//eval {emitdebug(parent); emitdebug(n);}
		//modify {delete(not_resolved);}
	}
}

/*
pattern FindResolvedHistoryType(parent : Node, not_resolved : UnresolvedHistory, def hist : Node)
{
	(	    
		:UnresolvedDeepHistory<not_resolved>;
		if {not_resolved.name == null;}
		
		//if {not_resolved.type == history_type::deep;}
		h:DeepHistory;				
		:FindHierarchy(parent, h, yield hist);//not_resolved.type
		//modify {delete(not_resolved);}
	| 
	    //parent:Node -:Contains-> not_resolved;
		:UnresolvedShallowHistory<not_resolved>;
		if {not_resolved.name == null;}
		
		//if {not_resolved.type == history_type::shallow;}
		h:ShallowHistory;				
		:FindHierarchy(parent, h, yield hist);//not_resolved.type
		//modify {delete(not_resolved);}
	| 
		//parent:Node -:Contains-> not_resolved;		
		if {typeof(not_resolved) == UnresolvedHistory;}
		if {not_resolved.name == null;}
		
		//if {not_resolved.type == history_type::any;}
		h:History;
		:FindHierarchy(parent, h, yield hist);//not_resolved.type
		//modify {delete(not_resolved);}
	|			
		
		if {not_resolved.name != null;}
		//def ret : History;
		h:History;
		:QualifiedRecType(parent, not_resolved.name.asArray("."), 0, h, yield hist);
		
		//modify {delete(not_resolved);}
	)
}*/

/*
rule ResolveHistory()
{
	n:Node -tran:Transition-> not_resolved:UnresolvedHistory;
	parent:NamedNode -:Contains-> not_resolved;
	hom(n, parent);
	def hist : Node;	
	
	
	
	modify
	{            
		n -:copy<tran>-> hist;
		
	}
}*/

rule ResolveFinal()
{
	parent:State -e:Contains-> not_resolved:UnresolvedFinalState <-tran:Transition- n:Node;
	
	alternative
	{
	   found
	   {
		 parent -:Contains-> final:FinalState;
		
		 modify { eval {yield ret = final;} }
		
	   } 
		
	   not
	   {
		 ~( parent -:Contains-> :FinalState; )
		
		 modify
		 {
		   parent -:Contains-> final:FinalState;
		  
		   eval {yield ret = final;}
		 }
	   }
	}		

	modify
	{			
		delete(not_resolved);
		def ret : Node;
		n -:copy<tran>-> ret;
	}		
}

rule ResolveTerminate()
{
	not_resolved:UnresolvedTerminate <-tran:Transition- n:Node;
	
	
	alternative
	{
	   found
	   {	   
		 -:TopState-> . -:Contains-> term:Terminate;
		
		 modify { eval {yield ret = term;} }		
	   } 
	   not
	   {
		 -:TopState-> top:Node;
		 ~( top -:Contains-> term:Terminate; )
		
		 modify
		 {
		   top -:Contains-> term:Terminate;
		  
		   eval {yield ret = term;}
		 }
	   }
	}		

	modify
	{			
		delete(not_resolved);
		def ret : Node;
		n -:copy<tran>-> ret;
	}		
}

rule ResolveExitPoint()
{	    
	parent:Node -e:Contains-> not_resolved:UnresolvedExitPoint; // match parent contains unresolved exit point node
	
	alternative
	{
	   found
	   {
		not_resolved <-tran:Transition- n:Node;	 // match node with transition to not resolved node
		hom(parent, n); // homomorphically parent and n
		
		ex:ExitPoint;
		def r : Node;
		:FindNameHierarchy(parent, ex, not_resolved.name, yield r);
					
		modify { n -:copy<tran>-> r; }
	   }
	   not
	   {	     
		 not_resolved <-tran:Transition- n:Node;
		 hom(parent, n);
		 ~(
			def r : Node;
			ex:ExitPoint;
			:FindNameHierarchy(parent, ex, not_resolved.name, yield r);//not_resolved.name,
		  )
		
		 modify
		 {
		   parent -:Contains-> ex:ExitPoint;
		   eval {ex.name = not_resolved.name;}		   
		   n -:copy<tran>-> ex;		   
		 }
	   }
	}
	 modify
	 {			
		delete(not_resolved);
	 } 
}

rule ResolveEntryPoint()
{
	parent:Node -e:Contains-> not_resolved:UnresolvedEntryPoint;
	
	alternative
	{
	   found
	   {
		not_resolved <-tran:Transition- n:Node;	
		hom(parent, n);
		
		ex:EntryPoint;
		def r : Node;
		:FindNameHierarchy(parent, ex, not_resolved.name, yield r);
					
		modify { n -:copy<tran>-> r; }
		
	   } 
		
	   not
	   {	     
		 not_resolved <-tran:Transition- n:Node;
		 hom(parent, n);
		 negative
		 {
			def r : Node;
			ex:EntryPoint;
			
			:FindNameHierarchy(parent, ex, not_resolved.name, yield r);//not_resolved.name,
		 }
		
		 modify
		 {
		   parent -:Contains-> ex:EntryPoint;
		   eval {ex.name = not_resolved.name;}
		   n -:copy<tran>-> ex;		
		 }
	   }
	}
	 modify { delete(not_resolved); } 
}

// resolve unresolved nodes
rule ResolveNames()
{
  st:Node -e:Edge-> not_resolved:Unresolved; // node that points to unresolved
  
  if {typeof(e) != Contains;} // not contains edge  
	
  res:NamedNode; // named node
  hom(st, res); // maybe that type  
  
  if {res.name == not_resolved.name;} // if name equals
  if (isReachable(st, res, Contains)); // if reachable, in that statemachine
  
  modify
  {
	st -:copy<e>-> res; // create edge to resolved			
	delete(not_resolved); // delete unresolved	
  }
}

// resolve unresolved nodes
rule ResolveQualifiedNames()
{  
  st:Node -e:Edge \ Contains->  not_resolved:Unresolved; // node that points to unresolved  
  //if {typeof(e) != Contains;}
	// search for qualified path node, return last node of that path 
  if {not_resolved.name.indexOf(".") != -1;}
  def res:StateMachineNode;
  :FindQualified(not_resolved.name.asArray("."), yield res);
  
  modify
  {
	st -:copy<e>-> res; // create edge to resolved			
	delete(not_resolved); // delete unresolved	
  }
}

rule ResolveNames2()
{
 
  st:Node <-e:Edge \ Contains- not_resolved:Unresolved; // node that points to unresolved
  //res:NamedNode \ Unresolved;
	// search for qualified path node, return last node of that path
  //if {typeof(e) != ;}
  res:NamedNode;
  hom(st, res);
  //:FindQualifiedParent(st, not_resolved.name.asArray("."), yield res);	
  if {res.name == not_resolved.name;}
  if (isReachable(st, res, Contains));
  
  modify
  {
	st -:copy<e>-> res; // create edge to resolved			
	delete(not_resolved); // delete unresolved	
  }
}
// replace target node with source with nested containment
procedure Replace(src : NamedNode, target : NamedNode)
{	    
	(def instance : NamedNode) = insertInduced(reachableOutgoing(src, Contains), src);	 // create sub graph clone contained in src node
	instance.name = target.name; // set instance name to target
	merge(instance, target); // merge instance to target
	return;
}

// delete node with nested containment
procedure Delete(src : Node)
{
    def ref nodes : set<Node> = reachableOutgoing(src, Contains) | reachable(src, And);
	for (n:Node in nodes) // for all contained nodes
	{
		rem(n); // remove from graph
	}
	rem(src); // remove root
	return;
}

// create instance edges for submachines
rule MarkSubMachines()
{
	st:SubMachineState; // search for sub machine state
	submachine_type : State \ SubMachineState; // some state except sub machine
	if { st.typename == submachine_type.name; } // if typename equals submachine_type name
	
    ~( submachine_type -:SubMachineInstance-> st; ) // not contained instance edge
	
	modify { submachine_type -:SubMachineInstance-> st; } // create instance edge
}

rule MergeSubmachine1()
{
	-:SubMachineInstance-> st:State; // search for type and instances  
	n2:ExitPoint <-:Contains- st -:Contains-> n1:ExitPoint;

	if {n1.name == n2.name;}

	modify { st -:Contains-> :ExitPoint<n1, n2>; }
}

rule MergeSubmachine2()
{
	-:SubMachineInstance-> st:State; // search for type and instances  
	n2:EntryPoint <-:Contains- st -:Contains-> n1:EntryPoint;

	if {n1.name == n2.name;}

	modify { st -:Contains-> :EntryPoint<n1, n2>; }
	
}
// instatiate sub machines
rule InstanceSubMachines()
{
  submachine_type:State -e:SubMachineInstance-> st:SubMachineState; // search for type and instances  
  
  modify { eval { Replace(submachine_type, st);	} }  	  // instantiate from type, create copy	  
}

// delete sub machine types already instantiated
rule DeleteSubMachineTypes()
{
  submachine:State; // search for submachine
  
  ~( -:Contains-> submachine; )
		  
  ( submachine -e:SubMachineInstance->; modify {})+ // contained more than 0 instance edges
		   
  modify { eval { Delete(submachine); }	}// delete it
}

rule ClearSubMachines()
{  
  submachine:State;
  
  multiple
  {
	submachine -e:SubMachineInstance->; // contained more than 0 instance edges
	
	modify { delete(e); }
  }
		   
}

rule CheckSelfTargets()
{    	
	alternative
	{
	  state
	  {
	    state:State -e:Transition-> t:SelfTarget;
		
		modify
		{
		  state -:copy<e>-> state;		  
		  delete(t);
		}
	  }
	  pseudo
	  {
		state:PseudoState -e:Transition-> t:SelfTarget;
		def src : State;
		
		:FindSourceState(state, yield src);
		
		modify
		{
		  state -:copy<e>-> src;
		  //state -e-> src;
		  delete(t);
		}
	  }
	}
}

rule CreateDepth()
{
  -:TopState-> top:State;
  t:CreateDepthRec(top, 0);
  
  modify { t();}
}

pattern CreateDepthRec(n : StateMachineNode, var depth : int)
{
  iterated
  {
	n -:Contains-> child:StateMachineNode;
	
	t:CreateDepthRec(child, depth + 1);
	
	modify { t(); }
  }
  
  modify { eval { n.depth = depth; } }
}

rule StateCombinations()
{
	//st:ConcurrentState;
	
	// st -r1:Region-> sub_reg:State;
	// st -r2:Region-> sub_reg2:State;	 
	
	
	-:TopState-> . -e:SimpleState-> state:State;
	and:CreateConfig(state);	
		
	modify
	{
		new_st : ActiveState;
		eval
		{
			new_st.name = state.name;
			new_st.entry_act = state.entry_act;
			new_st.exit_act = state.exit_act;
			new_st.do_act = state.do_act;
		}
		and(new_st);
		delete(e);
		// //m:State<sub_reg, and_st>;		
		
		// //eval {m.name = and_st.name;}
		// //delete(sub_reg2);
	}

	
	// negative
	// {
		// state -:Substate->;
	// }
	
	// def ref conf : set<Node>;
	// yield { yield conf = set<Node>{};}
	
	
	
	// iterated
	// {
		
		// st -r1:Region-> sub_reg:State;
			
			
		// //iterated
		// //{
			
			// //:SimpleStates(sub1, yield ret);
			
			// //
			
			
			// //:Comb(sub_reg, sub_reg, yield conf);
			
			
			
			// modify
			// {
				// // def ref conf : set<Node>;
				// // eval
				// // {
					// // yield conf = set<Node>();
					// // //conf.clear();
				// // }
				// //and();
				// //emitdebug("\nsimple", st);
				// //emitdebug("\nparents", conf);
			// }
		// //}
		
        // // modify
		// // {
			// // //and();
			// // //eval { Delete(sub1); }
		// // }
	// }
	
	// iterated
		// {
			// sub_reg2 -:Substate-> sub2:State;		
			// and:Comb(sub2, sub2);
			
			// modify
			// {
				// and();
				// //def and_st : State;
				// //and();
				// //sub_reg -:Substate-> and_st;
				// //eval { Delete(sub2); }
			// }
		// }
		
	 
}

/*
pattern SimpleStateIter(def ret : State)
{
	multiple
	{
		top -:SimpleState-> state:State;
		yield {yield ret = state;}
		
		// modify
		// {
			// new_st : ActiveState;
			// eval
			// {
				// new_st.name = state.name;
			// }
			// and(new_st);
			// // //m:State<sub_reg, and_st>;		
			
			// // //eval {m.name = and_st.name;}
			// // //delete(sub_reg2);
		// }
	}
}*/

rule SimpleStates()
{	
	st:State;
	
	-:TopState-> top:State;
	
	~( st -:Substate->; )
	~(	top -:SimpleState-> st; )
	//if (isReachableIncoming(st, top, Contains));
	
	modify
	{
		top -:SimpleState-> st;
	}
	//yield {yield ret = st;}
}

pattern CreateConfig(st : State) modify(root : ActiveState)
{	
	
	
	optional
	{
		
		parent:State -:Contains-> st;
		
		
		(
			if {typeof(parent) == State;}		
		
			and:CreateConfig(parent);
	
			
			modify
			{
				root <-:And- nst:ActiveState;				
				eval {yield new_st = nst;}
				and(nst);
			}
		| 	
			//parent:SubRegion -:Contains-> st;			
			p:SubRegion<parent>;
			and:CreateConfig(parent);
			
			modify
			{
				root <-:And- nst:ActiveSubRegionState;
				parent --> nst;
				eval
				{
					nst.idx 		  = p.idx;				
					yield new_st = nst;					
					// new_st.name 	  = parent.name;
					// new_st.entry_act  = parent.entry_act;
					// new_st.exit_act   = parent.exit_act;
					// new_st.do_act     = parent.do_act;
				}
				and(nst);
			}
		
		|	
			
			//parent:ConcurrentState -:Region-> st;	
			p:ConcurrentState<parent>;
			
			and:CreateConfig(parent);
			modify
			{
				root <-:And- nst:ActiveRegionState;
				parent --> nst;
				eval
				{
					nst.regions = p.regions;
					yield new_st = nst;
				// {
					// new_st.name 	  = parent.name;
					// new_st.entry_act = parent.entry_act;
					// new_st.exit_act  = parent.exit_act;
					// new_st.do_act    = parent.do_act;
				}
				//
				and(nst);
			}
		)
		
		modify
		{	
			def new_st : ActiveState;
			
			eval
			{
				new_st.name 	  = parent.name;
				new_st.entry_act  = parent.entry_act;
				new_st.exit_act   = parent.exit_act;
				new_st.do_act     = parent.do_act;
			}			
		}
	}
	
	
	modify
	{
		
	}
	// modify
	// {
		// eval
		// {
			// //ret.add(st);
		// }
	// }
}

pattern Comb(state : State, st : State, def ref ret : set<Node>)
{	
	
		//if {state != st;}	
	
		optional
		{
			negative
			{
				state -:Substate->;
			}		
		}	
		iterated
		{
			state -:Substate-> sub:State;
			
			:Comb(sub, sub, yield ret);				
		}
	
}

rule MarkAndRegions()
{
	st : ConcurrentState -e:Edge -> :ActiveState;	
	
	t:CreateAndOrRegion(st);
	
	modify { t(); }
}

// TODO: nested subregion in subregion
// pattern IterateConf(src : ActiveState)
// {
	
	// (
		// c : ActiveSubRegionState<src>;
		
		// ~(c --> :Oper;);
	// |
		// ~(c : ActiveSubRegionState<src>;)
		// parent : ActiveState --> src;
		// :IterateConf(parent);
	// )
	
// }

pattern CreateAndOrRegion(src:ConcurrentState)
{
	~(src --> :AndConf;)
	
	(
		src --> :SubRegion --> :ActiveSubRegionState <-- or:OrConf;
		
		modify { and_conf --> or; }
	)+
	
	modify { src --> and_conf:AndConf <-- :Eval; }	
}

rule OrSubRegion()
{
	st_sub:SubRegion;
	
	~( st_sub --> sub:ActiveSubRegionState <-- :OrConf; )
	
	iterated
	{
		st_sub -e:Edge-> sub:ActiveSubRegionState;
		
		modify { or --> sub; }
	}
	
	modify { or : OrConf; }
}

rule ClearAndRegion()
{
	st : ConcurrentState -a:Edge-> :AndConf;
	
	multiple
	{
		st -e:Edge-> :ActiveRegionState;
		
		modify
		{
			delete(e);
		}
	}
	
	modify
	{
		delete(a);
	}
}

rule ClearOrSubRegion()
{
	st_sub : SubRegion;	
	
	multiple
	{
		st_sub -e:Edge-> :ActiveSubRegionState;
		
		modify
		{
			delete(e);
		}
	}
	
	modify
	{				
	}
	
}

rule OrMoveToTopOfActiveState()
{
	sub:ActiveSubRegionState <-e:Edge- or:OrConf;
	
	def upper : ActiveState;
	:FindUpperActiveState(sub, yield upper);
	
	modify
	{
		delete(e);
		or --> upper;
	}
}

pattern FindUpperActiveState(st : ActiveState, def res : ActiveState)
{
	(
	  ~( --> st;)
	  yield {yield res = st;}
	|	
		parent:ActiveState --> st;
		:FindUpperActiveState(parent, yield res);
	)
}

rule AndOrConvertToBinary()
{	
	left:Node <-- and:Oper --> right:Node;	
	and -e:Edge-> third:Node;	
	
	multiple
	{
		from:Node -ne:Edge-> and;
		
		modify
		{
			delete(ne);
			from --> new_and;
		}
	}
	
	modify
	{
		and <-- new_and:typeof(and) --> third;		
		delete(e);
	}
}

rule UnfoldAndOr()
{
   left:OrConf <-- and:AndConf --> right:OrConf;   
   lor1:Node   <-- left        --> lor2:Node;
   ror1:Node   <-- right       --> ror2:Node;
   
   multiple
   {
		from:Node --> and;
		
		modify
		{			
			from --> or;
		}
   }
	
   modify
   {	  
	  or2:OrConf <-- or:OrConf --> a1:AndConf;
	  or3:OrConf <-- or2 	   --> a2:AndConf;
	  a4:AndConf <-- or3 	   --> a3:AndConf;	  
	  lor1 <-- a1 --> ror1;
	  lor2 <-- a2 --> ror1;
	  lor1 <-- a3 --> ror2;
	  lor2 <-- a4 --> ror2;
	  delete(left);
	  delete(right);
	  delete(and);	  
   }
}

pattern MarkSubRegions(st : ActiveRegionState, or_node : OrConf, var i : int)
{
	reg:ActiveRegionState --> sreg:ActiveSubRegionState;	
	
	if {reg.name == st.name;}
	if {sreg.idx == i;}	
	
	modify
	{
		or_node --> st;
	}
}

// pattern AndComb(parent : State, st1 : State, st2 : State) modify(def ret : State)
// {
	// modify
	// {
		// def a1 : State;
		// def a2 : State;
		// evalhere
		// {
			// //
			// (def g1 : State) = insertInduced(reachableOutgoing(st1, Contains) | reachable(st1, And), st1);
			// (def g2 : State) = insertInduced(reachableOutgoing(st2, Contains) | reachable(st1, And), st2);		
			// yield a1 = g1;
			// yield a2 = g2;
		// }		
		// a1 -:And- a2;
		// parent -:Contains-> a1;
		// parent -:Contains-> a2;
		// eval {yield ret = a1;}
	// }
// }