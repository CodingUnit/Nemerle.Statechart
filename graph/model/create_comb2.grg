rule SimpleStates()
{	
	parent:State;
	
	multiple
	{
		parent -e:Substate \ SimpleState-> st:State;
		
		~( st -:Substate->; )
		
		modify
		{
			parent -:SimpleState<e>-> st;
		}
	}
	
	modify
	{
		
	}
}

rule CreateComb()
{
	-:TopState-> st:State;		
	
	modify
	{
		eval
		{
			(def comb : Node) = get_comb(st);
			////emit("comb:", print_oper(comb));
			if (typeof(comb) == OrConf)
			{
				def or : OrConf = (OrConf)comb;
				def ref op : set<Node> = or.oper;
				for (i : Node in op)
				{
					if (typeof(i) == AndConf)
					{												
						(def ccomb : AndConf) = sub_region_sort((AndConf)i);
						create_comb_and(ccomb);
					} else
					if (typeof(i) >= State)
					{
						create_comb(array<Node>[i]);
					}
				}
			} else
			if (typeof(comb) == AndConf)
			{
				(def ccomb : AndConf) = sub_region_sort((AndConf)comb);
				create_comb_and(ccomb);
			} else
			if (typeof(comb) >= State)
			{
				create_comb(array<Node>[comb]);
			}			
			exec([ClearOper]);
			//Debug::halt("test cfg");
		}
		
	}
}

// delete oper nodes
rule ClearOper()
{
	n:Oper;
	
	replace{}
}

procedure create_comb_and(comb : AndConf) : (Node)
{
	def ref op : set<StateMachineNode> = set<StateMachineNode>(comb.oper);
	def ref oparr : array<Node> = array<Node>(op.asArray().orderAscendingBy<depth>());
	////emit("\ncreate_comb_and:", print_oper(comb), " \nsorted:", print_arr(oparr));
	(def res : Node) = create_comb(oparr);
	return (res);
}

procedure create_comb(ref n : array<Node>) : (Node)
{
	def prev : Node;
	def first_node : Node;
    def var first : boolean = true;
	for (i : Node in n)
	{
		def new_st : ActiveState;
		if (typeof(i) >= State)
		{
			(def cpy : Node) = addCopy(i);
			if (typeof(i) == SubRegion)
			{
				(def nst : ActiveSubRegionState) = retype(cpy, ActiveSubRegionState);
				////emit("\nsub region create:", print_oper(nst));
				nst.idx = ((SubRegion)i).idx;
				new_st = nst;				
			} else
			if (typeof(i) == ConcurrentState)
			{
				(def nst : ActiveRegionState) = retype(cpy, ActiveRegionState);
				////emit("\nconc state create:", print_oper(nst));
				nst.regions_count = ((ConcurrentState)i).regions_count;
				new_st = nst;				
			} else // if state
			{
				if (first)
				{
					////emit("\nbase state create:", print_oper(cpy));
					(new_st) = retype(cpy, ActiveBaseState);
				} else
				{
					////emit("\nstate create:", print_oper(cpy));
					(new_st) = retype(cpy, ActiveState);
				}
			}
		} else
		if (typeof(i) == AndConf)
		{
			def and : AndConf = (AndConf)i;
			def ref st : set<ConcurrentState> = set<ConcurrentState>(and.oper);
			def ref sub : set<AndConf> = set<AndConf>(and.oper);
			////emit("\nconc_comb:", print_oper(and));
			if (!st.empty() && !sub.empty())
			{
				def stc : ConcurrentState = st.peek(0);
				(def cpy1 : Node) = addCopy(stc);
				(def nst : ActiveRegionState) = retype(cpy1, ActiveRegionState);
				////emit("\ncreate st:", print_oper(nst));
				nst.regions_count = stc.regions_count;
				new_st = nst;
				
				for (sr : AndConf in sub)
				{
					(def f : Node) = create_comb_and(sr);					
					////emit(print_oper(nst), "\nedge:", print_oper(f));
					add(And, nst, f);
					//Debug::halt("create one and conf");
				}
			}
		}
		// new_st.id 	= i.id;
		// new_st.name = i.name;
		// new_st.entry_act = i.entry_act;
		// new_st.exit_act = i.exit_act;
		// new_st.do_act = i.do_act;
		// new_st.defer  = i.defer;
		// new_st.depth	  = i.depth;
		
		if (!first)			
		{
			add(And, prev, new_st);			
		} else 
		{
			first_node = new_st;
			first = false;
		}
		prev = new_st;
	}
	return (first_node);
}

procedure sub_region_sort(n : AndConf) : (AndConf)
{
	def ref oper : set<Node> = n.oper;
	////emit("\nsort:", print_set(oper));
	def ref res : set<Node> = set<Node>{};
	def ref filt : set<Node> = set<Node>{};
	def var min_depth : int = Math::intMax();
	for (i : StateMachineNode in oper)
	{
		if (!(i in filt))
		{
			if (typeof(i) == ConcurrentState)
			{
				def st : ConcurrentState = (ConcurrentState)i;
				filt.add(i);
				//res.rem(i); // remove from result set
				////emit("\nfilt1:", print_set(filt));
				def ref sub_reg : set<Node> = adjacentOutgoing(st, Region); // get sub regions
				////emit("\nsub_reg:", print_set(sub_reg));
				(def nst : AndConf) = add(AndConf); // add new and conf node			
				nst.depth = st.depth; // depth like state
				if (st.depth < min_depth) 
				{	
					min_depth = st.depth; // min depth calc
				}
				for (s : SubRegion in sub_reg) // for each sub region
				{
					(def nn : AndConf) = add(AndConf); // create new and conf
					nn.depth = s.depth;					
					////emit("\nsub:", print_set(set<Node>(s.sub_states)));
					nn.oper = oper & set<Node>(s.sub_states); // intersection of elements and recursive sub states of sub region				
					nn.oper.add(s); // add sub region to this set
					////emit("\nn.oper:", print_oper(nn));
					//res \= nn.oper; // remove this set from result set
					filt |= nn.oper;
					////emit("\nfilt:", print_set(filt));
					(def rn : AndConf) = sub_region_sort(nn); // recursive check in sub region				
					nst.oper.add(rn); // add and node to result set				
				}
				
				nst.oper.add(i);
				////emit("\nnst:", print_oper(nst));
				res.add(nst);
				////emit("\nres_iter:", print_set(res));
			} else
			{
				if (i.depth < min_depth) 
				{
					min_depth = i.depth; // min depth calc
				}
				res.add(i);
			}
		}
	}
	
	if (oper == res)
	{
		//emit("\rres:", print_oper(n));
		return (n);
	} else
	{
		(def nr : AndConf) = add(AndConf); // add new and conf node
		nr.oper = res;
		nr.depth = min_depth;
		//emit("\rres:", print_oper(nr));
		return (nr);
	}	
}

procedure get_comb(n : State) : (Node)
{
	def ref childs 	: set<Node> = adjacentOutgoing(n, Substate);		
		
	def var first : boolean = true;
	if (childs.empty())
	{
		//emit("\nget_comb:", print_oper(n));
		return (n);
	} else
	{
		def childs_comb : Node;
		if (typeof(n) != ConcurrentState)
		{
			first = true;
			for (i : State in childs)
			{
				(def comb : Node) = get_comb(i);			
				if (first)
				{
					childs_comb = comb;
					first = false;
				} else
				{
					(childs_comb) = or_comb(childs_comb, comb);
				}
				//emit("\nchilds_comb_or:", print_oper(childs_comb));
				
			}
		} else
		{
			for (i : State in childs)
			{
				(def comb : Node) = get_comb(i);
				
				if (first)
				{
					childs_comb = comb;
					first = false;
				} else
				{
					//emit("\nand:", print_oper(childs_comb), "&", print_oper(comb));
					(childs_comb) = and_comb(childs_comb, comb);
				}
				//emit("\nchilds_comb_and:", print_oper(childs_comb));				
			}
		}	
		(def res : Node) = and_comb(n, childs_comb);
		//emit("\nget_comb:", print_oper(res));
		return (res);
	}	
}

function print_arr(ref x : array<Node>) : string
{
	def var str : string = "[";
	def var first : boolean = true;
	for (i : Node in x)
	{
		if (first)
		{
			str = str + print_oper(i);
			first = false;
		} else
		{
			str = str + ", " + print_oper(i);
		}
		
	}
	str = str + "]";
	return (str);
}

function print_set(ref x : set<Node>) : string
{
	def var str : string = "{";
	def var first : boolean = true;
	for (i : Node in x)
	{
		if (first)
		{
			str = str + print_oper(i);
			first = false;
		} else
		{
			str = str + ", " + print_oper(i);
		}
		
	}
	str = str + "}";
	return (str);
}

function print_oper(x : Node) : string
{
	def var str : string = "";
	def var first : boolean = true;
	if (typeof(x) == AndConf)
	{
		def ref oper : set<Node> = ((AndConf)x).oper;
		str = "(";		
		for (i : Node in oper)
		{
			if (first)
			{
				str = str + print_oper(i);
				first = false;
			} else
			{
				str = str + " & " + print_oper(i);
			}
		}
		str = str + ")";
	} else
	if (typeof(x) == OrConf)
	{
		def ref oper : set<Node> = ((OrConf)x).oper;
		str = "(";
		first = true;
		for (i : Node in oper)
		{
			if (first)
			{
				str = str + print_oper(i);
				first = false;
			} else
			{
				str = str + " | " + print_oper(i);
			}
		}
		str = str + ")";
	} else
	if (typeof(x) >= NamedNode)
	{
		def p : NamedNode = (NamedNode)x;
		str = p.name;
	} else
	if (typeof(x) >= Node)
	{
		str = nameof(x);
	}	
	return (str);
}

procedure or(ref or : set<Node>) : (OrConf)
{
	(def n : OrConf) = add(OrConf);
	for (i : Node in or)
	{
		if (typeof(i) == OrConf)
		{
			n.oper |= ((OrConf)i).oper;
		} else
		{
			n.oper.add(i);
		}
	}

	return (n);
}

procedure or_comb(x : Node, y : Node) : (Node)
{
	emit("\n", print_oper(x), " | ", print_oper(y));
	(def res : OrConf) = or(set<Node>{x, y});
	// if (typeof(x) == OrConf && typeof(y) == OrConf)
	// {
		// def nx : OrConf = (OrConf)x;
		// def ny : OrConf = (OrConf)y;
		// (def n : OrConf) = add(OrConf);
		// n.oper = nx.oper | ny.oper;
		// //rem(y);
		// emit("\nres:", print_oper(n));
		// return (n);		
	// }	
	// if (typeof(y) == OrConf)
	// {
		// def ny : OrConf = (OrConf)y;			
		// (def n : OrConf) = add(OrConf);		
		// n.oper = set<Node>{x} | ny.oper;
		// emit("\nres:", print_oper(n));
		// return (n);		
	// } else
	// if (typeof(x) == OrConf)
	// {
		// (def n : OrConf) = add(OrConf);
		// def nx : OrConf = (OrConf)x;
		// n.oper = nx.oper | set<Node>{y};
		// emit("\nres:", print_oper(n));
		// return (n);		
	// } else	
	// {
		// (def n : OrConf) = add(OrConf);
		// n.oper = set<Node>{x, y};
		// emit("\nres:", print_oper(n));
		// return (n);
	// }
	emit("\nres:", print_oper(res));
	return (res);
}

procedure and(ref x : set<Node>) : (AndConf)
{
	(def n : AndConf) = add(AndConf);	
	for (i : Node in x)
	{
		if (typeof(i) == AndConf)
		{
			def conf : AndConf = (AndConf)i;
			n.oper |= conf.oper;
		} else 
		{
			n.oper.add(i);
		}
	}	
	return (n);
}

procedure and_or(x : OrConf, y : Node) : (OrConf)
{
	(def n : OrConf) = add(OrConf);
	def ref oper : set<Node> = ((OrConf)x).oper;
	//def ref res : set<Node> = set<Node>{};
	for (i : Node in oper)
	{			
		(def and : Node) = and_comb(i, y);
		n.oper.add(and);
	}
	return (n);
}

procedure and_comb(x : Node, y : Node) : (Node)
{	
	emit("\n", print_oper(x), " & ", print_oper(y));
	////emit(typeof(x), typeof(y));
	// if (typeof(x) >= State && typeof(y) >= State)
	// {
		// (def n : AndConf) = and(set<Node>{x, y});
		// // n.oper = set<Node>{x, y};
		
		// //emit("\nres:", print_oper(n));
		// return (n);
	// } else
	// if (typeof(x) >= State && typeof(y) == AndConf)
	// {
		// (def n : AndConf) = and(set<Node>{x, y});
		// // def ny : AndConf = (AndConf)y;
		// // n.oper = set<Node>{x} | ny.oper;		
		// //emit("\nres:", print_oper(n));
		// return (n);
	// } else
	// if (typeof(x) == AndConf && typeof(y) >= State)
	// {
		// def nx : AndConf = (AndConf)x;
		// (def n : AndConf) = add(AndConf);
		// n.oper = nx.oper | set<Node>{y};
		// //emit("\nres:", print_oper(n));
		// return (n);
	// } else
	// if (typeof(x) == AndConf && typeof(y) == AndConf)
	// {
		// def nx : AndConf = (AndConf)x;
		// def ny : AndConf = (AndConf)y;
		// (def n : AndConf) = add(AndConf);
		// n.oper = nx.oper | ny.oper;		
		// //emit("\nres:", print_oper(n));
		// return (n);
	// }
	if (typeof(x) == OrConf && typeof(y) == OrConf)
	{
		// def nx : OrConf = (OrConf)x;
		// def ny : OrConf = (OrConf)y;
		//def ref res   : set<Node> = set<Node>[];
		def ref operx : set<Node> = ((OrConf)x).oper;
		def ref opery : set<Node> = ((OrConf)y).oper;		
		(def n : OrConf) = add(OrConf);
		//emit("\nor_and_or:");		
		for (ix : Node in operx)
		{			
			for (iy : Node in opery)
			{
				//emit("\nor_and_or:", print_oper(ix), print_oper(iy));
				(def and : Node) = and_comb(ix, iy);
				n.oper.add(and);
			}
		}
		//n.oper = res;
		//rem(y);
		emit("\nres:", print_oper(n));
		return (n);		
	} else
	if (typeof(y) == OrConf)
	{
		
		(def n : OrConf) = and_or((OrConf)y, x);
		// def ref oper : set<Node> = ((OrConf)y).oper;
		// //def ref res : set<Node> = set<Node>{};
		// for (i : Node in oper)
		// {			
			// (def and : Node) = and_comb(x, i);
			// n.oper.add(and);
		// }
		//n.oper = res;
		emit("\nres:", print_oper(n));
		return (n);		
	} else
	if (typeof(x) == OrConf)
	{		
		(def n : OrConf) = and_or((OrConf)x, y);
		// def ref oper : set<Node> = ((OrConf)x).oper;
		// //def ref res  : set<Node> = set<Node>{};
		// (def n : OrConf) = add(OrConf);
		// for (i : Node in oper)
		// {
			// (def and : Node) = and_comb(i, y);		
			// n.oper.add(and);
		// }		
		emit("\nres:", print_oper(n));
		return (n);		
	}		
	else 
	{
		(def n : AndConf) = and(set<Node>{x, y});
		// n.oper = set<node>{x, y};
		
		emit("\nres:", print_oper(n));
		return (n);
		//emit("\nres:", "null");
		//return (null);
	}
	
}