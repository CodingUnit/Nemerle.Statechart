rule CreateComb()
{
	st:State;
	
	iterated
	{
		st -:Substate-> ch:State;
		
		break negative {if {ch.combinations.empty();}}
		
		modify {}
	}
	
	if {st.combinations.empty();}
	
	modify
	{
	}
}

function get_comb(n : State) : set<Node>
{
	def ref childs : set<Node> = adjacentOutgoing(n, Substate);
	return (childs);
}

procedure and_comb(x : Node, y : Node) : (AndConf)
{	
	if (typeof(x) == State && typeof(y) == AndConf)
	{
		def ny : AndConf = (AndConf)y;
		ny.oper.add(x);
		return (ny);
	} else
	if (typeof(x) == AndConf && typeof(y) == State)
	{
		def nx : AndConf = (AndConf)x;
		nx.oper.add(y);
		return (nx);
	} else
	if (typeof(x) == AndConf && typeof(y) == AndConf)
	{
		def nx : AndConf = (AndConf)x;
		def ny : AndConf = (AndConf)y;
		nx.oper |= ny.oper;
		rem(ny);
		return (nx);
	}
	else 
	{
		(def n : AndConf) = add(AndConf);
		n.oper = set<Node>{x, y};
		return (n);
	}
	
}