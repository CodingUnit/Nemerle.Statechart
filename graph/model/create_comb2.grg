rule CreateComb()
{
	-:TopState-> st:State;		
	
	modify
	{
		eval
		{
			(def comb : Node) = get_comb(st);
			emit("comb:", print_oper(comb));
			if (typeof(comb) == OrConf)
			{
				def or : OrConf = (OrConf)comb;
				def ref op : array<Node> = or.oper;
				for (i : Node in op)
				{
					if (typeof(i) == AndConf)
					{
						def ref and : array<Node> = ((AndConf)i).oper;
						create_comb(and);
					} else
					if (typeof(i) == State)
					{
						create_comb(array<Node>[i]);
					}
				}
			} else
			if (typeof(comb) == AndConf)
			{
				def ref and : array<Node> = ((AndConf)comb).oper;
				create_comb(and);
			} else
			if (typeof(comb) == State)
			{
				create_comb(array<Node>[comb]);
			}
		}
		
	}
}

procedure create_comb(ref n : array<Node>)
{
	def prev : Node;

	for (idx : int -> i : State in n)
	{
		def new_st : ActiveState;
		(def cpy : State) = addCopy(i);
		if (typeof(i) != SubRegion && typeof(i) != ConcurrentState)
		{
			if (idx == 0)
			{
				(new_st) = retype(cpy, ActiveBaseState);
			} else
			{
				(new_st) = retype(cpy, ActiveState);
			}
		} else
		if (typeof(i) == SubRegion)
		{
			(def nst : ActiveSubRegionState) = retype(cpy, ActiveSubRegionState);
			nst.idx = ((SubRegion)i).idx;
			new_st = nst;				
		} else
		if (typeof(i) == ConcurrentState)
		{
			
			(def nst : ActiveRegionState) = retype(cpy, ActiveRegionState);
			nst.regions_count = ((ConcurrentState)i).regions_count;
			new_st = nst;				
		}
		// new_st.id 	= i.id;
		// new_st.name = i.name;
		// new_st.entry_act = i.entry_act;
		// new_st.exit_act = i.exit_act;
		// new_st.do_act = i.do_act;
		// new_st.defer  = i.defer;
		// new_st.depth	  = i.depth;
		
		if (idx != 0)			
		{
			add(And, prev, new_st);
		}
		prev = new_st;
	}
	return;
}

procedure get_comb(n : State) : (Node)
{
	def ref childs 	: array<Node> = adjacentOutgoing(n, Substate).asArray();	
	def childs_comb : Node;
	
	if (typeof(n) != ConcurrentState)
	{
		for (idx : int -> i : State in childs)
		{
			(def comb : Node) = get_comb(i);
			if (idx == 0)
			{
				childs_comb = comb;
			} else
			{
				(childs_comb) = or_comb(childs_comb, i);
			}
		}
	} else
	{
		for (idx : int -> i : State in childs)
		{
			(def comb : Node) = get_comb(i);
			if (idx == 0)
			{
				childs_comb = comb;
			} else
			{
				(childs_comb) = and_comb(childs_comb, i);
			}
		}
	}
	if (childs.empty())
	{
		return (n);
	} else
	{
		(def res : Node) = and_comb(n, childs_comb);
		return (res);
	}	
}

function print_oper(x : Node) : string
{
	def var str : string = "";
	if (typeof(x) == AndConf)
	{
		def ref oper : array<Node> = ((AndConf)x).oper;
		str = "(";
		for (idx : int -> i : Node in oper)
		{
			if (idx == 0)
			{
				str = print_oper(i);
			} else
			{
				str = str + "& " + print_oper(i);
			}
		}
		str = str + ")";
	} else
	if (typeof(x) == OrConf)
	{
		def ref oper : array<Node> = ((OrConf)x).oper;
		str = "(";
		for (idx : int -> i : Node in oper)
		{
			if (idx == 0)
			{
				str = print_oper(i);
			} else
			{
				str = str + "| " + print_oper(i);
			}
		}
		str = str + ")";
	} else
	if (typeof(x) == State)
	{
		str = nameof(x);
	}
	return (str);
}

procedure or_comb(x : Node, y : Node) : (Node)
{
	emit(print_oper(x), "|", print_oper(y));
	if (typeof(x) == OrConf && typeof(y) == OrConf)
	{
		def nx : OrConf = (OrConf)x;
		def ny : OrConf = (OrConf)y;
		nx.oper += ny.oper;
		rem(y);
		emit("res:", print_oper(nx));
		return (nx);		
	}	
	if (typeof(y) == OrConf)
	{
		def ny : OrConf = (OrConf)y;				
		ny.oper.add(x, 0);
		emit("res:", print_oper(ny));
		return (ny);		
	} else
	if (typeof(x) == OrConf)
	{
		def nx : OrConf = (OrConf)x;
		nx.oper.add(y);
		emit("res:", print_oper(nx));
		return (nx);		
	} else	
	{
		(def n : OrConf) = add(OrConf);
		n.oper = array<Node>[x, y];
		emit("res:", print_oper(n));
		return (n);
	}
		
}

procedure and_comb(x : Node, y : Node) : (Node)
{	
	emit(print_oper(x), "&", print_oper(y));
	if (typeof(x) == State && typeof(y) == State)
	{
		(def n : AndConf) = add(AndConf);
		n.oper = array<Node>[x, y];
		emit("res:", print_oper(n));
		return (n);
	} else
	if (typeof(x) == State && typeof(y) == AndConf)
	{
		def ny : AndConf = (AndConf)y;
		ny.oper.add(x, 0);
		emit("res:", print_oper(ny));
		return (ny);
	} else
	if (typeof(x) == AndConf && typeof(y) == State)
	{
		def nx : AndConf = (AndConf)x;
		nx.oper.add(y);
		emit("res:", print_oper(nx));
		return (nx);
	} else
	if (typeof(x) == AndConf && typeof(y) == AndConf)
	{
		def nx : AndConf = (AndConf)x;
		def ny : AndConf = (AndConf)y;
		nx.oper += ny.oper;
		rem(y);
		emit("res:", print_oper(nx));
		return (nx);
	}
	if ((typeof(x) == State  || typeof(x) == AndConf) && typeof(y) == OrConf)
	{
		def ny : OrConf = (OrConf)y;
		def ref oper : array<Node> = ny.oper;
		def ref res : array<Node> = array<Node>[];
		for (i : Node in oper)
		{			
			(def and : Node) = and_comb(x, i);
			res.add(and);
		}
		ny.oper = res;
		emit("res:", print_oper(ny));
		return (ny);		
	} else
	if (typeof(x) == OrConf && (typeof(y) == State  || typeof(y) == AndConf))
	{
		def nx : OrConf = (OrConf)x;
		def ref oper : array<Node> = nx.oper;
		def ref res  : array<Node> = array<Node>[];
		for (i : Node in oper)
		{
			(def and : Node) = and_comb(i, y);		
			res.add(and);
		}
		nx.oper = res;
		emit("res:", print_oper(nx));
		return (nx);		
	} else
	if (typeof(x) == AndConf && typeof(y) == OrConf)
	{
		def ny : OrConf = (OrConf)y;
		def ref oper : array<Node> = ny.oper;
		def ref res  : array<Node> = array<Node>[];
		for (i : Node in oper)
		{
			(def and : Node) = and_comb(x, i);
			res.add(and);
		}
		ny.oper = res;
		emit("res:", print_oper(ny));
		return (ny);		
	} else
	if (typeof(x) == OrConf && typeof(y) == OrConf)
	{
		def nx : OrConf = (OrConf)x;
		def ny : OrConf = (OrConf)y;
		def ref operx : array<Node> = nx.oper;
		def ref opery : array<Node> = ny.oper;
		def ref res   : array<Node> = array<Node>[];
		for (ix : Node in operx)
		{			
			for (iy : Node in opery)
			{
				(def and : Node) = and_comb(ix, iy);
				res.add(and);
			}
		}
		nx.oper = res;
		rem(y);
		emit("res:", print_oper(nx));
		return (nx);		
	}		
	else 
	{
		emit("res:", "null");
		return (null);
	}
	
}