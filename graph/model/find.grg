// graph rewrite rule file, shows how to define a model to use, and how a rule looks like,
// with the pattern to match and the rewrite to apply, with lhs and rhs elements being indentified by their name

// find or create element in parent of type 
pattern FindOrCreate(parent : Node, type : Node) modify(def ret : Node)
{
  alternative
  {
    found
	{
	// search for parent contains node of that type
	  parent -:Contains-> t:typeof(type);
	  //if {typeof(t) == typeof(type);}
	  
	  //hom(parent, t);
	  modify
	  {
	  // return to rhs part
		eval { yield ret = t; }
	  }
	}
	not_found
	{	  
	  negative
	  {
	    // if not found
		parent -:Contains-> t:typeof(type);
		
		//if {typeof(t) == typeof(type);}
	  }
	  modify
	  {
	   // create
		parent -:Contains-> t:typeof(type);
		eval { yield ret = t; } // return to rhs part
	  }
	}
	
  }

  modify
  {
  }  
}

// find or create element in parent of type 
pattern FindHierarchy(parent : Node, type : Node, def ret : Node)
{
  (
	  // search for parent contains node of that type	  
	  parent -:Contains-> type;
	  yield {yield ret = type;} // yield to output
	|	
	  ~( parent -:Contains-> type; ) // if not found 
	  
	  p:Node -:Contains-> parent; // match parent
	  :FindHierarchy(p, type, yield ret); // recursive call with parent
	
  )

}

// find or create element in parent of type 
pattern FindNameHierarchy(parent : Node, type : Node, var name : string, def ret : Node)
{
  (
	// search for parent contains node of that type	  
	  parent -:Contains-> type;
	  t:NamedNode<type>; // try cast to type
	 
	  if {t.name == name;} // if name is equal to search
	  
	  yield {yield ret = t;} // return
	|
	  negative
	  {
	    // if not found
		parent -:Contains-> type;
	  }
	  
	  p:Node -:Contains-> parent; // get parent
	  :FindNameHierarchy(p, type, name, yield ret); // recursive call with parent
  )
}

// test ParentOf(elem : Node) : (State)
// {
  // parent:State -:Contains-> elem;
  
  // return (parent);
// }

// pattern FindContainedType(parent : Node, type : Node, def ret : Node)
// {
  // parent -:Contains-> type;
  // yield {yield ret = type;}
// }

pattern FindQualified(ref tar : array<string>, def ret : StateMachineNode)
{
	n:NamedNode;
	:QualifiedRec(n, tar, 0, yield ret);
}

pattern FindQualifiedType(ref tar : array<string>, type : Node, def ret : Node)
{
	n:NamedNode;
	:QualifiedRecType(n, tar, 0, type, yield ret);
}

pattern QualifiedRec(state : NamedNode, ref tar : array<string>, var idx : int, def ret : StateMachineNode)
{
	if { state.name == tar[idx];} // if name of this child equal current path at index
	(	   
		if {idx < tar.size() - 1;} // is not at end of array			
		state -:Contains-> t:NamedNode; // find named node contained in state
		:QualifiedRec(t, tar, idx + 1, yield ret); // recursive search for path at next index
	|	    
		if {idx >= tar.size() - 1;}        // index at end of array 									
		yield { yield ret = state; } // yield result
	)
}

// pattern QualifiedRecInParent(main_parent : Node, state : NamedNode, ref tar : array<string>, var idx : int, def ret : StateMachineNode)
// {
	// alternative
	// {	   
	    // first // first entry
		// {
		    // st:NamedNode; // search for named node
		    // if { idx == 0; } // at index 0 of path
            // if { st.name == tar[0]; } // name equal to this first name		  
		    // :QualifiedRec(st, tar, 1, yield ret);  // recursive call next index with that node
		// }
		// next
	    // {
			// negative
			// {
			   // if {idx == 0 || idx == tar.size();} // is not at 0 index or at end of array
			   // //if {state == null;}
			// }
			// state -:Contains-> t:NamedNode; // find named node contained in state
			// if { t.name == tar[idx];} // if name of this child equal current path at index
			
		    // :QualifiedRec(t, tar, idx + 1, yield ret); // recursive search for path at next index
	    // }
	    // end
	    // {
			// if {idx == tar.size();}        // index at end of array 		
			// if (isReachable(main_parent, state, Contains));
			// yield { yield ret = state; } // yield result
	    // }	   
	// }
// }

pattern QualifiedRecType(state : NamedNode, ref tar : array<string>, var idx : int, type : Node, def ret : Node)
{
	if { state.name == tar[idx];} // if name of this child equal current path at index
	(	  
		if {idx < tar.size() - 1;} // is not at 0 index or at end of array
		
		state -:Contains-> t:NamedNode; // find named node contained in state
		:QualifiedRecType(t, tar, idx + 1, type, yield ret); // recursive search for path at next index
	 |
		if {idx >= tar.size() - 1;}        // index at end of array 
		state -:Contains-> type;			
		yield { yield ret = type; } // yield result
	 
	)
}


/*
// find qualified target state.substate or state.pseudo syntax
test FindHistory(state : State, hist : History) : (StateMachineNode)
{
  def ret : StateMachineNode;
  
  :FindRecHierarchy(state, hist, null, yield ret);
  return (ret);    
}*/

/*
pattern FindRecHierarchy(state : State, type : StateMachineNode, var name : string, def ret : StateMachineNode)
{
	alternative
	{
	  found_hist
	  {
	    state -:Contains-> h:History; // search for history in state
		
		//if {typeof(type) >= History;}
		if {typeof(h) >= typeof(type);} // if type is above or equal to external type
		
		yield { yield ret = h; } // yield to output
		
	  }
	  found
	  {
		negative
		{
			if {typeof(type) >= History;}
		}
		state -:Contains-> n:NamedNode; // search for history in state
		if {typeof(n) == typeof(type);}
		if {n.name == name;}
		//if {typeof(n) >= typeof(hist);} // if type is above or equal to external type
		
		yield { yield ret = n; } // yield to output 
	  }
	  not_found
	  {
	    parent:State -:Contains-> state; // get parent of state	    
			
		negative
		{
		  state -:Contains-> n:typeof(type); // search for history in state
		}
		:FindRecHierarchy(parent, type, name, yield ret); // recursive search for history in parent
	  }
	}
}

*/

/*
pattern HistoryFindRec(state : State, hist : History, def ret : History)//var hist : history_type
{
	alternative
	{
	  found
	  {
	    state -:Contains-> h:History; // search for history in state
		
		//if {hist == history_type::deep; }
		if {typeof(h) >= typeof(hist);} // if type is above or equal to external type
		
		yield
		{
			yield ret = h; // yield to output
		}
		
	  }	  
	  not_found
	  {
	    parent:State -:Contains-> state; // get parent of state
		
	    negative
		{
			state -:Contains-> h:History; // it does not contain history			 
		}
				
		// negative
		// {
			// state -:Contains-> h:DeepHistory; // search for history in state
		
			// if {hist == history_type::deep; }
		// }
		:HistoryFindRec(parent, hist, yield ret); // recursive search for history in parent
	  }
	}
}*/

// find qualified target state.substate or state.pseudo syntax
test FindNamed(var name : string) : (NamedNode)
{
  t:NamedNode;  
  
  if { t.name == name; }   
  return (t);
}

/*
// find qualified target state.substate or state.pseudo syntax
test FindNamedHierarchy(st : State, type : StateMachineNode, var name : string) : (StateMachineNode)
{
  def t:StateMachineNode;  
  
  //if { t.name == name; }   
  :FindRecHierarchy(st, type, name, yield t);
  return (t);
}*/

// function LCA(u : Node, v : Node) : Node
// {	 
	 // def lca : Node;
	 // :LCArec(u, v, yield lca);
	 // return (lca);
// }

function LCA(u : StateMachineNode, v : StateMachineNode) : Node
{
	// parent1:StateMachineNode -:Contains-> u;
	// parent2:StateMachineNode -:Contains-> v;
	// yield
	// {
		// yield lca = LCAfunc(parent1, parent2, parent1.depth, parent2.depth);
	// }
	return (LCAfunc(adjacentIncoming(u, Contains).peek(0), adjacentIncoming(v, Contains).peek(0), u.depth - 1, v.depth - 1));
	//:LCArec(parent1, parent2, parent1.depth, parent2.depth, yield lca);
}

//pattern LCAp(u : StateMachineNode, v : StateMachineNode)
pattern LCArec(u : StateMachineNode, v : StateMachineNode, var d1 : int, var d2 : int, def lca : Node)
{	
	parent1:StateMachineNode -:Contains-> u;
	parent2:StateMachineNode -:Contains-> v;
	(
	     if { d1 > d2;}
	 
		 //parent:StateMachineNode -:Contains-> u;
		 :LCArec(parent1, v, d1 - 1, d2, yield lca);
	 |   
		 if { d1 < d2;}
	 
		 //parent:StateMachineNode -:Contains-> v;
		 :LCArec(u, parent2, d1, d2 - 1, yield lca);
     |   
		 if {d1 == d2;}
	     // if {u != v;}
		 // parent1:StateMachineNode -:Contains-> u;
		 // parent2:StateMachineNode -:Contains-> v;
		 
		 // :LCArec(parent1, parent2, d1, d2, yield lca);
     // | 
	     // if { u == v; }
		 yield { yield lca = u; }
	 // |	
		 // if {d1 == 0 && d2 == 0;}
		 // yield { yield lca = u; }
	)
	
}

function LCAfunc(u : Node, v : Node, var d1 : int, var d2 : int) : Node
{
	if (d1 > d2)
	{
		def p1 : Node = adjacentIncoming(u, Contains).peek(0);
		return (LCAfunc(p1, v, d1 - 1, d2));
	}
	if (d1 < d2)
	{
		def p2 : Node = adjacentIncoming(v, Contains).peek(0);
		return (LCAfunc(u, p2, d1, d2 - 1));
	} else
	{
		if (u != v)
		{
			def p1 : Node = adjacentIncoming(u, Contains).peek(0);
			def p2 : Node = adjacentIncoming(v, Contains).peek(0);
			return (LCAfunc(p1, p2, d1, d2));
		} else
		{
			return (u);
		}
	}
}
/*
Процедура LCA(u, v):
    h1 := depth(u)          // depth(x) = глубина вершины x
    h2 := depth(v)
  
    while h1 != h2:
       if h1 > h2:
          u := parent(u)
          h1 := h1 - 1
       else:
          v := parent(v)
          h2 := h2 - 1
  
    while u != v:
       u := parent(u)       // parent(x) = непосредственный предок вершины x
       v := parent(v)
  
    return u
*/
pattern FindSourceState(st : PseudoState, def source : State) 
{
  alternative
  {
    found
	{
		state:State -e:Transition-> st;
	   
		yield { yield source = state; }
	}
	not_found
	{
		state:PseudoState -e:Transition-> st;		
		
		:FindSourceState(state, yield source);
	}
  }
  
}