rule StateCombinations()
{
	-:TopState-> . -e:SimpleState-> state:State;
	and:CreateConfig(state);	
		
	modify
	{
		new_st : ActiveSimpleState;
		eval
		{
			new_st.id 	= state.id;
			new_st.name = state.name;
			new_st.entry_act = state.entry_act;
			new_st.exit_act = state.exit_act;
			new_st.do_act = state.do_act;
		}
		and(new_st);
		delete(e);
	} 
}

rule SimpleStates()
{	
	st:State;
	
	-:TopState-> top:State;
	
	~( st -:Substate->; )
	~( top -:SimpleState-> st; )
	//if (isReachableIncoming(st, top, Contains));
	
	modify
	{
		top -:SimpleState-> st;
	}
	//yield {yield ret = st;}
}

rule CreateConfigEdges()
{
	(
		src:State -:Transition->;
		
		iterated
		{
			st:ActiveState;
		
			~(src -:Config-> st;)
			if {st.id == src.id;}
		
			modify
			{
				src -:Config-> st;
			}
		}
		
		modify {}
	|
		-:Transition-> src:State;
		def st : ActiveState;
		def simple : State;
		
		:InitialConfigSimpleStates(src, yield simple, yield st);
		
		modify
		{
			simple -:Config-> st;
		}
	)
	
}

pattern CreateConfig(st : State) modify(root : ActiveState)
{	
	optional
	{
		parent:State -:Contains-> st;
		(
			if {typeof(parent) == State;}		
					
			and:CreateConfig(parent);
			//e:CreateConfigEdge(st);
			
			modify
			{
				root <-:And- nst:ActiveState;
				//parent -:Config-> nst;
				eval {yield new_st = nst;}
				and(nst);
			}
		| 				
			p:SubRegion<parent>;
			and:CreateConfig(parent);
			
			modify
			{
				root <-:And- nst:ActiveSubRegionState;
				//st -:Config-> nst;
				parent --> nst;
				eval
				{
					nst.idx 		  = p.idx;				
					yield new_st = nst;					
				}
				and(nst);
			}
		
		|	
			
			p:ConcurrentState<parent>;
			
			and:CreateConfig(parent);
			modify
			{
				root <-:And- nst:ActiveRegionState;
				//st -:Config-> nst;
				parent --> nst;
				eval
				{
					nst.regions = p.regions;
					yield new_st = nst;
				}
				and(nst);
			}
		)
		
		modify
		{	
			def new_st : ActiveState;
			
			eval
			{
				new_st.id 		  = parent.id;
				new_st.name 	  = parent.name;
				new_st.entry_act  = parent.entry_act;
				new_st.exit_act   = parent.exit_act;
				new_st.do_act     = parent.do_act;
			}			
		}
	}
	
	modify
	{	
	}
}

rule MarkAndRegions()
{
	st : ConcurrentState -e:Edge -> :ActiveState;	
	
	t:CreateAndOrRegion(st);
	
	modify { t(); }
}

// TODO: nested subregion in subregion
// pattern IterateConf(src : ActiveState)
// {
	
	// (
		// c : ActiveSubRegionState<src>;
		
		// ~(c --> :Oper;);
	// |
		// ~(c : ActiveSubRegionState<src>;)
		// parent : ActiveState --> src;
		// :IterateConf(parent);
	// )
	
// }

pattern CreateAndOrRegion(src:ConcurrentState)
{
	~(src --> :AndConf;)
	
	(
		src --> :SubRegion --> :ActiveSubRegionState <-- or:OrConf;
		
		modify { and_conf --> or; }
	)+
	
	modify { src --> and_conf:AndConf <-- :Eval; }	
}

rule OrSubRegion()
{
	st_sub:SubRegion;
	
	~( st_sub --> sub:ActiveSubRegionState <-- :OrConf; )
	
	iterated
	{
		st_sub -e:Edge-> sub:ActiveSubRegionState;
		
		modify { or --> sub; }
	}
	
	modify { or : OrConf; }
}

rule ClearAndRegion()
{
	st : ConcurrentState -a:Edge-> :AndConf;
	
	multiple
	{
		st -e:Edge-> :ActiveRegionState;
		
		modify
		{
			delete(e);
		}
	}
	
	modify
	{
		delete(a);
	}
}

rule ClearOrSubRegion()
{
	st_sub : SubRegion;	
	
	multiple
	{
		st_sub -e:Edge-> :ActiveSubRegionState;
		
		modify
		{
			delete(e);
		}
	}
	
	modify
	{				
	}
	
}

rule OrMoveToTopOfActiveState()
{
	sub:ActiveSubRegionState <-e:Edge- or:OrConf;
	
	def upper : ActiveState;
	:FindUpperActiveState(sub, yield upper);
	
	modify
	{
		delete(e);
		or --> upper;
	}
}

pattern FindUpperActiveState(st : ActiveState, def res : ActiveState)
{
	(
	  ~( --> st;)
	  yield {yield res = st;}
	|	
		parent:ActiveState --> st;
		:FindUpperActiveState(parent, yield res);
	)
}

pattern CopyConfig(n : Node, -ee:Edge->) modify(res : Node)
{
	// (
	   // a:ActiveState<n>;
	// |

		
	// )
	iterated
	{
		n -e:Edge-> child:Node;		
		
		t:CopyConfig(child, e);
		
		modify
		{				
			t(nn);			
		}
	}	
		
	modify
	{
		res -:typeof(ee)-> nn:copy<n>;
	}
				
}

rule DoublesEqualTargets()
{
	src:Node --> n:Node <-e:Edge- other:Node;
		
	if {typeof(n) >= ActiveState || typeof(n) >= Oper;}		
	
	t:CopyConfig(n, e);
	modify
	{
		//def nn : Node;
		//evalhere {(yield nn) = insertInduced(reachableOutgoing(n, Edge), n);}
		delete(e);
		//other -e->! nn;
		t(other);
	}
}

rule UnfoldAndOrComplex()
{
	left:OrConf <-- and:AndConf --> right:OrConf;
		
	
	(		
		and --> other:OrConf;
		
		modify
		{
			and --> res_or:OrConf;
			eval
			{
				Product(left, right, res_or);
			}
		}
	|
		
		~(
		   left <-- and --> right;
		   and  --> other:OrConf;
		 )
		
		modify
		{
			res_or:OrConf<and>;
			eval
			{
				Product(left, right, res_or);
			}
		}
	)	
	
	modify
	{		
		delete(right);
		delete(left);
	}
}

// product of all nodes adjacent in two nodes, connect to parent
procedure Product(left : Node, right : Node, parent : Node)
{
	for (chl:Node in adjacentOutgoing(left)) // for all left
	{
		for (chr:Node in adjacentOutgoing(right)) // for all right
		{
			(def a:AndConf) = add(AndConf); // create and
			add(Edge, a, chr); // connect to it
			add(Edge, a, chl);
			add(Edge, parent, a); // connect to parent
		}
	}
	return;
}

rule EvalConf()
{
	(
		left:ActiveState <-- and:AndConf --> right:ActiveState;
		parent:Node 	 --> and;
		
		t:EvalAndConf(left, left, right);
		
		modify
		{
			delete(and);
			parent --> left;			
			t();
		}
	|
		ev:Eval --> or:OrConf;
		
		iterated
		{
			or --> conf:ActiveState;
			
			modify {}
		}
		
		~(or --> :AndConf;)
		
		modify
		{
			//emitdebug("Number of state config:", count(it));
			delete(ev);
			delete(or);
		}
	)
		
}

pattern EvalAndConf(parent :ActiveState, left:ActiveState, right : ActiveState)
{
	(
		if {left.id == right.id;}
		
		left  --> lnext:ActiveState;
		right --> rnext:ActiveState;
		t:EvalAndConf(left, lnext, rnext);
		
		modify
		{
			delete(right);
			t();
		}
	|
		if {left.id != right.id;}
		
		modify
		{
			parent -:And-> right;
		}
	)	
}

rule ReachableConfigInit()
{
	-:TopState-> top:State;	
	if {top.possible_conf.empty();}	
	
	iterated it
	{
		active:ActiveState;
		
		~(--> active;)
		
		modify
		{
			eval
			{
				top.possible_conf.add(active);
				top.possible_conf_str.add(active.contains_str.asArray().asString("&"));
				
			}
		}
	}
	// names equals
		
	t:InitReachableConfig(top);
	//init:InitInitialConfig(top);
	modify
	{
		//def ref initial : set<State> = Set<State>{};
		iterated it;
		t();
		//init();
	}
}

rule InitialSimpleInit()
{
	simple:State;
	
	~(simple -:Substate->;)
	if {simple.initial_conf.empty();}
	
	modify
	{
		eval 
		{ 
			simple.initial_conf 	= simple.possible_conf;
			simple.initial_conf_str = simple.possible_conf_str;
		}
	}
}

rule InitialInit()
{
	simple:State;
	
	~(simple -:Substate->;)
	
	if {!simple.initial_conf.empty();}
	
	t:InitialInitRec(simple);
	
	modify
	{
		t();
	}
}

function IntersectArray(ref a1 : array<ActiveState>, ref a2 : array<ActiveState>) : array<ActiveState>
{
	def ref res : array<ActiveState> = array<ActiveState>[];
	for (i1 : ActiveState in a1)
	{
		if (i1 in a2)
		{
			res.add(i1);
		}
	}	
	return (res);
}

pattern InitialInitRec(state:State)
{	
	(
		parent:State -:Contains-> :InitialState --> state;
		
		if {parent.initial_conf.empty();}
		
		t:InitialInitRec(parent);
		
		modify
		{
			evalhere {parent.initial_conf = state.initial_conf;}
			t();
		}
		//if {state.initial_conf.empty();}
	|	
		parent:ConcurrentState -:Region-> state;
		
		if {parent.initial_conf.empty();}
		
		multiple
		{
			parent -:Region-> sub:SubRegion;
			
			break negative {if {sub.initial_conf.empty();}}
			
			modify			
			{
			}
		}
		
		t:InitialInitRec(parent);
		
		modify
		{			
			evalhere 
			{
				def ref states : array<ActiveState> = array<ActiveState>(state.initial_conf);
				for (i : State in adjacentOutgoing(parent, Region))
				{
					states = IntersectArray(states, i.initial_conf);
				}
				parent.initial_conf = states;
			}
			t();
		}
	|
		negative
		{
			:State -:Contains-> :InitialState --> state;
		}
		
		modify {}
	)
}

// filter configurations to this state set, configurations not contained states st, will be filtered
function FilterConf(ref conf : array<ActiveState>, ref st : set<State>) : array<ActiveState>
{
	def ref nconf : array<ActiveState> = array<ActiveState>(conf);
	for (a : ActiveState in conf)
	{
		if ((st & a.contains) == st) // configuration contains state only
		{
			nconf.add(a);
		}
	}
	return (nconf);
}

function ContainsConf(ref conf : array<ActiveState>, ref st : set<State>) : boolean
{
	for (a : ActiveState in conf)
	{
		if ((st & a.contains) != st) // configuration contains state only
		{
			return (false);
		}
	}
	return (true);
}

function GetConfigStr(ref st : array<ActiveState>) : array<string>
{
	def ref str : array<string>;
	for (s : ActiveState in st)
	{
		def ref arr : array<string> =  s.contains_str.asArray();
		def var text : string = arr.asString("&");
		str.add(text);
	}
	return (str);
}

pattern InitReachableConfig(state : State)
{
	iterated
	{
		state -:Substate-> sub:State;
		
		t:InitReachableConfig(sub);
		
		
		modify
		{
			def ref this_conf : set<State> = set<State>{sub};
			//
			evalhere
			{
				//def ref str : array<string>;
				sub.possible_conf = FilterConf(state.possible_conf, this_conf);				
				sub.possible_conf_str = GetConfigStr(sub.possible_conf);
				//sub.possible_conf = conf;
			}
			t();
		}
	}
	
	modify {}
}

/*
pattern InitInitialConfig(state : State)
{
	(
			if {state.initial_conf.empty();}
			
			t:InitialConfig(state);
			
			iterated
			{
				state -:Substate-> sub:State;
				
				rec:InitInitialConfig(sub);
				modify
				{
					evalhere
					{
						// sub.possible_conf = FilterConf(state.possible_conf, sub);
						// sub.possible_conf_str = array<string(){};
						// for (s : ActiveState in sub.possible_conf)
						// {
							// sub.possible_conf_str.add(s.asString("&"));
						// }
						
					}
					rec();
				}
			}
		
			modify
			{
				def ref init : set<State> = set<State>{};
				t(init);
				evalhere
				{
					state.initial_conf = FilterConf(state.possible_conf, init);
				}
			}
		|
			if {!state.initial_conf.empty();}
						
			iterated
			{
				state -:Substate-> sub:State;
				
				t:InitInitialConfig(sub);
				
				modify
				{
					evalhere
					{
						// if (state.initial_conf)
						// sub.initial_conf = 
						// sub.possible_conf = FilterConf(state.possible_conf, sub);
						// sub.possible_conf_str = array<string(){};
						// for (s : ActiveState in sub.possible_conf)
						// {
							// sub.possible_conf_str.add(s.asString("&"));
						// }
						
					}
					t();
				}
			}
			
			modify {}
		
	)
	 modify {}	
}
*/
rule ActiveStatesInit1()
{
	active:ActiveState;
	state:State;
	
	if {state.id == active.id;}
	~(if {state in active.contains;})
	
	
	modify
	{
		eval
		{
			active.contains.add(state);
			active.contains_str.add(state.name);
		}
	}
}

rule ActiveStatesInit()
{
	active:ActiveState;
	~(--> active;)
	
	if {active.contains.empty();}
	
	modify
	{
		eval
		{
			def ref all : set<Node> = reachable(active, Edge) | set<Node>{active};
			def ref all_st_name : set<string> = set<string>{};
			def ref all_st : set<State> = set<State>{};
			for (a : ActiveState in all)
			{				
				all_st_name |= a.contains_str;
				all_st |= a.contains;
			}
			for (a : ActiveState in all)
			{
				a.contains = all_st;
				a.contains_str = all_st_name;
			}
		}
	}
}

// rule ActiveStatesInit2()
// {
	// active:ActiveSubRegionState;
	
	// if {active.sub_region_contains.empty();}
	
	// modify
	// {
		// eval
		// {
			// def ref all : set<Node> = reachableOutgoing(active, Edge) | set<Node>{active};
			// def ref all_st : set<string> = set<string>{};
			// for (a : ActiveState in all)
			// {				
				// all_st.add(a.name);
			// }
			// for (a : ActiveState in all)
			// {
				// a.sub_region_contains = all_st;
			// }
		// }
	// }
// }

// rule CreateSimpleStatesTargets()
// {
	// -:StateTransition-> st:State;
	
	// if {st.simple_states.empty();}
	// t:InitialConfig(st);
	
	// modify
	// {
		// def ref tar : set<State> = set<State>{};
		// t(tar);
		// evalhere 
		// { 
			// for (i : State in tar)
			// {
				// st.simple_states.add(i.name); 
			// }
		// }
	// }
// }
// create transition for configs
rule CreateTranConfig()
{
	//def ref conf : set<State>;
	src:State -t:StateTransition-> tar:State;
		
	
	def tar_conf : ActiveState;
	def src_conf : ActiveState;
	
	def lca : Node;
	yield {yield lca = LCA(src, tar); }
	// ~(def sub_region : SubRegion; :GetSubRegion((State)LCA(src, tar), yield sub_region);)
		
	// :SourceConfigs(src, yield src_conf);
	// :TargetConfig(tar,  yield tar_conf);
		
	modify
	{
		src_conf -:copy<t>-> tar_conf;
	}
}

rule CreateTranConfigRegion()
{
	//def ref conf : set<State>;
	src:State -t:StateTransition-> tar:State;
	
	//:TargetConfig(tar);
	
	def sub_region : SubRegion;
	lca : State;
	if {lca == (State)LCA(src, tar);}
		//:LCA(src, tar, yield lca);
	//yield {yield lca = (State)LCA(src, tar); }
	:GetSubRegion(lca, yield sub_region);
	//if {reachableIncoming(lca, Contains, SubRegion);}	
	//def tar_conf : ActiveState;
	//def src_conf : ActiveState;
		
		
	
	//:TargetConfigRegion(src, tar, yield src_conf, yield tar_conf);
		//:TargetConfig(tar,  yield tar_conf);
	//~(src_conf -:Transition-> tar_conf;)		
	modify 
	{
		eval
		{
			for (s : ActiveState in src.possible_conf)
			{
				def tt : ActiveState = tar.initial_conf[i];
				addCopy(t, s, tt);
			}
			//src_conf -:copy<t>-> tar_conf;
		}
	}
	
	// yield
	// {
		
	//:SourceConfigs(src, t);
}

// function IsSubRegionPart(st : State) : boolean
// {
	
// }

pattern GetSubRegion(st : State, def parent : SubRegion)
{
	(
		p:SubRegion -:Contains-> st;
		
		yield {yield parent = p;}
	|
		p:State -:Contains-> st;
		~(:SubRegion -:Contains-> st;)
		:GetSubRegion(p, yield parent);
	)
}

// pattern TargetConfig(tar : State, def ret : ActiveState)
// {
	// //def tar_conf : ActiveState;
	
	// //yield {yield tar_conf = States2Conf(tar.simple_states);}
	// st:ActiveState;	
	// if {st.contains >= tar.simple_states;}
		// //:InitialConfig(tar, st);
		
	// yield {yield ret = st;}	
// }
/*
pattern TargetConfigRegion(src : State, tar : State,  -tran:StateTransition->, def srcconf : ActiveState, def tgtconf : ActiveState)
{
	//def tar_conf : ActiveState;
	
	//yield {yield tar_conf = States2Conf(tar.simple_states);}
	st_src:ActiveState;
	st_tar:ActiveState;

	~(--> st_src; )
	~(--> st_tar; )
	// def ref diff_src : set<string>;
	// def ref diff_tar : set<string>;
	
	if {st_src in src.reachable_conf;}
	//if {st_tar in tar.reachable_conf;}
	
	// yield 
	// { 
		// yield diff_src = ;
		// yield diff_tar = ;
	// }	
	
	//st_src.contains \ 
		
	
	
	if {st_tar.contains >= tar.simple_states;}
	
	if {(st_src.contains \ st_src.sub_region_contains) == (st_tar.contains \ st_tar.sub_region_contains);}
	
	~(
		st_src -t:StateTransition-> st_tar;
		if {t.out_str == tran.out_str;}
	 )
	//if {s}
		//:InitialConfig(tar, st);
		
	yield {yield srcconf = st_src; yield tgtconf = st_tar;}	
}*/

pattern IterateArray(ref src : array<ActiveState>, var idx : int, def ret : ActiveState)
{
	(		
		if {idx == src.size();}
	|
		if {idx != src.size();}
		
		yield {yield ret = src[idx];}
		
		:IterateArray(src, idx + 1, yield ret);
	)
}

pattern IterateTwoArray(ref src : array<ActiveState>, ref tar : array<ActiveState>, var idx : int, def ret1 : ActiveState, def ret2 : ActiveState)
{
	//if {src.size() == tar.size();}
	(		
		if {idx == src.size();}
		modify {}
	|
		if {idx != src.size();}		
		//yield {yield ret1 = src[idx];}//yield ret2 = tar[idx];}
		
		:IterateTwoArray(src, tar, idx + 1, yield ret1, yield ret2);
		
		modify {}
	)
}

pattern TargetConfigRegion(src : State, tar : State, def srcconf : ActiveState, def tgtconf : ActiveState)
{
	//def tar_conf : ActiveState;
	
	//yield {yield tar_conf = States2Conf(tar.simple_states);}
	//:IterateArray(src.possible_conf, 0, yield srcconf);
	//:IterateTwoArray(src.possible_conf, tar.initial_conf, 0, yield srcconf, yield tgtconf);
}

rule MoveConfigTransitionToTop()
{
	st:ActiveState -->;
		
}

// pattern SourceConfigs(src : State, def ret : ActiveState)
// {
	// multiple
	// {
		// st:ActiveState;
		// if {st in src.reachable_conf;}
		// yield {yield ret = st;}
	// }
// }

// function States2Conf(ref conf : set<State>) : ActiveState
// {
// // def res : ActiveState;
	 // def ref min_sel : set<ActiveState>;
	 // def ref names : set<string>;
	 // def var min : int = Math::intMax();
	 // for (ret : State in conf)
	 // {
		// def var size : int = ret.reachable_conf.size();
		// if (size < min)
		// {
			// min = size;
			// min_sel = ret.reachable_conf;
		// }
		
		// //yield act = ret;
	 // }
	 // for (c : State in conf)
	 // {
		// names.add(c.name);
	 // }
	 
	 // for (c : ActiveState in min_sel)
	 // {
		// if (c.contains >= names)
		// {
			// return (c);
		// }
	 // }
	 // return (null);
		// //yield act = res;
// }

pattern FindConfig(ref conf : set<State>)
{
	
}

pattern InitialConfig(rec_tar : State) modify(ref tar : set<State>)
{
	
	(		
		~(rec_tar -:Substate->;)
		//target:ActiveConfig;
		//if {target.name == tar.name;}conf.add(tar);
		//if {st.name == rec_tar.name;}
		 //if {rec_tar.name in st.contains;}
		 modify
		 {
			eval { tar.add(rec_tar);}
		 }
		
	|
		~(:ConcurrentState<rec_tar>;)
		rec_tar -:Contains-> :InitialState -:PseudoTransition-> child:State;
		
		t:InitialConfig(child);
		
		modify {t(tar);}
	| 	
		c:ConcurrentState<rec_tar>;
		
		t:InitialConfRegion(c);
		// iterated
		// {
			// def ret : ActiveState;
			// tar -:Region-> sub:SubRegion;
			// :TargetConfigs(sub, rec_tar);
		// }	
		modify
		{
			t(tar);
		}
	)
	
	modify {}
}

pattern InitialConfigSimpleStates(rec_tar : State, def simple : State, def ret : ActiveState)
{
	(		
		~(rec_tar -:Substate->;)
		
		target:ActiveState;
		~(rec_tar -:Config-> target;)
		if {target.id == rec_tar.id;}
		
		yield {yield simple = rec_tar;}
		yield {yield ret = target;}
		
	|
		~(:ConcurrentState<rec_tar>;)
		rec_tar -:Contains-> :InitialState -:PseudoTransition-> st:State;
		
		:InitialConfigSimpleStates(rec_tar, yield simple, yield ret);
				
	| 	
		c:ConcurrentState<rec_tar>;
		
		:InitialConfRegionSimpleStates(c, yield simple, yield ret);
		// iterated
		// {
			// def ret : ActiveState;
			// tar -:Region-> sub:SubRegion;
			// :TargetConfigs(sub, rec_tar);
		// }	
	)
		
}

pattern InitialConfRegionSimpleStates(rec_tar : ConcurrentState, def simple : State, def ret : ActiveState)
{
	iterated
	{
		rec_tar -:Region-> sub:SubRegion;
		t:InitialConfigSimpleStates(sub, yield simple, yield ret);		
	}	
}

pattern InitialConfRegion(rec_tar : ConcurrentState) modify(ref tar : set<State>)
{
	multiple
	{
		rec_tar -:Region-> sub:SubRegion;
		t:InitialConfig(sub);		
		
		modify
		{
			t(tar);
		}
	}	
	
	modify {}
}

//rule CreateConfEdges