using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using PathNode;
  /// <summary>
  /// Description of TransitionPathImpl.
  /// </summary>
  public partial class TransitionPath
  {
    public static FindPath(src_st : FsmState,
                          dest_st : FsmState,
                          exit : IEnumerable[FsmState],
                          entry : IEnumerable[FsmState]) : IEnumerable[FsmState] * IEnumerable[FsmState]
    {
      def src = src_st.SuperStatesFromTopInclude.NToList();
      def dest = dest_st.SuperStatesFromTopInclude.NToList();
      def (ex, en) = src.RemoveDupFirst(dest, (x, y) => x.Num == y.Num);
      (exit.Concat(ex.Reverse()), en.Concat(entry))
    }

    //* 1. The source and target are the same (self-transition).
                //* -2. The target is a substate of the source. (local or external?)
                //* -3. The source is a substate of the target. (local or external?)
                //* 4. The source and target share the same superstate.
                //* 5. All other cases.
                //*     a. The source and target reside at the save level in the
                //*        hiearchy (but do not share the same superstate).
                //*     b. The source is lower in the hiearchy than the target.
                //*     c. The target is lower in the hierarchy than the source.
                //*
                //* Case 1: Immediately performs the transition.
                //*
                //* Case 2: Traverses the hierarchy from the source to the target,
                //*         entering each state along the way. No states are exited.
                //*
                //* Case 3: Traverses the hierarchy from the source to the target,
                //*         exiting each state along the way. The target is then
                //*         entered.
                //*
                //* Case 4: The source is exited and the target entered.
                //*
                //* Case 5: Traverses the hiearchy until a common superstate is met.
    static FindLCA(st : FsmState, dest_st : FsmState) : IEnumerable[FsmState] * IEnumerable[FsmState]
    {
      def super = dest_st.Super;
      def dest = if (super != null) super else dest_st;
      FindPath(st.Super, dest, TraverseUtils.SingleElement(st), TraverseUtils.SingleElement(dest_st))
    }

    //static AddAction(nodes : PathNode, act : option[Actions]) : IEnumerable[PathNode]
    //{
    //  | (n, Some(act))  => TraverseUtils.DoubleElement(n, Action(act))
    //  | (n, _)          => TraverseUtils.SingleElement(n)
    //}

    static AddAction(nodes : IEnumerable[PathNode], act : option[Actions]) : IEnumerable[PathNode]
    {
      | (n, Some(act))  => n.Append(Action(act))
      | (n, _)          => n
    }

    static EntryNodeCreate(nodes : IEnumerable[FsmState]) : IEnumerable[PathNode]
    {
      def entering_state(st)
      {
        | FsmState(do_activity = do_act) => 
          def act = Actions(st.entry.SelectMany(_.actions).NToList());
          Entry(act, do_act.Map(x => (RunDoActivity(x, st), true)), st.Updated)
      }


      nodes.Select(entering_state)
      //Sequence(entry)
    }

    static GetExitNode(st : FsmState) : PathNode
    {
        //def exit = st.exit.Select(Exit);
      def do_act = st.do_activity.Map(StopDoActivity(_, st));
      def inline = if (st.history.HasValue) SaveHistory(st.history.Value) :: do_act; else do_act;
      def inline = inline.Map(x => (x, false));
      def act = Actions(st.exit.SelectMany(_.actions).NToList());
      Exit(act, inline, st)
        //| StateAction.Exit(state = FsmState(do_activity = act, history = TwoOption(HasValue = true) as h)) =>
        //    Exit(st, (SaveHistory(h.Value), false) :: act.Map(x => (StopDoActivity(x), false)))

        //| Exit(state = FsmState(do_activity = act)) => Exit(st, act.Map(x => (StopDoActivity(x), false)))
    }

    public ExitNodeCreate(nodes : IEnumerable[FsmState]) : IEnumerable[PathNode]
    {

      def exiting_state(st)
      {
        | FsmState.ConcurrentRegion(exit = e) as r => 
            def get_source()
            {
              match (transition.To)
              {
                | TransitionTarget.PseudoState(Join(region = reg, joined_tran = jtran)) => 
                    def src = jtran |> Source;
                    if (jtran.Last().FromRegion == transition.FromRegion) (reg, src, true) else (reg, src, false)
                | _ => (null, [transition.Source], true)
              }
            }

            def (reg, src, last) = get_source();
            def src = if (r.sub_states.Exists(src.Contains)) src else [nodes.First()];
            def regs = r.RegionsExcept(src);

            def node = if (last || r != reg) if (regs.Equals(r.sub_regions)) RegionExit(Enumerable.Empty(), r) else RegionExit(regs, r); else Empty();

            if (e.IsEmpty()) 
            {
              TraverseUtils.SingleElement(node)
            } else 
            {
              TraverseUtils.DoubleElement(GetExitNode(r), node)
            }

        | _ => TraverseUtils.SingleElement(GetExitNode(st))
      }

      nodes.SelectMany(exiting_state)
    }

    public static ExitNodeCreate(src : FsmState, nodes : IEnumerable[FsmState]) : IEnumerable[PathNode]
    {
      //def get_exit(st)
      //{
      //  | StateAction.Exit(state = FsmState(do_activity = act, history = TwoOption(HasValue = true) as h))=>
      //      Exit(st, (SaveHistory(h.Value), false) :: act.Map(x => (StopDoActivity(x), false)));

      //  | Exit(state = FsmState(do_activity = act)) => Exit(st, act.Map(x => (StopDoActivity(x), false)));
      //}

      def exiting_state(st)
      {
        | FsmState.ConcurrentRegion(exit = e) as r => 
            //def (reg, src, last) = get_source();
            def regs = r.RegionsExcept(src);
            def node = RegionExit(regs, r);
            if (e.IsEmpty()) TraverseUtils.SingleElement(node) else TraverseUtils.DoubleElement(GetExitNode(st), node)

        | _ => TraverseUtils.SingleElement(GetExitNode(st))
      }

      nodes.SelectMany(exiting_state)
    }

    NodesCreate(ex : IEnumerable[FsmState], tran : StateTransition) : IEnumerable[PathNode]
    {
      def (exit, en) = TraverseTransitionPath(tran);
      def ex = ex.Concat(exit);
      def node = ExitNodeCreate(ex); // create nodes for exit exit actions
      def node = AddAction(node, tran.action); // add transition action
      def entry_nodes = EntryNodeCreate(en); // create nodes for entry exit actions
      node.Concat(entry_nodes) // merge together
    }

    NodesCreate(ex : IEnumerable[FsmState], en : IEnumerable[FsmState]) : IEnumerable[PathNode]
    {
      def node        = ExitNodeCreate(ex); // create nodes for exit exit actions
      def entry_nodes = EntryNodeCreate(en); // create nodes for entry exit actions
      node.Concat(entry_nodes) // merge together
    }

    TraverseTransitionPath(tran : StateTransition) : IEnumerable[FsmState] * IEnumerable[FsmState]
    {
      // initial и pseudo is local transitions by default
      | Initial(AtLeastStaticTo = st, From = from)
      | Transition(To = PseudoState(PseudoStateNode(state = st)), From = from)
      | History(From = from, ToState = st)
      // fork transition
      | Transition(From = from, Local = true, AtLeastStaticTo = st)
      | Default(ToState = st, From = from)            => FindPath(from.Updated, st.Updated, Enumerable.Empty(), Enumerable.Empty())
      // transition to pseudo state
      | Transition(AtLeastStaticTo = st, From = from) => FindLCA(from.Updated, st.Updated)
      | Internal  // no path for internal transition
      | _        => (Enumerable.Empty(), Enumerable.Empty())
    }

    DefExitPath(src : FsmState, dest : FsmState) : void
    {
      def ex = FindPath(src.Updated, dest.Updated, Enumerable.Empty(), Enumerable.Empty())[0];
      AddNode(ExitNodeCreate(ex))
    }

    DefPath(src : FsmState, dest : FsmState, local : bool = true, skip : FsmState = null) : void
    {
      def node = GetPath(src, dest, local, skip);
      AddNode(node)
    }

    GetPath(src : FsmState, dest : FsmState, local : bool = true, skip : FsmState = null) : IEnumerable[PathNode]
    {
      if (src == null || dest == null) Enumerable.Empty() else
      {
        def (ex, en) = if (local) FindPath(src, dest, Enumerable.Empty(), Enumerable.Empty()) else FindLCA(src, dest);
        def ex = match (ex)
                  {
                    | head :: tail when (head == skip) => tail
                    | _                                => ex
                  }
        NodesCreate(ex, en)
      }
    }

    DefPath(src : FsmState, dest : FsmState, tr : StateTransition, ex_node : IEnumerable[PathNode] = null) : void
    {
      def ex = FindPath(src.Updated, dest.Updated, Enumerable.Empty(), Enumerable.Empty())[0];
      def node = NodesCreate(ex, tr);
      def node = if (ex_node != null) ex_node.Concat(node) else node;
      AddNode(node)
    }

  }
}
