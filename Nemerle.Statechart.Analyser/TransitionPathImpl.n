using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using PathNode;
  /// <summary>
  /// Description of TransitionPathImpl.
  /// </summary>
  public partial class TransitionPath
  {
    public static FindPath(src_st : FsmState,
             dest_st : FsmState,
             exit : list[FsmState],
             entry : list[FsmState]
             ) : list[FsmState] * list[FsmState]
    {
       def src = src_st.SuperStatesFromTopInclude.NToList();
       def dest = dest_st.SuperStatesFromTopInclude.NToList();
       def (ex, en) = src.RemoveDupFirst(dest, (x, y) => x == y : object);
       (exit + ex.Rev(), en + entry)
    }
    
     //* 1. The source and target are the same (self-transition).
                 //* -2. The target is a substate of the source. (local or external?)
                 //* -3. The source is a substate of the target. (local or external?)
                 //* 4. The source and target share the same superstate.
                 //* 5. All other cases.
                 //*     a. The source and target reside at the save level in the
                 //*        hiearchy (but do not share the same superstate).
                 //*     b. The source is lower in the hiearchy than the target.
                 //*     c. The target is lower in the hierarchy than the source.
                 //*
                 //* Case 1: Immediately performs the transition.
                 //*
                 //* Case 2: Traverses the hierarchy from the source to the target,
                 //*         entering each state along the way. No states are exited.
                 //*
                 //* Case 3: Traverses the hierarchy from the source to the target,
                 //*         exiting each state along the way. The target is then
                 //*         entered.
                 //*
                 //* Case 4: The source is exited and the target entered.
                 //*
                 //* Case 5: Traverses the hiearchy until a common superstate is met.
    FindLCA(st : FsmState, dest_st : FsmState) : list[FsmState] * list[FsmState]
    {
      def super = dest_st.super_state;
      def dest = if (super != null) super else dest_st;
      FindPath(st.super_state, dest, st :: [], dest_st :: []);
    }

    AddAction(nodes : PathNode, act : option[Actions]) : PathNode
    {
      | (n, Some(act))  => n + Action(act)
      | (n, _)          => n
    }

    EntryNodeCreate(nodes : list[FsmState]) : PathNode
    {
      def entering_state(st)
      {
          | StateAction.Entry(state = FsmState(do_activity = act)) => Entry(st, act.Map(x => (RunDoActivity(x), true)))
      }

      
      def entry = nodes.FoldLeft([], (x, a) => x.entry.FoldLeft(a, (x, a) => entering_state(x) :: a));
      Sequence(entry)
    }

    public ExitNodeCreate(nodes : list[FsmState]) : PathNode
    {
      def get_exit(st)
      {
        | StateAction.Exit(state = FsmState(do_activity = act, history = TwoOption(HasValue = true) as h)) =>
            Exit(st, (SaveHistory(h.Value), false) :: act.Map(x => (StopDoActivity(x), false)));
        | Exit(state = FsmState(do_activity = act)) => Exit(st, act.Map(x => (StopDoActivity(x), false)));
      }
      
      def exiting_state(st)
      {
        | FsmState.ConcurrentRegion(exit = e) as r => 
            def get_source()
            {
              match (transition.To)
              {
                | TransitionTarget.PseudoState(Join(region = reg, joined_tran = jtran)) => def src = jtran |> Source;
                    if (jtran.Last().FromRegion == transition.FromRegion) (reg, src, true) else (reg, src, false)
                | _ => (null, [transition.Source], true)
              }
            }
            
            def (reg, src, last) = get_source();
            def src = if (r.sub_states.Exists(x => src.Contains(x))) src else [nodes.Head];
            def regs = r.RegionsExcept(src);
            
            def node = if (last || r != reg) if (regs.Equals(r.sub_regions)) RegionExit([], r) else RegionExit(regs, r); else Empty();
            if (e.IsEmpty()) node else Sequence(e |> get_exit(_)) + node;
            
        | FsmState(exit = (_ :: _) as ex) => Sequence(ex |> get_exit(_))
        | _                               => Empty()
      }
      
      def nodes = nodes |> exiting_state(_);
      Sequence(nodes)
    }

    public static ExitNodeCreate(src : FsmState, nodes : list[FsmState]) : PathNode
    {
      def get_exit(st)
      {
        | StateAction.Exit(state = FsmState(do_activity = act, history = TwoOption(HasValue = true) as h))=>
            Exit(st, (SaveHistory(h.Value), false) :: act.Map(x => (StopDoActivity(x), false)));
        | Exit(state = FsmState(do_activity = act)) => Exit(st, act.Map(x => (StopDoActivity(x), false)));
      }
      
      def exiting_state(st)
      {
        | FsmState.ConcurrentRegion(exit = e) as r => 
            //def (reg, src, last) = get_source();
            def regs = r.RegionsExcept(src);
            def node = RegionExit(regs, r);
            if (e.IsEmpty()) node else Sequence(e |> get_exit(_)) + node;
            
        | FsmState(exit = (_ :: _) as ex) => Sequence(ex |> get_exit(_))
        | _                               => Empty()
      }
      
      def nodes = nodes |> exiting_state(_);
      Sequence(nodes)
    }
    
    NodesCreate(ex : list[FsmState], tran : StateTransition) : PathNode
    {
      def (exit, en) = TraverseTransitionPath(tran);
      def ex = ex + exit;
      def node = ExitNodeCreate(ex); // create nodes for exit exit actions
      def node = AddAction(node, tran.action); // add transition action
      def entry_nodes = EntryNodeCreate(en); // create nodes for entry exit actions
      node + entry_nodes // merge together
    }
    
    NodesCreate(ex : list[FsmState], en : list[FsmState]) : PathNode
    {
      def node = ExitNodeCreate(ex); // create nodes for exit exit actions
      def entry_nodes = EntryNodeCreate(en); // create nodes for entry exit actions
      node + entry_nodes // merge together
    }

    TraverseTransitionPath(tran : StateTransition) : list[FsmState] * list[FsmState]
    {
       // initial и pseudo is local transitions by default
      | Initial(AtLeastStaticTo = st, From = from)
      | Transition(To = PseudoState(PseudoStateNode(state = st)), From = from)
      | History(From = from, ToState = st)
       // fork transition
      | Transition(From = from, Local = true, AtLeastStaticTo = st)
      | Default(ToState = st, From = from)  => FindPath(from, st, [], [])
       // transition to pseudo state
      | Transition(AtLeastStaticTo = st, From = from) => FindLCA(from, st)
      | Internal => ([], []) // no path for internal transition
      | _        => ([], [])
    }
    
    DefExitPath(src : FsmState, dest : FsmState) : void
    {
      def ex = FindPath(src, dest, [], [])[0];
      AddNode(ExitNodeCreate(ex))
    }

    DefPath(src : FsmState, dest : FsmState, local : bool = true, skip : FsmState = null) : void
    {
      def node = GetPath(src, dest, local, skip);
      AddNode(node)
    }

    GetPath(src : FsmState, dest : FsmState, local : bool = true, skip : FsmState = null) : PathNode
    {
      if (src == null || dest == null) PathNode.Empty() else
      {
        def (ex, en) = if (local) FindPath(src, dest, [], []) else FindLCA(src, dest);
        def ex = match (ex)
                 {
                   | head :: tail when (head == skip) => tail
                   | _                                => ex
                 }
        NodesCreate(ex, en);
      }
    }
    
    DefPath(src : FsmState, dest : FsmState, tr : StateTransition, ex_node : PathNode = null) : void
    {
      def ex = FindPath(src, dest, [], [])[0];
      def node = NodesCreate(ex, tr);
      def node = if (ex_node != null) ex_node + node else node;
      AddNode(node)
    }

  }
}
