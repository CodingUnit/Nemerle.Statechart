// analyser.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  public partial class FsmAnalyser
  {
    
    InitStatechart() : void
    {
      def state = Fsm.state.ChangeName(FsmState.TopStateName);

      StateMap.Create(this, state)

    }

    InitStateMap() : void
    {
      InitStatechart();

      CreateHistoryStates();
      when (Error) throw FsmErrorException();
      RenameDuplicates()
    }
    
    CheckAddFinalState() : void
    {
      def check_target(tran)
      {
       def to = tran.To;
       def st = tran.From;
       def to = match (to, tran)
                  {
                // TODO: check later for need of termination of fsm if we reach final state
                    | (TransitionTarget.Final as t, StateTransition.Initial) with super = st
                    | (Final as t, _) with super = st.Super => 
                        match (super.sub_states.Find(x => x.IsFinal))
                        {
                          | None when (super.IsTopState) => 
                            TransitionTarget.PseudoState(this, PseudoStateNode.Terminate(super))
                            
                          | None =>   
                            def fin = FsmState(this, StateType.Final());
                            //super.Add(fin);
                            super.Add(fin);
                            t.ChangeState(fin);

                          | Some(fin)  => t.ChangeState(fin)
                        }
                    | _ => to
       

                  }
                  
        tran.To = to
      } 
     
      def change_name(st)
      {
        def super = st.Super;
        st.name = $"$(super)Final"
      }
      
      AllTransitions.Iter(check_target);
      def final = States.Where(_.IsFinal); // final state rename
      final.Iter(change_name);
    }

    public States : array[FsmState]
    {
      get
      {
        statemap.States
      }
    }

    public AllTransitions : array[StateTransition]
    {
      get
      {
        statemap.Transitions
      }
    }
    
    RenameDuplicates() : void
    {
      def rename_group(st)
      {
        foreach (st in st with i)
        {
          st.copy_num = i
        }
        //st.IterI((i, x) => x.сopy_num = i)
      }

      def dups = States.NToList().Duplicates((x, y) => FsmState.NameComparer(x, y));
      def dups = dups.GroupBy(x => x.Name).NToList();

      dups.Iter(rename_group)
    }

    CreateHistoryStates() : void
    {
    // check history duplicates in state
      def check_dup_history(st)
      {
        match (st.history)
        {
        // duplicate variants
          | TwoOption.Two(n, n2) =>
              match (n.type, n2.type)
              {
                | (HistoryType.Deep, HistoryType.Deep)
                | (HistoryType.Shallow, HistoryType.Shallow) => AddError(FsmError.DuplicateHistory(st, n))
                | _                                          => ()
              }
          | _ => ()
        }
      }

      def check_exit_actions(st)
      {
        | FsmState(exit = []) => st.exit = StateAction.Exit([], st, ActionFlags.None) :: []
        | _                   => ()
      }

      def update_hist(st)
      {
        when (st.history.HasValue)
        {
          check_dup_history(st);
          check_exit_actions(st)
        }
      }

      States.Iter(update_hist)
    }

    CreateActions() : void
    {
      def check_do(st, act)
      {
        def check(act)
        {
            | StateAction.Do(actions = [_], Concurrently = true, flags = f) => 
                def err = FsmWarning.NoConcurrentActivity(act);
                AddWarning(err);
                act.ChangeFlags(f & ~ActivityFlag.Concurrently);
            | _ => act
        }

        def act = act.Map(check);
        st.do_activity = act//Update(x => x.ChangeDoActivity(act))
      }

      States.Iter(x => check_do(x, x.do_activity));
    }

    CreateConcurrentRegion() : void
    {
      def warn = not_used_regions.Map(FsmWarning.RegionNotUsed);
      AddWarnings(warn)
    }

    CreateHierarchy() : void
    {

      def set_hierarchy_pos(st)
      {
        st.hierarchy_pos = if (st.IsTopState) 0
                           else  st.Super.hierarchy_pos + 1;
      }

      States.Iter(set_hierarchy_pos)
    }


    CreateSubMachines() : void
    {
      def init_clones(st)
      {
        Clones.Add(st, []);
      }
      
      States.Iter(init_clones)
      /*def inlined = States.Where(x => x.Data is FsmState.InlinedSubMachineInstance);
      inlined.Iter(x => x.InitInline());*/
            // TODO: надо делать обновление ссылок только один раз
      }


    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        InitStateMap();
        CheckTransitions();
        CheckAddFinalState();
        CreateSubMachines();
        CreateHierarchy(); // create hierarchy
        CheckInitialTransitions();
        CreateTransitions();
        BreakIfError();
        CreateTransitionPaths();
        CreateHistoryPaths(); // create history paths
        CreateConcurrentRegion();
        UpdateInitial();
        CreateActions();
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
          def err = x.error;
          when (err != null) AddError(err);
      }
    }

  }
}
