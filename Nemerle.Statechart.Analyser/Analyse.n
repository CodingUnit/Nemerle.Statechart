using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  public partial class FsmAnalyser
  {

    InitStateMap() : FsmAnalyser
    {
      def CheckAddFinalState(st, an)
      {
        def is_top(st)
        {
          def super = st.super_state; 
          // check if state is top or state is sub of top and don't have transitions
          super == null || (super.super_state == null && super.this_transitions is [])
        }
        
        def check_target(t, tran, an)
        {
          match (t, tran)
          {
          | (TransitionTarget.Final as t, _) when (is_top(st))=> 
              def term = PseudoStateNode.Terminate(TopState, 0);
              //TopState.pseudo_states ::= term;
              (TransitionTarget.PseudoState(t.transition, term), an)
          | (Final as t, Initial) with super = st
          | (Final as t, _) with super = st.super_state =>
              def fst = FsmState.Final(super, true);
              def super = super.AddSubState(fst);
              def an = an.ChangeStatemap(an.statemap.Add(super));
              //st.ChangeSuper();
              //def fst = fst.ChangeSuperState(super);
              (t.ChangeState(fst), an)
              
          | (t, _) => (t, an)
         }
        }
        
        st.all_transitions_with_init.FoldLeft(an, (x, a) => x.TargetTraverse(a, check_target(_, x, _)))
      }
      
      def an = InitStatechart();
      def an = an.UpdateStateMap(); // first update state map 
      def an = an.States.FoldLeft(an, CheckAddFinalState); // check to add final state
      def an = an.UpdateStateMap(); // second update state map
      an.CreateHistoryStates();
      when (an.Error) throw FsmErrorException();
      an.RenameDuplicates()
    }

    UpdateReference() : FsmAnalyser
    {
      def map = States.FoldLeft(statemap, (s, m) => s.UpdateReference(m));
      ChangeStatemap(map)
    }
    
    public UpdateStateMap() : FsmAnalyser
    {
      InitStates();
      def an = UpdateReference();
      StateId.CreateMasks(an);
      an
    }
    
    InitStates() : void
    {
      //def init_states(st, pos)
      //{
      //  st.hierarchy_pos = pos;
      //  st.SubStates.Iter(init_states(_, pos + 1)); // init sub states
      //}
      //init_states(TopState, 0); // init state map
      //states = statemap.States.NToList();
    }
    
    RenameDuplicates() : FsmAnalyser
    {
      def do_rename(st, n, map)
      {
        def st = st.ChangeCopyNum(n);
        (st.UpdateReference(map), n + 1)
      }
      
      def rename_group(st, map)
      {
        def (head :: _) = st;
        def map = map.Rem(head);
        st.FoldLeft((map, 0), (x, (m, i)) => do_rename(x, i, m))
      }
      
      def dups = States.Duplicates(FsmState.NameComparer);
      def dups = dups.Group(FsmState.NameComparer);
      def (map, _) = dups.FoldLeft((statemap, 0), (x, (m, _)) => rename_group(x, m));
      ChangeStatemap(map)
    }
    
    CreateHistoryStates() : void
    {
      // check history duplicates in state
      def check_dup_history(st)
      {
        match (st.history)
        {
          // duplicate variants
          | TwoOption.Two(StateHistory.Deep, StateHistory.Deep)
          | Two(StateHistory.Shallow, StateHistory.Shallow)  =>
              AddError(FsmError.DuplicateHistory(st, st.history.Value.First()));
          | _  => ()
        }
      }

      def check_exit_actions(st)
      {
        | StateHistory where (state = FsmState where (exit = []) as st) =>
             //st.exit = [StateAction.Exit([], st)]
            1;
        | _ => ()
      }

      def history = States.Filter(x => x.history.HasValue);
      history.Iter(check_dup_history);
      def history_states =  history |>< history.Value;
      def group = history_states.Group((x, y) => string.Compare(x.state.Name, y.state.Name));
      group.IterI((i, x) => x.Iter(x => x.Index = i));
      history_states.Iter(check_exit_actions);
    }

    InitEvents() : void
    {
      def int_evts =  States |>< internal_tran |> Trigger;
      def evts =  States |>< transitions |> Trigger;
      def evts = evts.Filter(x  => x.Name != null);
      def int_tran_evt = int_evts.RemoveDuplicatesSort(_.CompareTo(_));
      def tran_evt = evts.RemoveDuplicatesSort(_.CompareTo(_));
      def int_tran_evt =  int_tran_evt.Exclude(tran_evt, _  ==  _);
      int_tran_evt.Iter(x  => x.InternalOnly = true);
      def evts =  (int_tran_evt + tran_evt) |> (Name, _);
      def events_map = Map(evts);
      def events = events_map.Keys()
    }

    static nodes_eq : ((string * PathNode) * (string * PathNode)) -> bool = (x, y) => PathNode.Equals(x[1], y[1]);
    static nodes_cmp : ((string * PathNode) * (string * PathNode)) -> int = (x, y) => PathNode.Compare(x[1], y[1]);

    CreateHistory() : void
    {
      //def sub =  history_states |> (_, state, SubStatesParticipateInHistory);  // get all substates participate in history
      //def paths =  $[HistoryPath(par, st, h, this), (h, par, s) in sub, st in s, !(st is FsmState.Final)]; // create history paths
      //paths.Iter(_.CreatePath());
      //def paths = paths.Exclude(_.IsDefault);
      //def paths = paths.RemoveDuplicatesSort((x, y) => x.Name.CompareTo(y.Name));
      //history_paths = paths
    }

    CreateActions() : void
    {
      def check_do(act)
      {
        | StateAction.Do(actions = [_], Concurrently = true) => AddWarning(FsmWarning.NoConcurrentActivity(act));
            act.Concurrently = false
        | _ => ()
      }

      def acts =  trans_paths |>< Actions;
      def int_acts =  internal_transitions.Values() |>< Actions;
      def acts = acts + int_acts;
      def actions = acts.RemoveDuplicatesSort((x, y) => x.CompareTo(y));
      def do_activities = States.FilterValues(_.do_activity);
      do_activities.Iter(check_do);
      def tr = all_transitions |> PathNodeRecursive;
      def action_node = PathNode.Sequence(tr)
    }

    CreateConcurrentRegion() : void
    {
      def warn = not_used_regions |> FsmWarning.RegionNotUsed(_);
      AddWarnings(warn)
    }
    
    CreateSubMachines() : void
    {
      def fsm = States.FilterType();
      fsm.Map(x : FsmState.InlinedSubMachineInstance => x.InitInline());
      //InitStates();
    }
  }
}
