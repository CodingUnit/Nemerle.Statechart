using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  public partial class FsmAnalyser
  {

    //public NextGlobalNum() : int
    //{
    //  statemap.GetNextGlobalNum()
    //}


    //UpdateTransitions(tran : IEnumerable[StateTransition]) : void
    //{
    //  def group = tran.GroupBy(x => x.Source.Num);
    //  def st = group.Map(x => statemap[x.Key].UpdateTransitions(x));
    //  statemap.Update(st)
    //}

    InitStatechart() : void
    {
      def state = Fsm.state.ChangeName(FsmState.TopStateName);

      statemap = StateMap.Create(this, state)
      //UpdateStateMap(top);


    }

    InitStateMap() : void
    {
      InitStatechart();

      CreateHistoryStates();
      when (Error) throw FsmErrorException();
      RenameDuplicates()
    }


    //public UpdateStateMap(st : IEnumerable[FsmState]) : void
    //{
    //  statemap.Update(st)
    //}

    //public UpdateStateMap(top : FsmState = null) : void
    //{
    ////InitStates();
    //  statemap.Update(top ?? TopState);
    //  //when (upd_ref) 
    //  //{
    //  //  def top = TopState.ReduceSingle((x, _) => UpdateStateReference(x));
    //  //  statemap.Update(top)
    //  //}
    //}

    CheckAddFinalState() : void
    {
      def check_target(tran)
      {
       def to = tran.Value.To;
       def st = tran.Parent;
       def to = match (to, tran.Value)
                  {
            //| (TransitionTarget.Final, _) when (is_top(st)) => 
            //    def term = PseudoStateNode.Terminate(0, statemap.GetNextGlobalNum(), this);
            //    (TransitionTarget.PseudoState(this, term), null :: a)
                // TODO: check later for need of termination of fsm if we reach final state
                    | (TransitionTarget.Final as t, StateTransition.Initial) with super = st
                    | (Final as t, _) with super = st.Parent => 
                        match (super.ChildNodes.Find(x => x.Data is FsmState.Final))
                        {
                          | None => def fin = FsmState.Final(this);
                            def node = statemap.Add(super, GeneralTree(fin));
                            t.ChangeState(node.Data.StateNode);

                          | Some(fin)  => t.ChangeState(fin)
                        }
                    | _ => to
              //match (a.Find((x, _) => x.Num == super.Num))
              //{
              //  | Some((_, fin)) => def t = t.ChangeValue(TransitionTarget.CreateStateRef(fin, true));
              //                      (t, a)
              //  | _              => def fin = FsmState.Final(this);
              //                      def fin = fin.SetNewId();
              //                      def rf = TransitionTarget.CreateStateRef(fin, true);
              //                      def t = t.ChangeValue(rf);
              //                      (t, (super, fin) :: a)
              //}


                  }
                  
        tran.Value = tran.Value.ChangeTo(to)
      }

        //def check_final(f, st, sub)
        //{
        //  if (st.HaveFinal) st else
        //  match (f.Find((x, _) => x.Num == st.Num))
        //  {
        //    | Some((_, fin)) => st.ChangeSubStates(sub.Append(fin).NToList())
        //    | _              => null
        //  }
        //}

        //def check_tran(st, (x, (tr, a)))
        //{
        //  def (to, fin) = x.To.Reduce(a, final = check_target(st, _, x, _));
        //  def tran = x.ChangeTo(to);
        //  (tran :: tr, fin)
        //}

        //def check_state(s, _, a)
        //{
        //  def (tran, fin) = s.transitions.FoldBack(([], a), check_tran(s, _));
        //  def (init, fin) = s.initial.FoldBack(([], fin), check_tran(s, _));
        //  def st          = s.ChangeTransitionsInitial(tran, init);
        //  (st, fin)
        //}

        //def (top, final) = TopState.ReduceSingle([], check_state);

      TransitionEnumerate.Iter(check_target);

        // check to add final state
        //UpdateStateMap(top.ReduceSingle(true, check_final(final, _, _)))
    }

    States : IEnumerable[GeneralTree[FsmState]]
    {
      get
      {
        statemap.StateTree.GetBreadthFirstEnumerable()
      }
    }

    TransitionEnumerate : IEnumerable[NodeValue[FsmState, StateTransition]]
    {
      get
      {
        def en = statemap.StateTree.GetEnumerable(TreeTraversalType.BreadthFirst);
        en.SelectMany(x => x.AllTransitions())
      }
    }

    //TransitionMod : IEnumerable[GeneralTree[FsmState] * StateTransition]
    //{
    //  get
    //  {
    //    def en = statemap.StateTree.GetEnumerable(TreeTraversalType.BreadthFirst);
    //    en.SelectMany(x => x.Value.all_transitions_with_init.Select(y => (x, y)))
    //  }
    //}

    RenameDuplicates() : void
    {
      def rename_group(st)
      {
        st.IterI((i, x) => x.Update(x => x.ChangeCopyNum(i)))
      }

      def dups = States.NToList().Duplicates((x, y) => FsmState.NameComparer(x.Data, y.Data));
      def dups = dups.GroupBy(x => x.Data.Name);

      dups.Iter(rename_group)
    }

    CreateHistoryStates() : void
    {
    // check history duplicates in state
      def check_dup_history(st)
      {
        match (st.History())
        {
        // duplicate variants
          | TwoOption.Two(n, n2) =>
              match (n.Value, n2.Value)
              {
                | (PseudoStateNode.History(type = HistoryType.Deep), PseudoStateNode.History(type = HistoryType.Deep))
                | (PseudoStateNode.History(type = HistoryType.Shallow), PseudoStateNode.History(type = HistoryType.Shallow)) => AddError(FsmError.DuplicateHistory(st.Data, st.History().Value.First()))
                | _                                                                                                           => ()
              }
          | _ => ()
        }
      }

      def check_exit_actions(st)
      {
        | FsmState(exit = ex) when ex.IsEmpty() => st.ChangeExit(StateAction.Exit([], ActionFlags.None) :: [])
        | _                                     => st
      }

      def update_hist(st)
      {
        when (st.History().HasValue)
        {
          check_dup_history(st);
          st.Update(check_exit_actions);
        }
      }

      States.Iter(update_hist)
    }

    CreateActions() : void
    {
      def check_do(st, act)
      {
        def check(act)
        {
            | StateAction.Do(actions = [_], Concurrently = true, flags = f) => 
                def err = FsmWarning.NoConcurrentActivity(act);
                AddWarning(err);
                act.ChangeFlags(f & ~ActivityFlag.Concurrently);
            | _ => act
        }

        def act = act.Map(check);
        st.Update(x => x.ChangeDoActivity(act))
      }

      States.Iter(x => check_do(x, x.Data.do_activity));
    }

    CreateConcurrentRegion() : void
    {
      def warn = not_used_regions.Map(FsmWarning.RegionNotUsed);
      AddWarnings(warn)
    }

    CreateHierarchy() : void
    {

      def set_hierarchy_pos(st)
      {
        if (st.IsTopState()) st.Update(x => x.ChangeCalcHierarchyPos(0)); 
        else st.Data = st.Data.ChangeCalcHierarchyPos(st.Parent.Data.calc_hierarchy_pos + 1)
      }

      States.Iter(set_hierarchy_pos)
    }


    CreateSubMachines() : void
    {
      def inlined = States.FilterType();
      inlined.Iter(x : GeneralTree[FsmState.InlinedSubMachineInstance] => x.InitInline());
      //def (top, base_sm_types) = TopState.Reduce(true, [], inlined_sub_machine_instance = (x, _, acc) => x.InitInline(acc));
      // TODO: надо делать обновление ссылок только один раз
      //UpdateStateMap(top); // update tree with instanced state machines
      //UpdateStateMap(base_sm_types.SelectMany(_.AllStates)); // update base sm types and its contents
    }


    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        InitStateMap();
        CheckTransitions();
        CheckAddFinalState();
        CreateSubMachines();
        CreateHierarchy(); // create hierarchy
        CheckInitialTransitions();
        CreateTransitions();
        BreakIfError();
        CreateTransitionPaths();
        CreateHistoryPaths(); // create history paths
        CreateConcurrentRegion();
        UpdateInitial();
        CreateActions();
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
          def err = x.error;
          when (err != null) AddError(err);
      }
    }

  }
}
