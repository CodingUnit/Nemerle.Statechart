using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  public partial class FsmAnalyser
  {

    InitStatechart() : FsmAnalyser
    {
      def top = Fsm.state.Fold(null, 
                               (a, _)  => a,
                               (sr, s) => FsmState.ConcurrentRegion(s, sr.Select(x => x :> FsmState.ConcurrentSubRegion), this),
                               (sb, s) => FsmState.CreateState(s, sb, this),
                               (a, _)  => a
                              );
      //def topState = FsmState.State(Fsm.state, null, this, false); // create statemachine from top state
      def top = top.ChangeName(FsmState.TopStateName);
      def map = statemap.Init(top);
      ChangeStatemap(map)
    }

    InitStateMap() : FsmAnalyser
    {
      def CheckAddFinalState(sub, st)
      {
        def is_top(st)
        {
          def super = st.super_state; 
          // check if state is top or state is sub of top and don't have transitions
          super == null || (super.super_state == null && super.this_transitions is [])
        }

        def check_target(t, tran, a)
        {
          match (t, tran)
          {
            | (TransitionTarget.Final as t, _) when (is_top(st))=> 
                def term = PseudoStateNode.Terminate(TopState, 0);
              //TopState.pseudo_states ::= term;
                (TransitionTarget.PseudoState(t.transition, term), a)
            | (Final as t, Initial) with super = st
            | (Final as t, _) with super = st.super_state =>
                def fst = FsmState.Final(super, this, true);
                //def super = super.AddSubState(fst);
                //def an = an.ChangeStatemap(an.statemap.Add(super));
              //st.ChangeSuper();
              //def fst = fst.ChangeSuperState(super);
                (t.ChangeState(fst), fst :: a)
          }
        }

        
        def final = st.all_transitions_with_init.FoldLeft([], (x, a) => x.To.FoldThis(a, null, null, null, null, check_target(_, x, _), null, null, null, null, null).Map((a, b) => {x.To = a;b}));
        match (final)
        {
          | head :: _ => st.ChangeSubStates(sub.Concat(head))
          | _         => st
        }
      }

      def an = InitStatechart();
      def an = an.UpdateStateMap(); // first update state map 
      def top = an.TopState.FoldThis(CheckAddFinalState); // check to add final state
      def map = an.statemap.Init(top);
      def an = an.ChangeStatemap(map);
      def an = an.UpdateStateMap(); // second update state map
      def an = an.CreateHistoryStates();
      when (an.Error) throw FsmErrorException();
      an.RenameDuplicates()
    }

    public UpdateStateMap() : FsmAnalyser
    {
      //InitStates();
      def (top, an) = TopState.FoldThis(this, (s, t, an) => t.UpdateReference(s, an));
      def map = an.statemap.Update(top);
      an.ChangeStatemap(map)
    }

    //InitStates() : void
    //{
    //  //def init_states(st, pos)
    //  //{
    //  //  st.hierarchy_pos = pos;
    //  //  st.SubStates.Iter(init_states(_, pos + 1)); // init sub states
    //  //}
    //  //init_states(TopState, 0); // init state map
    //  //states = statemap.States.NToList();
    //}

    RenameDuplicates() : FsmAnalyser
    {
      def do_rename(st, n)
      {
        st.ChangeCopyNum(n)
      }

      def rename_group(st)
      {
        //def (head :: _) = st;
        //def map = map.Rem(head);
        st.MapIndex(do_rename)
      }

      def dups = States.NToList().Duplicates(FsmState.NameComparer);
      def dups = dups.Group(FsmState.NameComparer);

      def dups = dups |>< rename_group(_);
      def map = statemap.CheckNew(dups);
      ChangeStatemap(map)
    }

    CreateHistoryStates() : FsmAnalyser
    {
      // check history duplicates in state
      def check_dup_history(st, a)
      {
        match (st.history)
        {
          // duplicate variants
          | TwoOption.Two(StateHistory.Deep, StateHistory.Deep)
          | Two(StateHistory.Shallow, StateHistory.Shallow)  =>
              FsmError.DuplicateHistory(st, st.history.Value.First()) :: a
          | _  => a
        }
      }

      def check_exit_actions(st, acc)
      {
        match (st)
        {
          | StateHistory where (state = FsmState where (exit = []) as st) =>
              st.ChangeExit([StateAction.Exit([], st)]) :: acc
          | _ => acc
        }
      }

      def history = States.Filter(x => x.history.HasValue);
      def err = history.FoldLeft([], check_dup_history);
      def history_states : list[StateHistory] =  history |>< history.Value;
      def group = history_states.Group((x, y) => string.Compare(x.state.Name, y.state.Name));
      group.IterI((i, x) => x.Iter(x => x.Index = i));
      def st = history_states.FoldLeft([], check_exit_actions);
      def map = statemap.CheckNew(st);
      ChangeStatemapErrors(map, GetErrors(err))
    }

    //InitEvents() : void
    //{
    //}

    static nodes_eq : ((string * PathNode) * (string * PathNode)) -> bool = (x, y) => PathNode.Equals(x[1], y[1]);
    static nodes_cmp : ((string * PathNode) * (string * PathNode)) -> int = (x, y) => PathNode.Compare(x[1], y[1]);

    //CreateHistory() : void    
    //{
    //  //def sub =  history_states |> (_, state, SubStatesParticipateInHistory);  // get all substates participate in history
    //  //def paths =  $[HistoryPath(par, st, h, this), (h, par, s) in sub, st in s, !(st is FsmState.Final)]; // create history paths
    //  //paths.Iter(_.CreatePath());
    //  //def paths = paths.Exclude(_.IsDefault);
    //  //def paths = paths.RemoveDuplicatesSort((x, y) => x.Name.CompareTo(y.Name));
    //  //history_paths = paths
    //}

    CreateActions() : FsmAnalyser
    {
      def check_do(act, acc)
      {
        match (act)
        {
          | StateAction.Do(actions = [_], Concurrently = true) => def err = FsmWarning.NoConcurrentActivity(act);
              act.Concurrently = false;
              err :: acc
          | _ => acc
        }
      }

      def do_activities = States.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.do_activity));
      def err = do_activities.FoldLeft([], check_do);
      AddWarnings(err);
    }

    CreateConcurrentRegion() : FsmAnalyser
    {
      def warn = not_used_regions |> FsmWarning.RegionNotUsed(_);
      AddWarnings(warn)
    }

    CreateSubMachines() : FsmAnalyser
    {
      def (top, an) = TopState.FoldThis(this, null, null, null, null, (s, t, a) => t.ChangeSubStates(s).InitInline(a).Map((x, y) => (x : FsmState, y)), null, null);
      def map = an.statemap.Init(top);

      //def fsm = States.FilterType();
      //def (st, an) = fsm.MapThrough(this, (x : FsmState.InlinedSubMachineInstance, a) => x.InitInline(a));
      //def st = st |> _ : FsmState;
      //def map = an.statemap.Add(st);

      ChangeStatemap(map)
    }
  }
}
