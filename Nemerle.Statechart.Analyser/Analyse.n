using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  public partial class FsmAnalyser
  {

    InitStatechart() : FsmAnalyser
    {
      def topState = FsmState.State(fsm.state, null, this, false); // create statemachine from top state
      def topState = topState.ChangeName(FsmState.TopStateName);
      def map = statemap.Init(topState);
      ChangeStatemap(map)
    }

    InitStateMap() : FsmAnalyser
    {
      def CheckAddFinalState(sub, st)
      {
        def is_top(st)
        {
          def super = st.super_state; 
          // check if state is top or state is sub of top and don't have transitions
          super == null || (super.super_state == null && super.this_transitions is [])
        }

        def check_target(t, tran)
        {
          match (t, tran)
          {
            | (TransitionTarget.Final as t, _) when (is_top(st))=> 
                def term = PseudoStateNode.Terminate(TopState, 0);
              //TopState.pseudo_states ::= term;
                TransitionTarget.PseudoState(t.transition, term)
            | (Final as t, Initial) with super = st
            | (Final as t, _) with super = st.super_state =>
                def fst = FsmState.Final(super, true);
                //def super = super.AddSubState(fst);
                //def an = an.ChangeStatemap(an.statemap.Add(super));
              //st.ChangeSuper();
              //def fst = fst.ChangeSuperState(super);
                t.ChangeState(fst)

            | (t, _) => t
          }
        }

        st.all_transitions_with_init.Iter(x => x.TargetTraverse(check_target(_, x)));// FoldLeft(an, (x, a) => x.TargetTraverse(a, check_target(_, x, _)))
        match (st.all_transitions_with_init.Find(x => x.To is TransitionTarget.Final))
        {
          | Some(StateTransition where (To = Final(state = s))) => st.ChangeSubStates(sub + [s])
          | _                                                   => null
        }
      }

      def an = InitStatechart();
      def an = an.UpdateStateMap(); // first update state map 
      def top = an.TopState.FoldThis(CheckAddFinalState); // check to add final state
      def map = an.statemap.Init(top);
      def an = an.ChangeStatemap(map);
      def an = an.UpdateStateMap(); // second update state map
      an.CreateHistoryStates();
      when (an.Error) throw FsmErrorException();
      an.RenameDuplicates()
    }

    UpdateReference() : FsmAnalyser
    {
      def (top, an) = TopState.FoldThis(this, (s, t, an) => t.UpdateReference(s, an));
      def map = an.statemap.Update(top);
      an.ChangeStatemap(map)
      //def (st, an) = States.MapThrough(this, _.UpdateReference(_));
      //def map = an.statemap.ChangeStates(st.ToArray());
      //an.ChangeStatemap(map)
    }

    public UpdateStateMap() : FsmAnalyser
    {
      //InitStates();
      def an = UpdateReference();
      def map = statemap.Update(TopState);
      an.ChangeStatemap(map)
    }

    //InitStates() : void
    //{
    //  //def init_states(st, pos)
    //  //{
    //  //  st.hierarchy_pos = pos;
    //  //  st.SubStates.Iter(init_states(_, pos + 1)); // init sub states
    //  //}
    //  //init_states(TopState, 0); // init state map
    //  //states = statemap.States.NToList();
    //}

    RenameDuplicates() : FsmAnalyser
    {
      def do_rename(st, n)
      {
        st.ChangeCopyNum(n)
      }

      def rename_group(st)
      {
        //def (head :: _) = st;
        //def map = map.Rem(head);
        st.MapIndex(do_rename)
      }

      def dups = States.NToList().Duplicates(FsmState.NameComparer);
      def dups = dups.Group(FsmState.NameComparer);
      
      def dups = dups |>< rename_group(_);
      def map = statemap.CheckNew(dups);
      ChangeStatemap(map)
    }

    CreateHistoryStates() : void
    {
      // check history duplicates in state
      def check_dup_history(st)
      {
        match (st.history)
        {
          // duplicate variants
          | TwoOption.Two(StateHistory.Deep, StateHistory.Deep)
          | Two(StateHistory.Shallow, StateHistory.Shallow)  =>
              AddError(FsmError.DuplicateHistory(st, st.history.Value.First()));
          | _  => ()
        }
      }

      def check_exit_actions(st)
      {
        | StateHistory where (state = FsmState where (exit = []) as st) =>
            //st.exit = [StateAction.Exit([], st)]
            1;
        | _ => ()
      }

      def history = States.Filter(x => x.history.HasValue);
      history.Iter(check_dup_history);
      def history_states =  history |>< history.Value;
      def group = history_states.Group((x, y) => string.Compare(x.state.Name, y.state.Name));
      group.IterI((i, x) => x.Iter(x => x.Index = i));
      history_states.Iter(check_exit_actions);
    }

    InitEvents() : void
    {
      def int_evts =  States |>< internal_tran |> Trigger;
      def evts =  States |>< transitions |> Trigger;
      def evts = evts.Filter(x  => x.Name != null);
      def int_tran_evt = int_evts.RemoveDuplicatesSort(_.CompareTo(_));
      def tran_evt = evts.RemoveDuplicatesSort(_.CompareTo(_));
      def int_tran_evt =  int_tran_evt.Exclude(tran_evt, _  ==  _);
      int_tran_evt.Iter(x  => x.InternalOnly = true);
      def evts =  (int_tran_evt + tran_evt) |> (Name, _);
      def events_map = Map(evts);
      def events = events_map.Keys()
    }

    static nodes_eq : ((string * PathNode) * (string * PathNode)) -> bool = (x, y) => PathNode.Equals(x[1], y[1]);
    static nodes_cmp : ((string * PathNode) * (string * PathNode)) -> int = (x, y) => PathNode.Compare(x[1], y[1]);

    CreateHistory() : void    
    {
      //def sub =  history_states |> (_, state, SubStatesParticipateInHistory);  // get all substates participate in history
      //def paths =  $[HistoryPath(par, st, h, this), (h, par, s) in sub, st in s, !(st is FsmState.Final)]; // create history paths
      //paths.Iter(_.CreatePath());
      //def paths = paths.Exclude(_.IsDefault);
      //def paths = paths.RemoveDuplicatesSort((x, y) => x.Name.CompareTo(y.Name));
      //history_paths = paths
    }

    CreateActions() : void
    {
      def check_do(act)
      {
        | StateAction.Do(actions = [_], Concurrently = true) => AddWarning(FsmWarning.NoConcurrentActivity(act));
            act.Concurrently = false
        | _ => ()
      }

      def acts =  trans_paths |>< Actions;
      def int_acts =  internal_transitions.Values() |>< Actions;
      def acts = acts + int_acts;
      def actions = acts.RemoveDuplicatesSort((x, y) => x.CompareTo(y));
      def do_activities = States.FilterValues(_.do_activity);
      do_activities.Iter(check_do);
      def tr = all_transitions |> PathNodeRecursive;
      def action_node = PathNode.Sequence(tr)
    }

    CreateConcurrentRegion() : FsmAnalyser
    {
      def warn = not_used_regions |> FsmWarning.RegionNotUsed(_);
      AddWarnings(warn)
    }

    CreateSubMachines() : FsmAnalyser
    {
      def (top, an) = TopState.FoldThis(this, null, null, null, null, (s, t, a) => t.InitInline(a).Map((x, y) => (x : FsmState, y)), null, null);
      def map = an.statemap.Init(top);
      
      //def fsm = States.FilterType();
      //def (st, an) = fsm.MapThrough(this, (x : FsmState.InlinedSubMachineInstance, a) => x.InitInline(a));
      //def st = st |> _ : FsmState;
      //def map = an.statemap.Add(st);
      
      ChangeStatemap(map)
    }
  }
}
