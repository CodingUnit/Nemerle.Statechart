using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  public partial class FsmAnalyser
  {


    UpdateTransitions(tran : IEnumerable[StateTransition]) : void
    {
      def group = tran.GroupBy(x => x.Source.Num);
      def st = group.Map(x => statemap[x.Key].UpdateTransitions(x));
      statemap.Update(st)
    }

    InitStatechart() : void
    {
      def state = Fsm.state.ChangeName(FsmState.TopStateName);
      def top = state.Fold(null, 
                           (s, sb) => FsmState.CreateState(s, sb, this),
                           (s, sr) => FsmState.ConcurrentRegion(s, sr.Map(_ :> FsmState.ConcurrentSubRegion), this),
                           (s, _)  => FsmState.Final(s, this),
                           null);
                           
      UpdateStateMap(top, true);
      
      def map_st  = statemap.States;
      def name_st = statemap.namemap;
      when (map_st.Length != name_st.Count()) // if name and statemap not equal
      {
        def map_st = map_st.MapToList(_.Name);
        def name_st = name_st.Map(_.Key);
        def map = map_st.Exclude(name_st);//.Exists(_ == x));
        def name = name_st.Exclude(map_st);
        throw InvalidOperationException($"Statemap and names map not equal. New states in statemap ..$map. New states in namemap ..$name)");
      }
    }

    InitStateMap() : void
    {
      InitStatechart();
      
      
      CreateHistoryStates();
      when (Error) throw FsmErrorException();
      RenameDuplicates()
    }

    CheckAddFinalState() : void
    {
        def is_top(st)
        {
          def super = st.Super; 
        // check if state is top or state is sub of top and don't have transitions
          super == null || (super.Super == null && super.this_transitions.IsEmpty())
        }

        def check_target(t, tran, a)
        {
          def st = tran.From;
          match (t, tran)
          {
            | (TransitionTarget.Final, _) when (is_top(st)) => 
                def term = PseudoStateNode.Terminate(0, statemap.GetNextGlobalNum(), this);
                (TransitionTarget.PseudoState(this, term), a)
                
            | (Final as t, Initial) with super = st
            | (Final as t, _) with super = st.Super =>
                def fst = FsmState.Final(super.Name, this).SetNewId();
                //statemap.DefineState(fst, super);
                (t.ChangeStateNum(fst), (super, fst) :: a)
          }
        }

        def check_final(f, st, sub)
        {
          match (f.Find((x, _) => x.Num == st.Num))
          {
            | Some((_, final)) => st.ChangeSubStates(sub.Append(final).NToList())
            | _                => null
          }
        }

        def check_tran(x, (tr, a))
        {
          def (to, fin) = x.To.Reduce(a, final = check_target(_, x, _));
          def tran = x.ChangeTo(to);
          (tran :: tr, fin)
        }

        def check_state(s, _, a)
        {
          def (tran, fin) = s.transitions.FoldBack(([], a), check_tran);
          def (init, fin) = s.initial.FoldBack(([], fin), check_tran);
          def st          = s.ChangeTransitionsInitial(tran, init);
          (st, fin)
        }

        def (top, final) = TopState.ReduceSingle([], check_state);
        // check to add final state
        def top = top.ReduceSingle(true, check_final(final, _, _));
        UpdateStateMap(top); // update state map
    }
    
    public UpdateStateMap(st : IEnumerable[FsmState]) : void
    {
      statemap.Update(st)
    }
    
    public UpdateStateMap(top : FsmState = null, upd_ref : bool = false) : void
    {
    //InitStates();
      statemap.Update(top ?? TopState);
      when (upd_ref) 
      {
        def top = TopState.ReduceSingle((x, _) => x.UpdateReference());
        statemap.Update(top)
      }
    }

    RenameDuplicates() : void
    {
      def rename_group(st)
      {
        st.MapIndex(_.ChangeCopyNum(_))
      }

      def dups = States.NToList().Duplicates(FsmState.NameComparer);
      def dups = dups.Group(FsmState.NameComparer);

      def dups = dups.SelectMany(rename_group);
      statemap.Update(dups)
    }

    CreateHistoryStates() : void
    {
    // check history duplicates in state
      def check_dup_history(st)
      {
        match (st.history)
        {
        // duplicate variants
          | TwoOption.Two(StateHistory(type = HistoryType.Deep), StateHistory(type = HistoryType.Deep))
          | TwoOption.Two(StateHistory(type = HistoryType.Shallow), StateHistory(type = HistoryType.Shallow)) => AddError(FsmError.DuplicateHistory(st, st.history.Value.First()))
          | _                                                         => ()
        }
      }

      def check_exit_actions(st)
      {
        | FsmState(exit = ex) when ex.IsEmpty() => st.ChangeExit(StateAction.Exit([], ActionFlags.None) :: [])
        | _                                     => st
      }

      def update_hist(s, _)
      {
        if (s.history.HasValue)
        {
          check_dup_history(s);
          check_exit_actions(s);
        } else null
      }

      def top = TopState.ReduceSingle(update_hist);
      statemap.Update(top)
    }

    CreateActions() : void
    {
      def check_do(st, act)
      {
        def check(act)
        {
            | StateAction.Do(actions = [_], Concurrently = true, flags = f) => 
                def err = FsmWarning.NoConcurrentActivity(act);
                AddWarning(err);
                act.ChangeFlags(f & ~ActivityFlag.Concurrently);
            | _ => act
        }

        def act = act.Map(check);
        st.ChangeDoActivity(act)
      }

      def top = TopState.ReduceSingle((s, _) => check_do(s, s.do_activity));
      statemap.Update(top);
    }

    CreateConcurrentRegion() : void
    {
      def warn = not_used_regions |> FsmWarning.RegionNotUsed(_);
      AddWarnings(warn)
    }

    CreateHierarchy() : void
    {

      def set_hierarchy_pos(st)
      {
        def sub = st.sub_states.Map(x => x.ChangeCalcHierarchyPos(st.calc_hierarchy_pos + 1));//, st :: st.super_states
        st.ChangeSubStates(sub)
      }

      def top    = TopState.ChangeCalcHierarchyPos(0);
      def states = top.LevelOrderMap(set_hierarchy_pos);
      statemap.Update(states)
    }


    CreateSubMachines() : void
    {
      def (top, base_sm_types) = TopState.Reduce(true, [], inlined_sub_machine_instance = (x, _, acc) => x.InitInline(acc));

      UpdateStateMap(top); // update tree with instanced state machines
      UpdateStateMap(base_sm_types.SelectMany(_.AllStates)); // update base sm types and its contents
    }
    
    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        InitStateMap();
        CheckTransitions();
        CheckAddFinalState(); // check add final states from transitions declaration
        CreateSubMachines();
        CreateHierarchy(); // create hierarchy
        CheckInitialTransitions();
        CreateTransitions();
        BreakIfError();
        CreateTransitionPaths();
        CreateHistoryPaths(); // create history paths
        CreateConcurrentRegion();
        UpdateInitial();
        CreateActions();
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
           def err = x.error;
           when (err != null) AddError(err);
      }
    }
    
  }
}
