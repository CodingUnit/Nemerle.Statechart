using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  public partial class FsmAnalyser
  {

    public GetNewStateId(state : FsmState) : int
    {
      match (States.Find(x => x.Name == state.Name))
      {
        | Some(st) => st.Num
        | _        => GetNextStateNum()
      }
    }

    public GetNewTransitionId(tran : StateTransition) : int
    {
      match (all_transitions_with_init.Find(x => x.Name == tran.Name))
      {
        | Some(tr) => tr.Num
        | _        => GetNextTransitionNum()
      }
    }

    mutable state_num : int;
    mutable transition_num : int;

    GetNextStateNum() : int
    {
      def num = state_num;
      state_num++;
      num
    }

    GetNextTransitionNum() : int
    {
      def num = transition_num;
      transition_num++;
      num
    }
    
    UpdateTransitions(tran : IEnumerable[StateTransition]) : void
    {
        def group = tran.GroupBy(x => x.Source.Num);
        def st = group.Map(x => statemap[x.Key].UpdateTransitions(x));
        statemap.Update(st)
    }
    
    InitStatechart() : void
    {
      def top = Fsm.state.Fold(null, 
                               (_, a)  => a,
                               (_, a)  => a,
                               (_, a)  => a,
                               (s, _)  => FsmState.Final(s, this),
                               (s, sb) => FsmState.CreateState(s, sb, this),
                               (s, sr) => FsmState.ConcurrentRegion(s, sr.Select(_ :> FsmState.ConcurrentSubRegion), this),
                               s       => FsmState.Final(s, this),
                               null
                            );
      def top = top.CreateIterator(); // cache iterator
    //def topState = FsmState.State(Fsm.state, null, this, false); // create statemachine from top state
      def top = top.ChangeName(FsmState.TopStateName);
      UpdateStateMap(top);
      UpdateStateMap(null, true)
    }

    InitStateMap() : void
    {
      def CheckAddFinalState()
      {
        def is_top(st)
        {
          def super = st.Super; 
        // check if state is top or state is sub of top and don't have transitions
          super == null || (super.Super == null && super.this_transitions.IsEmpty())
        }

        def check_target(t, tran, a)
        {
          def st = tran.FromReal;
          match (t, tran)
          {
            | (TransitionTarget.Final as t, _) when (is_top(st))=> 
                def term = PseudoStateNode.Terminate(TopState, 0, this);
            //TopState.pseudo_states ::= term;
                (TransitionTarget.PseudoState(t.transition, this, term), a)
            | (Final as t, Initial) with super = st
            | (Final as t, _) with super = st.Super =>
                def fst = FsmState.Final(super, this, true);
                //def super = super.AddSubState(fst);
                //def an = an.ChangeStatemap(an.statemap.Add(super));
            //st.ChangeSuper();
            //def fst = fst.ChangeSuperState(super);
                (t.ChangeState(fst), fst :: a)
          }
        }

        def check_final(f, st, sub)
        {
          match (f.Find(x => x.Super.Name == st.Name))
          {
            | Some(final) => st.ChangeSubStates(sub.Concat(TraverseUtils.SingleElement(final)).ToList())
            | _           => null
          }
        }

        //def final = st.all_transitions_with_init.FoldLeft(acc, (x, a) => x.To.FoldThis(a, null, null, null, null, check_target(_, x, _), null, null, null, null, null).Map((a, b) => {x.To = a;b}));
        //def acc = acc.Concat(final);
        //match (final.Find(x => x.super_state.name == st.name))
        //{
        //  | Some(head) => (st.ChangeSubStates(sub.Concat(TraverseUtils.SingleElement(head))), final)
        //  | _         => (st, final)
        //}
        def check_tran(x, (tr, a))
        {
          def (to, fin) = x.To.Reduce(a, final = check_target(_, x, _));
          def tran = x.ChangeTo(to);
          (tran :: tr, fin)
        }

        def check_state(s, sb, a)
        {
          def (tran, fin) = s.transitions.FoldLeft(([], a), check_tran);
          def (init, fin) = s.initial.FoldLeft(([], fin), check_tran);
          def st = s.ChangeTransitionsSubStatesInitial(tran.Rev(), sb, init.Rev());
          (st, fin)
        }

        def (top, final) = TopState.ReduceSingle([], check_state);
        // check to add final state
        top.ReduceSingle(check_final(final, _, _));
      }

      InitStatechart();
      def top = CheckAddFinalState();
      UpdateStateMap(top); // update state map
      CreateHistoryStates();
      when (Error) throw FsmErrorException();
      RenameDuplicates()
    }

    public UpdateStateMap(top : FsmState = null, upd_ref : bool = false) : void
    {
    //InitStates();
      statemap.Update(top ?? TopState);
      def top = if (upd_ref) TopState.ReduceSingle(_.UpdateReference(_)); else TopState;
      statemap.Update(top);
    }

    //InitStates() : void
    //{
    //  //def init_states(st, pos)
    //  //{
    //  //  st.hierarchy_pos = pos;
    //  //  st.SubStates.Iter(init_states(_, pos + 1)); // init sub states
    //  //}
    //  //init_states(TopState, 0); // init state map
    //  //states = statemap.States.NToList();
    //}

    RenameDuplicates() : void
    {
      def do_rename(st, n)
      {
        st.ChangeCopyNum(n)
      }

      def rename_group(st)
      {
        //def (head :: _) = st;
        //def map = map.Rem(head);
        st.MapIndex(do_rename)
      }

      def dups = States.NToList().Duplicates(FsmState.NameComparer);
      def dups = dups.Group(FsmState.NameComparer);

      def dups = dups.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(rename_group(x)));
      statemap.Update(dups)
    }

    CreateHistoryStates() : void
    {
    // check history duplicates in state
      def check_dup_history(st, a)
      {
        match (st.history)
        {
        // duplicate variants
          | TwoOption.Two(StateHistory.Deep, StateHistory.Deep)
          | Two(StateHistory.Shallow, StateHistory.Shallow) => FsmError.DuplicateHistory(st, st.history.Value.First()) :: a
          | _                                               => a
        }
      }

      def check_exit_actions(st)
      {
        | FsmState(exit = []) => st.ChangeExit([StateAction.Exit([], st)])
        | _ => st
      }

      def update_hist(s, sb, err)
      {
        if (s.history.HasValue)
        {
          def err = check_dup_history(s, err);
          def s = check_exit_actions(s);
          (s.ChangeSubStates(sb), err)
        } else (s.ChangeSubStates(sb), err)
      }

      def (top, err) = TopState.ReduceSingle([], update_hist);
      statemap.Update(top);
      AddErrors(err)
    }

    static nodes_eq : ((string * PathNode) * (string * PathNode)) -> bool = (x, y) => PathNode.Equals(x[1], y[1]);
    static nodes_cmp : ((string * PathNode) * (string * PathNode)) -> int = (x, y) => PathNode.Compare(x[1], y[1]);

    //CreateHistory() : void    
    //{
    //  //def sub =  history_states |> (_, state, SubStatesParticipateInHistory);  // get all substates participate in history
    //  //def paths =  $[HistoryPath(par, st, h, this), (h, par, s) in sub, st in s, !(st is FsmState.Final)]; // create history paths
    //  //paths.Iter(_.CreatePath());
    //  //def paths = paths.Exclude(_.IsDefault);
    //  //def paths = paths.RemoveDuplicatesSort((x, y) => x.Name.CompareTo(y.Name));
    //  //history_paths = paths
    //}

    CreateActions() : void
    {
      def check_do(st : FsmState, act, acc)
      {
        def check(act, acc)
        {
          match (act)
          {
            | StateAction.Do(actions = [_], Concurrently = true, flags = f) => def err = FsmWarning.NoConcurrentActivity(act);
                def act = act.ChangeFlags(f & ~ActivityFlag.Concurrently);
                (act, err :: acc)
            | _ => (act, acc)
          }
        }

        def (act, err) = act.FoldList([], acc, check);
        (st.ChangeDoActivity(act), err)
      }

      def (top, err) = TopState.ReduceSingle([], (s, _, a) => check_do(s, s.do_activity, a));

      statemap.Update(top);
      AddWarnings(err)
    }

    CreateConcurrentRegion() : void
    {
      def warn = not_used_regions |> FsmWarning.RegionNotUsed(_);
      AddWarnings(warn)
    }

    CreateSubMachines() : void
    {
      def top = TopState.Reduce(inlined_sub_machine_instance = (t, s) => t.ChangeSubStates(s).InitInline());
      UpdateStateMap(top)
    //def fsm = States.FilterType();
    //def (st, an) = fsm.MapThrough(this, (x : FsmState.InlinedSubMachineInstance, a) => x.InitInline(a));
    //def st = st |> _ : FsmState;
    //def map = an.statemap.Add(st);
    }
  }
}
