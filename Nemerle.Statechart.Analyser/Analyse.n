// analyser.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  public partial class FsmAnalyser
  {
    InitFlags() : void
    {
      def pflags = Fsm.flags;
      def flags = pflags.flags;
      // if testing, enable auto entry exit actions, transition completed event
      def flags = if (pflags.TestingFeatures) flags | MachineFlag.AutoEntryExitActions | MachineFlag.TransitionCompleted
                  else flags;
      FsmFlags = pflags.ChangeFlags(flags);
    }
    
    InitStatechart() : void
    {
      InitFlags();
      statemap.Create(Fsm.state);
    }

    CreateStateMap() : void
    {
      InitStatechart();

      CheckHistoryStates(); // check for errors in history
      when (Error) throw FsmErrorException();
      RenameDuplicates();
    }

    public States : array[FsmState]
    {
      get
      {
        statemap.States
      }
    }

    public AllTransitions : array[StateTransition]
    {
      get
      {
        statemap.Transitions
      }
    }

    RenameDuplicates() : void
    {
      def rename_group(st)
      {
        foreach (st in st with i)
        {
          st.copy_num = i
        }
      }

      def to_upper(st)
      {
        def nname = st.name.ToCharArray();
        nname[0] = char.ToUpper(nname[0]);
        st.name = string(nname);
      }
      
      States.Iter(to_upper);
      def dups = States.NToList().Duplicates(FsmState.NameComparer);
      def dups = dups.GroupBy(_.Name).NToList();

      dups.Iter(rename_group)
    }

    CheckHistoryStates() : void
    {
    // check history duplicates in state
      def check_dup_history(h, st)
      {
        match (h)
        {
        // duplicate variants
          | TwoOption.Two(n, n2) =>
              match (n.type, n2.type)
              {
                | (HistoryType.Deep, HistoryType.Deep)
                | (HistoryType.Shallow, HistoryType.Shallow) => AddError(FsmError.DuplicateHistory(st, n))
                | _                                          => ()
              }
          | _ => () 
        }
      }

      def check_exit_actions(st)
      { // if not exit actions, add it
        | FsmState(exit = []) => st.exit = StateAction.Exit([], st, ActionFlags.None) :: []
        | _                   => ()
      }

      foreach (FsmState(history = TwoOption(HasValue = true) as h) as st in States)
      {
        check_dup_history(h, st);
        check_exit_actions(st)
      }
    }

    CreateActions() : void
    {
      //def check_do(st, act)
      //{
      //  def check(act)
      //  {
      //    | StateAction.Do(actions = [_], flags = f) => 
      //          def err = FsmWarning.NoConcurrentActivity(act);
      //          AddWarning(err);
      //          //act.ChangeFlags(f & ~ActivityFlag.Concurrently);
      //    | _ => act
      //  }

      //  def act = act.Map(check);
      //  st.do_activity = act//Update(x => x.ChangeDoActivity(act))
      //}

      foreach (st in States)
      {
        //check_do(st, st.do_activity);
        when (FsmFlags.AutoEntryExitActions) 
        {
          when (st.entry.IsEmpty())
          {
            st.entry = [StateAction.Entry([], st, ActionFlags.None)];
          }
          when (st.exit.IsEmpty())
          {
            st.exit  = [StateAction.Exit([], st, ActionFlags.None)];
          }
        }
      }
    }

    CreateConcurrentRegion() : void
    {
      def warn = not_used_regions.Map(FsmWarning.RegionNotUsed);
      AddWarnings(warn)
    }

#if 0
    CreateSubMachines() : void
    {
      def init_clones(st)
      {
        Clones.Add(st, []);
      }

      States.Iter(init_clones)
      /*def inlined = States.Where(x => x.Data is FsmState.InlinedSubMachineInstance);
      inlined.Iter(x => x.InitInline());*/
            // TODO: надо делать обновление ссылок только один раз
      }
#endif

    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        CreateStateMap();
        CheckTransitions();
        //CreateSubMachines();
        CheckInitialTransitions();
        CreateTransitions();
        CreateActions();
        BreakIfError();
        CreateTransitionPaths();
        CreateHistoryPaths(); // create history paths
        CreateConcurrentRegion();
        UpdateInitial();
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
          def err = x.error;
          when (err != null) AddError(err);
      }
    }

  }
}
