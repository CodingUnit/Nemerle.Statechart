using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  
  enum NodeType
  {
    | Xor
    | And
  }
  
  variant ActiveConfigTree : IGeneralTree[ActiveConfigTree]
  {
    | Leaf { node : ActiveState; }
    | Node { nodetype : NodeType; nodes : list[ActiveConfigTree]; }
    
    public Current : ActiveConfigTree
    {
      get
      {
        this
      }
    }
    
    public ChildNodes : IEnumerable[ActiveConfigTree] 
    {
      get
      {
        match (this)
        {
          | Node(nodes = lst) => lst
          | _                 => []
        }
      }
    }
  }
  
  
  /// <summary>
  /// Description of ActiveConfig.
  /// </summary>
  partial class FsmAnalyser
  {
    
    public ActiveConfigStates : list[ActiveState] {get;set;default []}
    
    ActiveStateConfig : ActiveConfigTree {get;set;}
    
    CreateTransition(tran : StateTransition) : Transition
    {
      null
    }
    
    MergeOrthogonalState(st : ActiveState, st2 : ActiveState) : ActiveState
    {
      def name = st.name + st2.name;
      def tran = st.transitions + st2.transitions;
      def st1 = st.state;
      def st2 = st2.state;
      
      def reg = st2.PartOfRegion.Value;
      
      
      def do_act = st1.do_activity + st2.do_activity;
      def pseudo = st1.pseudo_states + st2.pseudo_states;
      def en = st1.entry + st2.entry;
      def ex = st1.exit + st2.exit;
      def defer = st1.deferred_events + st2.deferred_events;
      def merged = [];//st1.merged_concurrent + st2.merged_concurrent;
      def newst = ActiveState(name, tran, null);
      def tran = st1.transitions + st2.transitions;
      
      def st = FsmState(do_act, reg, StateType.State(), [], tran, 
               pseudo, null, en, ex, defer, 0, null, name, this, null, []);
      newst.state = st;
      newst
    }
    
    ConvertAndState(nodes : list[ActiveConfigTree]) : ActiveConfigTree
    {
      def merge_and_states(x, a)
      {
         | (ActiveConfigTree.Leaf(st), ActiveConfigTree.Leaf(st2)) => 
             def node = MergeOrthogonalState(st, st2);
             ActiveConfigTree.Leaf(node)
             
         | (ActiveConfigTree.Node(nodes = lst), ActiveConfigTree.Leaf(st))
         
         | (ActiveConfigTree.Leaf(st), ActiveConfigTree.Node(nodes = lst)) => 
             def lst = lst.Map(x => (x :> ActiveConfigTree.Leaf).node);
             def st = lst.Map(x => MergeOrthogonalState(st, x));
             def nodes = st.Map(x => ActiveConfigTree.Leaf(x));
             ActiveConfigTree.Node(NodeType.Xor, nodes)
             
         | (ActiveConfigTree.Node(nodes = lst), ActiveConfigTree.Node(nodes = lst2)) => 
             def lst = lst.Map(x => (x :> ActiveConfigTree.Leaf).node);
             def lst2 = lst2.Map(x => (x :> ActiveConfigTree.Leaf).node);
             def res = lst.SelectMany(x => lst2.Select(MergeOrthogonalState(x, _)));
             def res = res.Map(x => ActiveConfigTree.Leaf(x));
             ActiveConfigTree.Node(NodeType.Xor, res)
      }
      
      nodes.Reduce(merge_and_states);
    }
    
    CreateActiveStates() : void
    {
      def create_active_config(x, a)
      {
        match (x)
        {
          | FsmState as st when st.IsSimple => 
             def nst = ActiveState(st.Name, st.transitions.Map(CreateTransition), st);
             //st.active_state = nst;
             ActiveConfigTree.Leaf(nst)
          | FsmState as st when st.IsRegion with type = NodeType.And 
          | st                              with type = NodeType.Xor => ActiveConfigTree.Node(type, a.NToList())
        }
      }
      
      def tree = TopState.FoldTree(null, create_active_config);
      ActiveStateConfig = tree;
      
      def reduce(x, a)
      {
        def a = a.NToList();
        match (x)
        {
          | ActiveConfigTree.Node(NodeType.Xor, nodes) => ActiveConfigTree.Node(NodeType.Xor, nodes + a)
          | ActiveConfigTree.Node(NodeType.And, _)     => match (ConvertAndState(a))
                                                          {
                                                            | ActiveConfigTree.Node(nodes = n) as node => 
                                                              def st = n.Map(x => (x :> ActiveConfigTree.Leaf).node);
                                                              foreach (st in st)
                                                              {
                                                                //def merged = st.state.merged_concurrent;
                                                                //merged.Iter(x => x.merged_states ::= (merged, x))
                                                              }
                                                              node
                                                            | ActiveConfigTree.Leaf(node)  as n =>
                                                              def st = node.state;
                                                              //st.merged_states ::= (st.merged_concurrent, st);
                                                              n
                                                          }
          | ActiveConfigTree.Leaf as n                 => n
        }
      }
      
      def states = match (tree.Reduce(reduce))
      {
        | ActiveConfigTree.Leaf(st)    => [st]
        | ActiveConfigTree.Node(_, st) => st.Map(x => (x :> ActiveConfigTree.Leaf).node)
      }
      ActiveConfigStates = states
    }
    
  }
}
