using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

namespace Nemerle.Statechart
{

  [Record]
  public class NodeReference
  {
    public Num           : int;
    public Source        : FsmState;
    public Dest          : FsmState;
    public SourceChange  : FsmState * FsmState -> FsmState;
    public DestChange    : FsmState * FsmState -> FsmState;
    public SourceVersion : FsmState -> uint;
    public DestVersion   : FsmState -> uint;
  }

  /// <summary>
  /// Description of ChangeManager.
  /// </summary>
  public class ChangeManager
  {
    mutable changes    : BitArray;
    analyser           : FsmAnalyser;
    mutable references : array[list[NodeReference]] = array[];

    public this(an : FsmAnalyser) 
    {
      this.analyser = an
    }

    statemap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }

    public HaveReference(num : int) : bool
    {
      references[num] != null
    }
    
    public StateMapChanged() : void
    {
      def num = statemap.GlobalId;
      when (num != references.Length)
      {
        Array.Resize(ref references, num);
        def ch = BitArray(num);
        when (changes != null) changes.OfType.[bool]().IterI(ch.Set);
        changes = ch
      }
    }

    public static throw_err() : void
    {
      throw InvalidOperationException("more than one modification detected!");
    }

    public Add(obj : int) : void
    {
      def refs = references[obj];
      when (refs != null) 
      {
        changes.Set(obj, true);
      }
    }

    public CreateReference(reference : NodeReference) : void
    {
      def refs = references[reference.Num];
      def refs = if (refs != null) reference :: refs
                  else reference :: [];
      references[reference.Num] = refs
    }

    public CheckChange() : list[FsmState]
    {
      def check(refs)
      {
        def change(rf, a)
        {
          def src = match (a.Find(x => x == rf.Source))
          {
            | Some(st) => st
            | _        => rf.Source.Updated
          }
          def dest = match (a.Find(x => x == rf.Dest))
          {
            | Some(st) => st
            | _        => rf.Dest.Updated
          }
          match (rf.SourceVersion(src), rf.DestVersion(dest))
          {
            | (x, y) when (x > y) => rf.DestChange(src, dest)  :: a
            | (x, y) when (x < y) => rf.SourceChange(src, dest) :: a
            | _                   => a
          }
        }

        refs.FoldLeft([], change)
      }
      
      //statemap.States.Map();
      def refs = references.FilterI((_, i) => changes[i]);
      def st = refs.SelectMany(check).NToList();
      changes.SetAll(false);
      st
    }

  }



}
