using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Statechart;
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Collections;

using NC = Nemerle.Collections;

namespace Nemerle.Statechart
{
  using ListUtils;

  //[Record]
  public partial class FsmAnalyser
  {

    internal statemap : StateMap;

    public FsmFlags : MachineFlags {get;set;}

    

    public LoadedMachines : Hashtable[string, StateNode.StateMachine]
    {
      get
      {
        statemap.LoadedMachines
      }
    }

    [Memoized]
    DeferedEvents : IEnumerable[StateEvent]
    {
      get
      {
        States.SelectMany(_.deferred_events).Where(x => x.Name != null).NToList()
      }
    }
    
    [Memoized]
    Events : list[StateEvent]
    {
      get
      {
        def defered = DeferedEvents;
        def evts = Transitions.Select(x => x.Trigger).Concat(defered);
        def evts = evts.Where(x => x.Name != null);
        evts.RemoveDuplicatesSort(x => x.Name)
      }
    }

    States : array[FsmState]
    {
      get
      {
        statemap.States
      }
    }

    internal StateTransitions : array[StateTransition]
    {
      get
      {
        statemap.Transitions
      }
    }

    public Complete : bool
    {
      get
      {
        messager.ErrorMessages.IsEmpty() && !Events.IsEmpty()
      }
    }

    [Memoized]
    public AllTransitions : list[Transition]
    {
      get
      {
        def trans = InitialTransition :: Transitions.Filter(x => x.MayRun);
        trans
      }
    }

    

    //[Memoized]
    //public all_actions : list[PathNode]
    //{
    //  get
    //  {
    //    def tran_act = tran_paths.SelectMany(_.Path);
    //    tran_act.RemoveDuplicatesSort(_.ToString())
    //  }
    //}


    HistoryStates : IEnumerable[PseudoStateNode.History]
    {
      get
      {
        PseudoStates.FilterType()
      }
    }

    Junctions : IEnumerable[PseudoStateNode.Junction]
    {
      get
      {
        PseudoStates.FilterType()
      }
    }

    PseudoStates : array[PseudoStateNode]
    {
      get
      {
        statemap.PseudoStates
      }
    }

    //public Used : NC.Hashtable[object, bool] = NC.Hashtable();

    [Memoized(States, PseudoStates)]
    InitialTran : IEnumerable[StateTransition]
    {
      get
      {
        States.FilterValues(_.initial_tran)
      }
    }

    forks : IEnumerable[PseudoStateNode.Fork]
    {
      get
      {
        PseudoStates.FilterType()
      }
    }

    joins : IEnumerable[PseudoStateNode.Join]
    {
      get
      {
        PseudoStates.FilterType()
      }
    }

    //[Accessor] mutable traverser : TransitionTraverser;

    //public special_transitions : IEnumerable[StateTransition]
    //{
    //  get
    //  {
    //    def fork_tran = forks.SelectMany(x => x.fork_tran);
    //    def join_tran = joins.SelectMany(x => x.joined_tran);
    //    def exit_tran = exit_points.SelectMany(x => x.tran.ToList());
    //    def entry_tran = entry_points.Select(x => x.tran);
    //    fork_tran + join_tran + exit_tran + entry_tran
    //  }
    //}

    exit_points : IEnumerable[PseudoStateNode.ExitPoint]
    {
      get
      {
        PseudoStates.FilterType()
      }
    }

    entry_points : IEnumerable[PseudoStateNode.EntryPoint]
    {
      get
      {
        PseudoStates.FilterType()
      }
    }

    concurrent_states : IEnumerable[FsmState]
    {
      get
      {
        States.Where(x => x.type is StateType.Region)
      }
    }

    public Fsm : StateNode.StateMachine;

    public NextJunctionNum() : int
    {
      unnamed_junction_num++;
      unnamed_junction_num
    }

    public NextChoiceNum() : int
    {
      unnamed_choice_num++;
      unnamed_choice_num
    }



    public mutable StatesId : StateId;

    internal StateMachinesInProj : list[string * StateNode.StateMachine];

    public static Flags : list[string * MachineFlag]  = [("debug", MachineFlag.Debug),
                                                         ("auto_initial", MachineFlag.AutoInitial),
                                                         ("local_default", MachineFlag.LocalDefault),
                                                         ("property_state_change", MachineFlag.PropertyStateChanged),
                                                         ("only_analyse", MachineFlag.OnlyAnalyse),
                                                         ("auto_entry_exit", MachineFlag.AutoEntryExitActions),
                                                         ("testing", MachineFlag.TestingFeatures),
                                                         ("transition_completed", MachineFlag.TransitionCompleted),
                                                         ("log", MachineFlag.Logging)
                                                        ];

    public this(fsm : StateNode.StateMachine, name : string, mach : list[string * StateNode.StateMachine])
    {
      this.Fsm = fsm;
      StateMachinesInProj = mach;
      Name = fsm.name.SpacesToUnderline() ?? name;
      statemap  = StateMap(this);
    }

    public Name     : string;

    FinalizeAnalyse() : void
    {
      StatesId = StateId(ActiveStates);
      StatesId.CreateMasks();
      def longest = ActiveStates.Max(x => x.name.Length);
      def len = ActiveStates.Count();

      def create_state_report(st)
      {
          | ActiveStateConfig(Id = null) with id = IdType(BitArray(len))
          | ActiveStateConfig(Id = id) =>

              def id_hex = id.Result.Fold("", (x, a) => x.ToString("X8") + a);
              def id_val = id.val.OfType.[bool]().MapListRev(x => if (x) '1' else '0');
              def id_val = string(id_val.ToArray());
              string.Format($<#{0, $longest}: Id = $(id_val) (0x$id_hex) #>, st.name)
      }

      when (FsmFlags.Debug)
      {
        def info = ActiveStates.Map(create_state_report);
        File.WriteAllLines($"$(Name)statemap.log", info);
      }
    }

    public Error : bool
    {
      get
      {
         !messager.ErrorMessages.IsEmpty()
      }
    }

    history_default_transitions : IEnumerable[StateTransition]
    {
      get
      {
        HistoryStates.FilterValues(x => x.default)
      }
    }

    [Memoized(StateTransitions, InitialTran)]
    all_transitions_with_spec : IEnumerable[StateTransition]
    {
      get
      {
        StateTransitions + history_default_transitions + InitialTran; // special_transitions +
      }
    }

    ConflictTransitions : IEnumerable[IEnumerable[StateTransition]]
    {
      get
      {
        States.SelectMany(_.ConflictTransitions)
      }
    }

    CompositeStates : IEnumerable[FsmState]
    {
      get
      {
        States.Where(_.IsComposite)
      }
    }

    SimpleStates : IEnumerable[FsmState]
    {
      get
      {
        States.Where(_.IsSimple)
      }
    }

    TopState : FsmState
    {
      get
      {
        statemap.StateTree
      }
    }

  }
}
