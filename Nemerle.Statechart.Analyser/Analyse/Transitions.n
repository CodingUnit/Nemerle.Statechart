using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using StateTransition;
  using ListUtils;
  //using DecisionNode;  
  using GuardNode;
  using Opt;
/// <summary>
/// Description of AnalyseTransitions.
/// </summary>
  partial class FsmAnalyser
  {

    CheckInitialTransitions() : void
    {
      def check_auto_initial(st, rec)
      {
        match (st)
        {
          | FsmState(type = StateType.Final)  => ()
          | FsmState(type = StateType.Region, sub_states = lst) => when (rec) foreach (st in lst) check_auto_initial(st, rec);
          | FsmState(initial = None, sub_states = head :: _) when (!head.IsFinal) => st.DefineInitial(head);
                                                                                     when (rec) check_auto_initial(head, rec);
          | _ => ()
        }
      }

      def check_init_tran_correct(t)
      {
        match (t.pseudo_states.FilterType())
        {
          | []           => ()
          | t1 :: _ :: _ => messager.AddError(FsmError.InitialPseudoStateAtMostOne(t1))
          | PseudoStateNode.Initial(tran = tran) as i :: [] => 
              match (tran.To)
              {
                | PseudoState(PseudoStateNode.History(state = st)) 
                | PseudoState(PseudoStateNode.EntryPoint(state = st))
                | TransitionTarget.State(st) when (t.AllSubStates.ContainsRef(st)) => ()
                | _                                                                => messager.AddError(FsmError.InitialTransitionMustGoToState(i))
              }
              match (tran.To)
              {
                | PseudoState(PseudoStateNode.History(default = None)) => messager.AddError(FsmError.InitialTransitionToHistoryMustHaveDefaultTran(i))
                | _                                                    => ()
              }
              when (tran.guard.NotEmpty) messager.AddError(FsmError.InitialTransitionCannotHaveGuards(i));
        }
        
      }
      
      
      // check state attributes
      foreach (st in States)
      {
        check_init_tran_correct(st); // check for correct initial transitions
        when (st.Attributes.Exists(_ is StateAttribute.Initial))
        {
          st.Super.DefineInitial(st)
        }
        when (FsmFlags.AutoInitial) check_auto_initial(st, false)
      }
      
      check_auto_initial(TopState, true);
      foreach (st when st.IsComposite in States)
      {
        when (!st.IncomingTransitions.IsEmpty())
        if (st.IsConcurrent)
        {
          def sreg = st.sub_states.Where(x => x.initial.IsNone);
          when (!sreg.IsEmpty())
          {
            messager.AddError(FsmError.SubRegionsMustContainInitial(sreg.NToList()))
          }
        } else
        {
          when (st.initial.IsNone) messager.AddError(FsmError.CompositeStateWithIncomingTransitionsMustHaveInitial(st))
        }
      }
      
    }
    
    
    CheckLocalTrans() : void
    {
      foreach (tr when tr.kind == TransitionKind.Local in StateTransitions)
      {
        def src = match (tr.FromPseudo)
        {
          | Some(PseudoStateNode.EntryPoint as p) => p.state
          | _                                     => tr.From
        }
        def dest = tr.AtLeastStaticTo;
        if (dest.IsSubstateOf(src) || src == dest : object || src.IsSubstateOf(dest)) () else
        {
          messager.AddError(FsmError.LocalTransitionTargetMustBeWithinOrSuper(tr))
        }
      }
    }
    
    CheckTransitions() : void
    {
      // check cross regions transition
      //foreach (StateTransition(AtLeastStaticTo = to) as tr in StateTransitions)
      //{
      //  match (to, tr.From)
      //  {
      //    | (null, _) => ()
      //    | (FsmState(PartOfRegion = Some(r), PartOfSubRegion = Some(sr)), FsmState(PartOfRegion = Some(r2), PartOfSubRegion = Some(sr2))) => 
      //        when (r : object == r2 && sr : object != sr2) AddError(FsmError.TransitionCrossOrthogonalBoundaryOfSameRegion(tr))
      //    | _         => ()
      //  }
      //}
      
      CheckLocalTrans();
    }

    

  }
}
