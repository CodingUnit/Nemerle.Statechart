// analyser.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using System.ComponentModel;
using CommonLib.Macros;
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.lgsp;
using de.unika.ipd.grGen.Action_root;
using de.unika.ipd.grGen.Model_StateMachine;

namespace Nemerle.Statechart
{

  using StateTransition;
  using CommonLib.Macros.ListUtils;

  [NotifyPropertyChange]
  partial class FsmAnalyser : INotifyPropertyChanged
  {

    public concurrent_field_pattern : bool
    {
      [Memoize]
      get
      {
        def flags = FsmFlags;
        if (flags.ForceFieldConcurrentStates) true
        else
        {
          if (flags.ForceConcurrentStateCombination) false else false;
            //gen.ActiveStates.Count() > gen.ConcurrentCombinationsLimit || gen.transitions.Length > gen.ConcurrentTransitionsLimit
        }
      }
    }

    internal CreateEvent(evt : TransitionEvent) : StateEvent
    {
      | TransitionEvent.Normal(n, _)   => match (EventClasses.Find(x => if (x is EventClass.External(evt_name = n2) when n != null) n2 == n.ToUpperFirst() else false))
          {
            | Some(e) => StateEvent.Normal(evt.Location, n, GetEventParms(evt), e)
            | _       => StateEvent.Normal(evt.Location, n, GetEventParms(evt), EventClass.Internal())
          }
      | Completion as e                => StateEvent.Completion(e.Location)
      | Timed(TimedExpr.Expr(ex)) as e => StateEvent.Timed(e.Location, ex)
      | _                              => throw InvalidOperationException("invalid event")
    }

    internal GetEventParms(evt : TransitionEvent) : list[string * string]
    {
      def (name, parms) = if (evt is TransitionEvent.Normal as n) (n.name, n.parms) else (null, []);
      if (parms.IsEmpty()) [] else
        match (EventDecls.Find(x => x.name == name))
        {
          | Some(e) => def types = e.parms_type;
                    if (types.Length != parms.Length)
                    {
                      messager.AddError(FsmError.EventDeclarationNumberOfParamsNotEqual(e, evt));
                      []
                    } else
                    {
                      parms.Zip(types)
                    }
          | _        => messager.AddError(FsmError.EventDeclarationNotFound(evt));[]
        }
    }

    actions : list[FsmAction]
    {
      [Memoize]
      get
      {
        def tran = StateTransitions.SelectMany(_.action);
        def st = States.SelectMany(_.actions);
        def pseudo = PseudoStates.SelectMany(_.Actions);
        tran.Concat(st).Concat(pseudo).NToList()
      }
    }

    CheckActivities() : void 
    {
      def do_act = States.SelectMany(x => x.do_activity.Select(y => (x, y)));

      def other_actions = actions;
      foreach ((_, StateAction.Do(action = Actions(actions = FsmAction.Normal(name = n, parameters = []) :: [])) as act) in do_act)
      {
        match (other_actions.Find(x => if (x is FsmAction.Normal(name = n2)) n2 == n else false))
        {
          | Some(a) => messager.AddError(FsmError.DoActivityDuplicateAction(act, a))
          | _       => ()
        }
      }

      def sm = do_act.Filter((x : FsmState, _) => x.PartOfStateMachine.HasValue);
      def do_act = sm.GroupBy((x : FsmState, _) => x.PartOfStateMachine.Value.SubMachineType);

      foreach (group in do_act)
      {
        foreach (st in group.GroupBy((x, _) => x.name))
        {
          def (need, not) = st.NToList().Partition((_, x) => x.need_completion);
          def st = FsmState(st.Key, this, StateType.State());
          if (need.Length > not.Length)
          {
            need.Iter((_, x) => x.state = st.name);
          } else
          {
            not.Iter((_, x) => x.state = st.name)
          }
        }
      }
    }

    PrintTree[T](tree : T, childs : T -> IEnumerable[T], print_elem : T -> string, file : string) : void
    {

      def indent((text, depth), (acc, prev_depth))
      {
        def ind = string(' ', depth * 2); // create indentation from depth
        def text = $"$ind$text"; // indent text
        // if depth lower than previous append empty line for beauty
        def text = if (depth < prev_depth) text :: "" :: acc else text :: acc;
        (text, depth)
      }

      // get pre order iterator and preorde depth function of elements
      def res = TreeUtils.GetPreOrderEnumerable(tree, childs).Map(print_elem); // map iterator to list of lines of printed text
      def depth = TreeUtils.GetPreOrderDepth(tree, childs).NToList();
      def with_depth = res.Zip(depth); // zip print result and depth to list of tuple(text * depth)
      def (res, _) = with_depth.Fold(([], 0), indent); // indent
      System.IO.File.WriteAllLines(file, res.Rev().ToArray()) // write to file
    }

    PrintFsm(tree : StateNode, file : string) : void
    {
      def print(st)
      {
        | StateNode.State as st => def str = $"$(st.name):, Type: $(st.type)";
                                  def str = if (st.parent is Some(p)) str + $", Parent:$p" else str;
                                  def sub_states = st.sub_states;
                                  def names = sub_states.Select(_.name);
                                  def str = if (sub_states.IsEmpty()) str else $"$str, Sub:..$(names)";
                                  str
        | _                     => ""
      }

      def get_childs(t)
      {
        | StateNode.StateMachine as t => t.state :: []
        | StateNode.Sequence as t     => t.lst
        | StateNode.State as t        => t.sub_states
        | _                           => []
      }

      PrintTree(tree, get_childs, print, file)
    }

    PrintFsmState(tree : FsmState, file : string) : void
    {
      //def file = System.IO.File.CreateText();

      def print(st)
      {
        def str = $<#$(st.Name):, Type: $(st.type)#>;
        def str = if (st.sub_states.IsEmpty()) str else str + $", Sub:..$(st.sub_states)";
        str
      }

      PrintTree(tree, _.sub_states, print, file)
    }

    map : Hashtable[StateNode, LGSPNode] = Hashtable();
    mutable graph_actions : rootActions;
    mutable proc_env : LGSPGraphProcessingEnvironment;

    FindQualifiedNode(name : string, state : IState) : INamedNode
    {
      mutable res;
      if (state == null) null else
      if (graph_actions.FindQualifiedNode.Apply(proc_env, state, name, ref res)) res else null
    }

    FindQualifed(path : list[string], tar : TargetType) : INode
    {
      //def find_all_path_nodes(parent, path)
      //{
      //  | (_, []) => parent
      //  | (IState as p, sub :: tail) => 
      //        match (FindQualifiedNode(p, sub))
      //        {
      //          | null => null
      //          | res  => find_all_path_nodes(res, tail)
      //        } // find in all substates of parent in parent.elem syntax
      //  | _ => null
      //}

      def (head :: path) = path;
      def parent = {mutable res; if (graph_actions.FindNamed.Apply(proc_env, head, ref res)) res else null}// search first node in path
      def node = path.FoldLeft(parent, (x, a) => if (a is IState as a) FindQualifiedNode(x, a) else null);
      match (node)
      {
        | null => null
        | IState as node => match (tar)
                            {
                              | TargetType.Final => null // error
                              | PseudoState(Join(name = n))
                              | PseudoState(Junction(name = n))
                              | PseudoState(EntryPoint(name = n))
                              | PseudoState(ExitPoint(name = n))
                              | Named(name = n)                   => FindQualifiedNode(n, node)
                              | PseudoState(p)                    => match (p)
                                                                      {
                                                                        | History(type = HistoryType.Deep) with type = DeepHistory.TypeInstance
                                                                        | History                          with type = History.TypeInstance => GetContained(node, type)
                                                                        | _                                   => null // error node here
                                                                      }
                                                                      
                              | _               => null // other not supported
                            }
        | _ => null
      }
    }

    ParentOf(node : LGSPNode) : IState
    {
      def nodes = GraphHelper.AdjacentIncoming(node, Contains.TypeInstance, State.TypeInstance);
      if (nodes.IsEmpty()) null else
      {
        nodes.First().Key :> IState
      }
    }
    
    GetContained(src : INode, node_type : NodeType) : IStateMachineNode
    {
      def nodes = GraphHelper.AdjacentOutgoing(src, Contains.TypeInstance, node_type);
      if (nodes.IsEmpty()) null else
      {
        nodes.First().Key :> IStateMachineNode
      }
    }
    
    CreateGraph() : void
    {
      graph = StateMachineNamedGraph();
      graph_actions = rootActions(graph);

      proc_env = LGSPGraphProcessingEnvironment(graph, graph_actions);

      def create_name(n, cntr)
      {
        def n = n ?? "";
        if (graph.GetNode(n) != null) 
        {
          def n = $"$n$cntr";
          create_name(n, cntr + 1)
        } else n
      }

      def create_name = create_name(_, 1);
      
      def set_name = (n : INamedNode, name) => {n.name = name; n;}
      
      def create_named(func : string -> INamedNode, n) : INamedNode
      {
        def node = func(create_name(n));
        set_name(node, n);
      }
      
      // check all states and create state nodes and substate relation edge
      def create_nodes(x, childs)
      {

        match (x)
        {
          | StateNode.StateMachine(name = n) => 
              def n = n ?? Name;
              def name = create_name(n);
              def st_node = graph.CreateNodeState(name); // create graph node
              def st_id = x.Id;
              st_node.name = n;
              st_node.id = st_id;
              map[x] = st_node;
              _ = graph.CreateEdgeTopState(st_node, childs.First()); // link it to sub state through edge for each substate
              st_node
          | State(name = n, type = t) as st => 
              def name = create_name(n);
              def st_id = st.Id;
              def st_node = match (t)
                            {
                              | SubRegion
                              | StateType.State => def node = graph.CreateNodeState(name);
                                                   childs.Iter(x => _ = graph.CreateEdgeSubstate(node, x));
                                                   node
                              | Region          => def node = graph.CreateNodeConcurrentState(name);
                                                   childs.Iter(x => _ = graph.CreateEdgeRegion(node, x));
                                                   node
                              | Final           => graph.CreateNodeFinalState();
                              | SubMachine      => def node = graph.CreateNodeSubMachineState(name);
                                                   childs.Iter(x => _ = graph.CreateEdgeSubstate(node, x));
                                                   node
                            }
              when (st_node is INamedNode as s) s.name = n;
              when (st_node is IState as s) s.id = st_id;              
              def st_node = st_node :> LGSPNode;
              map[st] = st_node;
              // link it to sub state through edge for each substate

              foreach (p in st.pseudo_states)
              {
                def st_id = p.Id;
                def node = match (p.node)
                {
                  | PseudoStateModelNode.EntryPoint as e        => create_named(graph.CreateNodeEntryPoint, e.name)// entry point needs transition pass
                  | ExitPoint as e                              => create_named(graph.CreateNodeExitPoint, e.name)
                  | Initial                                     => graph.CreateNodeInitialState();
                  | History(type = HistoryType.None)            => graph.CreateNodeHistory();
                  | History(type = HistoryType.Deep)            => graph.CreateNodeDeepHistory();
                  | History(type = HistoryType.Shallow)         => graph.CreateNodeShallowHistory();
                  | Fork                                        => graph.CreateNodeFork();
                  | Join as j                                   => create_named(graph.CreateNodeJoin, j.name)
                  | Junction(type = JunctionType.Junction) as j => create_named(graph.CreateNodeJunction, j.name)
                  | Junction(type = JunctionType.Choice) as j   => create_named(graph.CreateNodeChoice, j.name)
                  | Junction(type = JunctionType.Merge) as j    => create_named(graph.CreateNodeMerge, j.name)
                  | Terminate                                   => graph.CreateNodeTerminate();
                }
                when (node is IPseudoState as p) p.id = st_id;
                def node = node :> LGSPNode;
                map[p] = node;
                _ = graph.CreateEdgeContains(st_node, node);
              }
              st_node
          | _ => null
        }
      }
      def top : LGSPNode = Fsm.MapTree(create_nodes);
      def top = top :> IState;
      
      mutable max_id = StateNode.GetMaxId();

      def get_id() { def m = max_id; max_id++; m}

      def create_node(n, parent, func : string -> INamedNode)
      {
        def node = func(n);
        node.name = n;
        _ = graph.CreateEdgeContains(parent :> LGSPNode, node :> LGSPNode);
        node.id = get_id();
        node
      }

      def create_node2(n, parent, func : string -> IStateMachineNode)
      {
        def node = func(n);
        _ = graph.CreateEdgeContains(parent :> LGSPNode, node :> LGSPNode);
        node.id = get_id();
        node
      }
      
      

      def find_named(x) {mutable res; if (graph_actions.FindNamed.Apply(proc_env, x, ref res)) res else null}

      //graph_actions.FindQualifiedNode.Apply(proc_env, p, sub, ref res)
      foreach (node in Fsm.GetPreOrderEnumerable())
        {
          | StateNode.State(transitions = tran) as st => 
              
              def src = map[node];
              def parent = ParentOf(src);//{mutable res; if (graph_actions.ParentOf.Apply(proc_env, src, ref res)) res else null }
              match (st.parent)
              {
                | Some(p) => def parent = match (find_named(p))
                             {
                               | null => graph.CreateNodeUnresolved |> create_named(_, p)
                               | p    => p
                             }
                              _ = graph.CreateEdgeParent(src, parent :> LGSPNode)
                | _       => ()
              }
              foreach (tr in tran)
              {
                def target = match (tr.to)
                              {
                                | TargetType.Named(n) => match (find_named(n))// search for named node with name as target
                                                         {
                                                           | null => graph.CreateNodeUnresolved |> create_named(_, n)// not found, create new unresolved node
                                                           | node => node           
                                                         }
                                | Final               =>  // search final in parent state
                                                         match (GetContained(parent, FinalState.TypeInstance))
                                                         {
                                                           | null => 
                                                              mutable final;
                                                              _ = graph_actions.CreateFinalState.Apply(proc_env, src :> IState, ref final);
                                                              when (final.id == 0) final.id = get_id();
                                                              final
                                                           | final => final
                                                         }
                                                          
                                | Self                => src // to self node
                                | PseudoState(Junction(name = null, type = t)) => // unnamed junction
                                                    // create unnamed junction node in graph
                                                    def func = match (t)
                                                    {
                                                      | JunctionType.Choice   => graph.CreateNodeChoice
                                                      | JunctionType.Junction => graph.CreateNodeJunction
                                                      | JunctionType.Merge    => graph.CreateNodeMerge
                                                    }
                                                    create_node(PseudoStateNode.Junction.GetUnnamedName(this, t), parent, func);
                                | PseudoState(Join(name = n))
                                | PseudoState(Junction(name = n))
                                | PseudoState(EntryPoint(name = n))
                                | PseudoState(ExitPoint(name = n)) => find_named(n)
                                | PseudoState(p) => match (p)
                                    {
                                      | History(type = t) => def type : IStateMachineNode = match (t)
                                                                                              {
                                                                                                | HistoryType.Deep => DeepHistory()
                                                                                                | _                => History()
                                                                                              }
                                                             def type = type.Type;
                                                             def top_states = GraphHelper.ReachableIncoming(src, Contains.TypeInstance, State.TypeInstance, graph);
                                                             def states = ListUtils.SingleElement(src).Concat(top_states);
                                                             def hist = states.Select(GetContained(_, type)).Where(_ != null);
                                                             if (hist.IsEmpty()) graph.CreateNodeUnknown(create_name($"History$t")) else hist.First()
                                      | Fork              => create_node2(create_name("Fork"), parent, graph.CreateNodeFork)
                                      | Terminate         => match (GetContained(top, Terminate.TypeInstance))
                                                             {
                                                               | null =>
                                                                   mutable term;
                                                                   _ = graph_actions.CreateTerminate.Apply(proc_env, ref term);
                                                                   term
                                                               | term => term
                                                             } 
                                                             
                                      | t                 => graph.CreateNodeUnknown(create_name($"Pseudo_$t"))
                                    }
                                | Qualified as q      => // create path and last node                                                                                                     
                                                         def path = q.Path;
                                                         match (FindQualifed(path)) // find other nodes recursive
                                                         {
                                                           | null => def (p, t) = path;
                                                                     def name = $<#..$(p;".").$t#>;
                                                                     graph.CreateNodeUnresolved |> create_named(_, name)
                                                           | q    => q
                                                         }

                                | t => if (tr.kind == TransitionKind.Internal) src else
                                       graph.CreateNodeUnknown(create_name($"Target_$t"))
                              }
                match (src, target)
                {
                  | (_, null)
                  | (null, _)     => ()
                  | (src, LGSPNode as target) => foreach (trig in tr.evt)
                                     {
                                       def tran = match (tr.kind)
                                                  {
                                                    | TransitionKind.External => graph.CreateEdgeTransition(src, target);
                                                    | Internal                => null
                                                  }
                                       tran.trigger = trig.ToString();
                                       tran.guard = tr.guard.ToString();
                                       when (tr.action is Some(a))
                                       {
                                         def act = a.actions.Select(_.ToString());
                                         tran.action = $"..$act"
                                       }
                                     }
                  | _ => ()
                }

              }
          | _ => ()
        }
      GRSExport.Export(graph, $"graph$(Name).grs");
      //def state = 
      //graph.CreateNodeState(Fsm.st);
    }

    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        PrintFsm(Fsm, $"$(Name)_statenode.txt");
        CreateGraph();
        CreateStateMap();
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_created.txt");
        CheckHistoryStates(); // check for errors in history
        CheckTransitions();
        CheckInitialTransitions();
        CreateTransitions();
        BreakIfError();
        TransformFsm();
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_transform.txt");
        ResolveConflicts();
        MergeTransitions();
        CheckUsedElements();
        CheckActivities();
        CreateHistoryPaths(); // create history paths
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
          def err = x.error;
          when (err != null) messager.AddError(err);
      }
    }

  }
}
