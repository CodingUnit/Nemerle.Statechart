// analyser.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using System.ComponentModel;
using CommonLib.Macros;
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.Model_StateMachine;

namespace Nemerle.Statechart
{

  using StateTransition;
  using CommonLib.Macros.ListUtils;

  [NotifyPropertyChange]
  partial class FsmAnalyser : INotifyPropertyChanged
  {

    public concurrent_field_pattern : bool
    {
      [Memoize]
      get
      {
        def flags = FsmFlags;
        if (flags.ForceFieldConcurrentStates) true
        else
        {
          if (flags.ForceConcurrentStateCombination) false else false;
            //gen.ActiveStates.Count() > gen.ConcurrentCombinationsLimit || gen.transitions.Length > gen.ConcurrentTransitionsLimit
        }
      }
    }
    
    internal CreateEvent(evt : TransitionEvent) : StateEvent
    {
      | TransitionEvent.Normal(n, _)   => match (EventClasses.Find(x => if (x is EventClass.External(evt_name = n2) when n != null) n2 == n.ToUpperFirst() else false))
                                          {
                                            | Some(e) => StateEvent.Normal(evt.Location, n, GetEventParms(evt), e)
                                            | _       => StateEvent.Normal(evt.Location, n, GetEventParms(evt), EventClass.Internal())
                                          }
      | Completion as e                => StateEvent.Completion(e.Location)
      | Timed(TimedExpr.Expr(ex)) as e => StateEvent.Timed(e.Location, ex)
      | _                              => throw InvalidOperationException("invalid event")
    }
    
    internal GetEventParms(evt : TransitionEvent) : list[string * string]
    {
      def (name, parms) = if (evt is TransitionEvent.Normal as n) (n.name, n.parms) else (null, []);
      if (parms.IsEmpty()) [] else
      match (EventDecls.Find(x => x.name == name))
      {
        | Some(e) => def types = e.parms_type;
                     if (types.Length != parms.Length)
                     {
                       messager.AddError(FsmError.EventDeclarationNumberOfParamsNotEqual(e, evt));
                       []
                     } else
                     {
                       parms.Zip(types)
                     }
       | _        => messager.AddError(FsmError.EventDeclarationNotFound(evt));[]
      }
    }
    
    actions : list[FsmAction]
    {
      [Memoize]
      get
      {
        def tran = StateTransitions.SelectMany(_.action);
        def st = States.SelectMany(_.actions);
        def pseudo = PseudoStates.SelectMany(_.Actions);
        tran.Concat(st).Concat(pseudo).NToList()
      }
    }
    
    CheckActivities() : void 
    {
      def do_act = States.SelectMany(x => x.do_activity.Select(y => (x, y)));

      def other_actions = actions;
      foreach ((_, StateAction.Do(action = Actions(actions = FsmAction.Normal(name = n, parameters = []) :: [])) as act) in do_act)
      {
        match (other_actions.Find(x => if (x is FsmAction.Normal(name = n2)) n2 == n else false))
        {
          | Some(a) => messager.AddError(FsmError.DoActivityDuplicateAction(act, a))
          | _       => ()
        }
      }
      
      def sm = do_act.Filter((x : FsmState, _) => x.PartOfStateMachine.HasValue);
      def do_act = sm.GroupBy((x : FsmState, _) => x.PartOfStateMachine.Value.SubMachineType);
      
      foreach (group in do_act)
      {
        foreach (st in group.GroupBy((x, _) => x.name))
        {
          def (need, not) = st.NToList().Partition((_, x) => x.need_completion);
          def st = FsmState(st.Key, this, StateType.State());
          if (need.Length > not.Length)
          {
            need.Iter((_, x) => x.state = st.name);
          } else
          {
            not.Iter((_, x) => x.state = st.name)
          }
        }
      }
    }
    
    PrintTree[T](tree : T, childs : T -> IEnumerable[T], print_elem : T -> string, file : string) : void
    {
      
      def indent((text, depth), (acc, prev_depth))
      {
        def ind = string(' ', depth * 2); // create indentation from depth
        def text = $"$ind$text"; // indent text
        // if depth lower than previous append empty line for beauty
        def text = if (depth < prev_depth) text :: "" :: acc else text :: acc;
        (text, depth)
      }
      
      // get pre order iterator and preorde depth function of elements
      def res = TreeUtils.GetPreOrderEnumerable(tree, childs).Map(print_elem); // map iterator to list of lines of printed text
      def depth = TreeUtils.GetPreOrderDepth(tree, childs).NToList();
      def with_depth = res.Zip(depth); // zip print result and depth to list of tuple(text * depth)
      def (res, _) = with_depth.Fold(([], 0), indent); // indent
      System.IO.File.WriteAllLines(file, res.Rev().ToArray()) // write to file
    }
    
    PrintFsm(tree : StateNode, file : string) : void
    {
      def print(st)
      {
        | StateNode.State as st => def str = $"$(st.name):, Type: $(st.type)";
                                   def str = if (st.parent is Some(p)) str + $", Parent:$p" else str;
                                   def sub_states = st.sub_states;
                                   def names = sub_states.Select(_.name);
                                   def str = if (sub_states.IsEmpty()) str else $"$str, Sub:..$(names)";
                                   str
        | _                     => ""
      }
     
      def get_childs(t)
      {
        | StateNode.StateMachine as t => t.state :: []
        | StateNode.Sequence as t     => t.lst
        | StateNode.State as t        => t.sub_states
        | _                           => []
      }
      
      PrintTree(tree, get_childs, print, file)
    }
    
    PrintFsmState(tree : FsmState, file : string) : void
    {
      //def file = System.IO.File.CreateText();
      
      def print(st)
      {
        def str = $<#$(st.Name):, Type: $(st.type)#>;
        def str = if (st.sub_states.IsEmpty()) str else str + $", Sub:..$(st.sub_states)";
        str
      }
      
      PrintTree(tree, _.sub_states, print, file)
    }
    
    CreateGraph() : void
    {
      graph = StateMachineNamedGraph();
      // check all states and create state nodes and substate relation edge
      def create_nodes(x, childs)
      {
        match (x)
        {
          | StateNode.StateMachine(name = n) => 
              def st_node = graph.CreateNodeState(n); // create graph node
              childs.Iter(x => _ = graph.CreateEdgeSubstate(st_node, x)); // link it to sub state through edge for each substate
              st_node
          | State(name = n) as st => 
              def st_node = graph.CreateNodeState(n);
               // link it to sub state through edge for each substate
              childs.Iter(x => _ = graph.CreateEdgeSubstate(st_node, x));
              foreach (p in st.pseudo_states)
              {
                match (p.node)
                {
                   | PseudoStateModelNode.EntryPoint as e => graph.CreateNodeEntryPoint(e.name) // entry point needs transition pass
                }
                                                     
              }
              st_node
        }
      }
      def root = Fsm.MapTree(create_nodes);
      //def state = 
      //graph.CreateNodeState(Fsm.st);
    }
    
    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        PrintFsm(Fsm, $"$(Name)_statenode.txt");
        CreateStateMap();
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_created.txt");
        CheckHistoryStates(); // check for errors in history
        CheckTransitions();
        CheckInitialTransitions();
        CreateTransitions();
        BreakIfError();
        TransformFsm();
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_transform.txt");
        ResolveConflicts();
        MergeTransitions();
        CheckUsedElements();
        CheckActivities();
        CreateHistoryPaths(); // create history paths
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
          def err = x.error;
          when (err != null) messager.AddError(err);
      }
    }

  }
}
