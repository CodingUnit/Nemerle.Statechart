// analyser.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using System.ComponentModel;
using CommonLib.Macros;
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.lgsp;
using de.unika.ipd.grGen.Action_root;
using de.unika.ipd.grGen.Model_StateMachine;

namespace Nemerle.Statechart
{

  using StateTransition;
  using CommonLib.Macros.ListUtils;

  [NotifyPropertyChange]
  partial class FsmAnalyser : INotifyPropertyChanged
  {

    public concurrent_field_pattern : bool
    {
      [Memoize]
      get
      {
        def flags = FsmFlags;
        if (flags.ForceFieldConcurrentStates) true
        else
        {
          if (flags.ForceConcurrentStateCombination) false else false;
            //gen.ActiveStates.Count() > gen.ConcurrentCombinationsLimit || gen.transitions.Length > gen.ConcurrentTransitionsLimit
        }
      }
    }

    internal CreateEvent(evt : TransitionEvent) : StateEvent
    {
      | TransitionEvent.Normal(n, _)   => match (EventClasses.Find(x => if (x is EventClass.External(evt_name = n2) when n != null) n2 == n.ToUpperFirst() else false))
          {
            | Some(e) => StateEvent.Normal(evt.Location, n, GetEventParms(evt), e)
            | _       => StateEvent.Normal(evt.Location, n, GetEventParms(evt), EventClass.Internal())
          }
      | Completion as e                => StateEvent.Completion(e.Location)
      | Timed(TimedExpr.Expr(ex)) as e => StateEvent.Timed(e.Location, ex)
      | _                              => throw InvalidOperationException("invalid event")
    }

    internal GetEventParms(evt : TransitionEvent) : list[string * string]
    {
      def (name, parms) = if (evt is TransitionEvent.Normal as n) (n.name, n.parms) else (null, []);
      if (parms.IsEmpty()) [] else
        match (EventDecls.Find(x => x.name == name))
        {
          | Some(e) => def types = e.parms_type;
                    if (types.Length != parms.Length)
                    {
                      messager.AddError(FsmError.EventDeclarationNumberOfParamsNotEqual(e, evt));
                      []
                    } else
                    {
                      parms.Zip(types)
                    }
          | _        => messager.AddError(FsmError.EventDeclarationNotFound(evt));[]
        }
    }

    actions : list[FsmAction]
    {
      [Memoize]
      get
      {
        def tran = StateTransitions.SelectMany(_.action);
        def st = States.SelectMany(_.actions);
        def pseudo = PseudoStates.SelectMany(_.Actions);
        tran.Concat(st).Concat(pseudo).NToList()
      }
    }

    CheckActivities() : void 
    {
      def do_act = States.SelectMany(x => x.do_activity.Select(y => (x, y)));

      def other_actions = actions;
      foreach ((_, StateAction.Do(action = Actions(actions = FsmAction.Normal(name = n, parameters = []) :: [])) as act) in do_act)
      {
        match (other_actions.Find(x => if (x is FsmAction.Normal(name = n2)) n2 == n else false))
        {
          | Some(a) => messager.AddError(FsmError.DoActivityDuplicateAction(act, a))
          | _       => ()
        }
      }

      def sm = do_act.Filter((x : FsmState, _) => x.PartOfStateMachine.HasValue);
      def do_act = sm.GroupBy((x : FsmState, _) => x.PartOfStateMachine.Value.SubMachineType);

      foreach (group in do_act)
      {
        foreach (st in group.GroupBy((x, _) => x.name))
        {
          def (need, not) = st.NToList().Partition((_, x) => x.need_completion);
          def st = FsmState(st.Key, this, StateType.State());
          if (need.Length > not.Length)
          {
            need.Iter((_, x) => x.state = st.name);
          } else
          {
            not.Iter((_, x) => x.state = st.name)
          }
        }
      }
    }

    PrintTree[T](tree : T, childs : T -> IEnumerable[T], print_elem : T -> string, file : string) : void
    {

      def indent((text, depth), (acc, prev_depth))
      {
        def ind = string(' ', depth * 2); // create indentation from depth
        def text = $"$ind$text"; // indent text
        // if depth lower than previous append empty line for beauty
        def text = if (depth < prev_depth) text :: "" :: acc else text :: acc;
        (text, depth)
      }

      // get pre order iterator and preorde depth function of elements
      def res = TreeUtils.GetPreOrderEnumerable(tree, childs).Map(print_elem); // map iterator to list of lines of printed text
      def depth = TreeUtils.GetPreOrderDepth(tree, childs).NToList();
      def with_depth = res.Zip(depth); // zip print result and depth to list of tuple(text * depth)
      def (res, _) = with_depth.Fold(([], 0), indent); // indent
      System.IO.File.WriteAllLines(file, res.Rev().ToArray()) // write to file
    }

    PrintFsm(tree : StateNode, file : string) : void
    {
      def print(st)
      {
        | StateNode.State as st => def str = $"$(st.name):, Type: $(st.type)";
                                  def str = if (st.parent is Some(p)) str + $", Parent:$p" else str;
                                  def sub_states = st.sub_states;
                                  def names = sub_states.Select(_.name);
                                  def str = if (sub_states.IsEmpty()) str else $"$str, Sub:..$(names)";
                                  str
        | _                     => ""
      }

      def get_childs(t)
      {
        | StateNode.StateMachine as t => t.state :: []
        | StateNode.Sequence as t     => t.lst
        | StateNode.State as t        => t.sub_states
        | _                           => []
      }

      PrintTree(tree, get_childs, print, file)
    }

    PrintFsmState(tree : FsmState, file : string) : void
    {
      //def file = System.IO.File.CreateText();

      def print(st)
      {
        def str = $<#$(st.Name):, Type: $(st.type)#>;
        def str = if (st.sub_states.IsEmpty()) str else str + $", Sub:..$(st.sub_states)";
        str
      }

      PrintTree(tree, _.sub_states, print, file)
    }

    map : Hashtable[StateNode, LGSPNode] = Hashtable();
    mutable graph_actions : rootActions;
    mutable proc_env : LGSPGraphProcessingEnvironment;

    FindQualifed(path : list[string], tar : TargetType) : INode
    {
      def node = {mutable res; if (graph_actions.FindQualifiedPath.Apply(proc_env, path.ToList(), ref res)) res else null};
      if (tar == null) node else
      if (node == null) null else
      match (tar)
      {
        | PseudoState(p) => match (p)
                              {
                                | History(type = HistoryType.Deep) with type = DeepHistory.TypeInstance
                                | History                          with type = History.TypeInstance => GetContained(node, type)
                                | _                                                                 => null // error node here
                              }
        | _              => null // other not supported
      }
    }

    ParentOf(node : LGSPNode) : IState
    {
      def nodes = GraphHelper.AdjacentIncoming(node, Contains.TypeInstance, State.TypeInstance);
      if (nodes.IsEmpty()) null else
      {
        nodes.First().Key :> IState
      }
    }
    
    GetContained(src : INode, node_type : NodeType) : IStateMachineNode
    {
      def nodes = GraphHelper.AdjacentOutgoing(src, Contains.TypeInstance, node_type);
      if (nodes.IsEmpty()) null else
      {
        nodes.First().Key :> IStateMachineNode
      }
    }
    
    create_name(n : string) : string
    {
      def loop(n, cntr)
      {
        def n = n ?? "";
        if (graph.GetNode(n) != null) 
        {
          def n = $"$n$cntr";
          loop(n, cntr + 1)
        } else n
      }
      
      loop(n, 1)
    }
      
    create_named(func : string -> INamedNode, n : string) : INamedNode
    {
      def node = func(create_name(n));
      //set_name(node, n);
      node.name = n;
      node
      //set_name = (n : INamedNode, name) => {n.name = name; n;}
    }
      
    create_node(n : string, parent : IState, func : string -> INamedNode) : INamedNode
    {
      def node = func(n);
      node.name = n;
      _ = graph.CreateEdgeContains(parent :> LGSPNode, node :> LGSPNode);
      node.id = get_id();
      node
    }

    create_node2(n : string, parent : IState, func : string -> IStateMachineNode) : IStateMachineNode
    {
      def node = func(n);
      _ = graph.CreateEdgeContains(parent :> LGSPNode, node :> LGSPNode);
      node.id = get_id();
      node
    }

    find_named(x : string) : INamedNode
    {
      mutable res; 
      if (graph_actions.FindNamed.Apply(proc_env, x, ref res)) res else null
    }
      
    GetTarget(src : LGSPNode, to : TargetType) : LGSPNode
    {
      def parent = ParentOf(src);
      def n = match (to)
        {
          | PseudoState(Join(name = n))
          | PseudoState(Junction(name = n))
          | PseudoState(EntryPoint(name = n))
          | PseudoState(ExitPoint(name = n))
          | TargetType.Named(n) => match (find_named(n))// search for named node with name as target
                                    {
                                      | null => graph.CreateNodeUnresolved |> create_named(_, n)// not found, create new unresolved node
                                      | node => node           
                                    }
          | Final               =>  // search final in parent state
                                    match (GetContained(parent, FinalState.TypeInstance))
                                    {
                                      | null => 
                                        mutable final;
                                        _ = graph_actions.CreateFinalState.Apply(proc_env, src :> IState, ref final);
                                        when (final.id == 0) final.id = get_id();
                                        final
                                      | final => final
                                    }
                                                          
                      
          | PseudoState(Junction(name = null, type = t) as j) => // unnamed junction
                              // create unnamed junction node in graph
                              def func = match (t)
                              {
                                | JunctionType.Choice   => graph.CreateNodeChoice
                                | JunctionType.Junction => graph.CreateNodeJunction
                                | JunctionType.Merge    => graph.CreateNodeMerge
                              }
                              def node = create_node(PseudoStateNode.Junction.GetUnnamedName(this, t), parent, func);
                              ConnectJunction(j, node :> LGSPNode); // connect junction targets
                              node
         
          | PseudoState(p) => match (p)
              {
                | History(type = t) => def type : IHistory = match (t)
                                                  {
                                                    | HistoryType.Deep => DeepHistory()
                                                    | _                => History()
                                                  }
                                       mutable res;
                                       if (graph_actions.FindHistory.Apply(proc_env, src :> IState, type, ref res))
                                       {
                                         res
                                       } else
                                       {
                                         graph.CreateNodeUnknown(create_name($"History$t"))
                                       }
                                       
                | Fork as f         => def node = create_node2(create_name("Fork"), parent, graph.CreateNodeFork);
                                       def target = f.target.Map(GetTarget(src, _)); // get target nodes of fork
                                       foreach (t in target) // for each target
                                       {
                                         _ = graph.CreateEdgeTransition(src, t) // create edge from source to target node
                                       }
                                       node
                                       
                | Terminate         => def top = graph.GetCompatibleEdges(TopState.TypeInstance).First().Target; // find top state
                                        match (GetContained(top, Terminate.TypeInstance)) // search for terminate in it
                                        {
                                          | null =>
                                              mutable term;
                                              _ = graph_actions.CreateTerminate.Apply(proc_env, ref term);
                                              term
                                          | term => term
                                        } 
                | t                 => graph.CreateNodeUnknown(create_name($"Pseudo_$t"))
              }
          | Qualified as q      => // create path and last node                                                                                                     
                                    def path = q.FinalPath;
                                    match (FindQualifed(path)) // find other nodes recursive
                                    {
                                      | null => def (p, t) = path;
                                                def name = if (t != null) $<#..$(p;".").$t#> else $<#..$(p;".")#>;
                                                graph.CreateNodeUnresolved |> create_named(_, name)
                                      | q    => q
                                    }
          | Self                
          | NoTarget            => src // to self node
          | t                   => graph.CreateNodeUnknown(create_name($"Target_$t"))
        }
        n :> LGSPNode
    }
    
    enum TranType 
    {
      | State 
      | Pseudo 
      | Link
    };
    
    GetSource(src : LGSPNode, tr : StateNode.Transition) : LGSPNode
    {
      match (tr.from)
      {
        | PseudoState(PseudoStateModelNode.Join as j) => def node = (graph.CreateNodeJoin |> create_named(_, "Join")) :> LGSPNode;
                                                         _ = graph.CreateEdgeContains(src, node);
                                                         ConnectJoin(j, node);
                                                         node
        | _                                           => src
      }
    }
    
    CreateTransition(src : LGSPNode, tr : StateNode.Transition, type : TranType) : void
    {
      def src = GetSource(src, tr);
      def target = GetTarget(src, tr.to);
      match (target)
      {
        | null   => ()
        | target => 
            match (type)
            {
              | Pseudo =>
                  def tran = graph.CreateEdgePseudoTransition(src, target);
                  tran.guard = tr.guard.ToString();
                  tran.action = tr.action.MapDefault(_.ToString(), "");
                  tran.out_str = tr.ExecStr(TransitionEvent.None);
                  
              | State => 
              
              foreach (trig in tr.evt)
              {
              
                def tran : IStateTransition = match (tr.kind)
                                              {
                                                | Internal                => graph.CreateEdgeInternalTransition(src, target)
                                                | Local                   => graph.CreateEdgeLocalTransition(src, target)
                                                | _                       => graph.CreateEdgeExternalTransition(src, target);
                                              }
                if (trig is TransitionEvent.Normal(name = null)) () else
                  tran.trigger = trig.ToString();
                tran.guard = tr.guard.ToString();
                tran.action = tr.action.MapDefault(_.ToString(), "");
                tran.out_str = tr.ExecStr(trig);
              }
              
              | Link => _ = graph.CreateEdgeTransition(src, target);
            }
      }
    }
    
    mutable max_id : int;

    get_id() : int { def m = max_id; max_id++; m}
      
    ConnectJunction(j : PseudoStateModelNode.Junction, src : LGSPNode) : void
    {
      // connect one src and its nodes
      foreach (n in j.nodes)
      {
        def target = GetTarget(src, n.to); // get target of that node
        when (target != null) // if correct and created
        {
          def tran = graph.CreateEdgePseudoTransition(src, target); // create edge
          tran.guard = n.guard.ToString(); // set guard and actions
          tran.action = n.action.MapDefault(_.ToString(), "");
        }
        match (n.to) // go further
        {
          | TargetType.PseudoState(Junction as j) => ConnectJunction(j, target) // loop
          | _                                     => ()
        }
      }
    }
    
    ConnectJoin(j : PseudoStateModelNode.Join, src : LGSPNode) : void
    {
      // for each of source   
      foreach (from in j.sources)
      {
        // search for node of source path 
        def from = match (FindQualifed(from.Parts, null))
        {
          // not found create unresolved
          | null => graph.CreateNodeUnresolved |> create_named(_, from.FullName)
          | node => node
        }
        // create edge from source to this Join node
        _ = graph.CreateEdgeTransition(from :> LGSPNode, src)
      }
                                                        
    }
    
    CreateGraph() : void
    {
      graph = StateMachineNamedGraph();
      graph_actions = rootActions(graph);
      proc_env = LGSPGraphProcessingEnvironment(graph, graph_actions);
      /*
      1) For all states, in tree, create state and pseudo nodes
      2) For all states, get all pseudo states and create edges connecting them
      3) For all states, create transition edges from states to targets
      */
      // check all states and create state nodes and substate relation edge
      def create_nodes(x, childs)
      {

        def node = match (x)
        {
          | StateNode.StateMachine(name = n) => 
              def n = n ?? Name;
              def name = create_name(n);
              def st_node = graph.CreateNodeState(name); // create graph node
              def st_id = x.Id;
              st_node.name = n;
              st_node.id = st_id;
              map[x] = st_node;
              _ = graph.CreateEdgeTopState(st_node, childs.First()); // link it to sub state through edge for each substate
              st_node
          | State(name = n, type = t) as st => 
              def name = create_name(n);
              def st_id = st.Id;
              def st_node = match (t)
                            {
                              | SubRegion
                              | StateType.State => def node = graph.CreateNodeState(name);
                                                   childs.Iter(x => _ = graph.CreateEdgeSubstate(node, x));
                                                   node
                              | Region          => def node = graph.CreateNodeConcurrentState(name);
                                                   childs.Iter(x => _ = graph.CreateEdgeRegion(node, x));
                                                   node
                              | Final           => graph.CreateNodeFinalState();
                              | SubMachine      => def node = graph.CreateNodeSubMachineState(name);
                                                   childs.Iter(x => _ = graph.CreateEdgeSubstate(node, x));
                                                   node
                            }
              when (st_node is INamedNode as s) s.name = n;
              when (st_node is IState as s) s.id = st_id;              
              def st_node = st_node :> LGSPNode;
              map[st] = st_node;
              // link it to sub state through edge for each substate

              foreach (p in st.pseudo_states)
              {
                def st_id = p.Id;
                def node = match (p.node)
                {
                  | PseudoStateModelNode.EntryPoint as e        => create_named(graph.CreateNodeEntryPoint, e.name)// entry point needs transition pass
                  | ExitPoint as e                              => create_named(graph.CreateNodeExitPoint, e.name)
                  | Initial                                     => graph.CreateNodeInitialState();
                  | History(type = HistoryType.None)            => graph.CreateNodeHistory();
                  | History(type = HistoryType.Deep)            => graph.CreateNodeDeepHistory();
                  | History(type = HistoryType.Shallow)         => graph.CreateNodeShallowHistory();
                  | Fork                                        => graph.CreateNodeFork();
                  | Join as j                                   => create_named(graph.CreateNodeJoin, j.name)
                  | Junction(type = JunctionType.Junction) as j => create_named(graph.CreateNodeJunction, j.name)
                  | Junction(type = JunctionType.Choice) as j   => create_named(graph.CreateNodeChoice, j.name)
                  | Junction(type = JunctionType.Merge) as j    => create_named(graph.CreateNodeMerge, j.name)
                  | Terminate                                   => graph.CreateNodeTerminate();
                }
                when (node is IPseudoState as p) p.id = st_id;
                def node = node :> LGSPNode;
                map[p] = node;
                _ = graph.CreateEdgeContains(st_node, node);
              }
              st_node
          | _ => null
        }
          
        node
      }
      //def top : LGSPNode 
      _ = Fsm.MapTree(create_nodes);
      //def top = top :> IState;
      
      max_id = StateNode.GetMaxId();

      //def get_id() { def m = max_id; max_id++; m}
      

      //graph_actions.FindQualifiedNode.Apply(proc_env, p, sub, ref res)
      foreach (node in map)
      {
        def src = node.Value;
        match (node.Key)
        {
          | StateNode.State(transitions = tran) as st => 
              
              //def parent = ParentOf(src);//{mutable res; if (graph_actions.ParentOf.Apply(proc_env, src, ref res)) res else null }
              match (st.parent)
              {
                | Some(p) => def parent = match (find_named(p))
                             {
                               | null => graph.CreateNodeUnresolved |> create_named(_, p)
                               | p    => p
                             }
                              _ = graph.CreateEdgeParent(src, parent :> LGSPNode)
                | _       => ()
              }
              
               // create all transition edges between state and targets
              foreach (tr in tran)
              {
                CreateTransition(src, tr, TranType.State)
              }
              
              
          | PseudoState(p) => 
              match (p)
              {
                | EntryPoint(tran = t)
                | ExitPoint(tran = Some(t))
                | History(default = Some(t)) => CreateTransition(src, t, TranType.Pseudo)
                | Junction as j              => ConnectJunction(j, src)
                | Join as j                  => ConnectJoin(j, src);
                                                // create edge from join to target
                                                CreateTransition(src, j.tran, TranType.State);
                                                  
                | Initial(tran = t)          => foreach (tr in t)
                                                {
                                                  CreateTransition(src, tr, TranType.Pseudo)
                                                }
                                                  
                | _                         => ()    
              }
          | _ => ()
        }
      }
      GRSExport.Export(graph, $"$(Name).grs");
      //def state = 
      //graph.CreateNodeState(Fsm.st);
    }

    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        PrintFsm(Fsm, $"$(Name)_statenode.txt");
        CreateGraph();
        CreateStateMap();
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_created.txt");
        CheckHistoryStates(); // check for errors in history
        CheckTransitions();
        CheckInitialTransitions();  
        CreateTransitions();
        BreakIfError();
        TransformFsm();
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_transform.txt");
        ResolveConflicts();
        MergeTransitions();
        CheckUsedElements();
        CheckActivities();
        CreateHistoryPaths(); // create history paths
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
          def err = x.error;
          when (err != null) messager.AddError(err);
      }
    }

  }
}
