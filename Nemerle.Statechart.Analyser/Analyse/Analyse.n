// analyser.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using System.ComponentModel;
using CommonLib.Macros;
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.lgsp;
using de.unika.ipd.grGen.Action_root;
using de.unika.ipd.grGen.Model_StateMachine;

namespace Nemerle.Statechart
{

  using StateTransition;
  using CommonLib.Macros.ListUtils;

  [NotifyPropertyChange]
  partial class FsmAnalyser : INotifyPropertyChanged
  {

    public concurrent_field_pattern : bool
    {
      [Memoize]
      get
      {
        def flags = FsmFlags;
        if (flags.ForceFieldConcurrentStates) true
        else
        {
          if (flags.ForceConcurrentStateCombination) false else false;
            //gen.ActiveStates.Count() > gen.ConcurrentCombinationsLimit || gen.transitions.Length > gen.ConcurrentTransitionsLimit
        }
      }
    }
    
    internal CreateEvent(evt : TransitionEvent) : StateEvent
    {
      | TransitionEvent.Normal(n, _)   => match (EventClasses.Find(x => if (x is EventClass.External(evt_name = n2) when n != null) n2 == n.ToUpperFirst() else false))
                                          {
                                            | Some(e) => StateEvent.Normal(evt.Location, n, GetEventParms(evt), e)
                                            | _       => StateEvent.Normal(evt.Location, n, GetEventParms(evt), EventClass.Internal())
                                          }
      | Completion as e                => StateEvent.Completion(e.Location)
      | Timed(TimedExpr.Expr(ex)) as e => StateEvent.Timed(e.Location, ex)
      | _                              => throw InvalidOperationException("invalid event")
    }
    
    internal GetEventParms(evt : TransitionEvent) : list[string * string]
    {
      def (name, parms) = if (evt is TransitionEvent.Normal as n) (n.name, n.parms) else (null, []);
      if (parms.IsEmpty()) [] else
      match (EventDecls.Find(x => x.name == name))
      {
        | Some(e) => def types = e.parms_type;
                     if (types.Length != parms.Length)
                     {
                       messager.AddError(FsmError.EventDeclarationNumberOfParamsNotEqual(e, evt));
                       []
                     } else
                     {
                       parms.Zip(types)
                     }
       | _        => messager.AddError(FsmError.EventDeclarationNotFound(evt));[]
      }
    }
    
    actions : list[FsmAction]
    {
      [Memoize]
      get
      {
        def tran = StateTransitions.SelectMany(_.action);
        def st = States.SelectMany(_.actions);
        def pseudo = PseudoStates.SelectMany(_.Actions);
        tran.Concat(st).Concat(pseudo).NToList()
      }
    }
    
    CheckActivities() : void 
    {
      def do_act = States.SelectMany(x => x.do_activity.Select(y => (x, y)));

      def other_actions = actions;
      foreach ((_, StateAction.Do(action = Actions(actions = FsmAction.Normal(name = n, parameters = []) :: [])) as act) in do_act)
      {
        match (other_actions.Find(x => if (x is FsmAction.Normal(name = n2)) n2 == n else false))
        {
          | Some(a) => messager.AddError(FsmError.DoActivityDuplicateAction(act, a))
          | _       => ()
        }
      }
      
      def sm = do_act.Filter((x : FsmState, _) => x.PartOfStateMachine.HasValue);
      def do_act = sm.GroupBy((x : FsmState, _) => x.PartOfStateMachine.Value.SubMachineType);
      
      foreach (group in do_act)
      {
        foreach (st in group.GroupBy((x, _) => x.name))
        {
          def (need, not) = st.NToList().Partition((_, x) => x.need_completion);
          def st = FsmState(st.Key, this, StateType.State());
          if (need.Length > not.Length)
          {
            need.Iter((_, x) => x.state = st.name);
          } else
          {
            not.Iter((_, x) => x.state = st.name)
          }
        }
      }
    }
    
    PrintTree[T](tree : T, childs : T -> IEnumerable[T], print_elem : T -> string, file : string) : void
    {
      
      def indent((text, depth), (acc, prev_depth))
      {
        def ind = string(' ', depth * 2); // create indentation from depth
        def text = $"$ind$text"; // indent text
        // if depth lower than previous append empty line for beauty
        def text = if (depth < prev_depth) text :: "" :: acc else text :: acc;
        (text, depth)
      }
      
      // get pre order iterator and preorde depth function of elements
      def res = TreeUtils.GetPreOrderEnumerable(tree, childs).Map(print_elem); // map iterator to list of lines of printed text
      def depth = TreeUtils.GetPreOrderDepth(tree, childs).NToList();
      def with_depth = res.Zip(depth); // zip print result and depth to list of tuple(text * depth)
      def (res, _) = with_depth.Fold(([], 0), indent); // indent
      System.IO.File.WriteAllLines(file, res.Rev().ToArray()) // write to file
    }
    
    PrintFsm(tree : StateNode, file : string) : void
    {
      def print(st)
      {
        | StateNode.State as st => def str = $"$(st.name):, Type: $(st.type)";
                                   def str = if (st.parent is Some(p)) str + $", Parent:$p" else str;
                                   def sub_states = st.sub_states;
                                   def names = sub_states.Select(_.name);
                                   def str = if (sub_states.IsEmpty()) str else $"$str, Sub:..$(names)";
                                   str
        | _                     => ""
      }
     
      def get_childs(t)
      {
        | StateNode.StateMachine as t => t.state :: []
        | StateNode.Sequence as t     => t.lst
        | StateNode.State as t        => t.sub_states
        | _                           => []
      }
      
      PrintTree(tree, get_childs, print, file)
    }
    
    PrintFsmState(tree : FsmState, file : string) : void
    {
      //def file = System.IO.File.CreateText();
      
      def print(st)
      {
        def str = $<#$(st.Name):, Type: $(st.type)#>;
        def str = if (st.sub_states.IsEmpty()) str else str + $", Sub:..$(st.sub_states)";
        str
      }
      
      PrintTree(tree, _.sub_states, print, file)
    }
    
    map : Hashtable[StateNode, LGSPNode] = Hashtable();
    mutable graph_actions : rootActions;
    mutable proc_env : LGSPGraphProcessingEnvironment;
    
    FindQualifed(parent : INamedNode, path : list[string], tar : TargetType) : LGSPNode
    {
      def find_all_path_nodes(parent, path)
      {
        | (_, []) => parent
        | (IState as p, sub :: tail) => 
              mutable res;
              if (graph_actions.FindQualifiedNode.Apply(proc_env, p, sub, ref res))// search final in parent state
              {
                find_all_path_nodes(res, tail)
              } else
              {
                null
              } // find in all substates of parent in parent.elem syntax
        | _ => null
      }
                                                   
      match (find_all_path_nodes(parent, path))
      {
        | null => null
        | IState as node => match (tar)
                            {
                              | TargetType.Final => null // error
                              | Named as n       => mutable res;
                                                    if (graph_actions.FindQualifiedNode.Apply(proc_env, node, n.name, ref res)) // todo
                                                    {
                                                      res :> LGSPNode
                                                    } else
                                                    {
                                                      null
                                                    }
                              | PseudoState(p)   => def type = match (p)
                                                    {
                                                      | History(type = HistoryType.Deep)    => def type = DeepHistoryState.TypeInstance; null
                                                      | History(type = HistoryType.Shallow) => def type = ShallowHistoryState.TypeInstance; null
                                                      | History(type = HistoryType.None)    => def type = History.TypeInstance; null
                                                      | _                                   => null
                                                    }
                                                    null // todo
                              | _               => null // other not supported
                            }
      }
    }
    
    CreateGraph() : void
    {
      graph = StateMachineNamedGraph();
      graph_actions = rootActions(graph);
      
      proc_env = LGSPGraphProcessingEnvironment(graph, graph_actions);
      
      def create_name(n, cntr)
      {
        def n = n ?? "";
        if (graph.GetNode(n) != null) 
        {
          def n = $"$n$cntr";
          create_name(n, cntr + 1)
        } else n
      }
      
      def create_name = create_name(_, 1);
      def set_name = (n : INamedNode, name) => {n.name = name; n;}
      
      // check all states and create state nodes and substate relation edge
      def create_nodes(x, childs)
      {
        
        match (x)
        {
          | StateNode.StateMachine(name = n) => 
              def name = create_name(n);
              def st_node = graph.CreateNodeState(name); // create graph node
              def st_id = x.Id;
              st_node.name = n;
              st_node.id = st_id;
              map[x] = st_node;
              _ = graph.CreateEdgeContains(st_node, childs.First()); // link it to sub state through edge for each substate
              st_node
          | State(name = n, type = t) as st => 
              def name = create_name(n);
              def st_id = st.Id;
              def st_node = match (t)
                            {
                              | SubRegion
                              | StateType.State => def node = graph.CreateNodeState(name);
                                                   childs.Iter(x => _ = graph.CreateEdgeSubstate(node, x));
                                                   node
                              | Region          => def node = graph.CreateNodeConcurrentState(name);
                                                   childs.Iter(x => _ = graph.CreateEdgeRegion(node, x));
                                                   node
                              | Final           => graph.CreateNodeFinalState();
                              | SubMachine      => def node = graph.CreateNodeSubMachineState(name);
                                                   childs.Iter(x => _ = graph.CreateEdgeSubstate(node, x));
                                                   node
                            }
              when (st_node is INamedNode as s) s.name = n;
              when (st_node is IState as s) s.id = st_id;
              def st_node = st_node :> LGSPNode;
              map[st] = st_node;
               // link it to sub state through edge for each substate
              
              
              foreach (p in st.pseudo_states)
              {
                def st_id = p.Id;
                def node = match (p.node)
                {
                   | PseudoStateModelNode.EntryPoint as e        => graph.CreateNodeEntryPoint(create_name(e.name)) |> set_name(_, e.name);// entry point needs transition pass
                   | ExitPoint as e                              => graph.CreateNodeExitPoint(create_name(e.name)) |> set_name(_, e.name)
                   | Initial                                     => graph.CreateNodeInitialState();
                   | History(type = HistoryType.None)            => graph.CreateNodeHistory();
                   | History(type = HistoryType.Deep)            => graph.CreateNodeDeepHistoryState();
                   | History(type = HistoryType.Shallow)         => graph.CreateNodeShallowHistoryState();
                   | Fork                                        => graph.CreateNodeFork();
                   | Join as j                                   => graph.CreateNodeJoin(create_name(j.name)) |> set_name(_, j.name)
                   | Junction(type = JunctionType.Junction) as j => graph.CreateNodeJunction(create_name(j.name)) |> set_name(_, j.name)
                   | Junction(type = JunctionType.Choice) as j   => graph.CreateNodeChoice(create_name(j.name)) |> set_name(_, j.name)
                   | Junction(type = JunctionType.Merge) as j    => graph.CreateNodeMerge(create_name(j.name)) |> set_name(_, j.name)
                   | Terminate                                   => graph.CreateNodeTerminate();
                }
                when (node is IPseudoState as p) p.id = st_id;
                def node = node :> LGSPNode;
                map[p] = node;
                _ = graph.CreateEdgeContains(st_node, node);
              }
              st_node
           | _ => null
        }
      }
      _ = Fsm.MapTree(create_nodes);
      
      def find_path(q)
      {
          def loop(t, res)
          {
            match (t)
            {
              | TargetType.Qualified(p, t) => loop(t, p :: res)
              | _                          => (res.Rev(), t)
            }
          }
        
        loop(q.target, q.parent :: [])
        
      }
      
      def find_named(x) {mutable res; if (graph_actions.FindNamed.Apply(proc_env, x, ref res)) Some(res) else None()}
      //graph_actions.FindQualifiedNode.Apply(proc_env, p, sub, ref res)
      foreach (node in Fsm.GetPreOrderEnumerable())
      {
        | StateNode.State(transitions = tr) as st => 
          foreach (tr in tr)
          {
            //def src = match (tr.from) 
            //{
            //  | TargetType.Named(n) => match (graph.GetNode(n))
            //                           {
            //                             | null => null
            //                             | node => node
            //                           }
            //  | PseudoState(p)       => null
            //  | Qualified as t       => match (graph.GetNode(t.parent))
            //                            {
            //                              | null => null
            //                              | p    => null // see all substates of p
            //                                         //def edges = p.GetExactOutgoing(EdgeType_Contains.typeVar);
            //                                        //edges.Find(x => (x.Target : de.unika.ipd.grGen.lgsp.LGSPNode).Name == "");
            //                            }
            //  | _                    => null                                                                                   null
            //} 
            def src = map[node];
            def target = match (tr.to)
                        {
                          | TargetType.Named(n) => mutable res;
                                                   if (graph_actions.FindNamed.Apply(proc_env, n, ref res)) // search for named node with name as target
                                                   {
                                                     res :> LGSPNode
                                                   } else
                                                   {
                                                     null // error
                                                   }
                          | Final               => mutable final;
                                                   if (graph_actions.FindFinalState.Apply(proc_env, src :> IState, ref final))// search final in parent state
                                                   {
                                                     final :> LGSPNode
                                                   } else
                                                   {
                                                     // not find final state
                                                     if (graph_actions.CreateFinalState.Apply(proc_env, src :> IState, ref final))
                                                     {
                                                       final :> LGSPNode
                                                     } else
                                                     {
                                                        null
                                                     }
                                                   }
                          | Self                => src // to self node
                          | PseudoState         => null //
                          | Qualified as q      => def (path, t) = find_path(q);                                                                                                      
                                                   def (head :: path) = path;
                                                   mutable parent;
                                                   def target = if (graph_actions.FindNamed.Apply(proc_env, head, ref parent))// search final in parent state
                                                   {
                                                     FindQualifed(parent, path, t)
                                                   } else
                                                   {
                                                      // not find final state
                                                     null
                                                   } // find in all substates of parent in parent.elem syntax
                                                   target      
                                                   
                           | _ => null                        
                        }
              when (src != null && target != null)
                _ = graph.CreateEdgeTransition(src, target);
          }
         | _ => ()
      }
      GRSExport.Export(graph, $"graph$(Name).grs");
      //def state = 
      //graph.CreateNodeState(Fsm.st);
    }
          
    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        PrintFsm(Fsm, $"$(Name)_statenode.txt");
        CreateGraph();
        CreateStateMap();
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_created.txt");
        CheckHistoryStates(); // check for errors in history
        CheckTransitions();
        CheckInitialTransitions();
        CreateTransitions();
        BreakIfError();
        TransformFsm();
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_transform.txt");
        ResolveConflicts();
        MergeTransitions();
        CheckUsedElements();
        CheckActivities();
        CreateHistoryPaths(); // create history paths
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
          def err = x.error;
          when (err != null) messager.AddError(err);
      }
    }

  }
}
