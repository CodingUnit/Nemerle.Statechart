// analyser.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using System.ComponentModel;
using CommonLib.Macros;
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.lgsp;
using de.unika.ipd.grGen.Action_StateMachine;
using de.unika.ipd.grGen.Model_StateMachine;
using Nemerle.Compiler;

namespace Nemerle.Statechart
{

  using StateTransition;
  using CommonLib.Macros.ListUtils;
  using CommonLib.Macros.LensUtils;
  using StateNode;

  [NotifyPropertyChange]
  partial class FsmAnalyser : INotifyPropertyChanged
  {
    graph : Graph = Graph();
    
    public concurrent_field_pattern : bool
    {
      [Memoize]
      get
      {
        def flags = FsmFlags;
        if (flags.ForceFieldConcurrentStates) true
        else
        {
          if (flags.ForceConcurrentStateCombination) false else false;
            //gen.ActiveStates.Count() > gen.ConcurrentCombinationsLimit || gen.transitions.Length > gen.ConcurrentTransitionsLimit
        }
      }
    }

    internal CreateEvent(evt : TransitionEvent) : StateEvent
    {
      | TransitionEvent.Normal(n, _)   => match (EventClasses.Find(x => if (x is EventClass.External(evt_name = n2) when n != null) n2 == n.ToUpperFirst() else false))
          {
            | Some(e) => StateEvent.Normal(evt.location, n, GetEventParms(evt), e)
            | _       => StateEvent.Normal(evt.location, n, GetEventParms(evt), EventClass.Internal())
          }
      | Completion as e                => StateEvent.Completion(e.location)
      | Timed(TimedExpr.Expr(ex)) as e => StateEvent.Timed(e.location, ex)
      | _                              => throw InvalidOperationException("invalid event")
    }

    internal GetEventParms(evt : TransitionEvent) : list[string * string]
    {
      def (name, parms) = if (evt is TransitionEvent.Normal as n) (n.name, n.parms) else (null, []);
      if (parms.IsEmpty()) [] else
        match (EventDecls.Find(x => x.name == name))
        {
          | Some(e) => def types = e.parms_type;
                    if (types.Length != parms.Length)
                    {
                      messager.AddError(FsmError.EventDeclarationNumberOfParamsNotEqual(e, evt));
                      []
                    } else
                    {
                      parms.Zip(types)
                    }
          | _        => messager.AddError(FsmError.EventDeclarationNotFound(evt));[]
        }
    }

    actions : list[FsmAction]
    {
      [Memoize]
      get
      {
        def tran = StateTransitions.SelectMany(_.action);
        def st = States.SelectMany(_.actions);
        def pseudo = PseudoStates.SelectMany(_.Actions);
        tran.Concat(st).Concat(pseudo).NToList()
      }
    }

    CheckActivities() : void 
    {
      def do_act = States.SelectMany(x => x.do_activity.Select(y => (x, y)));

      def other_actions = actions;
      foreach ((_, StateAction.Do(action = Actions(actions = FsmAction.Normal(name = n, parameters = []) :: [])) as act) in do_act)
      {
        match (other_actions.Find(x => if (x is FsmAction.Normal(name = n2)) n2 == n else false))
        {
          | Some(a) => messager.AddError(FsmError.DoActivityDuplicateAction(act, a))
          | _       => ()
        }
      }

      def sm = do_act.Filter((x : FsmState, _) => x.PartOfStateMachine.HasValue);
      def do_act = sm.GroupBy((x : FsmState, _) => x.PartOfStateMachine.Value.SubMachineType);

      foreach (group in do_act)
      {
        foreach (st in group.GroupBy((x, _) => x.name))
        {
          def (need, not) = st.NToList().Partition((_, x) => x.need_completion);
          def st = FsmState(st.Key, this, StateType.State());
          if (need.Length > not.Length)
          {
            need.Iter((_, x) => x.state = st.name);
          } else
          {
            not.Iter((_, x) => x.state = st.name)
          }
        }
      }
    }

    PrintTree[T](tree : T, childs : T -> IEnumerable[T], print_elem : T -> string, file : string) : void
    {

      def indent((text, depth), (acc, prev_depth))
      {
        def ind = string(' ', depth * 2); // create indentation from depth
        def text = $"$ind$text"; // indent text
        // if depth lower than previous append empty line for beauty
        def text = if (depth < prev_depth) text :: "" :: acc else text :: acc;
        (text, depth)
      }

      // get pre order iterator and preorde depth function of elements
      def res = TreeUtils.GetPreOrderEnumerable(tree, childs).Map(print_elem); // map iterator to list of lines of printed text
      def depth = TreeUtils.GetPreOrderDepth(tree, childs).NToList();
      def with_depth = res.Zip(depth); // zip print result and depth to list of tuple(text * depth)
      def (res, _) = with_depth.Fold(([], 0), indent); // indent
      System.IO.File.WriteAllLines(file, res.Rev().ToArray()) // write to file
    }

    PrintFsm(tree : StateNode, file : string) : void
    {
      def print(st)
      {
        | StateNode.State as st => def str = $"$(st.name):, Type: $(st.type)";
                                  def str = if (st.parent is Some(p)) str + $", Parent:$p" else str;
                                  def sub_states = st.sub_states;
                                  def names = sub_states.Select(_.name);
                                  def str = if (sub_states.IsEmpty()) str else $"$str, Sub:..$(names)";
                                  str
        | _                     => ""
      }

      def get_childs(t)
      {
        | StateNode.StateMachine as t => t.state :: []
        | StateNode.Sequence as t     => t.lst
        | StateNode.State as t        => t.sub_states
        | _                           => []
      }

      PrintTree(tree, get_childs, print, file)
    }

    PrintFsmState(tree : FsmState, file : string) : void
    {
      //def file = System.IO.File.CreateText();

      def print(st)
      {
        def str = $<#$(st.Name):, Type: $(st.type)#>;
        def str = if (st.sub_states.IsEmpty()) str else str + $", Sub:..$(st.sub_states)";
        str
      }

      PrintTree(tree, _.sub_states, print, file)
    }

    public CreateGraph() : void
    {
      graph.CreateGraph(Name, Fsm, Hashtable(StateMachinesInProj));
    }
    
    public ParseExprs(fsm : StateNode.StateMachine) : StateNode.StateMachine
    {
      
      
      //def map_act(x)
      //{
      //  | FsmAction.ParseString(s) as a => MainParser.ParseExpr(Env, s) |> FsmAction.Expr(a.pos, _)
      //  | x                             => x
      //}
      
      //def map_actions(x)
      //{
      //  Actions(x.pos, x.actions.Map(map_act))
      //}
      
      //def map_guard(x)
      //{
      //  | GuardNode.ParseString(s) as a => MainParser.ParseExpr(Env, s) |> GuardNode.Expr(a.pos, _)
      //  | x                             => x
      //}

      //def map_node(p)
      //{
      //  def act   = map_actions |> p.action.Map;
      //  def guard = p.guard     |> map_guard;
      //  def to    = p.to        |> map_target;
      //  p.ChangeGuardActionTo(guard, act, to)
      //}
    
      //and map_target(t)
      //{
      //  | TargetType.PseudoState(j) as t => j |> map_pseudo |> t.ChangeNode
      //  | x                              => x
      //}
      
      //and map_junc(j)
      //{
      //  j.nodes.Map(map_node) |> j.ChangeNodes
      //}
      
      //and map_pseudo(p : PseudoStateModelNode)
      //{
      //  | Junction as j                      => j          |> map_junc
      //  | EntryPoint as e                    => e.tran     |> map_tran      |> e.ChangeTran
      //  | ExitPoint as e                     => map_tran   |> e.tran.Map    |> e.ChangeTran
      //  | Initial as i                       => map_tran   |> i.tran.Map    |> i.ChangeTran
      //  | History as h                       => map_tran   |> h.default.Map |> h.ChangeDefault
      //  | Fork as f                          => map_target |> f.target.Map  |> f.ChangeTarget
      //  | Join as j                          => j.tran     |> map_tran      |> j.ChangeTran
      //  | x                                  => x
      //}
      
      //and map_tran(t)
      //{
      //  def guard = t.guard     |> map_guard;
      //  def to    = t.to        |> map_target;
      //  def act   = map_actions |> t.action.Map;
      //  t.ChangeGuardActionTo(guard, act, to)
      //}
      
      def parse(x)
      {
        def act = State.entry_lens >> Entry.action_lens >> Actions.actions_lens;// >>. FsmAction.ParseString.expr_lens;
        def act = act.ToBasePartial();
        //def act = act.DownCast.[FsmAction.ParseString]();
        def act = act.DownMap(x, x : FsmAction.ParseString => MainParser.ParseExpr(Env, x.expr) |> FsmAction.Expr(x.pos, _));
        //act.Map(x, x => x.actions.Map(x => if (Fsm)));
        null : StateNode
        //match (x)
        //{
        //   | State as st                  => def entry = st.entry.Map(x => map_actions(x.action) |> x.ChangeAction);
        //                                     def exit  = st.exit.Map(x => map_actions(x.action) |> x.ChangeAction);
        //                                     def doact = st.do_activity.Map(x => map_actions(x.action) |> x.ChangeAction);
        //                                     def tran  = st.transitions.Map(map_tran);
        //                                     st.pseudo_states.Map(x => x.node |> map_pseudo |> x.ChangeNode)
        //                                     |> st.ChangePseudoStates
        //                                     |> _.ChangeTransitions(tran)
        //                                     |> _.ChangeEntry(entry)
        //                                     |> _.ChangeExit(exit)
        //                                     |> _.ChangeDoActivity(doact)
        //                                     |> _.Rebuild(ch)
        //   | x                            => x                                             
        //}
      }
      
      fsm.Reduce(parse) :> StateNode.StateMachine
    }
    
    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        PrintFsm(Fsm, $"$(Name)_statenode.txt");
        CreateStateMap();
        graph.CreateGraph(Name, Fsm, LoadedMachines);
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_created.txt");
        CheckHistoryStates(); // check for errors in history
        CheckTransitions();
        CheckInitialTransitions();  
        CreateTransitions();
        BreakIfError();
        TransformFsm();
        when (FsmFlags.Logging) PrintFsmState(TopState, $"$(Name)_after_transform.txt");
        ResolveConflicts();
        MergeTransitions();
        CheckUsedElements();
        CheckActivities();
        CreateHistoryPaths(); // create history paths
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
          def err = x.error;
          when (err != null) messager.AddError(err);
      }
    }

  }
}
