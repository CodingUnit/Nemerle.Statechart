using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Statechart;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using ListUtils;

  [Record]
  public struct ErrorInfo
  {
    public this(err : list[FsmError]) { errors = err; warnings = []; }
    
    [NeedChange] public errors : list[FsmError];
    [NeedChange] public warnings : list[FsmWarning];
    
    public AddWarning(err : list[FsmWarning]) : ErrorInfo {ChangeWarnings(warnings.HeadAppend(err))}
    public AddError(err : list[FsmError]) : ErrorInfo {ChangeErrors(errors.HeadAppend(err))}
    public AddError(err : FsmError) : ErrorInfo {ChangeErrors(err :: errors)}
  }
  
  [Record]
  public partial class FsmAnalyser
  {

    GetErrorInfo() : ErrorInfo
    {
      ErrorInfo([], [])
    }
    
    [NeedChange(Warnings)]
    [NeedChange(Errors)]
    [NeedChange]
    public statemap : StateMap;

    public FsmFlags : MachineFlags
    {
      get
      {
        Fsm.flags
      }
    }
    
    //[Accessor] mutable states : list[FsmState];
    public Events : IEnumerable[string]
    {
      get
      {
        def evts = States.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.events));
        def evts = evts.Where(x => x.Name != null);
        def evts = evts.Select(x => x.Name);
        evts.Distinct()
      }
    }

    public mutable transitions : Map[string, StateTransition];

    //public events : IEnumerable[string] // event * for internal transition
    //{
    //  get
    //  {
    //    def int_evts =  
    //    def evts =  States |>< transitions |> Trigger;
        
    //    def int_tran_evt = int_evts.RemoveDuplicatesSort(_.CompareTo(_));
    //    //def tran_evt = evts.RemoveDuplicatesSort(_.CompareTo(_));
    //    //def int_tran_evt =  int_tran_evt.Exclude(tran_evt, _  ==  _);
    //    //int_tran_evt.Iter(x  => x.InternalOnly = true);
    //    //def evts =  (int_tran_evt + tran_evt) |> (Name, _);
    //    //Map(evts)
    //  }
    //}
    public trans_paths : IEnumerable[TransitionPaths]
    {
      get
      {
        States.Select(_.paths).Where(_ != null)
        //$[x.paths, x in States, x.paths != null]
      }
    }

    public transition_nodes : Map[string, PathNode]
    {
      get
      {
        def trans_nodes = transitions.Map((x, y) => (x, y.PathNode)); // nodes
        def trans_nodes = trans_nodes.RemoveDuplicatesSort(nodes_cmp);
        Map(trans_nodes)
      }
    }

    public int_trans_nodes : Map[string, PathNode]
    {
      get
      {
        def int_nodes = internal_transitions |> (_, _[2].PathNode);
        Map(int_nodes.RemoveDuplicatesSort(nodes_cmp))
      }
    }

    public all_pseudo : IEnumerable[PseudoStateNode]
    {
      get
      {
        States.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.pseudo_states))
      }
    }

    public actions : IEnumerable[string]
    {
      get
      {
        def acts =  trans_paths.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.Actions));
        def int_acts =  internal_transitions.Values().FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.Actions));
        def acts = acts.Concat(int_acts);
        acts.Distinct()
        //acts.RemoveDuplicatesSort((x, y) => x.CompareTo(y));
        //def do_activities = States.FilterValues(_.do_activity);
      //def err = do_activities.FoldLeft([], check_do);
      }
    }

    public action_node : PathNode
    {
      get
      {
        def tr = all_transitions |> PathNodeRecursive;
        PathNode.Sequence(tr)
      }
    }

    public not_used_history : list[StateHistory]
    {
      get
      {
        $[h, x in States, h in x.history.Value, !h.Used]
      }
    }

    public HistoryStates : IEnumerable[StateHistory]
    {
      get
      {
        States.FoldLeft([], (x, a) => a.HeadAppend(x.history.Value)).Where(_.Used)//$[h, x in States, h in x.history.Value, h.Used]//.Filter(x => x.history.HasValue) |>< history.Value
      }
    }

    public HistoryPaths : IEnumerable[HistoryPath]
    {
      get
      {
        def paths = States.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.HistoryPaths.Select(x => x[1])));
        def paths = paths.Exclude(x => x.IsDefault);
        paths.RemoveDuplicatesSort(_.Name)
      }
    }

    public work_transitions : Map[string, StateTransition]
    {
      get
      {
        def select = transitions.Filter((_, x)  => x.HistoryTarget == null);
        Map(select)
      }
    }

    public work_transition_nodes : Map[string, PathNode]
    {
      get
      {
        def work_nodes = work_transitions |> (_, _[2].PathNode);
        Map(work_nodes.RemoveDuplicatesSort(nodes_cmp))
      }
    }

    public initial_transition_nodes : Map[string, PathNode]
    {
      get
      {
        def init_nodes = initial_transitions |> (_, _[2].PathNode);
        Map(init_nodes.RemoveDuplicatesSort(nodes_cmp))
      }
    }

    states_initial_tran : IEnumerable[StateTransition]
    {
      get
      {
        States.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.initial))
        //States |>< Initial
      }
    }

    used_states_initial_tran : IEnumerable[StateTransition]
    {
      get
      {
        states_initial_tran.Where(_.Used)
      }
    }

    not_used_states_initial_tran : IEnumerable[StateTransition]
    {
      get
      {
        states_initial_tran.Exclude(_.Used)
      }
    }

    public mutable initial_transitions : Map[string, StateTransition];

    [Accessor] do_activities : list[StateAction.Do];

    public Regions : IEnumerable[FsmState.ConcurrentRegion]
    {
      get
      {
        def regs = States.FilterType();
        regs.Filter(_.LivedNested);
      }
    }

    public all_transitions_with_init : IEnumerable[StateTransition]
    {
      get
      {
        if (TopState != null) TopState.all_transitions_nested else Enumerable.Empty()
      }
    }
    
    public not_used_regions : IEnumerable[FsmState.ConcurrentRegion]
    {
      get
      {
        def regs = States.FilterType();
        regs.Exclude(_.LivedNested);
      }
    }

    public PseudoStates : IEnumerable[PseudoStateNode]
    {
      get
      {
        other_pseudo.Concat(junctions).Concat(choices).Concat(merges)
      }
    }

    public other_pseudo : IEnumerable[PseudoStateNode]
    {
      get
      {
        all_pseudo.Exclude(x => x is PseudoStateNode.Junction || x is PseudoStateNode.Merge || x is PseudoStateNode.Fork)
      }
    }

    public junctions : IEnumerable[PseudoStateNode.Junction]
    {
      get
      {
        def get_junction(t, a)
        {
          match (t)
          {
            | StateTransition where (To = TransitionTarget.PseudoState(Junction as j)) => j :: a
            | _ => a
          }
        }

        def junc = all_pseudo.FilterType();
        States.FoldLeft([], (x, a) => x.all_transitions_with_init.FoldLeft(a, get_junction)).Concat(junc)
      }
    }

    public choices : IEnumerable[PseudoStateNode.Junction]
    {
      get
      {
        def get_choice(t, a)
        {
          match (t)
          {
            | StateTransition where (To = TransitionTarget.PseudoState(Junction(type = JunctionType.Choice) as j)) => j :: a
            | _ => a
          }
        }

        def choice = all_pseudo.FilterType();
        States.FoldLeft([], (x, a) => x.all_transitions_with_init.FoldLeft(a, get_choice)).Concat(choice)
      }
    }

    public merges : IEnumerable[PseudoStateNode.Merge]
    {
      get
      {
        def get_merge(t, a)
        {
          match (t)
          {
            | StateTransition where (To = TransitionTarget.PseudoState(Merge as j)) => j :: a
            | _ => a
          }
        }

        def merge = all_pseudo.FilterType();
        States.FoldLeft([], (x, a) => x.all_transitions_with_init.FoldLeft(a, get_merge)).Concat(merge)
      }
    }

    public forks : list[PseudoStateNode.Fork]
    {
      get
      {
        def get_forks(t, a)
        {
          match (t)
          {
            | StateTransition where (To = TransitionTarget.PseudoState(Fork as j)) => j :: a
            | _ => a
          }
        }

        States.FoldLeft([], (x, a) => x.all_transitions_with_init.FoldLeft(a, get_forks))
      }
    }

    [Accessor] traverser : TransitionTraverser = TransitionTraverser();

    public special_transitions : IEnumerable[StateTransition]
    {
      get
      {
        def get_special_transitions(tran, a)
        {
          match (tran)
          {
            | StateTransition.Transition(Destination = TransitionDestination.Fork(sub_tran = tr)) => a.HeadAppend(tr)
            | StateTransition.Transition(To = PseudoState(PseudoStateNode.Join(transition = tr))) => tr :: a 
            | _                                                                                   => a
          }
        }

        def special = used_transitions.FoldLeft([], get_special_transitions);
        special.RemoveDuplicatesSort(StateTransition.Comparer)
      //special_transitions.Iter(x => x.UpdateReference(statemap));
      }
    }

    public concurrent_states : IEnumerable[FsmState]
    {
      get
      {
        States.Filter(_ is FsmState.ConcurrentSubRegion)
      }
    }

    public LivedStates : IEnumerable[FsmState]
    {
      get
      {
        States.Filter(_.Lived)
      }
    }

    public empty_states : list[FsmState]
    {
      get
      {
        def filter_used(st)
        {
          | FsmState.ConcurrentSubRegion
          | ConcurrentRegion
          | Final => false
          | _ => true
        }

        def empty =  States.Exclude(_.LivedNested); // determine lived states
        empty.Filter(filter_used)
      }
    }

    public LivedNestedStates : IEnumerable[FsmState]
    {
      get
      {
        States.Filter(_.LivedNested) // determine lived states
      }
    }

    [NeedChange(transitions, initial_transitions)]
    public mutable internal_transitions : Map[string, StateTransition];

    public States : IEnumerable[FsmState]
    {
      get
      {
        statemap.States
      }
    }

    public PathsFromOut : list[StateTransition]
    {
      get
      {
        States |> PathFromOut
      }
    }

    public Fsm : StateNode.StateMachine;

    public NextJunctionNum() : FsmAnalyser
    {
      //unnamed_junction_num++; 
      //unnamed_junction_num
      ChangeUnnamedJunctionNum(unnamed_junction_num + 1)
    }

    public NextChoiceNum() : FsmAnalyser
    {
      //unnamed_choice_num++; 
      //unnamed_choice_num
      ChangeUnnamedChoiceNum(unnamed_choice_num + 1)
    }


    CheckParseErrors() : void
    { 
      def check_err(err, res)
      {
        def r = match (err)
                 {
                   | StateNode.Error(StateNode.DoActivity as node) => ParseError.DuplicateActivity(node)
                   | StateNode.Error(node)                         => ParseError.UnknownElement(node)
                 }
        r :: res
      }

      def flags = FsmFlags.errors |> ParseError.UnknownMachineFlag(_);
      def err = Fsm.GetErrors().FoldLeft([], check_err).Rev();
      def errs = err + flags;
      AddErrors(errs)
    }

    public AddParseError(err : ParseError) : string
    {
      "Parse Error:" + match (err)
      {
        | DuplicateActivity(act) => $<#Duplicate do activity $act, state may have only one do activity node#>
        | UnknownElement(node)   => $<#Unknown parse node $node #>
        | UnknownMachineFlag(f)  => $<#Unknown state machine flag "$f" #>
      }
      //Errors ::= str;
    }

    public BreakIfError() : void
    {
      when (!Errors.IsEmpty()) throw FsmErrorException()
    }

    public GetError(err : FsmError) : string
    {
      | StateNotFound(s)                                    => $<#State "$s" Not Found#>
      | SubMachineStateNotFound(m, s)                       => $<#Sub machine "$m" does not contain referenced sub state "$s"#>
      | UnknownState(s, name, tran)                         => $<#Transition "$tran" in "$s" has unknown target state "$name"#>
      | DuplicateTransition(tran)                           => $<#Duplicate transitions "$tran"#>;
      | DuplicateHistory(st, hist)                          => $<#Duplicate history of type "$(hist.type)" in "$st"#>
      | RegionMustContainInitial(reg, tran)                 => $<#Transition "$tran" requires region "$reg" to contain initial transition in each of it sub regions#>
      | SubRegionsMustContainInitial(reg, tran)             => $<#Transition "$tran" requires sub regions "$reg" to contain initial transitions#>
      | UnknownTerminateTransition(tran)                    => $<#Unknown terminate transition target of "$tran", there is several terminate pseudo states, specify full name#>                  
      | ForkMustGoToRegion(f)                               => $<#Fork "$f" must go to concurrent sub regions#>
      | ForkMustGoToSeparateRegion(f)                       => $<#Fork "$f" must go to different concurrent sub regions#>
      | UnknownNode(tran)                                   => $<#Unknown pseudostate node used in target of "$tran" transition #>
      | JoinTransitionMustHaveSameTrigger(j, tran)          => $<#Transitions "$tran" to join "$j" must have same event trigger#>
      | JoinTransitionMustLeaveRegion(j, tran)              => $<#Transitions "$tran" to join "$j" must leave sub state of same orthogonal region#>
      | TransitionCrossOrthogonalBoundaryOfSameRegion(tran) => $<#Transition "$tran" is cross orthogonal boundary of same region, this is not allowed#>
      | DefaultTransitionMustGoToState(tran, hist)          => $<#Default history transition "$tran" of history "$hist" must go to state#>
      | JunctionElseMustBeLast(j)                           => $<#Else node in junction "$(j.state).$j" must be the last alternative node#>
      | JunctionActionMaybeLast(j, a)                       => $<#Junction action "$a" in "$(j.state).$j" maybe single in node or last#>
      | JunctionElseMustAfterAnotherGuard(j)                => $<#Junction else node in "$(j.state).$j" must have preceded another GuardNode#>
      | EmptyJunction(j)                                    => $<#There is a empty node in junction "$(j.state).$j"#>
      | ChoiceElseMustBeLast(j)                             => $<#Else node in choice "$(j.state).$j" must be the last alternative node#>
      | ChoiceActionMaybeLast(j, a)                         => $<#Choice action "$a" in "$(j.state).$j" maybe single in node or last#>
      | ChoiceElseMustAfterAnotherGuard(j)                  => $<#Choice else node in "$(j.state).$j" must have preceded another GuardNode#>
      | EmptyChoice(j)                                      => $<#There is a empty node in choice "$(j.state).$j"#>
      | SeveralState(st)                                    => $<#There is several duplicate states of name $st #>
      | Sequence(e)                                         => $<#..$(e;"\n";GetError)#>
    }

    public GetWarning(err : FsmWarning) : string
    {
      match (err)
      {
        | HistoryNotUsed(hist = StateHistory(state = st, type = t))  => $<#"$t History in "$st" is not used in fsm life history#>
        | StateNotUsed(state = st)                                   => $<#State "$st" is not used in fsm life history#>
        | TransitionNotUsed(tran)                                    => $<#Transition "$tran" is not used in fsm life history#>
        | RegionNotUsed(reg)                                         => $<#Concurrent region "$reg" is not used in fsm life history#>
        | NoConcurrentActivity(act)                                  => $<#There is no other activities in do activity node $act. Flag is no meaning, concurrent activity means that several activities may run concurently in do activity region of state.#>
        | TransitionOverriden(tran,by)                               => $<#Transition $(tran.GuardedName) is overriden by $(by.GuardedName), due to execute priority rules, because these transition is unguarded#>
        | x                                                          => $"Unknown Warning $x"
      }
    }

    public AddWarnings(err : list[FsmWarning]) : void
    {
      def err = GetWarnings(err);
      Warnings = Warnings.HeadAppend(err);
    }

    public AddErrors(err : list[FsmError]) : void
    {
      def err = GetErrors(err);
      AddErrors(err)
    }

    public AddWarnings(err : list[string]) : void
    {
      Warnings = Warnings.HeadAppend(err);
    }
    
    public AddErrors(err : string) : void
    {
      Errors = err :: Errors
    }
    
    public AddErrors(err : list[string]) : void
    {
      Errors = Errors.HeadAppend(err);
    }
    
    public AddErrors(err : FsmError) : void
    {
      AddErrors(GetError(err))
    }

    public AddErrors(err : list[ParseError]) : void
    {
      AddErrors(GetErrors(err))
    }

    public GetErrors(err : list[FsmError]) : list[string]
    {
      err.Map(GetError)
    }

    public GetErrors(err : IEnumerable[ParseError]) : list[string]
    {
      err.Map(AddParseError)
    }

    public GetWarnings(err : IEnumerable[FsmWarning]) : list[string]
    {
      err.Map(GetWarning)
    }

    public AddErrors(err : ErrorInfo) : void
    {
      Errors = GetErrors(err.errors);
      Warnings = GetWarnings(err.warnings);
    }
    
    public this(fsm : StateNode.StateMachine)
    {
      this.Fsm = fsm;
      statemap = StateMap(this);
    }

    public mutable Errors   : list[string] = [];
    public mutable Warnings : list[string] = [];

    FinalizeAnalyse() : void
    {
      def id = StateId(this);
      def top = id.CreateMasks();
      Errors = Errors.Rev();
      Warnings = Warnings.Rev();
      UpdateStateMap(top);
    }

    public Analyse() : void
    {
      try
      {
        CheckParseErrors();
        InitStateMap();
        CheckTransitions();
        CreateSubMachines();
        CheckInitialTransitions();
        CreateTransitions();
        BreakIfError();
        CreateTransitionPaths();
        CreateConcurrentRegion();
        UpdateInitial();
        CreateActions();
        FinalizeAnalyse();
      }
      catch 
      {
        | x is FsmErrorException => 
           def err = x.error;
           when (err != null) AddErrors(err);
      }
    }

    //public TransitionEvents : list[StateEvent]
    //{
    //  get
    //  {
    //    events_map.Values()
    //  }
    //}

    public Error : bool
    {
      get
      {
         !Errors.IsEmpty()
      }
    }

    public guards : IEnumerable[GuardNode]
    {
      get
      {
        def tran = transitions.Values().Concat(initial_transitions.Values());// |>< Guards;
        def guards = tran.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.Guards));
        //def init_guards =  |>< Guards;
        //def guards = guards + init_guards;
        guards.RemoveDuplicatesSort(_.Name)
      }
    }

    public history_transitions : Map[string, StateTransition]
    {
      get
      {
        transitions.Filter((_, x)  => x.HistoryTarget != null);
      }
    }

    public history_default_transitions : IEnumerable[StateTransition]
    {
      get
      {
        HistoryStates.FilterValues(_.default).Where(_.Used)//x.ActualTo != null)
      }
    }

    public used_transitions : IEnumerable[StateTransition]
    {
      get
      {
        states_transitions.Where(_.UsedInGenerate)
      }
    }

    public states_transitions : IEnumerable[StateTransition]
    {
      get
      {
        States.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.all_transitions))
      }
    }

    public not_used_transitions : IEnumerable[StateTransition]
    {
      get
      {
        def not_used = states_transitions.Exclude(_.UsedInGenerate);
        def not_used = not_used.Where(x => x.From.Lived);
        def not_used = not_used.Exclude(_.NotWork);
        not_used.Exclude(_.Used);
      }
    }

    public all_transitions : IEnumerable[StateTransition]
    {
      get
      {
          work_transitions.Values().Concat(initial_transitions.Values()).
          Concat(history_transitions.Values()).
          Concat(history_default_transitions).
          Concat(special_transitions).
          Concat(PathsFromOut)
      }
    }

    public ActionNodes : IEnumerable[PathNode]
    {
      get
      {
        action_node.Unsequenced.RemoveDuplicatesSort(PathNode.Compare)
      }
    }

    //public static StringComparator : string * string -> int = string.Compare(_, _, StringComparison.CurrentCulture);
    //public static StrEq : string * string -> bool = (x, y) => StringComparator(x, y) == 0;

    public TopState : FsmState
    {
      get
      {
        statemap.Top
      }
    }

  }
}
