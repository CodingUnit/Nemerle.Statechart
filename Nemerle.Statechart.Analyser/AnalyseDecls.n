using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Statechart;
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Collections;

using NC = Nemerle.Collections;

namespace Nemerle.Statechart
{
  using ListUtils;

  //[Record]
  public partial class FsmAnalyser
  {

 //   public clones : Hashtable[FsmState, list[FsmState]] = Nemerle.Collections.Hashtable();
    
    public statemap : StateMap;

    public FsmFlags : MachineFlags {get;set;}
    
    public EventCtx : EventContext = EventContext();
    
    //[Accessor] mutable states : list[FsmState];
    public Events : IEnumerable[string]
    {
      get
      {
        def evts = States.SelectMany(x => x.Events);
        def evts = evts.Where(x => x.Name != null);
        def evts = evts.Select(_.Name);
        evts.Distinct()
      }
    }

    public States : array[FsmState]
    {
      get
      {
        statemap.States
      }
    }

    public StateTransitions : array[StateTransition]
    {
      get
      {
        statemap.Transitions
      }
    }
    
    //public mutable transitions : Map[string, StateTransition];

    //public trans_paths : IEnumerable[TransitionPaths]
    //{
    //  get
    //  {
    //    States.Select(_.paths).Where(_ != null)
    //    //$[x.paths, x in States, x.paths != null]
    //  }
    //}

    public mutable HistoryPaths : Hashtable[FsmState, list[HistoryPath]]; // paths from outer history

    public Complete : bool
    {
      get
      {
        Errors.IsEmpty() && !Events.IsEmpty()
      }
    }
    
    //public actions : IEnumerable[FsmAction]
    //{
    //  get
    //  {
    //    trans_paths.SelectMany(_.Actions);
    //  }
    //}

    [Memoized]
    public actions : list[FsmAction]
    {
      get
      {
        def st_act = States.SelectMany(_.actions);
        //def tr_act = StateTransitions.SelectMany(_.action);
        //st_act.Concat(tr_act).
        def act = all_used_transitions.SelectMany(_.action).Concat(st_act);
        def act = act.Exclude(_ is FsmAction.Normal(name = null));
        act.RemoveDuplicatesSort(_.ToString())
      }
    }
    
    [Memoized]
    public all_actions : list[PathNode]
    {
      get
      {
        def tran_act = tran_paths.SelectMany(_.Path);
        tran_act.RemoveDuplicatesSort(_.ToString())
      }
    }

    [Memoized]
    public tran_paths : list[PathSequence]
    {
      get
      {
        all_used_transitions.Map(x => x.Path.Path)
      }
    }
    
    [Memoized]
    public tran_path_nodes : list[TranPath]
    {
      get
      {
        def ex = tran_paths.SelectMany(x => x.exit_tran_path);
        def en = tran_paths.SelectMany(x => x.entry_tran_path);
        def ex = ex.RemoveDuplicatesSort(x => x.state.ToString());
        def en = en.RemoveDuplicatesSort(x => x.state.ToString());
        ex.Concat(en).NToList()
      }
    }
    
    
    //public action_node_all : IEnumerable[PathNode]
    //{
    //  get
    //  {
    //    def get_inline(p)
    //    {
    //      | PathNode.Entry(inline = inl)
    //      | Exit(inline = inl)           => inl.Map((x, _) => x)
    //      | _                            => Enumerable.Empty()
    //    }


    //    def inlined = action_node.SelectMany(get_inline);
    //    action_node.Concat(inlined)
    //  }
    //}

    public not_used_history : IEnumerable[PseudoStateNode]
    {
      get
      {
        HistoryStates.Where(x => !Used[x])
        //$[h, x in States, h in x.history.Value, !h.Used]
      }
    }

    public HistoryStates : IEnumerable[PseudoStateNode.History]
    {
      get
      {
        PseudoStates.FilterType()//$[h, x in States, h in x.history.Value, h.Used]//.Filter(x => x.history.HasValue) |>< history.Value
      }
    }

    public PseudoStates : array[PseudoStateNode]
    {
      get
      {
        statemap.PseudoStates
      }
    }
    
    public Used : NC.Hashtable[object, bool] = NC.Hashtable();

    InitialTran : IEnumerable[StateTransition]
    {
      get
      {
        States.FilterValues(x => x.initial_tran)
      }
    }
    
    //used_states_initial_tran : IEnumerable[StateTransition]
    //{
    //  get
    //  {
    //    InitialTran.Where(x => Used[x])
    //  }
    //}

    not_used_states_initial_tran : IEnumerable[StateTransition]
    {
      get
      {
        InitialTran.Where(x => !Used[x]);
      }
    }

    public DoActivities : IEnumerable[StateAction.Do]
    {
      get
      {
        States.SelectMany(x => x.do_activity)
      }
    }

    public Regions : IEnumerable[FsmState]
    {
      get
      {
        def regs = States.Where(x => x.type is StateType.Region);
        regs.Where(x => x.LivedNested);
      }
    }

    public not_used_regions : IEnumerable[FsmState]
    {
      get
      {
        def regs = States.Where(x => x.type is StateType.Region);
        regs.Where(x => !x.LivedNested)
      }
    }

    public forks : IEnumerable[PseudoStateNode.Fork]
    {
      get
      {
        PseudoStates.FilterType()
      }
    }

    public joins : IEnumerable[PseudoStateNode.Join]
    {
      get
      {
        PseudoStates.FilterType()
      }
    }
    
    [Accessor] mutable traverser : TransitionTraverser;

    public special_transitions : IEnumerable[StateTransition]
    {
      get
      {
        def fork_tran = forks.SelectMany(x => x.fork_tran);
        def join_tran = joins.SelectMany(x => x.joined_tran);
        fork_tran + join_tran
      }
    }

    public concurrent_states : IEnumerable[FsmState]
    {
      get
      {
        States.Where(x => x.type is StateType.Region)
      }
    }

    public empty_states : IEnumerable[FsmState]
    {
      get
      {
        def filter_used(st)
        {
          | StateType.SubRegion
          | Region
          | Final => false
          | _     => true
        }

        def empty =  States.Exclude(x => x.LivedNested); // determine lived states
        empty.Where(x => filter_used(x.type))
      }
    }

    public LivedNestedStates : IEnumerable[FsmState]
    {
      get
      {
        States.Where(x => x.LivedNested) // determine lived states
      }
    }  

    public Fsm : StateNode.StateMachine;

    public NextJunctionNum() : int
    {
      unnamed_junction_num++;
      unnamed_junction_num
    }

    public NextChoiceNum() : int
    {
      unnamed_choice_num++; 
      unnamed_choice_num
    }


    CheckParseErrors() : void
    { 
      def check_err(err)
      {
        match (err)
        {
          | StateNode.Error(StateNode.DoActivity as node) => ParseError.DuplicateActivity(node)
          | StateNode.Error(node)                         => ParseError.UnknownElement(node)
        }
      }

      def flags = Fsm.flags.errors.Select(x => ParseError.UnknownMachineFlag(x));// |> ParseError.UnknownMachineFlag(_);
      def err = Fsm.GetErrors().Select(check_err);
      def errs = err.Concat(flags);
      AddErrors(errs)
    }

    public AddParseError(err : ParseError) : string
    {
      "Parse Error:" + match (err)
      {
        | DuplicateActivity(act) => $<#Duplicate do activity $act, state may have only one do activity node#>
        | UnknownElement(node)   => $<#Unknown parse node $node #>
        | UnknownMachineFlag(f)  => $<#Unknown state machine flag "$f" #>
      }
      //Errors ::= str;
    }

    public BreakIfError() : void
    {
      when (!Errors.IsEmpty()) throw FsmErrorException()
    }

    public GetError(err : FsmError) : string
    {
      | StateNotFound(s)                                         => $<#State "$s" Not Found#>
      //| SubMachineStateNotFound(m, s)                          => $<#Sub machine "$m" does not contain referenced sub state "$s"#>
      | UnknownTarget(tran, t)                                   => $<#Transition "$tran" has unknown target "$t"#>
      | DuplicateTransition(tran)                                => $<#Duplicate transitions "$tran"#>;
      | DuplicateHistory(st, PseudoStateNode.History(type = t))  => $<#Duplicate history of type "$(t)" in "$st"#>
      | RegionMustContainInitial(reg, tran)                      => $<#Transition "$tran" requires region "$reg" to contain initial transition in each of it sub regions#>
      | SubRegionsMustContainInitial(reg, tran)                  => $<#Transition "$tran" requires sub regions "$reg" to contain initial transitions#>
      | UnknownTerminateTransition(tran)                         => $<#Unknown terminate transition target of "$tran", there is several terminate pseudo states, specify full name#>                  
      | ForkMustGoToRegion(f)                                    => $<#Fork "$f" must go to concurrent sub regions#>
      | ForkMustGoToSeparateRegion(f)                            => $<#Fork "$f" must go to different concurrent sub regions of one region#>
      | UnknownNode(tran, n)                                     => $<#Unknown node "$n" used in target of "$tran" transition #>
      | JoinTransitionMustHaveSameTrigger(j, tran)               => $<#Transitions "$tran" to join "$j" must have same event trigger#>
      | JoinTransitionMustLeaveRegion(j, tran)                   => $<#Transitions "$tran" to join "$j" must leave sub state of same orthogonal region#>
      | TransitionCrossOrthogonalBoundaryOfSameRegion(tran)      => $<#Transition "$tran" is cross orthogonal boundary of same region, this is not allowed#>
      | DefaultTransitionMustGoToState(tran, hist)               => $<#Default history transition "$tran" of history "$hist" must go to state#>
      | JunctionElseMustBeLast(j)                                => $<#Else node in junction "$(j.state).$j" must be the last alternative node#>
      | JunctionActionMaybeLast(j, a)                            => $<#Junction action "$a" in "$(j.state).$j" maybe single in node or last#>
      | JunctionElseMustAfterAnotherGuard(j)                     => $<#Junction else node in "$(j.state).$j" must have preceded another GuardNode#>
      | EmptyJunction(j)                                         => $<#There is a empty node in junction "$(j.state).$j"#>
      | ChoiceElseMustBeLast(j)                                  => $<#Else node in choice "$(j.state).$j" must be the last alternative node#>
      | ChoiceActionMaybeLast(j, a)                              => $<#Choice action "$a" in "$(j.state).$j" maybe single in node or last#>
      | ChoiceElseMustAfterAnotherGuard(j)                       => $<#Choice else node in "$(j.state).$j" must have preceded another GuardNode#>
      | EmptyChoice(j)                                           => $<#There is a empty node in choice "$(j.state).$j"#>
      | SeveralState(st)                                         => $<#There is several duplicate states of name $st #>
      | ParentStateNotFound(s, p)                                => $<#Parent state "$p" for state "$s" not found#>
      | InitialPseudoStateAtMostOne(i)                           => $<#There can be only one initial pseudo state in region, error defined in "$i" #>
      | InitialTransitionMustGoToState(i)                        => $<#Transition from initial pseudo state "$i", must go to default state of a composite state, not other targets#>
      | InitialTransitionCannotHaveGuards(i)                     => $<#Transition from initial pseudo state cannon have guards: "$i"#>
      | StateHasNotHistory(s)                                    => $<#State "$s" does'nt have history #>
      //| ThereMustBeOnlyOneInitial(s, t)                             => $<#In state "$s" may be only one unguarded initial transition, these transitions erroneus: "..$t"#>
      //| Sequence(e)                                            => $<#..$(e;"\n";GetError)#>
      //| n                                                        => throw InvalidOperationException($"unnkown error $n")
    }

    public GetWarning(err : FsmWarning) : string
    {
      match (err)
      {
        | HistoryNotUsed(hist = PseudoStateNode.History(state = st, type = t))  => $<#"$t History in "$st" is not used in fsm life history#>
        | StateNotUsed(state = st)                                                                  => $<#State "$st" is not used in fsm life history#>
        | TransitionNotUsed(tran)                                                                   => $<#Transition "$tran" is not used in fsm life history#>
        | RegionNotUsed(reg)                                                                        => $<#Concurrent region "$reg" is not used in fsm life history#>
        | NoConcurrentActivity(act)                                                                 => $<#There is no other activities in do activity node $act. Flag is no meaning, concurrent activity means that several activities may run concurently in do activity region of state.#>
        | TransitionOverriden(tran,by)                                                              => $<#Transition $(tran.GuardedName) is overriden by $(by.GuardedName), due to execute priority rules, because this transition is always enabled#>
        | x                                                                                         => $"Unknown Warning $x"
      }
    }

    public AddWarning(err : FsmWarning) : void
    {
      def err = GetWarning(err);
      Warnings.Add(err);
    }

    public AddWarnings(err : IEnumerable[FsmWarning]) : void
    {
      def err = GetWarnings(err);
      Warnings.AddRange(err);
    }

    public AddErrors(err : IEnumerable[FsmError]) : void
    {
      def err = GetErrors(err);
      AddErrors(err)
    }

    public AddWarnings(err : IEnumerable[string]) : void
    {
      Warnings.AddRange(err);
    }

    public AddErrors(err : string) : void
    {
      Errors.Add(err)
    }

    public AddErrors(err : IEnumerable[string]) : void
    {
      Errors.AddRange(err)
    }

    public AddError(err : FsmError) : void
    {
      AddErrors(GetError(err))
    }

    public AddErrors(err : IEnumerable[ParseError]) : void
    {
      AddErrors(GetErrors(err))
    }

    public GetErrors(err : IEnumerable[FsmError]) : IEnumerable[string]
    {
      err.Select(GetError)
    }

    public GetErrors(err : IEnumerable[ParseError]) : IEnumerable[string]
    {
      err.Select(AddParseError)
    }

    public GetWarnings(err : IEnumerable[FsmWarning]) : IEnumerable[string]
    {
      err.Select(GetWarning)
    }

    public StatesId : StateId;

    public this(fsm : StateNode.StateMachine, name : string)
    {
      this.Fsm = fsm;
      Name = fsm.name ?? name;
      statemap  = StateMap(this);
      StatesId = StateId(this);
    }

    public Name     : string;
    public Errors   : List[string] = List();
    public Warnings : List[string] = List();

    FinalizeAnalyse() : void
    {
      StatesId.CreateMasks();
      def longest = States.Max(x => x.Name.Length);
      def len = States.Count();
      //def num_len = len.ToString().Length;
      
      
      def create_state_report(st)
      {
        match (st)
        {
          | FsmState(Id = null) with id = IdType(BitArray(len))
          | FsmState(Id = id) => 
        
              def id_hex = id.Result.Fold("", (x, a) => x.ToString("X8") + a);
              def id_val = id.val.OfType.[bool]().MapListRev(x => if (x) '1' else '0');
              def id_val = string(id_val.ToArray());
              string.Format($<#{0, $longest}: Id = $(id_val) (0x$id_hex) #>, st.Name)
        }
      }
      
      
      when (FsmFlags.Debug) 
      {
        def info = States.Map(create_state_report);
        File.WriteAllLines($"$(Name)statemap.log", info);
      }
    }

    public Error : bool
    {
      get
      {
         !Errors.IsEmpty()
      }
    }

    public guards : IEnumerable[GuardNode]
    {
      get
      {
        def guards = StateTransitions.SelectMany(x => x.Guards);// transitions.Values().Concat(initial_transitions.Values());// |>< Guards;
        guards.RemoveDuplicatesSort(_.Name)
      }
    }

    public history_default_transitions : IEnumerable[StateTransition]
    {
      get
      {
        HistoryStates.FilterValues(x => x.default).Where(x => Used[x])//x.ActualTo != null)
      }
    }

    public used_transitions : IEnumerable[StateTransition]
    {
      get
      {
        StateTransitions.Where(x => Used[x])
      }
    }

    //public Clones : NC.Hashtable[FsmState, list[FsmState]] = NC.Hashtable();
    public LivedStates : IEnumerable[FsmState]
    {
      get
      {
        States.Where(_.Lived)
      }
    }
    

    public not_used_transitions : IEnumerable[StateTransition]
    {
      get
      {
        def not_used = StateTransitions.Where(x => !Used[x]);
        not_used.Where(x => x.From.Lived);
      }
    }

    [Memoized]
    public all_transitions_with_spec : IEnumerable[StateTransition]
    {
      get
      {
        StateTransitions + history_default_transitions + special_transitions + InitialTran;
      }
    }
    
    [Memoized]
    public all_used_transitions : IEnumerable[StateTransition]
    {
      get
      {
        def trans = all_transitions_with_spec;
        trans.Where(_.Used)
      }
    }

    //public ActionNodes : IEnumerable[PathNode]
    //{
    //  get
    //  {
    //    action_node//.RemoveDuplicatesSort(PathNode.Compare)
    //  }
    //}

    //public static StringComparator : string * string -> int = string.Compare(_, _, StringComparison.CurrentCulture);
    //public static StrEq : string * string -> bool = (x, y) => StringComparator(x, y) == 0;

    public TopState : FsmState
    {
      get
      {
        statemap.StateTree
      }
    }

  }
}
