using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using StateTransition;
  using ListUtils;
  using DecisionNode;  
  using GuardNode;
  using Opt;
/// <summary>
/// Description of AnalyseTransitions.
/// </summary>
  public partial class FsmAnalyser
  {

    CheckInitialTransitions() : void
    {
      def check_auto_initial(st)
      {
        match (st.Data)
        {
          | FsmState.Final 
          | ConcurrentRegion       => ()
          | _ when st.InitialTransitions().IsEmpty()  =>
          
              match (st.SubStates().NToList())
              {
                | head :: _ => if (head.Data is FsmState.Final) () else st.DefineInitial(head);
                | _         => ()
              }

          | _                      => ()
        }
      }

      //States.Iter(x => check_duplicates(x.InitialTransitions().Select(_.Value)));  // check duplicates
      when (FsmFlags.AutoInitial) States.Iter(check_auto_initial);

      def top = TopState;
      when (top.InitialTransitions().IsEmpty()) // if not have initial transition in top state
        when (top.Transitions().IsEmpty()) // if not have other transitions
          check_auto_initial(top) // initial is first substate

      //def create_path_from_out(st, _)
      //{
      //  def path = StateTransition.Initial(TopState, st).Create();
      //  def path = path.TraversePath();
      //  st.ChangePathFromOut(path)
      //}

      //UpdateStateMap(top);
      //def top = top.ReduceSingle(create_path_from_out);
      //UpdateStateMap(top);
    }

    is_crossed_orthogonal(tr : NodeValue[FsmState, StateTransition], st : GeneralTree[FsmState]) : bool
    {
      match (tr.Value, st)
      {
        | (StateTransition(To = TransitionTarget.State(state = n)), _) when n.PartOfRegion() == st.PartOfRegion() : object => n.PartOfSubRegion() != st.PartOfSubRegion() : object
        | _                                                                                                                => false
      }
    }

    CreateAndCheckSuperStateTransitions() : void
    {
      def resolve_conflict(trans)
      {
        def conflict = trans.OrderByDescending(x => x.Parent.HierarchyPos()).NToList();
        match (conflict)
        {
          // if first transition is guarded then dynamic choice with left in hierarchy
          | NodeValue(Value = StateTransition(Guard = Some)) as head :: tail  => 
              def (path, _) = tail.SplitFind(x => x.Value.Guard.IsNone); // get all include last without GuardNode
              //def st = st.Update(x => x.DeleteTransitions(end)); // delete from usual transitions in state
              head.Parent.DefineTransitions(path);
              //st.UpdateTransitions(tr :: path)

          // if without guard it overrides all in 
          | _ => ()
        }

      }

      def check_duplicate_tran(tr)
      {
        def check_begin_and_ends(tr : list[_])
        {
          def equal(lst, lst2)
          {
            lst.Equals(lst2, _ == _);
          }

          def acts = tr.Select(x => x.Value.ActionList);
          def res = acts.ElementsEqual(equal);
          when (res) AddError(FsmError.DuplicateTransition(tr));
        }

        def dups = tr.NToList().Duplicates(FsmStateFuncs.Compare(StateTransition.GuardComparer)); // find duplicates with same guards and same triggers
        if (!dups.IsEmpty())
        {
          AddError(FsmError.DuplicateTransition(dups))
        } else
        {
          def begin_and_end_eq = tr.NToList().DuplicatesGroup((x, y) => x.Value.To.CompareTo(y.Value.To));
          begin_and_end_eq.Iter(check_begin_and_ends)
        }
      }

      def check_override(tr)
      {
        // без гуарда переопределяет на том же уровне с гуардами и без гуардов, если такое возникает то необходимо сигнализировать
        match (tr.Find(x => x.Value.Guard.IsNone))
        {
          | Some(t) => 
                  def tr = tr.Except(t);
                  def warn = tr.Map(x => FsmWarning.TransitionOverriden(x.Value, t.Value));
                  AddWarnings(warn)

          | _ => ()
        }
      }

      def check_trans(st, get_tran, func)
      {

        def parent_trans = get_tran(st); // get the super states transitions and concatinate with current
        //def parent_trans = parent_trans.Select(x => (x.Value.FriendlyTriggerName, x)); // get with trigger names
        def by_trigger   = parent_trans.GroupBy(x => x.Value.FriendlyTriggerName);
        def conflict     = by_trigger.Where(x => x.IsMoreThanOne());

        //def conflict     = conflict.OrderBy(x => x.);
        conflict.Iter(func);

      }

      def check_init_ext_trans(func)
      {
        States.Iter(x => check_trans(x, x => x.ExternalTransitions(), func));
        States.Iter(x => check_trans(x, x => x.InitialTransitions(), func));
      }

      check_init_ext_trans(check_duplicate_tran);
      check_init_ext_trans(check_override);

      def (simple, other) = States.PartitionLazy(_.IsSimpleState());
      simple.Iter(x => check_trans(x, x => x.ExternalTransitions() + x.SuperStates().SelectMany(x => x.ExternalTransitions()), resolve_conflict));
      other.Iter(_.DeleteTransitions());
    }

  //  CheckCrossTransitions() : void
  //  {
  //    def group(tr, st : GeneralTree[FsmState])
  //    {
  //      match (tr)
  //      {
  //        | _ :: []  => st // if not have group exit
  //        | StateTransition(Guard = Some) as head :: tail  => 
  //            def (path, end) = tail.SplitFind(x => x.Guard.IsNone); // get all include last without GuardNode
  //            head.ChangeParentCrossed(path).Change();
  //            def path = path.Map(_.ChangeCrossFor(true));
  //            def st = st.Update(x => x.DeleteTransitions(end)); // delete from usual transitions in state

  //            st.UpdateTransitions(tr :: path)

  //        | _ :: tail  => st.DeleteTransitions(tail)

  //        | _  => st
  //      }
  //    }

  //    def check_cross_tran(tr, st)
  //    {
  //      single_func
  //      {
  //        tr.NToList().Sort((x, y) => StateTransition.GuardComparer(y, x));
  //        __.Sort((x, y) => y.From.Depth - x.From.Depth); // sort on hierarchy position
  //        group(__, st); // group transitions
  //      }
  //    }

  //    def check_cross(st)
  //    {
  //      def tran = st.AllTransitions();
  //      def group = FsmState.create_transition_group(tran).Where((_, x) => x.IsMoreThanOne()).Values();
  //      //group.FoldLeft(st, check_cross_tran)
  //    }


  //    States.Iter(check_cross); // check from the top state
  //  }

  //  check_duplicates(tr : IEnumerable[StateTransition]) : void
  //  {


  //    def group = FsmState.create_transition_group(tr).Values();
  //    def group = group.Where(_.IsMoreThanOne());
  //    group.Iter(check_duplicate_tran);
  //    group.Iter(check_override);
  //  }

  ///// <summary>
  ///// Check duplicates
  ///// </summary>
  //  CheckDuplicates() : void
  //  {
  //    States.Iter(x => check_duplicates(x.this_transitions));
  //    States.Iter(x => check_duplicates(x.initial));
  //  }




    create_join_transitions() : void
    {

      def check_join(j, tr : IEnumerable[_])
      {
        match (j.Value)
        {
          | PseudoStateNode.Join(target = t) as jn =>

              if (tr.ElementsEqual((x, y) => x.Value.Trigger == y.Value.Trigger))
              {
                if (tr.All(x => x.Parent.PartOfSubRegion().HasValue) &&
                    tr.ElementsEqual((x, y) => x.Parent.PartOfRegion().Value == y.Parent.PartOfRegion().Value : object))
                {
                  def tran = StateTransition.Transition(j.Parent, t, tr.First().Value.Trigger);
                  def reg = tr.First().Parent.PartOfRegion().Value.Data;
                  def tr = tr.OrderBy(x => x.Parent.PartOfSubRegion().Value.Index());
                  //j.joined_tran = tr;
                  //j.region = reg;

                  //j.transition = tran;
                  /// !!! mutable
                  //tr.Iter(x => x.ToPseudo.SetValue(x => (x :> PseudoStateNode.Join).ChangeRegionJoinedTranTransition(reg, tr, tran)));
                  jn.region.Data = reg;
                  def jn = jn.ChangeJoinedTran(tr);
                  jn.transition.Value = tran
                } else 
                {
                  AddError(FsmError.JoinTransitionMustLeaveRegion(j, tr.NToList()));
                }
              } else 
              {
                AddError(FsmError.JoinTransitionMustHaveSameTrigger(j, tr.NToList()))
              }

          | _ => ()
        }
      }

      def get_join(t, lst)
      {
        match (t.Value)
        {
          | StateTransition(To = TransitionTarget.PseudoState(NodeValue(Value = PseudoStateNode.Join) as j)) => (j, t) :: lst
          | _                                                                                                => lst
        }
      }

      def join_tran = AllTransitions.FoldLeft([], get_join);
      def jtrans = join_tran.GroupBy((x, _) => x);
      def jtrans = jtrans.Map(x => (x.Key, x.Values()));
      jtrans.Iter(check_join)
    }

    create_fork_transitions() : void
    {
      def check_fork(f : NodeValue[FsmState, PseudoStateNode])
      {
        match (f.Value)
        {
          | PseudoStateNode.Fork(target = t) as j =>

              def st = t.Select(x => x.ToState);
              def reg = st.Select(x => x.PartOfSubRegion());
              if (!reg.IsEmpty() && reg.All(x => x.HasValue))
              {
                //def sreg = reg |> Last();
                def dups = reg.DuplicatesGroup(x => x.Value.Index());
                def regs = st.Select(x => x.PartOfRegion().Value);
                if (dups.Count() != 0 || !regs.ElementsEqual((x, y) => x == y : object)) 
                {

                  AddError(FsmError.ForkMustGoToSeparateRegion(f))
                } else
                {
                  //def reg = regs.First();
                  def sub_trans = t.Map(x => NodeValue(f.Parent, StateTransition.Transition(f.Parent, x, null)));
                  f.Value = j.ChangeForkTran(sub_trans);
                  //def sub_trans = sub_trans.Map(x => x.ChangeLocal(true));
                  //tr.ToPseudo.SetValue(x => (x :> PseudoStateNode.Fork).ChangeForkTran(sub_trans))
                }
              } else
              {
                AddError(FsmError.ForkMustGoToRegion(f))
              }

          | _ => ()
        }
      }

      def tran = AllTransitions.GetPseudo(_ is PseudoStateNode.Fork);
      tran.Iter(check_fork)
      //statemap.Update();
    }

    /// <summary>
    /// Creating Transitions
    /// </summary>
    CreateTransitions() : void
    {
      //def check_targets(node)
      //{
      //  match (node.Value.To)
      //  {
      //    //| TransitionTarget.PseudoState(NodeValue(Value = PseudoStateNode.Junction) as n) => CheckJunction(n);
      //    | _                                                                              => ()
      //  }

      //}

      //def check_tran(st)
      //{
      //  st.AllTransitions().Iter(x => check_targets(x))
      //}

      //States.Iter(check_tran);
      create_join_transitions(); // creating join transitions
      create_fork_transitions(); // creating fork transitions
      CreateAndCheckSuperStateTransitions(); // create parent transitions
      //CheckDuplicates(); // check duplicates
      //CheckCrossTransitions(); // look for cross transitions
    }

    CheckTransitions() : void
    {
      //def proc_tran(st, tran)
      //{
      //  match (tran.To)
      //  {
      //    | TransitionTarget.State as t when (!statemap.Contains(st)) => AddError(FsmError.UnknownTarget(tran, t))
      //    | _                                                         => ()
      //  }
      //}

      def check_cross_orthogonal(tr)
      {
        when (is_crossed_orthogonal(tr, tr.Parent)) AddError(FsmError.TransitionCrossOrthogonalBoundaryOfSameRegion(tr));
      }

      //def check_tran(st, _)
      //{
        //st.TraverseTargets(resolve_targets(st, _, _), true); // first pass named and qualified
        //st.TraverseTargets(resolve_targets(st, _, _)) // second pass final
      //}

      foreach (st in States)
      {
        //st.AllTransitions().Iter(proc_tran(st, _));
        st.AllTransitions().Iter(check_cross_orthogonal)
      }

      //UpdateStateMap(TopState.ReduceSingle(check_tran))
    }

    RenameTransition(tran : IEnumerable[NodeValue[FsmState, StateTransition]]) : void
    {
      def dups = tran.NToList().Duplicates((x, y) => x.Value.Name.CompareTo(y.Value.Name));
      dups.Iter(x => x.Update(x => x.ChangeNeedGuardedName(true)));
      def dups = tran.DuplicatesGroup(x => x.Value.Name);
      dups.Iter(x => x.Iter(x => Used[x] = false));
      //def dups = tran.Duplicates((x, y) => x.Value.Name.CompareTo(y.Value.Name));
      //def dups = dups.Map(x => (x.Value.GuardedName, x));
      //def tran = tran.Map(x => (x.Value.Name, x));
      //def tran = tran.Concat(dups);
      //def (dups, tran) = tran.DuplicatesPartition(x => x[0]);
      //def dups = dups.GroupBy(x => x[0]);
      def err = dups.Map(x => FsmError.DuplicateTransition(x.NToList()));
      AddErrors(err);
    }

    CreateTransitionPaths() : void
    {
      def traverse()
      {
        traverser = TransitionTraverser(this);
        traverser.Add(TopState.InitialTransitions());
        traverser.Traverse(); // model the fsm traversing states and transition from top recursively through initial transition and pseudo states
        traverser = null;
      }

      //def update_states()
      //{
      //  //def dest = trans_paths.SelectMany(x => x.Paths.Map((_, y) => y.Transition.Destination));
      //  //def tran = dest.SelectMany(_.Transition);
      //  //UpdateTransitions(tran);
      //  //def hist = dest.OfType.[TransitionDestination.History]().Select(_.state);
      //  //def hist = hist.RemoveDuplicatesSort(_.Name).Select(_.ChangeUsed(true));

      //  //def update_hist(s, _)
      //  //{
      //  //  def hist = hist.Where(x => x.Num == s.Num);
      //  //  hist.FoldLeft(s, (x, a) => a.UpdateHistory(x))
      //  //}

      //  ////statemap.Update(st);
      //  //def top = TopState.ReduceSingle(update_hist);
      //  //UpdateStateMap(top)
      //}

      traverse(); // traverse paths
      //update_states();
      CreateTransitionsWithPaths()
    }

    CreateTransitionsWithPaths() : void
    {
      def empty = empty_states.Select(FsmWarning.StateNotUsed); // warning about all without substates and not lived that is not used
      def not_used = not_used_transitions.Select(FsmWarning.TransitionNotUsed);
      AddWarnings(empty);
      AddWarnings(not_used); // determine used elements

      //def (used_hstates, not_used) = history_states.Partition(_.Used);
      //history_states = used_hstates;

      RenameTransition(used_transitions);
      //def int_tran =  States.SelectMany(_.internal_tran);
      //def int_tran =  RenameTransition(int_tran);
      //def int_tran = Map(int_tran);
      //def init = used_states_initial_tran;
      //def init = RenameTransition(init);
      //def init = Map(init);
      //internal_transitions = int_tran;
      //transitions = trans;
      //initial_transitions = init;
      def hist = not_used_history.Select(FsmWarning.HistoryNotUsed);
      AddWarnings(hist)
    }

    CreateHistoryPaths() : void
    {
      def create_hist_path(h, a)
      {
        match (h.Value)
        {
          | PseudoStateNode.History => def sub = h.SubStatesParticipateIn();
                                       def parent = h.Parent;
                                       //node.ParticipateInHistory().Select(x => (x.Parent, HistoryPath(x.state, this, x)).CreatePath()));
                                       sub.FoldLeft(a, (x, a) => HistoryPath(parent, x, h).CreatePath() :: a)
          | _                       => a
        }
        //def shist = st.SuperStates().Where(x => x.ParticipateInHistory().Exists(x => x.Value is PseudoStateNode.History(type = HistoryType.Shallow)));
        //def spaths = shist.SelectMany(x => x.Value.HistoryPaths);
        //def paths = st.ParticipateInHistory.Select(x => (x.state.name, HistoryPath(x.state, st, x).CreatePath()));
        //def paths = paths.Concat(spaths).NToList();
        //st.ChangeHistoryPaths(paths)
      } 

      def paths = HistoryStates.FoldLeft([], create_hist_path);
      def paths = paths.GroupBy(x => x.From).Select(x => (x.Key, x.NToList()));
      HistoryPaths = Hashtable(paths);
      //HistoryPaths = paths;
      //States.Iter(create_hist_path);
      //def top = TopState.ReduceSingle(create_hist_path);
      //UpdateStateMap(top)
    }

    UpdateInitial() : void
    {
      def warn = not_used_states_initial_tran.Select(FsmWarning.TransitionNotUsed);
      AddWarnings(warn)
    }

  }
}
