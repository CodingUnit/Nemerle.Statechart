using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using StateTransition;
  using ListUtils;
  using DecisionNode;  
  using GuardNode;
/// <summary>
/// Description of AnalyseTransitions.
/// </summary>
  public partial class FsmAnalyser
  {

    CheckInitialTransitions() : FsmAnalyser
    {
      def check_auto_initial(sub, st)
      {
          | (_, FsmState.Final) 
          | (_, ConcurrentRegion) => st
          | (head :: _, FsmState where (initial = [])) when (!(head is FsmState.Final)) =>
              st.DefineInitial(head);
          | (_, x) => x
      }

      def an = States.FoldLeft(this, (x, a) => a.check_duplicates(x.initial));  // check duplicates
      def top = if (fsm.flags.AutoInitial) TopState.FoldThis(check_auto_initial) else TopState;

      def top = if (top.initial is []) // if not have initial transition in top state
                 if (top.transitions is []) // if not have other transitions
                   check_auto_initial(top.sub_states, top) // initial is first substate
                 else top; // else initial transition is top state
                else top;
      def map = an.statemap.Init(top);
      //def map = map.ChangeStates(states.ToArray());
      ChangeStatemap(map)
    }

    is_crossed_orthogonal(tr : StateTransition, st : FsmState) : bool
    {
      | (StateTransition where (To = TransitionTarget.State(state = FsmState where (PartOfRegion = Some(r), PartOfSubRegion = Some(sr)))),
                        FsmState where (PartOfRegion = Some(r2), PartOfSubRegion = Some(sr2))) when r == r2 =>
          sr2 != sr
      | _ => false
    }

    CreateSuperStateTransitions() : FsmAnalyser
    {
      def create_trans(st)
      {
        | FsmState.State(super_state = null) => st
        | FsmState where (super_state = super, PartOfSubRegion = r) =>
            single_func
            {
              super.combined_transitions;
              if (r.HasValue) __.Filter(x => !is_crossed_orthogonal(x, st)) else __;
              st.DefineTransitions(__)
            }
      }

      def states = States.Map(create_trans);
      ChangeStatemap(statemap.ChangeStates(states.ToArray()))
    }

    CheckCrossTransitions() : FsmAnalyser
    {
      def group(tr, st)
      {
        match (tr)
        {
          | _ :: []  => st // if not have group exit
          | StateTransition where (Guard = Some()) as head :: tail  => head.IsCrossed = true; // cross transition
              def (path, end) = tail.SplitFind(x  => x.Guard.IsNone); // get all include last without GuardNode
              head.ParentCrossed = path;
              path.Iter(x => x.CrossFor = true);
              st.DeleteTransitions(end); // delete from usual transitions in state
          | _ :: tail  => st.DeleteTransitions(tail)
          | _  => st
        }
      }

      def check_cross_tran(tr, st)
      {
        single_func
        {
          tr.Sort((x, y) => StateTransition.GuardComparer(y, x));
          __.Sort((x, y) => y.From.hierarchy_pos - x.From.hierarchy_pos); // sort on hierarchy position
          group(__, st); // group transitions
        }
      }

      def check_cross(st)
      {
        def tran = st.transitions + st.internal_tran + st.initial;
        def group = FsmState.create_transition_group(tran).Filter((_, x) => x.Length > 1).Values();
        group.FoldLeft(st, check_cross_tran)
      }

      def states = States.Map(check_cross); // check from the top state
      ChangeStatemap(statemap.ChangeStates(states.ToArray()))
    }

    check_duplicates(tr : list[StateTransition]) : FsmAnalyser
    {
      def check_duplicate_tran(tr)
      {
        def check_begin_and_ends(tr)
        {
          def equal(lst, lst2)
          {
            lst.Equals(lst2, _ == _);
          }

          if (tr.Length > 1)
          {
            def acts = tr |> ActionList;
            def res = acts.ElementsEqual(equal);
            if (res) [FsmError.DuplicateTransition(tr)] else [];
          } else [];
        }

        def ordinary = tr.Exclude(x => x is Initial || x.IsCompletion);
        def dups = ordinary.Duplicates(StateTransition.GuardComparer); // find duplicates with same guards and same triggers
        if (dups is _ :: _)
        {
          [FsmError.DuplicateTransition(dups)]
        } else
        {
          def (intern, other) = tr.Partition(_ is Internal);
          def err = check_begin_and_ends(intern);
          def begin_and_end_eq = other.Group((x,y) => x.From.CompareTo(y.From) - x.To.CompareTo(y.To));
          def begin_and_end_eq = begin_and_end_eq.Filter(x => x.Length > 1);
          def err2 = begin_and_end_eq |>< check_begin_and_ends(_);
          err + err2
        }
      }

      def check_override(tr)
      {
        match (tr.Find(x => x.Guard.IsNone))
        {
          | Some(t) => def tr = tr.Exclude([t], (x, y) => x == y : object);
              tr.Map(x => FsmWarning.TransitionOverriden(x, t))
          | _ => []
        }
      }

      def group = FsmState.create_transition_group(tr).Values();
      def group = group.Filter(x => x.Length > 1);
      def dup = group |>< check_duplicate_tran(_);
      def warn = group |>< check_override(_);
      ChangeErrorsWarnings(GetErrors(dup), GetWarnings(warn))
    }

  /// <summary>
  /// Check duplicates
  /// </summary>
    CheckDuplicates() : FsmAnalyser
    {
      def an = States.FoldLeft(this, (x, a) => a.check_duplicates(x.this_transitions));
      an.States.FoldLeft(an, (x, a) => a.check_duplicates(x.initial))
    }

    get_named(tar : TransitionTarget.Named, an : FsmAnalyser) : TransitionTarget * FsmAnalyser
    {
      match (tar)
      {
        | Named(name = n, transition = tr) =>

            def states = pseudo_states.Filter(x => x.NativeName.HasValue);
            match (states.Find(x => x.NativeName.Value == n))
            {
              | Some(t) => (TransitionTarget.PseudoState(tr, t), an)
              | _ => (tar, an.AddErrors(FsmError.UnknownNode(tr)))
            }
      }   
    }

    check_targets(tr : TransitionTarget, an : FsmAnalyser) : TransitionTarget * FsmAnalyser
    {
      match (tr)
      {
        | PseudoState(node = Junction as j, transition = tr) as node => def (n, an) = CheckJunctionChoice(j, an);
            if (j != n : object) (TransitionTarget.PseudoState(tr, n), an) else (node, an)
        | _  => (tr, an)
      }

    }

    resolve_targets(st : FsmState, tr : TransitionTarget, an: FsmAnalyser) : TransitionTarget * FsmAnalyser
    {
      // TODO: может ли оно быть null?
      def tran = tr?.transition;

      match (tr)
      {
        | TransitionTarget.Final(state = null) as t =>
            def super = if (tran is Initial) st else st.super_state;
            match (super.sub_states.FindType())
            {
              | (Some(st), _)  => (t.ChangeState(st), an)
              | _              => (t, an)
            }

        | PseudoState(node = Terminate(state = null) as node) as t =>
            match (pseudo_states.Filter(_ is PseudoStateNode.Terminate))
            {
              | [] => (TransitionTarget.PseudoState(tran, node), an)
              | [term] => (TransitionTarget.PseudoState(tran, term), an)
              | _ => def an = an.AddErrors(FsmError.UnknownTerminateTransition(tran));
                  (t, an)
            }

        | PseudoState(node = Join(state = null, name = n)) as t =>
            match (pseudo_states.FilterType())
            {
              | [] => def an = an.AddErrors(FsmError.UnknownNode(tran));
                  (t, an)
              | joins =>
                  match (joins.Find(x : PseudoStateNode.Join => x.name == n))
                  {
                    | Some(j) => (TransitionTarget.PseudoState(tran, j), an)
                    | _ => def an = an.AddErrors(FsmError.UnknownNode(tran));
                        (t, an)
                  }
            }

        | Named as t => def (t, an) = get_named(t, this);
            an.resolve_targets(st, t, an)
        | Qualified(parent = st, target = t) => 
            def (st, an) = an.statemap.Get(st, an);
            match (st, t)
            {
              | (FsmState.SubMachine as m, TransitionTarget.State(state = FsmState where (Name = n))) =>
                  def m = m.Scan(); // scan external sub machine for states
                  def an = if (m.ref_sub_states.Contains(n)) an else an.AddErrors(FsmError.SubMachineStateNotFound(m, n));
                  (TransitionTarget.SubMachine(tran, m, n), an)
              | (null, _) => def an = an.AddErrors(FsmError.UnknownState(t.transition.From, FsmState.State(st.Name), t.transition));
                  (t, an)
              | (st, t) => resolve_targets(st, t, an)
            }
        | t  => (t, an)
      }
    }

    create_join_transitions() : FsmAnalyser
    {

      def check_join(j, tr)
      {
        match (j)
        {
          | PseudoStateNode.Join(state = st, target = t) =>

              if (tr.ElementsEqual((x, y) => x.Trigger == y.Trigger))
              {
                if (tr.All(x => x.From.PartOfSubRegion.HasValue) &&
                    tr.ElementsEqual((x, y) => x.From.PartOfRegion.Value == y.From.PartOfRegion.Value))
                {
                  def tran = Transition(st, tr.Head.Trigger, t, j);
                  def reg = tr.Head.From.PartOfRegion.Value;
                  def tr = tr.Sort((x, y) => x.FromRegion.index - y.FromRegion.index);
                  //j.joined_tran = tr;
                  //j.region = reg;

                  def j = j.ChangeRegionJoinedTranTransition(reg, tr, tran);
                  //j.transition = tran;
                  /// !!! mutable
                  tr.Iter(x => x.To = TransitionTarget.PseudoState(x, j));
                  []
                } else [FsmError.JoinTransitionMustLeaveRegion(j, tr)]
              } else
              {
                [FsmError.JoinTransitionMustHaveSameTrigger(j, tr)]
              }
        }
      }

      def get_join(t, lst)
      {
        match (t)
        {
          | StateTransition where (To = TransitionTarget.PseudoState(Join as j)) => (j, t) :: lst
          | _ => lst
        }
      }

      def join_tran = States.Map(x => x.all_transitions_with_init.FoldLeft([], get_join)).Flatten();
      def jtrans = join_tran.Group((x, y) => x[0].name.CompareTo(y[0].name)).Map(x => (x.Head[0], x.Split()[1]));
      def err = jtrans |>< check_join(_);
      AddErrors(err)
    }

    create_fork_transitions() : FsmAnalyser
    {
      def check_fork(tr, f)
      {
        match (f)
        {
          | PseudoStateNode.Fork(target = t) =>

              def st = t |> ToState;
              def reg = st |> PartOfSubRegions;
              if (!reg.IsEmpty() && reg.All(x => !x.IsEmpty()))
              {
                def sreg = reg |> Last();
                def dups = sreg.Duplicates((x, y) => x.index - y.index);
                if (dups.Length != 0) [FsmError.ForkMustGoToSeparateRegion(f)] else
                {
                  def reg = sreg.Head.contained_in;
                  def sub_trans = t |> StateTransition.Transition(reg, null, _, f) : StateTransition;
                  sub_trans.Iter(x => x.Local = true);
              /// !!! mutable
                  tr.To = TransitionTarget.PseudoState(tr, f.ChangeForkTran(sub_trans));
                  []
                }
              } else
              {
                [FsmError.ForkMustGoToRegion(f)]
              }
        }
      }

      def get_fork(t, lst)
      {
        match (t)
        {
          | StateTransition where (To = TransitionTarget.PseudoState(Fork as f)) => (t, f) :: lst
          | _ => lst
        }
      }

      def tran = States |>< all_transitions_with_init.FoldLeft([], get_fork);
      def err = tran |>< check_fork(_);
      AddErrors(err)
    }
  /// <summary>
  /// Creating Transitions
  /// </summary>
    CreateTransitions() : FsmAnalyser
    {
      def check_tran(st, an)
      {
        st.all_transitions_with_init.FoldLeft(an, (x, a) => x.TargetTraverse(a, check_targets))
      }

      def an = States.FoldLeft(this, check_tran);
      def an = an.create_join_transitions(); // creating join transitions
      def an = an.create_fork_transitions(); // creating fork transitions
      def an = an.CreateSuperStateTransitions(); // create parent transitions
      def an = an.CheckDuplicates(); // check duplicates
      an.CheckCrossTransitions(); // look for cross transitions
    }

    CheckTransitions() : FsmAnalyser
    {
      def proc_tran(st, tran)
      {
        match (tran.To)
        {
          | TransitionTarget.State(state = to) when (!statemap.Contains(st.Name)) => [FsmError.UnknownState(st, to, tran)]
          | _  => []
        }

      }

      def check_cross_orthogonal(tr)
      {
        if (is_crossed_orthogonal(tr, tr.Source)) [FsmError.TransitionCrossOrthogonalBoundaryOfSameRegion(tr)] else []        
      }

      def init(st)
      {
        def err = st.initial |>< proc_tran(st, _);
        def err2 = st.all_transitions |>< proc_tran(st, _);
        err + err2
      }

      def check_tran(st, an)
      {
        st.all_transitions_with_init.FoldLeft(an, (x, a) => x.TargetTraverse(a, (a, b) => resolve_targets(st, a, b)))
      }

      def err = States |>< init(_);
      def err2 = States.Map(x => x.all_transitions |>< check_cross_orthogonal(_)).Flatten();
      def an = States.FoldLeft(this, check_tran);
      
      def update_states(an)
      {
        def dest = States.FoldLeft([], (x, a) => x.all_transitions_with_init.FoldLeft(a, (x, a) => x.To.Fold(null,  (a, b) => resolve_targets(st, a, b))));
        def st = dest.Map(_.ToState).Filter(_ != null);
        an.statemap.CheckNew(st)
      }
      
      update_states(an);
      //def trans = States |>< all_transitions_with_init;
      //def states = States.Map(x => trans.FoldLeft(x, (y, s) => s.UpdateFromTarget(y.To))); // updating states to new transition analyse info
      an.AddErrors(err + err2)
    }

    RenameTransition(tran : list[StateTransition], an : FsmAnalyser) : list[string * StateTransition] * FsmAnalyser
    {
      def (dups, tran) = tran.DuplicatesPartition(StateTransition.Comparer);
      dups.Iter(x => x.NeedGuardedName = true);
      def dups = dups |> (GuardedName, _);
      def tran = tran |> (Name, _);
      def tran = tran + dups;
      def (dups, tran) = tran.DuplicatesPartition((x, y) => x[0].CompareTo(y[0]));
      def dups = dups.Group((x, y) => x[0].CompareTo(y[0]));
      def err = dups.Map(x => FsmError.DuplicateTransition(x.Split()[1]));
      def an = an.AddErrors(err);
      (tran, an)
    }

    CreateTransitionPaths() : FsmAnalyser
    {
      def traverse()
      {
        traverser.Add(TopState.initial);
        def res = traverser.Traverse(this); // model the fsm traversing states and transition from top recursively through initial transition and pseudo states
        def map = statemap.CheckNew(res);
        ChangeStatemap(map)
        //$[x.paths, x in States, x.paths != null]
      }

      def update_states(an)
      {
        def dest = an.trans_paths.Map(x => x.Paths.Map((_, y) => y.Transition.Destination)).Flatten();
        def st = dest.Map(_.ToState).Filter(_ != null);
        an.statemap.CheckNew(st)
      }

      def an = traverse(); // traverse paths
      def st = update_states(an);
      def an = an.ChangeStatemap(st);
      an.CreateTransitionsWithPaths()
    }

    CreateTransitionsWithPaths() : FsmAnalyser
    {
      def determine_used()
      {
        def empty = empty_states.Map(x => FsmWarning.StateNotUsed(x) : FsmWarning); // warning about all without substates and not lived that is not used
        def not_used = not_used_transitions.Map(x => FsmWarning.TransitionNotUsed(x) : FsmWarning);
        empty + not_used
      }
      
      def warnings = determine_used(); // determine used elements

      //def (used_hstates, not_used) = history_states.Partition(_.Used);
      //history_states = used_hstates;

      def (trans, an) = RenameTransition(used_transitions, this);
      def trans = Map(trans);
      def int_tran =  States |>< internal_tran;
      def (int_tran, an) =  an.RenameTransition(int_tran, an);
      def int_tran = Map(int_tran);
      def init = used_states_initial_tran;
      def (init, an) = an.RenameTransition(init, an);
      def init = Map(init);
      def an = an.ChangeInternalTransitionsTransitionsInitialTransitions(int_tran, trans, init);
      def hist = not_used_history.Map(x => FsmWarning.HistoryNotUsed(x) : FsmWarning);
      def warnings = warnings + hist;
      an.ChangeWarnings(GetWarnings(warnings))
    }
    
    UpdateInitial() : FsmAnalyser
    {
      def warn = not_used_states_initial_tran |> FsmWarning.TransitionNotUsed(_);
      AddWarnings(warn)
    }

  }
}
