using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using StateTransition;
  using ListUtils;
  using DecisionNode;  
  using GuardNode;
  using Opt;
/// <summary>
/// Description of AnalyseTransitions.
/// </summary>
  public partial class FsmAnalyser
  {

    CheckInitialTransitions() : void
    {
      def check_auto_initial(st)
      {
        match (st.Value)
        {
          | FsmState.Final 
          | ConcurrentRegion       => ()
          | _ when st.InitialTransitions().IsEmpty()  =>

              match (st.SubStates().First())
              {
                | null => ()
                | head => if (head.Value is FsmState.Final) () else st.DefineInitial(head);
              }

          | _                      => ()
        }
      }

      States.Iter(x => check_duplicates(x.InitialTransitions().Select(_.Value)));  // check duplicates
      when (FsmFlags.AutoInitial) States.Iter(check_auto_initial);

      def top = TopState;
      when (top.InitialTransitions().IsEmpty()) // if not have initial transition in top state
        when (top.Transitions().IsEmpty()) // if not have other transitions
          check_auto_initial(top) // initial is first substate

      //def create_path_from_out(st, _)
      //{
      //  def path = StateTransition.Initial(TopState, st).Create();
      //  def path = path.TraversePath();
      //  st.ChangePathFromOut(path)
      //}

      //UpdateStateMap(top);
      //def top = top.ReduceSingle(create_path_from_out);
      //UpdateStateMap(top);
    }

    is_crossed_orthogonal(tr : StateTransition, st : SimpleTreeNode[FsmState]) : bool
    {
      | (StateTransition(To = TransitionTarget.State(state = n)), _) when n.PartOfRegion() == st.PartOfRegion() => n.PartOfSubRegion() == st.PartOfSubRegion()
      | _                                                                                                       => false
    }

    CreateSuperStateTransitions() : void
    {
      def resolve_conflict(trans)
      {
        
      }
      
      def check_duplicate_tran(tr)
      {
        //def check_begin_and_ends(tr : IEnumerable[_])
        //{
        //  def equal(lst, lst2)
        //  {
        //    lst.Equals(lst2, _ == _);
        //  }

        //  when (tr.IsMoreThanOne())
        //  {
        //    def acts = tr.Select(x : StateTransition => x.ActionList);
        //    def res = acts.ElementsEqual(equal);
        //    when (res) AddError(FsmError.DuplicateTransition(tr));
        //  }
        //}

        //def ordinary = tr.Exclude(x => x is Initial || x.IsCompletion);
        def dups = tr.NToList().Duplicates(FsmStateFuncs.Compare(StateTransition.GuardComparer)); // find duplicates with same guards and same triggers
        when (!dups.IsEmpty())
        {
          AddError(FsmError.DuplicateTransition(dups))
        }// else
        //{
          //def (intern, other) = tr.PartitionLazy(_ is Internal);
          //def begin_and_end_eq = other.NToList().Group((x, y) => x.From.Value.CompareTo(y.From.Value) - x.To.CompareTo(y.To)).Select(x => x.AsEnumerable());
          //def begin_and_end_eq = begin_and_end_eq.Where(_.IsMoreThanOne());
          //def merged = begin_and_end_eq.Append(intern);
          //merged.Iter(check_begin_and_ends)
        //}
      }

      def check_override(tr)
      {
        // без гуарда переопределяет на том же уровне с гуардами и без гуардов, если такое возникает то необходимо сигнализировать
        match (tr.Filter(x => x.Value.Guard.IsNone))
        {
          | [] 
          | [_] => ()
          | _ => def warn = tr.Map(x => FsmWarning.TransitionOverriden(x, t));
                 AddWarnings(warn)
          | _ => ()
        }
      }
      def create_trans(st)
      {
        
        def parent_trans = st.ExternalTransitions() + st.SuperStates().SelectMany(x => x.ExternalTransitions()); // get the super states transitions and concatinate with current
        //def parent_trans = parent_trans.Select(x => (x.Value.FriendlyTriggerName, x)); // get with trigger names
        def by_trigger   = parent_trans.GroupBy(x => x.Value.FriendlyTriggerName);
        def conflict     = by_trigger.Where(x => x.IsMoreThanOne());
        def conflict     = conflict.Select(x => x.OrderByDescending(x => x.Parent.Value.hierarchy_pos));
        //def conflict     = conflict.OrderBy(x => x.);
        conflict.Iter(check_duplicate_tran);
        conflict.Iter(check_override);
        conflict.Iter(resolve_conflict);
        
        //when (parent != null)
        //{
        //  def trans = if (parent.PartOfSubRegion().HasValue)
        //               {
        //                 parent.Value.all_transitions.Exclude(is_crossed_orthogonal(_, st))
        //               } else
        //               {
        //                 parent.Value.all_transitions
        //               }
        //  st.DefineTransitions(trans)
        //}
        //| FsmState(PartOfSubRegion = Some, sub_states = sub) with trans = st.all_transitions.Exclude(is_crossed_orthogonal(_, st))

        //| FsmState(sub_states = sub, all_transitions = trans) => 

            //def sub = sub.Map(x => x.DefineTransitions(trans.Map(t => t.SetNewId())));
            //st.ChangeSubStates(sub)

      }

    def (simple, other) = States.PartitionLazy(_.IsSimpleState());
    simple.Iter(create_trans);
    other.Iter(_.DeleteTransitions());
  }

    CheckCrossTransitions() : void
    {
      def group(tr, st : SimpleTreeNode[FsmState])
      {
        match (tr)
        {
          | _ :: []  => st // if not have group exit
          | StateTransition(Guard = Some) as head :: tail  => 
              def (path, end) = tail.SplitFind(x => x.Guard.IsNone); // get all include last without GuardNode
              head.ChangeParentCrossed(path).Change();
              def path = path.Map(_.ChangeCrossFor(true));
              def st = st.Update(x => x.DeleteTransitions(end)); // delete from usual transitions in state
              
              st.UpdateTransitions(tr :: path)

          | _ :: tail  => st.DeleteTransitions(tail)

          | _  => st
        }
      }

      def check_cross_tran(tr, st)
      {
        single_func
        {
          tr.NToList().Sort((x, y) => StateTransition.GuardComparer(y, x));
          __.Sort((x, y) => y.From.Depth - x.From.Depth); // sort on hierarchy position
          group(__, st); // group transitions
        }
      }

      def check_cross(st)
      {
        def tran = st.AllTransitions();
        def group = FsmState.create_transition_group(tran).Where((_, x) => x.IsMoreThanOne()).Values();
        //group.FoldLeft(st, check_cross_tran)
      }


      States.Iter(check_cross); // check from the top state
    }

    check_duplicates(tr : IEnumerable[StateTransition]) : void
    {
      

      def group = FsmState.create_transition_group(tr).Values();
      def group = group.Where(_.IsMoreThanOne());
      group.Iter(check_duplicate_tran);
      group.Iter(check_override);
    }

  /// <summary>
  /// Check duplicates
  /// </summary>
    CheckDuplicates() : void
    {
      States.Iter(x => check_duplicates(x.this_transitions));
      States.Iter(x => check_duplicates(x.initial));
    }




    create_join_transitions() : void
    {

      def check_join(j, tr : IEnumerable[_])
      {
        match (j)
        {
          | PseudoStateNode.Join(state = st, target = t) =>

              if (tr.ElementsEqual((x, y) => x.Trigger == y.Trigger))
              {
                if (tr.All(x => x.From.PartOfSubRegion().HasValue) &&
                    tr.ElementsEqual((x, y) => x.From.PartOfRegion().Value == y.From.PartOfRegion().Value))
                {
                  def tran = StateTransition.Create(st, tr.First().Trigger, t, j);
                  def reg = tr.First().From.PartOfRegion().Value;
                  def tr = tr.OrderBy(x : StateTransition => x.FromRegion.index);
                  //j.joined_tran = tr;
                  //j.region = reg;

                  //j.transition = tran;
                  /// !!! mutable
                  tr.Iter(x => x.ToPseudo.SetValue(x => (x :> PseudoStateNode.Join).ChangeRegionJoinedTranTransition(reg, tr, tran)));
                } else 
                {
                  AddError(FsmError.JoinTransitionMustLeaveRegion(j, tr));
                }
              } else 
              {
                AddError(FsmError.JoinTransitionMustHaveSameTrigger(j, tr));
              }
        }
      }

      def get_join(t, lst)
      {
        match (t)
        {
          | StateTransition(To = TransitionTarget.PseudoState(SimpleTreeNode(Value = PseudoState(PseudoStateNode.Join as j)))) => (j, t) :: lst
          | _                                                                                                                  => lst
        }
      }

      def join_tran = States.SelectMany(x => x.all_transitions_with_init.FoldLeft([], get_join));
      def jtrans = join_tran.GroupBy(x => x[0].name);
      def jtrans = jtrans.Select(x => (x.First()[0], x.Values()));
      jtrans.Iter((x, y) => check_join(x, y));
    }

    create_fork_transitions() : void
    {
      def check_fork(tr, f)
      {
        match (f)
        {
          | PseudoStateNode.Fork(target = t) =>

              def st = t |> ToState;
              def reg = st |> PartOfSubRegions;
              if (!reg.IsEmpty() && reg.All(x => !x.IsEmpty()))
              {
                def sreg = reg |> Last();
                def dups = sreg.Duplicates((x, y) => x.index - y.index);
                if (dups.Length != 0) 
                {
                  AddError(FsmError.ForkMustGoToSeparateRegion(f))
                } else
                {
                  def reg = sreg.Head.contained_in;
                  def sub_trans = t |> StateTransition.Create(reg, null, _, f);
                  def sub_trans = sub_trans.Map(x => x.ChangeLocal(true));
              /// !!! mutable
                  tr.ToPseudo.SetValue(x => (x :> PseudoStateNode.Fork).ChangeForkTran(sub_trans))
                }
              } else
              {
                AddError(FsmError.ForkMustGoToRegion(f));
              }
        }
      }

      def get_fork(t, lst)
      {
        match (t)
        {
          | StateTransition(To = TransitionTarget.PseudoState(SimpleTreeNode(Value = PseudoState(PseudoStateNode.Fork as f)))) => (t, f) :: lst
          | _                                                                                                                  => lst
        }
      }

      def tran = States.SelectMany(x => x.all_transitions_with_init.FoldLeft([], get_fork));
      tran.Iter(check_fork);
      statemap.Update();
    }
  /// <summary>
  /// Creating Transitions
  /// </summary>
    CreateTransitions() : void
    {
      def check_targets(node)
      {
        match (node)
        {
          | TransitionTarget.PseudoState(SimpleTreeNode(Value = PseudoState(PseudoStateNode.Junction as j) as n)) as t => def tree = CheckJunction(j);
                                                                                                                          t.node.Value = n.ChangeNode(j.ChangeDecisionTree(tree));
                                                                                                                //node.SetValue(x => (x :> PseudoStateNode.Junction).ChangeDecisionTree(tree))
          | _                                                                                                => ()
        }

      }

      def check_tran(st)
      {
        st.all_transitions_with_init.Iter(x => check_targets(x.To))
      }

      States.Iter(check_tran);
      create_join_transitions(); // creating join transitions
      create_fork_transitions(); // creating fork transitions
      CreateSuperStateTransitions(); // create parent transitions
      CheckDuplicates(); // check duplicates
      CheckCrossTransitions(); // look for cross transitions
    }

    CheckTransitions() : void
    {
      def proc_tran(st, tran)
      {
        match (tran.To)
        {
          | TransitionTarget.State as t when (!statemap.Contains(st)) => AddError(FsmError.UnknownTarget(tran, t))
          | _                                                         => ()
        }
      }

      def check_cross_orthogonal(tr)
      {
        when (is_crossed_orthogonal(tr, tr.Source.Value)) AddError(FsmError.TransitionCrossOrthogonalBoundaryOfSameRegion(tr));
      }

      //def check_tran(st, _)
      //{
        //st.TraverseTargets(resolve_targets(st, _, _), true); // first pass named and qualified
        //st.TraverseTargets(resolve_targets(st, _, _)) // second pass final
      //}

      foreach (st in States)
      {
        st.all_transitions_with_init.Iter(proc_tran(st, _));
        st.all_transitions.Iter(check_cross_orthogonal)
      }

      //UpdateStateMap(TopState.ReduceSingle(check_tran))
    }

    RenameTransition(tran : IEnumerable[StateTransition]) : IEnumerable[string * StateTransition]
    {
      def (dups, tran) = tran.DuplicatesPartition(_.Name);
      def dups = dups.Map(x => x.ChangeNeedGuardedName(true));
      def dups = dups |> (GuardedName, _);
      def tran = tran |> (Name, _);
      def tran = tran.Concat(dups);
      def (dups, tran) = tran.DuplicatesPartition(x => x[0]);
      def dups = dups.GroupBy(x => x[0]);
      def err = dups.Map(x => FsmError.DuplicateTransition(x.Values()));
      AddErrors(err);
      tran
    }

    CreateTransitionPaths() : void
    {
      def traverse()
      {
        traverser = TransitionTraverser(this);
        traverser.Add(TopState.initial);
        traverser.Traverse(); // model the fsm traversing states and transition from top recursively through initial transition and pseudo states
        traverser = null;
      }

      def update_states()
      {
        def dest = trans_paths.SelectMany(x => x.Paths.Map((_, y) => y.Transition.Destination));
        //def tran = dest.SelectMany(_.Transition);
        //UpdateTransitions(tran);
        def hist = dest.OfType.[TransitionDestination.History]().Select(_.state);
        def hist = hist.RemoveDuplicatesSort(_.Name).Select(_.ChangeUsed(true));

        def update_hist(s, _)
        {
          def hist = hist.Where(x => x.Num == s.Num);
          hist.FoldLeft(s, (x, a) => a.UpdateHistory(x))
        }

        //statemap.Update(st);
        def top = TopState.ReduceSingle(update_hist);
        UpdateStateMap(top)
      }

      traverse(); // traverse paths
      update_states();
      CreateTransitionsWithPaths()
    }

    CreateTransitionsWithPaths() : void
    {
      def determine_used()
      {
        def empty = empty_states.Select(FsmWarning.StateNotUsed); // warning about all without substates and not lived that is not used
        def not_used = not_used_transitions.Select(FsmWarning.TransitionNotUsed);
        AddWarnings(empty);
        AddWarnings(not_used);
      }

      determine_used(); // determine used elements

      //def (used_hstates, not_used) = history_states.Partition(_.Used);
      //history_states = used_hstates;

      def trans = RenameTransition(used_transitions);
      def trans = Map(trans);
      def int_tran =  States.SelectMany(_.internal_tran);
      def int_tran =  RenameTransition(int_tran);
      def int_tran = Map(int_tran);
      def init = used_states_initial_tran;
      def init = RenameTransition(init);
      def init = Map(init);
      internal_transitions = int_tran;
      transitions = trans;
      initial_transitions = init;
      def hist = not_used_history.Select(FsmWarning.HistoryNotUsed);
      AddWarnings(hist)
    }

    CreateHistoryPaths() : void
    {
      def create_hist_path(st, _)
      {
        def shist = st.SuperStates.Where(x => x.ParticipateInHistory.Exists(x => x.type == HistoryType.Shallow));
        def spaths = shist.SelectMany(_.HistoryPaths);
        def paths = st.ParticipateInHistory.Select(x => (x.state.name, HistoryPath(x.state, st, x).CreatePath()));
        def paths = paths.Concat(spaths).NToList();
        st.ChangeHistoryPaths(paths)
      } 

      def top = TopState.ReduceSingle(create_hist_path);
      UpdateStateMap(top)
    }

    UpdateInitial() : void
    {
      def warn = not_used_states_initial_tran.Select(FsmWarning.TransitionNotUsed);
      AddWarnings(warn)
    }

}
}
