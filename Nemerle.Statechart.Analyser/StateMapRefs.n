using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of StateMapRefs.
  /// </summary>
  partial class StateMap
  {

    UpdateHistoryReference(hist : PseudoStateNode.History, st : FsmState) : PseudoStateNode.History
    {
      def default = hist.default.Map(UpdateTargetReference(_, st));
      hist.ChangeDefault(default)
    }

    UpdateStateReference(st : FsmState) : FsmState
    {
      | FsmState.SubMachine(type = type) as st =>
          def fsm = States.FilterType();
          match (fsm.Find(x => x.type == type))
          {
            | Some(FsmState.InlinedSubMachine as f) => UpdateStateReference(st.Instance(f))
            | _                                     => st
          }
      | _ => 

      UpdateRefsToParent(st, st.ChildNodes);
      def st = st.TransitionMap(UpdateTargetReference(_, st));
      st.HistoryMap(UpdateHistoryReference(_, st))
    }

    UpdateTargetReference(tr : StateTransition, st : FsmState) : StateTransition
    {
      def source = if (tr.Source != null) st else null;
	  
      def to = tr.To.ReduceSingle(true, (x, _) => ResolveTargets(st, st, x, tr));
      tr.ChangeSourceNumTo(source, to)
    }

    GetNamed(tar : TransitionTarget.Named, tr : StateTransition) : TransitionTarget
    {
      match (tar)
      {
        | Named(name = n) =>

            def states = Analyser.PseudoStates.Filter(x => x.NativeName.HasValue);
            match (states.Find(x => x.NativeName.Value == n))
            {
              | Some(t) => TransitionTarget.PseudoState(Analyser, CreatePseudoRef(t))
              | _       => Analyser.AddError(FsmError.UnknownNode(tr));
                           tar
            }
      }
    }

    GetNode[T](name : string, err : int -> void) : option[T] where T : PseudoStateNode
    {
      def pseudo = Analyser.PseudoStates.FilterType();
      def pseudo = if (name != null) pseudo.Where(x => if (x.NativeName is Some(n)) name == n else false) else pseudo;
      match (pseudo.NToList())
      {
        | []     => err(1);None()
        | [node] => Some(node)
        | _      => err(2);None()
      }
    }
    
    CheckPseudo(st : FsmState, res : FsmState, np : ReferenceNode[PseudoStateNode], targ : TransitionTarget, tran : StateTransition) : ReferenceNode[PseudoStateNode]
    {
      if (np.IsFixed) null else
      match (np.Value)
      {
        | Fork as j => 
        //| EntryPoint
        //| ExitPoint =>
            //ParentFor(p.Num, st);
            //st.Super
            ChangeMan.Add(st.Super.Num, x => x.ChangePseudoStates(x.pseudo_states.Append(j).NToList()));
            np.Fix(j.Num)
        | History as t       => def hist = res.GetHistory(t);
                                np.Fix(hist.Num)
        | Junction(IsUnnamed = true) as j => ChangeMan.Add(st.Super.Num, x => x.AddPseudo(j));
                                             np.Fix(j.Num)
        | Junction(name = n) => match (GetNode(n, _ => Analyser.AddError(FsmError.UnknownTarget(tran, targ))))
                                {
                                  | Some(Junction as j) => np.Fix(j.Num)
                                  | _                   => np
                                }
        | Join(name = n)     => match (GetNode(n, _ => Analyser.AddError(FsmError.UnknownTarget(tran, targ))))
                                {
                                  | Some(Join as j) => np.Fix(j.Num)
                                  | _               => np
                                } 
        | Terminate          =>
                                match (GetNode(null, n => if (n == 2) Analyser.AddError(FsmError.UnknownTerminateTransition(tran)) 
                                                          else throw InvalidOperationException("not found terminate node")))
                                {
                                  | Some(Terminate as t) => np.Fix(t.Num)//TransitionTarget.PseudoState(this, node)
                                  | _                    => np
                                }
        | _                  => null
      }
    }        

    public static CreateStateRef(val : FsmState, fix : bool = false) : ReferenceNode[FsmState]
    {
      def statemap = val.analyser.statemap;
      val.analyser.statemap.ChangeMan.NewReferences = true;
      def node = ReferenceNode(val, -1, val.analyser, statemap.Get, statemap.ChangeMan.Add);
      if (fix) node.Fix(val.Num) else node
    }
    
    public static CreatePseudoRef(val : PseudoStateNode, fix : bool = false) : ReferenceNode[PseudoStateNode]
    {
      def statemap = val.analyser.statemap;
      val.analyser.statemap.ChangeMan.NewReferences = true;
      def node = ReferenceNode(val, -1, val.analyser, x => statemap.ParentFor(x).GetPseudo(x), (i, x) => statemap.ChangeMan.Add(statemap.ParentFor(i).Num, y => y.ChangePseudo(i, x)));
      if (fix) node.Fix(val.Num) else node
    }
    
    // TODO: решить проблему с двойным обходом узлов до разрешения и после
    ResolveTargets(st : FsmState, res : FsmState, tr : TransitionTarget, tran : StateTransition) : TransitionTarget
    {
      match (tr)
      {
        | State(state = cst, value = r) as t when (!r.IsFixed) => def cst = cst.Updated;
                                                                  t.ChangeValue(r.Fix(cst.Num))

        | Named as t => def t = GetNamed(t, tran);
                        ResolveTargets(st, st, t, tran)
        | Qualified(parent = res, target = t) => 
            def res = Get(res);
            match (res, t)
            {
              | (FsmState.SubMachine as m, TransitionTarget.State(state = FsmState(Name = n))) =>
                  def m = m.Scan(); // scan external sub machine for states
                  when (!m.ref_sub_states.Contains(n)) Analyser.AddError(FsmError.SubMachineStateNotFound(m, n));
                  TransitionTarget.Nowhere(Analyser)//TransitionTarget.SubMachine(Analyser, m, n)

              | (null, _) => Analyser.AddError(FsmError.UnknownTarget(tran, tr));
                             t
              | (res, t)  => ResolveTargets(st, res, t, tran)
            }
        | PseudoState(p) as t => def np = CheckPseudo(st, res, p, t, tran);
                                 if (np == null) null else t.ChangeNode(np) 

        | _                   => null
      }
    }


  }
}
