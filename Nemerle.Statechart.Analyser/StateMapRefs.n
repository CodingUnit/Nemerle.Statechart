using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of StateMapRefs.
  /// </summary>
  partial class StateMap
  {

    UpdateReferences() : void
    {
      states.Iter(UpdateStateReference)
    }

    UpdatePseudoStateReference(p : PseudoStateNode, st : FsmState) : void
    {
      match (p)
      {
       | History as h => h.default.Iter(UpdateTransitionReference(_, st))
       | _            => ()
      }
    }
    //UpdateHistoryReference(hist : PseudoStateNode.History, st : FsmState) : void
    //{
    //  hist.default.Iter(UpdateTargetReference(_, st))
    //}

    UpdateStateReference(state : FsmState) : void
    {
      //match (state.Data)
      //{
      //  | FsmState.SubMachine(type = type) as st =>
      //    def fsm = States.Where(x => x.Data is FsmState.InlinedSubMachine);
      //    match (fsm.Find(x => (x.Data :> FsmState.InlinedSubMachine).type == type))
      //    {
      //      | Some(f) => st.Instance(f)
      //      | _       => ()
      //    }
      //  | _ =>

      state.transitions.Iter(UpdateTransitionReference(_, state));
      state.pseudo_states.Iter(UpdatePseudoStateReference(_, state));
    // }
    }

    UpdateTransitionReference(tr : StateTransition, st : FsmState) : void
    {      
      def recursive_resolve(prev)
      {        
        def to = ResolveTarget(st, prev, tr);
        if (to == null) prev else
          if (to : object != prev) recursive_resolve(to) else to
      }

      def to = recursive_resolve(tr.To);  
      tr.To = to
    }

    ResolvePseudoState(p : PseudoStateNode, st : FsmState) : PseudoStateNode
    {
      match (p)
      {                                   // get history from state
        | PseudoStateNode.History as h => st.GetHistory(h)
        | Terminate                    => match (pseudo_states.Find(x => x is PseudoStateNode.Terminate))
                                          {
                                            | Some(ft) => ft
                                            | _        => def t = PseudoStateNode.Terminate(state_tree);
                                                          state_tree.AddPseudo(t);
                                                          t
                                          }
        | _ => match (p.NativeName) // find for name
            {
              | Some(p)   => GetPseudoIn(p, null)
              | _         => null
            }
      }

    }
    // TODO: решить проблему с двойным обходом узлов до разрешения и после
    ResolveTarget(st : FsmState, tr : TransitionTarget, tran : StateTransition) : TransitionTarget
    {
      match (tr)
      {
        // TODO: продумать алгоритм разрешения неоднозначности из того в каком состояниии
        // осуществляется переход
        | Named(par, n)   => match (GetNamed(n, par))
            {
              | null => Analyser.AddError(FsmError.UnknownNode(tran));
                        null
              | t    => t
            }
        | Qualified(parent = par, target = t) => 
            def res = Get(par);
            match (res, t)
            {
              | (null, _) => Analyser.AddError(FsmError.UnknownTarget(tran, tr));
                             null
              | (res, _)  => ResolveTarget(res, TransitionTarget.Named(Analyser, res, par), tran)
            }
        | PseudoState(p) as t    => match (ResolvePseudoState(p, st))
            {
              | null => Analyser.AddError(FsmError.UnknownTarget(tran, tr));
                        null
              | n    => t.ChangeNode(n)
            }
        | State(s) as t          => match (Get(s.NativeName))
                                    {
                                      | null    => Analyser.AddError(FsmError.StateNotFound(s));t
                                      | s       => t.ChangeState(s)
                                    }

        | _                   => null // other not supported yet
      }
    }


  }
}
