using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of StateMapRefs.
  /// </summary>
  partial class StateMap
  {

    UpdateHistoryReference(hist : PseudoStateNode.History, st : FsmState) : PseudoStateNode.History
    {
      def default = hist.default.Map(UpdateTargetReference(_, st));
      hist.ChangeDefault(default)
    }

    UpdateStateReference(st : FsmState) : FsmState
    {
      | FsmState.SubMachine(type = type) as st =>
          def fsm = States.FilterType();
          match (fsm.Find(x => x.type == type))
          {
            | Some(FsmState.InlinedSubMachine as f) => UpdateStateReference(st.Instance(f))
            | _                                     => st
          }
      | _ => 

      UpdateRefsToParent(st, st.ChildNodes);
      def st = st.TransitionMap(UpdateTargetReference(_, st));
      st.HistoryMap(UpdateHistoryReference(_, st))
    }

    UpdateTargetReference(tr : StateTransition, st : FsmState) : StateTransition
    {
      def source = if (tr.Source != null) st else null;

      // recursive resolve targets until tree is completed and no modification needed
      def recursive_traverse(prev)
      {
        def to = prev.ReduceSingle(true, (x, _) => ResolveTargets(st, st, x, tr));
        if (to != prev : object) recursive_traverse(to) else to
      }

      def to = recursive_traverse(tr.To);
      tr.ChangeSourceNumTo(source, to)
    }

    GetNamed(tar : TransitionTarget.Named, tr : StateTransition) : TransitionTarget
    {
      match (tar)
      {
        | Named(name = n) =>

            def states = Analyser.PseudoStates.Filter(x => x.NativeName.HasValue);
            match (states.Find(x => x.NativeName.Value == n))
            {
              | Some(t) => TransitionTarget.PseudoState(Analyser, t)
              | _       => Analyser.AddError(FsmError.UnknownNode(tr));
                          tar
            }
      }
    }

    CheckPseudo(st : FsmState, res : FsmState, p : PseudoStateNode, targ : TransitionTarget, tran : StateTransition) : PseudoStateNode
    {
      def pseudo = Analyser.PseudoStates;
      match (p)
      {
        | PseudoStateNode.Junction as j  when j.IsUnnamed
        | Fork
        | EntryPoint
        | ExitPoint =>
            ParentFor(p.Num, st);
            null
        | History as t when (t.Num == -1) => def hist = res.GetHistory(t);
                                             ChangeMan.CreateReference(NodeReference(hist.Num, res, st, 
                                                                                      (s, d) => s.ChangeHistory(TransitionTarget.PseudoState.GetHistory(d, tran)), 
                                                                                      (s, d) => TransitionTarget.PseudoState.SetHistory(d, tran, s.GetHistory(t)), 
                                                                                      x => x.GetHistory(t).version, 
                                                                                      x => TransitionTarget.PseudoState.GetHistory(x, tran).version));
                                             hist

        | Junction(name = n) as j  => def junc = pseudo.FilterType();
                                      match (junc.Find(x => x.name == n))
                                      {
                                        | Some(PseudoStateNode.Junction as j) => j
                                        | _                                   => Analyser.AddError(FsmError.UnknownTarget(tran, targ));
                                                                                j
                                      }
        | Join(name = n) as j     => def join = pseudo.FilterType();
                                    match (join.Find(x => x.name == n))
                                    {
                                      | Some(PseudoStateNode.Join as j) => j
                                      | _                               => Analyser.AddError(FsmError.UnknownTarget(tran, targ)); j
                                    }
        | Terminate as node =>
            match (Analyser.PseudoStates.Filter(_ is PseudoStateNode.Terminate))
            {
              | []     => node//TransitionTarget.PseudoState(this, node)
              | [node] => node//TransitionTarget.PseudoState(this, term)
              | _      => Analyser.AddError(FsmError.UnknownTerminateTransition(tran));
                          null
            }
        | _ => null
      }
    }        

    // TODO: решить проблему с двойным обходом узлов до разрешения и после
    ResolveTargets(st : FsmState, res : FsmState, tr : TransitionTarget, tran : StateTransition) : TransitionTarget
    {
      match (tr)
      {
        | State(state = cst)  as t => def cst = cst.Updated;
                                     if (!ChangeMan.HaveReference(cst.Num))
                                     {
                                      ChangeMan.CreateReference(NodeReference(cst.Num, cst, st, (_, d) => TransitionTarget.State.GetState(d, tran), 
                                                                                          (s, d) => TransitionTarget.State.SetState(d, tran, s), 
                                                                                          _.version, 
                                                                                          x => TransitionTarget.State.GetState(x, tran).version));
                                      t.ChangeState(cst)
                                     } else t
                                     

        | Named as t => def t = GetNamed(t, tran);
                        ResolveTargets(st, st, t, tran)
        | Qualified(parent = res, target = t) => 
            def res = Get(res);
            match (res, t)
            {
              | (FsmState.SubMachine as m, TransitionTarget.State(state = FsmState(Name = n))) =>
                  def m = m.Scan(); // scan external sub machine for states
                  when (!m.ref_sub_states.Contains(n)) Analyser.AddError(FsmError.SubMachineStateNotFound(m, n));
                  TransitionTarget.SubMachine(Analyser, m, n)

              | (null, _) => Analyser.AddError(FsmError.UnknownTarget(tran, tr));
                             t
              | (res, t)  => ResolveTargets(st, res, t, tran)
            }
        | PseudoState(p) as t => def np = CheckPseudo(st, res, p, t, tran);
                                if (np == null) null else t.ChangeNode(np) 

        | _                   => null
      }
    }


  }
}
