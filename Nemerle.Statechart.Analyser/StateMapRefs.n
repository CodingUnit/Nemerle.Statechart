using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of StateMapRefs.
  /// </summary>
  partial class StateMap
  {
    
    UpdateHistoryReference(hist : StateHistory, st : FsmState) : StateHistory
    {
      //def hist = if (history.reference) state.GetHistory(this) else this;
      //ChangeState(st);
      def default = hist.default.Map(UpdateTargetReference(_, st));
      hist.ChangeDefault(default)
    }
    
    UpdateStateReference(st : FsmState) : FsmState
    {
      | FsmState.SubMachine(type = type) as st =>
          def fsm = States.FilterType();
          match (fsm.Find(x => x.type == type))
          {
            | Some(FsmState.InlinedSubMachine as f) => UpdateStateReference(st.Instance(f))
            | _                                     => st
          }
      | _ => 
      
      UpdateRefsToParent(st, st.ChildNodes);
      def init     = st.initial.Map(UpdateTargetReference(_, st));
      def tran     = st.transitions.Map(UpdateTargetReference(_, st));
      def int_tran = st.internal_tran.Map(UpdateTargetReference(_, st));
      def hist     = st.history.Map(UpdateHistoryReference(_, st));
      //TraverseTargets(resolve_targets(st, _, _), true); // first pass named and qualified
      //def pseudo = pseudo_states.Map(_.UpdateReference());
      st.ChangeHistoryInitialInternalTranTransitions(hist, init, int_tran, tran)
    }

    UpdateTargetReference(tr : StateTransition, st : FsmState) : StateTransition
    {
      //def from = if (From != null) Statemap.Get(From) else null;
      def source = if (tr.Source != null) st else null;
      def to = tr.To.ReduceSingle(true, (x, _) => ResolveTargets(st, x, tr));
      //st.TraverseTargets(, true); // first pass named and qualified
      tr.ChangeSourceNumTo(source, to)
    }

    GetNamed(tar : TransitionTarget.Named, tr : StateTransition) : TransitionTarget
    {
      match (tar)
      {
        | Named(name = n) =>

            def states = Analyser.PseudoStates.Filter(x => x.NativeName.HasValue);
            match (states.Find(x => x.NativeName.Value == n))
            {
              | Some(t) => TransitionTarget.PseudoState(Analyser, t)
              | _       => Analyser.AddError(FsmError.UnknownNode(tr));
                           tar
            }
      }
    }
    
    CheckPseudo(st : FsmState, p : PseudoStateNode, targ : TransitionTarget, tran : StateTransition) : PseudoStateNode
    {
      def pseudo = Analyser.PseudoStates;
      match (p)
      {
        | PseudoStateNode.Junction(name = n) when (n.StartsWith("Unnamed"))
        | Fork
        | EntryPoint
        | ExitPoint =>
            ParentFor(p.Num, st);
            p

        | Junction(name = n) as j  => def junc = pseudo.FilterType();
                                      match (junc.Find(x => x.name == n))
                                      {
                                        | Some(PseudoStateNode.Junction as j) => j
                                        | _                                   => Analyser.AddError(FsmError.UnknownTarget(tran, targ));
                                                                                 j
                                      }
        | Merge(name = n) as j    =>  def merge = pseudo.FilterType();
                                      match (merge.Find(x => x.name == n))
                                      {
                                        | Some(PseudoStateNode.Merge as j) => j
                                        | _                                => Analyser.AddError(FsmError.UnknownTarget(tran, targ)); j
                                      }
        | Join(name = n) as j     => def join = pseudo.FilterType();
                                     match (join.Find(x => x.name == n))
                                     {
                                       | Some(PseudoStateNode.Join as j) => j
                                       | _                               => Analyser.AddError(FsmError.UnknownTarget(tran, targ)); j
                                     }
        | p                        => p
      }
    }
    
    ResolveTargets(st : FsmState, tr : TransitionTarget, tran : StateTransition) : TransitionTarget
    {
      match (tr)
      {
        //| TransitionTarget.Final(state = null) as t =>
        //    def super = if (tran is Initial) st else st.Super;
        //    match (super.sub_states.FindType())
        //    {
        //      | Some(FsmState.Final as st)  => t.ChangeState(st)
        //      | _                           => tr
        //    }
        | State(st_num) as t => def st = st_num.Updated;
                                t.ChangeStateNum(st)

        | History(h) as t     => t.ChangeHistory(st.GetHistory(h))
        | PseudoState(node = Terminate as node) as p =>
            match (Analyser.PseudoStates.Filter(_ is PseudoStateNode.Terminate))
            {
              | []     => p.ChangeNode(node)//TransitionTarget.PseudoState(this, node)
              | [node] => p.ChangeNode(node)//TransitionTarget.PseudoState(this, term)
              | _      => Analyser.AddError(FsmError.UnknownTerminateTransition(tran));
                          tr
            }

        | PseudoState(node = Join(name = n)) =>
            match (Analyser.PseudoStates.FilterType())
            {
              | [] => Analyser.AddError(FsmError.UnknownNode(tran));
                      null
              | joins =>
                  match (joins.Find(x : PseudoStateNode.Join => x.name == n))
                  {
                    | Some(j) => TransitionTarget.PseudoState(Analyser, j)
                    | _       => Analyser.AddError(FsmError.UnknownNode(tran));
                                tr
                  }
            }

        | Named as t => def t = GetNamed(t, tran);
                        ResolveTargets(st, t, tran)
        | Qualified(parent = st, target = t) => 
            def st = Get(st);
            match (st, t)
            {
              | (FsmState.SubMachine as m, TransitionTarget.State(state = FsmState(Name = n))) =>
                  def m = m.Scan(); // scan external sub machine for states
                  when (!m.ref_sub_states.Contains(n)) Analyser.AddError(FsmError.SubMachineStateNotFound(m, n));
                  TransitionTarget.SubMachine(Analyser, m, n)
                  
              | (null, _) => Analyser.AddError(FsmError.UnknownTarget(tran, tr));
                             t
              | (st, t) => ResolveTargets(st, t, tran)
            }
        | PseudoState(p) as t => t.ChangeNode(CheckPseudo(st, p, t, tran))

        | t  => t
      }
    }
    
    CheckAddFinalState(top : FsmState) : FsmState
    {
        //def is_top(st)
        //{
        //  def super = st.Super; 
        //// check if state is top or state is sub of top and don't have transitions
        //  super == null || (super.Super == null && super.this_transitions.IsEmpty())
        //}

        def check_target(st, t, tran, a)
        {
          match (t, tran)
          {
            //| (TransitionTarget.Final, _) when (is_top(st)) => 
            //    def term = PseudoStateNode.Terminate(0, statemap.GetNextGlobalNum(), this);
            //    (TransitionTarget.PseudoState(this, term), null :: a)
                // TODO: check later for need of termination of fsm if we reach final state
            | (TransitionTarget.Final as t, StateTransition.Initial) with super = st
            | (Final as t, _) with super = st.Super => (t, super :: a)
          }
        }

        def check_final(f, st, sub)
        {
          if (st.HaveFinal) st else
          match (f.Find(x => x.Num == st.Num))
          {
            | Some => def fin = FsmState.Final(Analyser).SetNewId();
                      st.ChangeSubStates(sub.Append(fin).NToList())
            | _    => null
          }
        }

        def check_tran(st, (x, (tr, a)))
        {
          def (to, fin) = x.To.Reduce(a, final = check_target(st, _, x, _));
          def tran = x.ChangeTo(to);
          (tran :: tr, fin)
        }

        def check_state(s, _, a)
        {
          def (tran, fin) = s.transitions.FoldBack(([], a), check_tran(s, _));
          def (init, fin) = s.initial.FoldBack(([], fin), check_tran(s, _));
          def st          = s.ChangeTransitionsInitial(tran, init);
          (st, fin)
        }

        def (top, final) = top.ReduceSingle([], check_state);
        // check to add final state
        top.ReduceSingle(true, check_final(final, _, _))
    }
    
  }
}
