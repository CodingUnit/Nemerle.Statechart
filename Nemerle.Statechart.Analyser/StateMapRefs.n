using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of StateMapRefs.
  /// </summary>
  partial class StateMap
  {
    
    UpdateHistoryReference(hist : PseudoStateNode.History, st : FsmState) : PseudoStateNode.History
    {
      def default = hist.default.Map(UpdateTargetReference(_, st));
      hist.ChangeDefault(default)
    }
    
    UpdateStateReference(st : FsmState) : FsmState
    {
      | FsmState.SubMachine(type = type) as st =>
          def fsm = States.FilterType();
          match (fsm.Find(x => x.type == type))
          {
            | Some(FsmState.InlinedSubMachine as f) => UpdateStateReference(st.Instance(f))
            | _                                     => st
          }
      | _ => 
      
      UpdateRefsToParent(st, st.ChildNodes);
      def init     = st.initial.Map(UpdateTargetReference(_, st));
      def tran     = st.transitions.Map(UpdateTargetReference(_, st));
      def int_tran = st.internal_tran.Map(UpdateTargetReference(_, st));
      def hist     = st.history.Map(UpdateHistoryReference(_, st));
      st.ChangeHistoryInitialInternalTranTransitions(hist, init, int_tran, tran)
    }

    UpdateTargetReference(tr : StateTransition, st : FsmState) : StateTransition
    {
      //def from = if (From != null) Statemap.Get(From) else null;
      def source = if (tr.Source != null) st else null;
      def to = tr.To.ReduceSingle(true, (x, _) => ResolveTargets(st, x, tr));
      //st.TraverseTargets(, true); // first pass named and qualified
      tr.ChangeSourceNumTo(source, to)
    }

    GetNamed(tar : TransitionTarget.Named, tr : StateTransition) : TransitionTarget
    {
      match (tar)
      {
        | Named(name = n) =>

            def states = Analyser.PseudoStates.Filter(x => x.NativeName.HasValue);
            match (states.Find(x => x.NativeName.Value == n))
            {
              | Some(t) => TransitionTarget.PseudoState(Analyser, t)
              | _       => Analyser.AddError(FsmError.UnknownNode(tr));
                           tar
            }
      }
    }
    
    CheckPseudo(st : FsmState, p : PseudoStateNode, targ : TransitionTarget, tran : StateTransition) : PseudoStateNode
    {
      def pseudo = Analyser.PseudoStates;
      match (p)
      {
        | PseudoStateNode.Junction(name = n) when (n.StartsWith("Unnamed"))
        | Fork
        | EntryPoint
        | ExitPoint =>
            ParentFor(p.Num, st);
            p
        | History as t             => st.GetHistory(t)
        | Junction(name = n) as j  => def junc = pseudo.FilterType();
                                      match (junc.Find(x => x.name == n))
                                      {
                                        | Some(PseudoStateNode.Junction as j) => j
                                        | _                                   => Analyser.AddError(FsmError.UnknownTarget(tran, targ));
                                                                                 j
                                      }
        | Merge(name = n) as j    =>  def merge = pseudo.FilterType();
                                      match (merge.Find(x => x.name == n))
                                      {
                                        | Some(PseudoStateNode.Merge as j) => j
                                        | _                                => Analyser.AddError(FsmError.UnknownTarget(tran, targ)); j
                                      }
        | Join(name = n) as j     => def join = pseudo.FilterType();
                                     match (join.Find(x => x.name == n))
                                     {
                                       | Some(PseudoStateNode.Join as j) => j
                                       | _                               => Analyser.AddError(FsmError.UnknownTarget(tran, targ)); j
                                     }
        | p                        => p
      }
    }
    
    ResolveTargets(st : FsmState, tr : TransitionTarget, tran : StateTransition) : TransitionTarget
    {
      match (tr)
      {
        | State(st_num) as t => def st = st_num.Updated;
                                t.ChangeStateNum(st)

        | PseudoState(node = Terminate as node) as p =>
            match (Analyser.PseudoStates.Filter(_ is PseudoStateNode.Terminate))
            {
              | []     => p.ChangeNode(node)//TransitionTarget.PseudoState(this, node)
              | [node] => p.ChangeNode(node)//TransitionTarget.PseudoState(this, term)
              | _      => Analyser.AddError(FsmError.UnknownTerminateTransition(tran));
                          tr
            }

        | PseudoState(node = Join(name = n)) =>
            match (Analyser.PseudoStates.FilterType())
            {
              | [] => Analyser.AddError(FsmError.UnknownNode(tran));
                      null
              | joins =>
                  match (joins.Find(x : PseudoStateNode.Join => x.name == n))
                  {
                    | Some(j) => TransitionTarget.PseudoState(Analyser, j)
                    | _       => Analyser.AddError(FsmError.UnknownNode(tran));
                                tr
                  }
            }

        | Named as t => def t = GetNamed(t, tran);
                        ResolveTargets(st, t, tran)
        | Qualified(parent = st, target = t) => 
            def st = Get(st);
            match (st, t)
            {
              | (FsmState.SubMachine as m, TransitionTarget.State(state = FsmState(Name = n))) =>
                  def m = m.Scan(); // scan external sub machine for states
                  when (!m.ref_sub_states.Contains(n)) Analyser.AddError(FsmError.SubMachineStateNotFound(m, n));
                  TransitionTarget.SubMachine(Analyser, m, n)
                  
              | (null, _) => Analyser.AddError(FsmError.UnknownTarget(tran, tr));
                             t
              | (st, t) => ResolveTargets(st, t, tran)
            }
        | PseudoState(p) as t => t.ChangeNode(CheckPseudo(st, p, t, tran))

        | t  => t
      }
    }
    
    
  }
}
