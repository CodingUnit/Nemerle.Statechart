using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of StateMapRefs.
  /// </summary>
  partial class StateMap
  {

    UpdateReferences() : void
    {
      state_tree.GetBreadthFirstEnumerable().Iter(UpdateStateReference)
    }

    UpdateHistoryReference(hist : PseudoStateNode.History, st : FsmState) : void
    {
      hist.default.Iter(UpdateTargetReference(_, st))
    }

    UpdateStateReference(state : FsmState) : void
    {
      //match (state.Data)
      //{
      //  | FsmState.SubMachine(type = type) as st =>
      //    def fsm = States.Where(x => x.Data is FsmState.InlinedSubMachine);
      //    match (fsm.Find(x => (x.Data :> FsmState.InlinedSubMachine).type == type))
      //    {
      //      | Some(f) => st.Instance(f)
      //      | _       => ()
      //    }
      //  | _ =>

      state.transitions.Iter(UpdateTransitionReference(_, state));
      state.pseudo_states.Iter(UpdatePseudoReference(_, state));
    // }
    }

    UpdateTransitionReference(tr : StateTransition, st : FsmState) : void
    {
      //def from = match (tr.Value.From)
      //            {
      //              | null                        => null
      //              | FsmNode.PseudoState(p) as n => def node = CheckPseudo(st, st, p, null, tr);
      //                                  n.ChangeNode(node)
      //              | FsmNode.State(s) as n       => UpdateStateReference(s);n
      //            }

      //def recursive_resolve(prev)
      //{
      //  def to = ResolveTarget(st, prev, tr);
      //  if (to : object != prev) recursive_resolve(to) else to
      //}

      tr.To = ResolveTarget(st, tr.To, tr)
    }

    //public NewReferences : bool {get;set;}

    
    //public ResolveTarget(targ : TransitionTarget) : GeneralTree[FsmNode]
    //{

    //}

    ResolvePseudoReference(st : FsmState, res : FsmState, np : PseudoStateNode, targ : TransitionTarget, tran : StateTransition) : PseudoStateNode
    {
      match (np)
      {
        | PseudoStateNode.History(default = d, type = t) => d.Iter(UpdateTransitionReference(_, st))
        | PseudoStateNode.Fork =>
        //| EntryPoint
        //| ExitPoint =>
            //ParentFor(p.Num, st);
            //st.Super

            def st = SuperForPseudo(st, tran);
            np.Parent = st;
            pseudo_states.Add(st, np);
            //ParentFor(j.Num, st);
            //ChangeMan.Add(st.Num, x => x.AddPseudo(j));
            np

        | History       => res.GetHistory(np)
                                //np.Fix(hist.Num)
//#if 0
//        | Junction(IsUnnamed = true) => def st = SuperForPseudo(st, tran);
//                                        np.Parent = st;
//                                        pseudo_states.Add(st, np);
//                                        np
//                                            //ParentFor(j.Num, st);
//                                            //def j = j.ChangeTo(ch.First() :> TransitionTarget.JunctionNode); // update childs resolved
//                                            //ChangeMan.Add(st.Num, x => x.AddPseudo(j)); // add to super state
//                                            //np.Fix(j.Num)

//        | Junction(name = n) => match (GetNode(n, _ => Analyser.AddError(FsmError.UnknownTarget(tran, targ))))
//            {
//              | Some(null)          => np
//              | Some(NodeValue(Value = Junction) as j) => j// update childs resolved

//                    //ChangeMan.Add(st.Super.Num, x => x.AddPseudo(j));
//                  //np.Fix(j.Num); // fix target
//                                                          //def tar = ResolveTarget(st, j.to, tran) :> TransitionTarget.JunctionNode;
//                                                          //fixed.SetValue(j => (j :> PseudoStateNode.Junction).ChangeTo(tar));
//                                                          //fixed// update junction in state to updated value
//              | _                   => np
//            }
//#endif            
        | Join(name = n)     => match (GetNode(n, _ => Analyser.AddError(FsmError.UnknownTarget(tran, targ))))
            {
              | Some(null)                         => np
              | Some(NodeValue(Value = Join) as j) => j
              | _                                  => np
            }
        | Terminate     => match (GetNode(null, n => when (n == 2) Analyser.AddError(FsmError.UnknownTerminateTransition(tran))))
            {
              | Some(null)           => //def t = t.ChangeNum(GetNextGlobalNum());
                                                            def st = SuperForPseudo(st, tran);
                                                            np.Parent = st;
                                                            pseudo_states.Add(st, np);
                                                            np
                                                            //ParentFor(t.Num, st);
                                                            //ChangeMan.Add(st.Num, x => x.AddPseudo(t));
                                                            //np.Fix(t.Num)
              | Some(NodeValue(Value = Terminate) as t)   => t//TransitionTarget.PseudoState(this, node)
              | _                                         => np
            }
        | _                  => null
      }
    }

    UpdatePseudoReference(np : PseudoStateNode, st : FsmState) : void
    {
      match (np)
      {
        | PseudoStateNode.History(default = d) => d.Iter(UpdateTransitionReference(_, st))
        //| PseudoStateNode.Fork =>


        //    def st = SuperForPseudo(st, tran);
        //    np.Parent = st;
        //    pseudo_states.Add(st, np);
        //    np

        //| History       => res.GetHistory(np)
                                //np.Fix(hist.Num)
//#if 0
//        | Junction(IsUnnamed = true) => def st = SuperForPseudo(st, tran);
//                                        np.Parent = st;
//                                        pseudo_states.Add(st, np);
//                                        np
//                                            //ParentFor(j.Num, st);
//                                            //def j = j.ChangeTo(ch.First() :> TransitionTarget.JunctionNode); // update childs resolved
//                                            //ChangeMan.Add(st.Num, x => x.AddPseudo(j)); // add to super state
//                                            //np.Fix(j.Num)

//        | Junction(name = n) => match (GetNode(n, _ => Analyser.AddError(FsmError.UnknownTarget(tran, targ))))
//            {
//              | Some(null)          => np
//              | Some(NodeValue(Value = Junction) as j) => j// update childs resolved

//                    //ChangeMan.Add(st.Super.Num, x => x.AddPseudo(j));
//                  //np.Fix(j.Num); // fix target
//                                                          //def tar = ResolveTarget(st, j.to, tran) :> TransitionTarget.JunctionNode;
//                                                          //fixed.SetValue(j => (j :> PseudoStateNode.Junction).ChangeTo(tar));
//                                                          //fixed// update junction in state to updated value
//              | _                   => np
//            }
//#endif            
        //| Join(name = n)     => match (GetNode(n, _ => Analyser.AddError(FsmError.UnknownTarget(tran, targ))))
        //    {
        //      | Some(null)                         => np
        //      | Some(NodeValue(Value = Join) as j) => j
        //      | _                                  => np
        //    }
        | _                  => ()
      }
    }

    ResolvePseudoState(p : PseudoStateNode, st : FsmState) : TransitionTarget
    {
      //GetPseudoIn()
      
      match (p.NativeName)
      {
        | Some(p)   => GetPseudoIn(p, st)
        | _         => null
      }
    }
    // TODO: решить проблему с двойным обходом узлов до разрешения и после
    ResolveTarget(st : FsmState, tr : TransitionTarget, tran : StateTransition) : TransitionTarget
    {
      match (tr)
      {
        // TODO: продумать алгоритм разрешения неоднозначности из того в каком состояниии
        // осуществляется переход
        | Named(par, n) as t => match (GetNamed(n, par))
                        {
                          | null => Analyser.AddError(FsmError.UnknownNode(tran));
                                    null
                          | t    => t
                        }
        | Qualified(parent = par, target = t) => 
            def res = Get(par);
            match (res, t)
            {
              | (null, _) => Analyser.AddError(FsmError.UnknownTarget(tran, tr));
                             null
              | (res, _)  => ResolveTarget(res, TransitionTarget.Named(Analyser, res, par), tran)
            }
        | PseudoState(p)     => match (ResolvePseudoState(p, st))
                                 {
                                   | null => Analyser.AddError(FsmError.UnknownTarget(tran, tr));
                                             null
                                   | t    => t
                                 }
        | State(s) as t       => match (Get(s.NativeName))
                                {
                                  | null    => Analyser.AddError(FsmError.StateNotFound(s));t
                                  | s       => t.ChangeState(s)
                                }

        | _                   => null
      }
    }


  }
}
