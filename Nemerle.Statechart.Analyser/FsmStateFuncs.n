using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of FsmStateFuncs.
  /// </summary>
  module FsmStateFuncs
  {

    public IsTopState(this node : GeneralTree[FsmState]) : bool
    {
      node.Parent == null
    }

    public SubRegions(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      if (node.Value is FsmState.ConcurrentRegion) node.Children else Enumerable.Empty()
    }

    public SubStates(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.Children
    }

    /// <summary>
    /// Is it Lived state, consider on nesting lived states
    /// </summary>
    public LivedNested(this node : GeneralTree[FsmState]) : bool
    {
      node.Lived() || !node.AllLivedSubStates().IsEmpty()
    }

    /// <summary>
    /// Direct lived substates with consider of nesting state life
    /// </summary>
    public LivedSubStatesNested(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.Children.Where(x => x.LivedNested())
    }

    /// <summary>
    /// All Lived substates with consider of nesting state life on all nesting levels
    /// </summary>
    public AllLivedSubStatesNested(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.GetBreadthFirstEnumerable().Where(_.LivedNested())
        //sub_states.Filter(_.LivedNested) + (sub_states |>< AllLivedSubStatesNested)
    }

    /// <summary>
    /// Direct lived sub states without consider of living nesting states of this substates
    /// </summary>
    public LivedSubStates(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.SubStates().Where(x => x.Value.Lived)
    }

      /// <summary>
    /// All sub states at all nesting levels
    /// </summary>
    public AllSubStates(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.AllStates().Skip(1)
        //sub_states + (sub_states |>< AllSubStates)
    }

    /// <summary>
    /// All sub states include this at all nesting levels
    /// </summary>
    public AllStates(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.GetBreadthFirstEnumerable()
    }

    //public AllPseudoStates : list[PseudoStateNode]
    //{
    //  get
    //  {
    //    pseudo_states + (sub_states |>< AllPseudoStates)
    //  }
    //}

    /// <summary>
    /// All lived sub states
    /// </summary>
    public AllLivedSubStates(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.AllSubStates().Where(x => x.Value.Lived)
    }

    public DefineInitial(this node : GeneralTree[FsmState], st : GeneralTree[FsmState]) : void
    {
      def tran = StateTransition.Initial(node, st);
      node.Value.analyser.statemap.Transitions.Add(node, NodeValue(node, tran));
      //node.Update(x => x.ChangeInitial(tran :: x.initial))
    }

        /// <summary>
    /// Sub states included in the history of this state
    /// </summary>
    public SubStatesParticipateInHistory(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.History().Value.SelectMany(x => x.SubStatesParticipateIn())
    }

    public History(this node : GeneralTree[FsmState]) : TwoOption[NodeValue[FsmState, PseudoStateNode]]
    {
      def hist = node.Value.analyser.statemap.PseudoStates[node].FoldLeft([], (x, a) => if (x.Value is PseudoStateNode.History) x :: a else a);
      TwoOption.FromList(hist)
    }

    public SubStatesParticipateIn(this node : NodeValue[FsmState, PseudoStateNode]) : IEnumerable[GeneralTree[FsmState]]
    {
      match (node.Value)
      {
        | PseudoStateNode.History(type = HistoryType.Deep)     => node.Parent.AllLivedSubStates()
        | PseudoStateNode.History(type = HistoryType.Shallow)  => node.Parent.LivedSubStatesNested()
        | _                                                    => Enumerable.Empty()
      }
    }

    public PartOfRegion(this node : GeneralTree[FsmState]) : option[GeneralTree[FsmState]]
    {
      node.SuperStatesInclude().Find(x => x.Value is FsmState.ConcurrentRegion)
    }

    public PartOfSubRegion(this node : GeneralTree[FsmState]) : option[GeneralTree[FsmState]]
    {
      node.SuperStatesInclude().Find(x => x.Value is FsmState.ConcurrentSubRegion)
    }
    
    ///// <summary>
    ///// History pseudo-states in which participate this state
    ///// </summary>
    public ParticipateInHistory(this node : GeneralTree[FsmState]) : IEnumerable[NodeValue[FsmState, PseudoStateNode]]
    {
      node.Value.analyser.HistoryStates.Where(x => x.SubStatesParticipateIn().Contains(node))
    }

    public SuperStates(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.Parents()
    }

    public SuperStatesFromTop(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      Enumerable.Reverse(node.SuperStates())
    }

    public SuperStatesFromTopInclude(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.SuperStatesFromTop().Append(node)
    }    

    public HaveFinal(this node : GeneralTree[FsmState]) : bool
    {
      match (node.Value)
      {
        | ConcurrentRegion => node.Children.All(x => x.HaveFinal())
        | _                => node.SubStates().Exists(x => x.Value is FsmState.Final)
      }
    }

    public FinalSubState(this node : GeneralTree[FsmState]) : option[GeneralTree[FsmState.Final]]
    {
      node.SubStates().FindType()
    }

        /// <summary>
    /// Transitions defined direct from this state
    /// </summary>
    public this_transitions(this node : GeneralTree[FsmState]) : IEnumerable[NodeValue[FsmState, StateTransition]]
    {
      node.AllTransitions().Where(x  => x.Parent == node : object)
    }

    //public IsSubStateOf(this node : GeneralTree[FsmState], st : GeneralTree[FsmState]) : bool
    //{
    //  node.SuperStates().Exists(_ == st)
    //}

    public Index(this node : GeneralTree[FsmState]) : int
    {
      node.Parent.Children.IndexOf(node)
    }

    public Super(this node : GeneralTree[FsmState]) : GeneralTree[FsmState]
    {
      node.Parent
    }

        //[TraverseIgnore] 
        //[NeedChange(index)] 
    public ContainedIn(this node : GeneralTree[FsmState]) : GeneralTree[FsmState]
    {
      node.Super()
    }

    public static all_transitions_nested(this node : GeneralTree[FsmState]) : IEnumerable[StateTransition]
    {
      node.GetBreadthFirstEnumerable().SelectMany(x => x.Value.all_transitions_with_init)
    }
              /// <summary>
          /// Indicates that maybe external transitions from some points of orthogonal state out of region not only completion
          /// </summary>
    public MayTakePlaceForcedTransitions(this node : GeneralTree[FsmState]) : bool 
    {
      node.all_transitions_nested().Exists(_.OutOfRegion)
    }

    public NeedHistorySave(this node : GeneralTree[FsmState]) : bool
    {
      !node.ParticipateInHistory().IsEmpty()
    }

    public get_pattern(reg : IEnumerable[GeneralTree[FsmState]]) : string
    {
      def idx = reg.Select(x => x.Index()).OrderBy(x => x).NToList();
      $<#..$(idx;"")#>
    }


    public RegionExcept(this node : GeneralTree[FsmState], st : IEnumerable[GeneralTree[FsmState]]) : GeneralTree[FsmState]
    {
      match (node.SubRegions().Except(st))
      {
        | [sub]     => sub
        | head :: _ => head
        | _         => null
      }
    }

    public RegionsExcept(this node : GeneralTree[FsmState], st : IEnumerable[GeneralTree[FsmState]]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.SubRegions().Where(x => !x.AllSubStates().Exists(y => st.Exists(y : object == _)) && !st.Exists(_ == x : object))
    }

    public RegionsExcept(this node : GeneralTree[FsmState], st : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.SubRegions().Where(x => !x.AllSubStates().Contains(st) && x : object != st)
    }

    public GetPseudo(this tran : IEnumerable[NodeValue[FsmState, StateTransition]], is_pseudo : PseudoStateNode -> bool) : IEnumerable[NodeValue[FsmState, PseudoStateNode]]
    {
      def get_pseudo(t, lst)
      {
        match (t.Value)
        {
          | StateTransition(To = TransitionTarget.PseudoState(NodeValue(Value = j) as t)) when (is_pseudo(j)) => t :: lst
          | _                                                                                                 => lst
        }
      }

      tran.FoldLeft([], get_pseudo).Distinct()
    }

    public Joins(this node : GeneralTree[FsmState]) : IEnumerable[NodeValue[FsmState, PseudoStateNode]]
    {
      node.AllLivedSubStatesNested().SelectMany(x => x.AllTransitions().GetPseudo(_ is PseudoStateNode.Join))
    }

    public HaveJoinTransitions(this node : GeneralTree[FsmState]) : bool
    {
      !node.Joins().IsEmpty()
    }

    public Transitions(this node : GeneralTree[FsmState]) : IEnumerable[NodeValue[FsmState, StateTransition]]
    {
      node.Value.statemap.Transitions[node].Where(x => x.Value is StateTransition.Transition)
    }
    
    public AllTransitions(this node : GeneralTree[FsmState]) : IEnumerable[NodeValue[FsmState, StateTransition]]
    {
      node.Value.statemap.Transitions[node]
    }
    
    public ExternalTransitions(this node : GeneralTree[FsmState]) : IEnumerable[NodeValue[FsmState, StateTransition]]
    {
      node.AllTransitions().Where(x => !(x.Value is StateTransition.Initial))
    }
    
    public InitialTransitions(this node : GeneralTree[FsmState]) : IEnumerable[NodeValue[FsmState, StateTransition]]
    {
      node.Value.statemap.Transitions[node].Where(x => x.Value is StateTransition.Initial)
    }

    public InternalTransitions(this node : GeneralTree[FsmState]) : IEnumerable[NodeValue[FsmState, StateTransition]]
    {
      node.Value.statemap.Transitions[node].Where(x => x.Value is StateTransition.Internal)
    }
    
    public AddSubState(this st : GeneralTree[FsmState], sub : GeneralTree[FsmState]) : void
    {
      //st.analyser = Analyser;
      _ = st.Children.Add(sub);
      //if (sub_states.Exists(x => x.Num == st.Num)) this else ChangeSubStates(sub_states.Append(st).NToList())//sub_states = sub_states + [st];
    }

    public DefineTransitions(this st : GeneralTree[FsmState], tr : IEnumerable[NodeValue[FsmState, StateTransition]]) : void
    {
      st.Value.statemap.Transitions.Add(st, tr);
      //def (tran : IEnumerable[StateTransition.Transition], other)   = tr.PartitionType();
      //def (intern : IEnumerable[StateTransition.Internal], other)   = other.PartitionType();
      //def (init : IEnumerable[StateTransition.Initial], _)          = other.PartitionType();
      //def intern = internal_tran + intern.Select(_ : StateTransition);
      //def init = initial + init.Select(_ : StateTransition);
      //def tran = transitions + tran.Select(_ : StateTransition);
      //ChangeTransitionsInitialInternalTran(tran.NToList(), init.NToList(), intern.NToList())
    }

    public static Compare(comparer : StateTransition * StateTransition -> int) :  NodeValue[FsmState, StateTransition] *  NodeValue[FsmState, StateTransition] -> int
    {
      (x, y) => comparer(x.Value, y.Value)
    }
    
    public DeleteTransitions(this st : GeneralTree[FsmState], tr : IEnumerable[NodeValue[FsmState, StateTransition]]) : void
    {
      st.Value.statemap.Transitions.Rem(st, tr)
    }
    
    public DeleteTransitions(this st : GeneralTree[FsmState]) : void
    {
      st.Value.statemap.Transitions.Clear(st)
    }
    
    public IsSimpleState(this node : GeneralTree[FsmState]) : bool
    {
      node.SubStates().IsEmpty()
    }

    /// <summary>
    /// Use both types of history in state
    /// </summary>
    public BothHistories(this node : GeneralTree[FsmState]) : bool
    {
        node.History().IsTwo
    }

    public UsedHistory(this node : GeneralTree[FsmState]) : IEnumerable[NodeValue[FsmState, PseudoStateNode]]
    {
        node.History().Value.Where(x => node.Value.analyser.Used[x])
    }
    
    public Lived(this node : GeneralTree[FsmState]) : bool
    {
      def an = node.Value.analyser;
      an.LivedStates[node] || an.Clones[node].Exists(x => x.Lived())
    }
    
      //public GetFsmNode(this node : GeneralTree[FsmState]) : GeneralTree[FsmNode]
    //{
    //  node.Value.statemap.GetNode(node)
    //}
    
    //public HaveFinalCompletion() : bool
    //{
    //  def st = SuperStatesInclude;
    //  HaveFinal && st.Exists(x => !x.completion_transitions.IsEmpty())
    //}


    //public FinalStates : IEnumerable[FsmState]
    //{
    //    sub_regions.Select(x => x.FinalSubState.Value) else Enumerable.Empty()
    //}

    /// <summary>
    /// Events for which reacts state or nested states
    /// </summary>
    public events_nested(this node : GeneralTree[FsmState]) : IEnumerable[StateEvent]
    {
      def evts = node.AllLivedSubStates().SelectMany(x => x.Value.events);
      evts.Distinct()
    }

    public PartOfRegionsOf(this node : GeneralTree[FsmState], st : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.SuperStatesInclude().NToList().FirstElems(_ == st : object).Where(x => x.Value is FsmState.ConcurrentRegion)
    }
    
    public SuperStatesInclude(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    {
      node.SuperStates().AddBefore(node)
    }

    public PartOfStateMachine(this node : GeneralTree[FsmState]) : option[GeneralTree[FsmState]]
    {
      node.SuperStatesInclude().Find(x => x.Value is FsmState.InlinedSubMachine)
    }

    //public AllPseudo(this node : GeneralTree[FsmState])  : IEnumerable[PseudoStateNode]
    //{
    //    node.AllStates().SelectMany(_.ChildPseudo)
    //}

    //public AllHistory : IEnumerable[PseudoStateNode.History]
    //{
    //  get
    //  {
    //    AllSubStates.SelectMany(x => x.history.Value)
    //  }
    //}

    //public PartOfSubRegions(this node : GeneralTree[FsmState]) : IEnumerable[GeneralTree[FsmState]]
    //{
    //    node.SuperStatesInclude().Where(x => x.Value is FsmState.)
    //}

    //public PartOfTopRegion : option[ConcurrentRegion]
    //{
    //  get
    //  {
    //    match (PartOfRegions)
    //    {
    //      | []  => None()
    //      | lst => Some(lst.Last())
    //    }
    //  }
    //}

    //public PartOfRegion : option[ConcurrentRegion]
    //{
    //  get
    //  {
    //    SuperStatesInclude.FindType()
    //  }
    //}

    //public PartOfRegions : IEnumerable[ConcurrentRegion]
    //{
    //  get
    //  {
    //    SuperStatesInclude.FilterType()
    //  }
    //}    
  }
  
  module PseudoStateFuncs
  {
        public GetName(this node : NodeValue[FsmState, PseudoStateNode]) : string
        {
          def state = node.Parent;
          def state_val = state.Value;
          match (node.Value)
          {
            | PseudoStateNode.History(type = t) => 
            
              def type = match (t)
                          {
                            | HistoryType.Deep     => "Deep"
                            | Shallow              => "Shallow"
                            | None                 => ""
                          }

              
              if (state.History().IsOne) $"$(state_val)History" else $"$(state_val)$(type)History"
              
           | PseudoStateNode.Terminate => $"$(state_val)Terminate"
           | n                         => n.ToString()
           //| FsmNode.State(st)                                => st.Value.Name
           //| FsmNode.PseudoState(n)                           => n.ToString()
          }
        }

        public SimpleName(this node : NodeValue[FsmState, PseudoStateNode]) : string
        {
          def state = node.Parent.Value;
          match (node.Value)
          {
            | PseudoStateNode.History => $"$(state)History"
            | _                       => null
          }
        }
        
        
  }
}

