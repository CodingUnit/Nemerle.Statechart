using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of FsmStateFuncs.
  /// </summary>
  module FsmStateFuncs
  {

    public IsTopState(this node : SimpleTreeNode[FsmState]) : bool
    {
      node.Parent == null
    }

    public SubRegions(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      if (node.Value is FsmState.ConcurrentRegion) node.Children else Enumerable.Empty()
    }

    public SubStates(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.Children
    }

    /// <summary>
    /// Is it Lived state, consider on nesting lived states
    /// </summary>
    public LivedNested(this node : SimpleTreeNode[FsmState]) : bool
    {
      node.Value.Lived || !node.AllLivedSubStates().IsEmpty()
    }

    /// <summary>
    /// Direct lived substates with consider of nesting state life
    /// </summary>
    public LivedSubStatesNested(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.Children.Where(x => x.LivedNested())
    }

    /// <summary>
    /// All Lived substates with consider of nesting state life on all nesting levels
    /// </summary>
    public AllLivedSubStatesNested(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.GetBreadthFirstEnumerable().Where(_.LivedNested())
        //sub_states.Filter(_.LivedNested) + (sub_states |>< AllLivedSubStatesNested)
    }

    /// <summary>
    /// Direct lived sub states without consider of living nesting states of this substates
    /// </summary>
    public LivedSubStates(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.SubStates().Where(x => x.Value.Lived)
    }

      /// <summary>
    /// All sub states at all nesting levels
    /// </summary>
    public AllSubStates(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.AllStates().Skip(1)
        //sub_states + (sub_states |>< AllSubStates)
    }

    /// <summary>
    /// All sub states include this at all nesting levels
    /// </summary>
    public AllStates(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.GetBreadthFirstEnumerable()
    }

    //public AllPseudoStates : list[PseudoStateNode]
    //{
    //  get
    //  {
    //    pseudo_states + (sub_states |>< AllPseudoStates)
    //  }
    //}

    /// <summary>
    /// All lived sub states
    /// </summary>
    public AllLivedSubStates(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.AllSubStates().Where(x => x.Value.Lived)
    }

    public DefineInitial(this node : SimpleTreeNode[FsmState], st : SimpleTreeNode[FsmState]) : void
    {
      def tran = StateTransition.Initial(node, st);
      node.Update(x => x.ChangeInitial(tran :: x.initial))
    }

        /// <summary>
    /// Sub states included in the history of this state
    /// </summary>
    public SubStatesParticipateInHistory(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.History().Value.SelectMany(x => x.SubStatesParticipateIn())
    }

    public History(this node : SimpleTreeNode[FsmState]) : TwoOption[SimpleTreeNode[FsmNode]]
    {
      def hist = node.Value.analyser.statemap.GetNode(node).Children.FoldLeft([], (x, a) => if (x.Value is FsmNode.PseudoState(PseudoStateNode.History) as n) x :: a else a);
      TwoOption.FromList(hist)
    }

    public SubStatesParticipateIn(this node : SimpleTreeNode[FsmNode]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      match (node.Value)
      {
        | FsmNode.PseudoState(PseudoStateNode.History(type = HistoryType.Deep))     => node.ParentState().AllLivedSubStates()
        | FsmNode.PseudoState(PseudoStateNode.History(type = HistoryType.Shallow))  => node.ParentState().LivedSubStatesNested()
        | _                                                                         => Enumerable.Empty()
      }
    }

    public PartOfRegion(this node : SimpleTreeNode[FsmState]) : option[SimpleTreeNode[FsmState]]
    {
      node.Parents().Find(x => x.Value is FsmState.ConcurrentRegion)
    }

    public PartOfSubRegion(this node : SimpleTreeNode[FsmState]) : option[SimpleTreeNode[FsmState]]
    {
      node.Parents().Find(x => x.Value is FsmState.ConcurrentSubRegion)
    }
    
    ///// <summary>
    ///// History pseudo-states in which participate this state
    ///// </summary>
    public ParticipateInHistory(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmNode]]
    {
      node.Value.analyser.HistoryStates.Where(x => x.SubStatesParticipateIn().Contains(node))
    }

    public SuperStates(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.Parents()
    }

    public SuperStatesFromTop(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      Enumerable.Reverse(node.SuperStates())
    }

    public SuperStatesFromTopInclude(this node : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.SuperStatesFromTop().Append(node)
    }    

    public HaveFinal(this node : SimpleTreeNode[FsmState]) : bool
    {
      match (node.Value)
      {
        | ConcurrentRegion => node.Children.All(x => x.HaveFinal())
        | _                => node.SubStates().Exists(x => x.Value is FsmState.Final)
      }
    }

    public FinalSubState(this node : SimpleTreeNode[FsmState]) : option[SimpleTreeNode[FsmState.Final]]
    {
      node.SubStates().FindType()
    }

        /// <summary>
    /// Transitions defined direct from this state
    /// </summary>
    public this_transitions(this node : SimpleTreeNode[FsmState]) : IEnumerable[StateTransition]
    {
      node.Value.all_transitions.Where(x  => if (x.From.Value is FsmNode.State as st) st.node : object == node else false)
    }

    //public IsSubStateOf(this node : SimpleTreeNode[FsmState], st : SimpleTreeNode[FsmState]) : bool
    //{
    //  node.SuperStates().Exists(_ == st)
    //}

    public Index(this node : SimpleTreeNode[FsmState]) : int
    {
      node.Parent.Children.IndexOf(node)
    }

    public Super(this node : SimpleTreeNode[FsmState]) : SimpleTreeNode[FsmState]
    {
      node.Parent
    }

        //[TraverseIgnore] 
        //[NeedChange(index)] 
    public ContainedIn(this node : SimpleTreeNode[FsmState]) : SimpleTreeNode[FsmState]
    {
      node.Super()
    }

    public static all_transitions_nested(this node : SimpleTreeNode[FsmState]) : IEnumerable[StateTransition]
    {
      node.GetBreadthFirstEnumerable().SelectMany(x => x.Value.all_transitions_with_init)
    }
              /// <summary>
          /// Indicates that maybe external transitions from some points of orthogonal state out of region not only completion
          /// </summary>
    public MayTakePlaceForcedTransitions(this node : SimpleTreeNode[FsmState]) : bool 
    {
      node.all_transitions_nested().Exists(_.OutOfRegion)
    }

    public NeedHistorySave(this node : SimpleTreeNode[FsmState]) : bool
    {
      !node.ParticipateInHistory().IsEmpty()
    }

    public get_pattern(reg : IEnumerable[SimpleTreeNode[FsmState]]) : string
    {
      def idx = reg.Select(x => x.Index()).OrderBy(x => x).NToList();
      $<#..$(idx;"")#>
    }


    public RegionExcept(this node : SimpleTreeNode[FsmState], st : IEnumerable[SimpleTreeNode[FsmState]]) : SimpleTreeNode[FsmState]
    {
      match (node.SubRegions().Except(st))
      {
        | [sub]     => sub
        | head :: _ => head
        | _         => null
      }
    }

    public RegionsExcept(this node : SimpleTreeNode[FsmState], st : IEnumerable[SimpleTreeNode[FsmState]]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.SubRegions().Where(x => !x.AllSubStates().Exists(y => st.Exists(y : object == _)) && !st.Exists(_ == x : object))
    }

    public RegionsExcept(this node : SimpleTreeNode[FsmState], st : SimpleTreeNode[FsmState]) : IEnumerable[SimpleTreeNode[FsmState]]
    {
      node.SubRegions().Where(x => !x.AllSubStates().Contains(st) && x : object != st)
    }

    public GetPseudo(this tran : IEnumerable[StateTransition], is_pseudo : PseudoStateNode -> bool) : IEnumerable[FsmNode.PseudoState]
    {
      def get_pseudo(t, lst)
      {
        match (t)
        {
          | StateTransition(To = TransitionTarget.PseudoState(SimpleTreeNode(Value = FsmNode.PseudoState(j) as t))) when (is_pseudo(j)) => t :: lst
          | _                                                                                                                           => lst
        }
      }

      tran.FoldLeft([], get_pseudo).Distinct()
    }

    public Joins(this node : SimpleTreeNode[FsmState]) : IEnumerable[FsmNode.PseudoState]
    {
      node.AllLivedSubStatesNested().SelectMany(x => x.Value.all_transitions.GetPseudo(_ is PseudoStateNode.Join))
    }

    public HaveJoinTransitions(this node : SimpleTreeNode[FsmState]) : bool
    {
      !node.Joins().IsEmpty()
    }

    public GetFsmNode(this node : SimpleTreeNode[FsmState]) : SimpleTreeNode[FsmNode]
    {
      node.Value.statemap.GetNode(node)
    }
    
    //public HaveFinalCompletion() : bool
    //{
    //  def st = SuperStatesInclude;
    //  HaveFinal && st.Exists(x => !x.completion_transitions.IsEmpty())
    //}


    //public FinalStates : IEnumerable[FsmState]
    //{
    //    sub_regions.Select(x => x.FinalSubState.Value) else Enumerable.Empty()
    //}

  }
  
  module PseudoStateFuncs
  {
        public GetName(this node : SimpleTreeNode[FsmNode]) : string
        {
          def state = node.ParentState();
          def state_val = state.Value;
          match (node.Value)
          {
            | FsmNode.PseudoState(PseudoStateNode.History(type = t)) => 
            
              def type = match (t)
                          {
                            | HistoryType.Deep     => "Deep"
                            | Shallow              => "Shallow"
                            | None                 => ""
                          }

              
              if (state.History().IsOne) $"$(state_val)History" else $"$(state_val)$(type)History"
              
           | FsmNode.PseudoState(PseudoStateNode.Terminate()) => $"$(state_val)Terminate"
           | FsmNode.State(st)                                => st.Value.Name
           | FsmNode.PseudoState(n)                           => n.ToString()
          }
        }

        public SimpleName(this node : SimpleTreeNode[FsmNode]) : string
        {
          def state = node.ParentState().Value;
          match (node.Value)
          {
            | FsmNode.PseudoState(PseudoStateNode.History) => $"$(state)History"
            | _                                            => null
          }
        }
  }
}

