using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PathNode;
  using TransitionDestination;
  using TransitionTarget;
  using FsmState;

  [Record]
  public class PathSequence
  {
    [NeedChange]
    public path : list[PathNode] = [];

    public this() {}

    public Add(node : PathNode) : PathSequence
    {
      ChangePath(node :: path)
    }

    public Add(nodes : IEnumerable[PathNode]) : PathSequence
    {
      ChangePath(path.HeadAppend(nodes))
    }

    public Path : IEnumerable[PathNode]
    {
      get
      {
        path.Rev()
      }
    }
  }

  /// <summary>
  /// Transition Path
  /// </summary>
  public partial class TransitionPath
  {
    [Accessor]
    mutable path : PathSequence = PathSequence();
    public recursive : bool;
    public traverser : TransitionTraverser;

    [Accessor]
    mutable transition : NodeValue[FsmState, StateTransition];
    public analyser : FsmAnalyser;

    AddNode(node : PathNode) : void
    {
      path = path.Add(node)
    }

    AddNode(node : IEnumerable[PathNode]) : void
    {
      path = path.Add(node)
    }

#if 0        
    TraverseChoice(j : NodeValue[FsmState, PseudoStateNode], tran : StateTransition) : TransitionDestination
    {
      match (j.Value)
      {
      | PseudoStateNode.Junction(tree = t) =>
          def jst = j.Parent;  
          DefPath(tran.From.StateDecl, jst);
          def exit = ExitNodeCreate(TraverseUtils.SingleElement(jst));
          AddNode(exit);
          def init_path = path;
          //path = Empty();



          def create_targ_tree(t, pst)
          {
            match (t.Data)
            {
              | TreeJunctionNode.Node(junc = j) =>
                def st = j.Parent;
                def node_path = GetPath(pst, st, true, jst);
                t.Update(x => x.ChangeNodePathOutPath(node_path, Enumerable.Empty()));
                st

            | TreeJunctionNode.Target(target = tar, junc = j) as tt=>

                def st = j.Parent;
                path = init_path;
                def node_path = GetPath(pst, st, true, jst);
                DefPath(st, tar.ToState, true, jst);
                def dest = TraverseTargetReg(tar, tran);
                def out_path = path.Path;
                t.Data = tt.ChangeDestOutPathNodePath(dest, out_path, node_path); 
                st
              }

          }

          traverser?.Log($"\nTraversing choice node $j");
          _ = t.GetBreadthFirstEnumerable().Fold(jst, create_targ_tree);//Reduce(j.state, (t, _, _, a) => create_tree_node(t, a), create_targ_tree);
          path = init_path;
          ChoiceNode(t)

          | _ => ()
        }
    }

    TraverseJunction(j : PseudoStateNode.Junction, tran : StateTransition) : TransitionDestination
    {
      //| (PseudoStateNode.Junction(to = jn), _) =>
        //TraverseJunctionNode(j.to, tran, j)
        null
    }


    TraverseJunctionNode(j : TransitionTarget.JunctionNode, junc : PseudoStateNode.Junction) : TransitionDestination
    {
      | (JunctionNode(decisionTree = t), PseudoStateNode.Junction(state = jst)) =>

          def init_path = path;

          def create_targ_tree(t)
          {
            | DecisionNode.Target(target = tar, state = st) as t =>
                  path = init_path;
                  def node_path = init_path.Add(GetPath(jst, st, true, jst));
                  DefPath(st, tar.ToState, true, jst);
                  def dest = TraverseTargetReg(tar, transition);
                  def out_path = path.Path;
                  t.ChangeDestinationOutPathNodePath(dest, out_path, node_path.Path)
          }

          traverser?.Log($"\nTraversing junction node $j");
          def dest_tree = t.Reduce(target = create_targ_tree);
          JunctionNode(dest_tree)

    }

    TraverseJunctionNode(j : TransitionTarget.JunctionNode, tran : StateTransition, junc : PseudoStateNode.Junction) : TransitionDestination
    {
          def jst = junc.state;
          DefPath(tran.From, jst);
          def exit = ExitNodeCreate(TraverseUtils.SingleElement(jst));
          AddNode(exit);
          def path = TransitionPath(tran, analyser, recursive);
          path.TraverseJunctionNode(j, junc);
    }



    TraverseMerge(j : PseudoStateNode.Junction, tr : StateTransition) : TransitionDestination
    {
      null
      //| (PseudoStateNode.Junction(to = TransitionTarget.JunctionNode(guard = g, action = a, to = t)), _) =>

      //    match (g)
      //    {
      //      | GuardNode.Empty => ()
      //      | g               => transition = transition.AddCheck(CheckNode.Guard([g]));
      //    }
      //    match (a)
      //    {
      //      | Some(a) => AddNode(Action(a))
      //      | _       => ()
      //    }

      //    DefPath(j.state, t.ToState);
      //    TraverseTargetReg(t, tr)
    }
#endif

    TraversePseudo(st : NodeValue[FsmState, PseudoStateNode], tr : NodeValue[FsmState, StateTransition]) : TransitionDestination
    {
      match (st.Value)
      {
        | History                                     => TraverseHistory(st)
        | Terminate                                   => tr.Used(true);
                                                        Terminate(st)
        | Fork(target = t)                            => TraverseFork(st, t)
        //| Junction(type = JunctionType.Choice) as j   => TraverseChoice(j, tr)
        //| Junction(type = JunctionType.Merge)  as m   => TraverseMerge(m, tr)
        //| Junction as j                               => TraverseJunction(j, tr)
        | _                                           => Unknown()
      }
    }
    /// <summary>
    /// Processing final state node
    /// </summary>
    TraverseFinal(st : GeneralTree[FsmState]) : TransitionDestination
    {
      def reg = st.PartOfRegion();
      def sr = st.PartOfSubRegion();
      match (st.Data, reg, sr)
      {
        | (FsmState.Final, Some(r), Some(sr)) =>
          def tran = st.CompletionTransitions();
          match (tran.NToList())
          {
            | []   => traverser?.Log($"\nEntering in final state $st of Region ($r:$sr) and live in it");
                      State(st)
            | tran =>
                //st.Completion = tran;
                traverser?.Log($"\nEntering in final state $st of Region ($r:$sr) transitions ..$tran may happen");
                traverser?.Add(tran);
                TransitionDestination.Final(st, sr, r, tran)
          }

        // if we not have completion transition and transitions from this or upper states, final state must recognised as terminate node
        | (Final, _, _) when (st.CompletionTransitions().IsEmpty() && st.Transitions().IsEmpty()) => Terminate(NodeValue(st.Parent, PseudoStateNode.Terminate(0)))

        | (Final, _, _) =>
          def tran = st.CompletionTransitions();
          def history = st.ParticipateInHistory();
          def hist_clear = ClearHistory(history.NToList()); // create clear history node
          traverser?.Log($"\nEntering in final state $st");
          // find completion transition
          match (tran.NToList())
          {
            | []                                  => 
              traverser?.Log("..and live in it");
              State(st)
                  // if have completion transition without guard
            | [NodeValue(Value = Transition(Guard = None)) as tran] as tr =>
                  // if not defined transition path create it
                traverser?.Log($"..and pass it by completion transition $tran");
                traverser?.Add(tr);
                AddNode(hist_clear); // get nodes and add to path
                TransitionExecute(tran)
                  // if we have transition list
            | tran                                =>
                AddNode(hist_clear); // add node
                traverser?.Add(tran);
                traverser?.Log($"..and pass it by completion transitions ..$tran");
                Choice(st.Parent, tran.NToList(), Some(st))
          }

        | _ => null
      }
    }


    TraverseHistory(hist : NodeValue[FsmState, PseudoStateNode]) : TransitionDestination
    {
      match (hist.Value)
      {
        | PseudoStateNode.History(default = tran) =>
            tran.Iter(traverser?.Add);
            hist.Used(true);
            History(hist)
        | _ => null
      }
    }

    //TraverseSubMachine(fsm : FsmState.SubMachine, state : string) : TransitionDestination
    //{
    //  def fsm = fsm.ChangeLived(true);
    //  TransitionDestination.SubMachine(fsm, state)
    //}

    TraverseDefaultTransition(tran : NodeValue[FsmState, StateTransition]) : TransitionDestination
    {
      match (tran.Value)
      {
        | Default(history = hist, From = from) as tr =>
          DefPath(tran.Parent, from, tran); // unwind path from Source up to transition begining (From)
          def st = tr.ToState;
          when (st == null) throw FsmErrorException(FsmError.DefaultTransitionMustGoToState(tran, hist));
          tran.Used(true);
          TraverseTargetReg(tr.To, tran)
          //match (hist, st.history.Value.Find(x => x.type == HistoryType.Deep))
          //{
          //  | (PseudoStateNode.History(type = HistoryType.Deep), Some(PseudoStateNode.History(default = t, type = HistoryType.Deep) as h)) =>
          //      when (t is Some(tr)) traverser?.Add(tr);
          //      History(h)

          //  | _ => TraverseTargetReg(tr.To, tr)
          //}
        | _ => null
      }
    }

    TraverseOrdinaryTransition(tran : NodeValue[FsmState, StateTransition]) : TransitionDestination
    {
      DefPath(tran.Parent, tran.Value.From, tran); // unwind path from Source up to transition begining (From)
      tran.Used(true);
      TraverseTargetReg(tran.Value.To, tran)
    }

    TraverseHistoryPath(tran : NodeValue[FsmState, StateTransition]) : TransitionDestination
    {
      match (tran.Value)
      {
        | StateTransition.History(From = from, history = hist, ToState = st) =>

          def src = tran.Parent;
          //def tran = if (tr.From == null) tr.ChangeFrom(tr.From) else tran;
          DefPath(src, from, tran); // unwind path from Source up to transition begining (From)
          tran.Used(true);
          if (st.Data is ConcurrentRegion) HistoryRestore(hist) 
          else TraverseStateTarget(st);
        | _ => null
      }
    }

    TraverseInitialTransition(tran : NodeValue[FsmState, StateTransition]) : TransitionDestination
    {
      DefPath(tran.Parent, tran.Value.From, tran); // unwind path from Source up to transition begining (From)
      tran.Used(true);
      TraverseTarget(tran.Value.To, tran)
    }

    TraverseStateTarget(st : GeneralTree[FsmState]) : TransitionDestination
    {
      match (st.Data)
      {
        // transition to region
        | ConcurrentRegion      => TraverseOrthogonalRegion(st)
        | Final                 => TraverseFinal(st)
        | _ => match (st.InitialTransitions().NToList())// with (initial = [Initial(guard = None) as init]) => 
            {
              // if simple state and no initial transition
              | [] => traverser?.Log($"\nEntering state $st and live in it");
                      st.Lived(true);
                      traverser?.Add(st);
                      State(st) // end state
                // if state with one initial transition without Guard
              | [NodeValue(Value = Initial(guard = None)) as init] =>
        // check initial transition path, and traverse it if it null
      // TODO: !!! update initial transition in fsm state from destination
                  traverser?.Log($"\nEntering state $st and pass through initial transition $init");
                  traverser?.Add(init);
                  TransitionExecute(init)

              | init => 
                  traverser?.Log($"\nEntering state $st and pass through several initial transitions ..$init");
                  traverser?.Add(init);
                  init.Iter(x => x.Used(true));
                  Choice(st, init, None()); // creating dynamic choice node
            }
      }
    }

    TraverseTarget(to : TransitionTarget, tr : NodeValue[FsmState, StateTransition]) : TransitionDestination
    {
      match (to)
      {
        | State(state = st) => TraverseStateTarget(st)
          // if target is orthogonal state
        | Final(state = st) => TraverseFinal(st) // process final node
        | PseudoState(node = st)   => TraversePseudo(st, tr)
        //| SubMachine(m, s)  => TraverseSubMachine(m, s)
        | _                 => Unknown()
      }
    }

    TraverseTargetReg(to : TransitionTarget, tr : NodeValue[FsmState, StateTransition]) : TransitionDestination
    {
      match (to)
      {
        | TransitionTarget(PartOfSubRegion = Some(r)) when (!tr.Value.WithinRegion) => TraverseSubRegion(r, to, tr)
        | _                                                                         => TraverseTarget(to, tr)
      }
    }

    TraverseTransition(tran : NodeValue[FsmState, StateTransition]) : TransitionDestination
    {
      match (tran.Value)
      {
        | Internal                                => tran.Used(true);
                                                  NoStateChange()
        | Default                                 => TraverseDefaultTransition(tran)
        | Initial                                 => TraverseInitialTransition(tran)
        | History                                 => TraverseHistoryPath(tran)
          // if not exit from region
        | Transition(WithinRegion = true)         => TraverseWithinRegionTransition(tran)
          // if go to join pseudo state
        | Transition(To = TransitionTarget.PseudoState(node = NodeValue(Value = Join) as j)) => TraverseJoinTransition(j, tran)
          // if from state in orthogonal region, and transition begins in orthogonal regions boundary or upper
        | _ 
                                                  => 
            if (tran.Parent.PartOfSubRegion() is Some(r))
              TraverseTransitionFromRegion(r, tran) else TraverseOrdinaryTransition(tran)
                                                // else ordinary transition
      }
    }

    /// <summary>
    /// Traversing path
    /// </summary>
    //rec : bool = false
    public Traverse() : void
    {
      def check_actual_to(to)
      {
        | SubRegion(state = st)
        | ForceStateChange(st)                   => check_actual_to(st)
        | Choice(_, _, Some(st))
        | Final(state = st)
        | State(st)                              =>
                                                st.Lived(true);
                                                when (recursive) traverser?.Add(st);
                                                st
        | Terminate(NodeValue(Parent =  st))
        | Region(st)
        | Choice(st, _, _)                       => st
        | _                                      => null
      }


      //recursive = rec;
      def to = TraverseTransition(transition); // traversing transition
      traverser?.Log($"transition: $transition destination:$to");
      def actual = check_actual_to(to);

      transition.Update(x => x.ChangeDestinationActualToPath(to, actual, this));
    }

    public this(tran : NodeValue[FsmState, StateTransition], rec : bool = false)
    {
      recursive = rec;
      transition = tran;
      this.analyser = tran.Value.analyser;
      traverser = analyser.Traverser;
    }

    public Actions : IEnumerable[string]
    {
      get
      {
        path.Path.PathActions()
      }
    }
  }

}
