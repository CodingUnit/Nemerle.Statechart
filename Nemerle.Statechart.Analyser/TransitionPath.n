using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PathNode;
  using TransitionDestination;
  using TransitionTarget;
  using FsmState;

  [Record]
  public class PathSequence
  {
    [NeedChange]
    public path : list[PathNode] = [];

    public this() {}

    public Add(node : PathNode) : PathSequence
    {
      ChangePath(node :: path)
    }

    public Add(nodes : IEnumerable[PathNode]) : PathSequence
    {
      ChangePath(path.HeadAppend(nodes))
    }

    public Path : IEnumerable[PathNode]
    {
      get
      {
        path.Rev()
      }
    }
  }

  /// <summary>
  /// Transition Path
  /// </summary>
  public partial class TransitionPath
  {
    [Accessor]
    mutable path : PathSequence = PathSequence();
    public recursive : bool;
    public traverser : TransitionTraverser;

    [Accessor]
    mutable transition : StateTransition;
    public analyser : FsmAnalyser;

    AddNode(node : PathNode) : void
    {
      path = path.Add(node)
    }

    AddNode(node : IEnumerable[PathNode]) : void
    {
      path = path.Add(node)
    }

    TraverseChoice(j : PseudoStateNode.Junction, tran : StateTransition) : TransitionDestination
    {
      | (PseudoStateNode.Junction(to = TransitionTarget.JunctionNode(decisionTree = t), state = jst), _) =>

          DefPath(tran.From, jst);
          def exit = ExitNodeCreate(TraverseUtils.SingleElement(jst));
          AddNode(exit);
          def init_path = path;
          //path = Empty();

          def create_tree_node(t)
          {
              | DecisionNode.Condition(state = st, PrevState = pst) =>
                def node_path = GetPath(pst, st, true, jst);
                t.ChangeNodePathOutPath(node_path, Enumerable.Empty())
          }

          def create_targ_tree(t)
          {
            | DecisionNode.Target(target = tar, state = st, PrevState = pst) as t =>

                path = init_path;
                def node_path = GetPath(pst, st, true, jst);
                DefPath(st, tar.ToState, true, jst);
                def dest = TraverseTargetReg(tar, tran);
                def out_path = path.Path;
                t.ChangeDestinationOutPathNodePath(dest, out_path, node_path)
          }

          traverser?.Log($"\nTraversing choice node $j");
          def dest_tree = t.Reduce((t, _, _) => create_tree_node(t), create_targ_tree);
          path = init_path;
          ChoiceNode(dest_tree)
    }

    TraverseJunction(j : PseudoStateNode.Junction, tran : StateTransition) : TransitionDestination
    {
      //| (PseudoStateNode.Junction(to = jn), _) =>
        TraverseJunctionNode(j.to, tran)
    }

    TraverseJunctionNode(j : TransitionTarget.JunctionNode) : TransitionDestination
    {
      | JunctionNode(decisionTree = t, state = jst) =>

          def init_path = path;

          def create_targ_tree(t)
          {
            | DecisionNode.Target(target = tar, state = st) as t =>
                  path = init_path;
                  def node_path = init_path.Add(GetPath(jst, st, true, jst));
                  DefPath(st, tar.ToState, true, jst);
                  def dest = TraverseTargetReg(tar, transition);
                  def out_path = path.Path;
                  t.ChangeDestinationOutPathNodePath(dest, out_path, node_path.Path)
          }

          traverser?.Log($"\nTraversing junction node $j");
          def dest_tree = t.Reduce(target = create_targ_tree);
          JunctionNode(dest_tree)

    }

    TraverseJunctionNode(j : TransitionTarget.JunctionNode, tran : StateTransition) : TransitionDestination
    {
      | (JunctionNode(state = jst), _) =>
      
          def jst = jst.Updated;
          DefPath(tran.From.Updated, jst);
          def exit = ExitNodeCreate(TraverseUtils.SingleElement(jst));
          AddNode(exit);
          def path = TransitionPath(tran, analyser, recursive);
          path.TraverseJunctionNode(j);
    }

    TraverseMerge(j : PseudoStateNode.Merge, tr : StateTransition) : TransitionDestination
    {
      | (PseudoStateNode.Merge(to = TransitionTarget.JunctionNode(guard = g, action = a, to = t)), _) =>

          match (g)
          {
            | GuardNode.Empty => ()
            | g               => transition = transition.AddCheck(CheckNode.Guard([g]));
          }
          match (a)
          {
            | Some(a) => AddNode(Action(a))
            | _       => ()
          }

          DefPath(j.state, t.ToState);
          TraverseTargetReg(t, tr)
    }

    TraversePseudo(st : PseudoStateNode, tr : StateTransition) : TransitionDestination
    {
      match (st)
      {
        | Terminate  as n                             => transition = tr.ChangeUsed(true);
                                                         Terminate(n)
        | Fork(target = t) as f                       => TraverseFork(f, t)
        | Junction(type = JunctionType.Choice) as j   => TraverseChoice(j, tr)
        | Junction as j                               => TraverseJunction(j, tr)
        | Merge    as m                               => TraverseMerge(m, tr)
        | _                                           => Unknown()
      }
    }
    /// <summary>
    /// Processing final state node
    /// </summary>
    TraverseFinal(st : FsmState) : TransitionDestination
    {
      | FsmState.Final(PartOfRegion = Some(r), PartOfSubRegion = Some(sr), completion_transitions = tran) =>
          match (tran.NToList())
          {
            | []   => traverser?.Log($"\nEntering in final state $st of Region ($r:$sr) and live in it");
              State(st)
            | tran =>
                //st.Completion = tran;
                traverser?.Log($"\nEntering in final state $st of Region ($r:$sr) transitions ..$tran may happen");
                traverser?.Add(tran);
                Final(st, sr, r, tran)
          }

      | Final(Super = parent, completion_transitions = tran) =>

          def history = st.ParticipateInHistory;
          def hist_clear = ClearHistory(history); // create clear history node
          traverser?.Log($"\nEntering in final state $st");
          // find completion transition
          match (tran.NToList())
          {
            | []                                  => 
              traverser?.Log("..and live in it");
              State(st)
                  // if have completion transition without guard
            | [Transition(Guard = None) as tran]  =>
                  // if not defined transition path create it
                traverser?.Log($"..and pass it by completion transition $tran");
                traverser?.Add(tran);
                AddNode(hist_clear); // get nodes and add to path
                TransitionExecute(tran)
                  // if we have transition list
            | tran                                =>
                AddNode(hist_clear); // add node
                traverser?.Add(tran);
                traverser?.Log($"..and pass it by completion transitions ..$tran");
                Choice(parent, tran, Some(st))
          }

      | _ => null
    }


    TraverseHistory(hist : StateHistory) : TransitionDestination
    {
      | StateHistory(default = Some(Default as tran)) =>
          traverser?.Add(tran);
          History(hist)
      | _  =>
          History(hist)
    }

    TraverseSubMachine(fsm : FsmState.SubMachine, state : string) : TransitionDestination
    {
      def fsm = fsm.ChangeLived(true);
      TransitionDestination.SubMachine(fsm, state)
    }

    TraverseDefaultTransition(tran : StateTransition.Default) : TransitionDestination
    {
      | Default(history = hist, Source = src, From = from) =>

          DefPath(src, from, tran); // unwind path from Source up to transition begining (From)
          def st = tran.ToState;
          when (st == null) throw FsmErrorException(FsmError.DefaultTransitionMustGoToState(tran, hist));
          transition = tran.ChangeUsed(true);
          match (hist, st.history.Value.Find(_ is StateHistory.Deep))
          {
            | (StateHistory.Deep, Some(StateHistory.Deep(default = t) as h)) =>
                when (t is Some(tr)) traverser?.Add(tr);
                History(h)

            | _ => TraverseTargetReg(tran.To, tran)
          }
    }

    TraverseOrdinaryTransition(tran : StateTransition) : TransitionDestination
    {
      DefPath(tran.Source, tran.From, tran); // unwind path from Source up to transition begining (From)
      transition = tran.ChangeUsed(true);
      TraverseTargetReg(tran.To, tran)
    }

    TraverseHistoryPath(tran : StateTransition.History) : TransitionDestination
    {
      | History(From = from, Source = src, history = hist, ToState = st) =>

          def tran = if (tran.Source == null) tran.ChangeSource(tran.From.Updated) else tran;
          DefPath(src, from, tran); // unwind path from Source up to transition begining (From)
          transition = tran.ChangeUsed(true);
          if (st is ConcurrentRegion) HistoryRestore(hist) 
          else TraverseStateTarget(st.Updated);
    }

    TraverseInitialTransition(tran : StateTransition.Initial) : TransitionDestination
    {
      DefPath(tran.Source, tran.From, tran); // unwind path from Source up to transition begining (From)
      transition = tran.ChangeUsed(true);
      TraverseTarget(tran.To, tran)
    }

    TraverseStateTarget(st : FsmState) : TransitionDestination
    {
        // transition to region
      | ConcurrentRegion as r => TraverseOrthogonalRegion(r)
      | Final as st           => TraverseFinal(st)
        // if simple state and no initial transition
      | FsmState(initial = []) as st => 
         traverser?.Log($"\nEntering state $st and live in it");
         def st = st.ChangeLived(true);
         traverser?.Add(st);
         State(st) // end state
          // if state with one initial transition without Guard
      | FsmState(initial = [Initial(guard = None) as init])  => 
          // check initial transition path, and traverse it if it null
      // TODO: !!! update initial transition in fsm state from destination
          traverser?.Log($"\nEntering state $st and pass through initial transition $init");
          traverser?.Add(init);
          TransitionExecute(init)

      | FsmState(initial = init) as st  => 
          traverser?.Log($"\nEntering state $st and pass through several initial transitions ..$init");
          traverser?.Add(init);
          def init = init.Map(_.ChangeUsed(true));
          Choice(st, init, None()); // creating dynamic choice node
    }

    TraverseTarget(to : TransitionTarget, tr : StateTransition) : TransitionDestination
    {
      match (to)
      {
        | State(st)         => TraverseStateTarget(st.Updated)
          // if target is orthogonal state
        | Final(st)         => TraverseFinal(st.Updated) // process final node
        | History(st)       => TraverseHistory(st) // process history node
        | PseudoState(st)   => TraversePseudo(st, tr)
        | SubMachine(m, s)  => TraverseSubMachine(m, s)
        | JunctionNode as t => TraverseJunctionNode(t, tr)
        | _                 => Unknown()
      }
    }

    TraverseTargetReg(to : TransitionTarget, tr : StateTransition) : TransitionDestination
    {
      match (to)
      {
        | TransitionTarget(PartOfSubRegion = Some(r)) when (!transition.WithinRegion) => TraverseSubRegion(r.Updated, to, tr)
        | _                                                                           => TraverseTarget(to, tr)
      }
    }

    TraverseTransition(tran : StateTransition) : TransitionDestination
    {
      | Internal                                => transition = tran.ChangeUsed(true);
                                                   NoStateChange()
      | Default as tr                           => TraverseDefaultTransition(tr)
      | Initial as tr                           => TraverseInitialTransition(tr)
      | History as tr                           => TraverseHistoryPath(tr)
          // if not exit from region
      | Transition(WithinRegion = true)         => TraverseWithinRegionTransition(tran)
          // if go to join pseudo state
      | Transition(To = PseudoState(Join as j)) => TraverseJoinTransition(j, tran)
          // if from state in orthogonal region, and transition begins in orthogonal regions boundary or upper
      | Transition(Source = FsmState(PartOfSubRegion = Some(r))) 
                                                => TraverseTransitionFromRegion(r, tran)
                                                // else ordinary transition
      | _                                       => TraverseOrdinaryTransition(tran)
    }

    /// <summary>
    /// Traversing path
    /// </summary>
    //rec : bool = false
    public Traverse() : void
    {
      def check_actual_to(to)
      {
        | SubRegion(state = st)
        | ForceStateChange(st)                   => check_actual_to(st)
        | Choice(_, _, Some(st))
        | Final(state = st)
        | State(st)                              =>
                                                def st = st.ChangeLived(true);
                                                when (recursive) traverser?.Add(st);
                                                st
        | Terminate(PseudoStateNode(state = st)) 
        | Region(st)
        | Choice(st, _, _)                       => st
        | _                                      => null
      }


      //recursive = rec;
      def to = TraverseTransition(transition); // traversing transition
      traverser?.Log($"transition: $transition destination:$to");
      def actual = check_actual_to(to);
      transition = transition.ChangeDestinationActualTo(to, actual);
    }

    public this(tran : StateTransition, analyser : FsmAnalyser, rec : bool = false)
    {
      recursive = rec;
      transition = tran;
      this.analyser = analyser;
      traverser = analyser.Traverser;
    }

    public Actions : IEnumerable[string]
    {
      get
      {
        path.Path.PathActions()
      }
    }
  }

}
