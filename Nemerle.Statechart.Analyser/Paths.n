using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;


namespace Nemerle.Statechart
{

  using FsmState;

  [Record]
  public variant PathNode
  {
    //| Empty
    //| Sequence {seq : IEnumerable[PathNode];}
    | Entry
      {
        action : FsmAction;
        //inline : list[PathNode * bool] = [];
        state  : FsmState;
        
        //this (action : Actions)
        //{
        //  this.action = action;
        //}

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }

      }

    | Exit
      {
        action : FsmAction;
        //inline : list[PathNode * bool] = [];
        state  : FsmState;
        
        //this (action : Actions)
        //{
        //  this.action = action;
        //}

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }


      }

    | Action
      {
        action : FsmAction;

        override ToString() : string {$"PathNode+Action$(action)"}
      }
    | ClearHistory
      {
        history : list[PseudoStateNode.History];

        override ToString() : string {$"PathNode+ClearHistory$history"}
      }
    | SaveHistory
      {
        history : list[PseudoStateNode.History];

        override ToString() : string {$"PathNode+SaveHistory$history"}
      }

    | RunDoActivity
      {
        activity : StateAction.Do;

        state : FsmState;
        override ToString() : string {$"DoActivity$(state)Run"}
      }

    | StopDoActivity
      {
        activity : StateAction.Do;

        state : FsmState;
        override ToString() : string {$"DoActivity$(state)Stop"}
      }
    //| RegionExit
    //  {
    //    states_in : IEnumerable[FsmState];
    //    region : FsmState;

    //    override ToString() : string {$"RegionExit$(region)In$states_in"}
    //  }

    public PathAction : option[FsmAction]
    {
      get
      {
        match (this)
        {
          | Entry(action = act)
          | Exit(action = act)
          | Action(action = act)  => Some(act)
          | _                     => None()
        }
      }
    }

    public static PathActions(this path : IEnumerable[PathNode]) : IEnumerable[FsmAction]
    {
      path.FilterValues(_.PathAction)
      //path.SelectMany(_.Actions)
    }

  }

  public variant CheckNode
  {
    | Empty
    | Sequence {nodes : list[CheckNode];}
    | RegionStates {states : list[FsmState];}
    | Join {join : PseudoStateNode;tran : StateTransition;}
    | Guard {tran : list[GuardNode];}

    public static @+(a : CheckNode, b : CheckNode) : CheckNode
    {
      | (Sequence(a), Sequence(b)) => Sequence(a.Concat(b).NToList())
      | (Sequence(a), b)           => Sequence(a.Append(b).NToList())
      | (a, Sequence(b))           => Sequence(b.AddBefore(a).NToList())
      | (a, b)                     => Sequence(TraverseUtils.DoubleElement(a, b).NToList())
    }

  }


  /// <summary>
  /// Description of TransitionPath.
  /// </summary>
  [Record]
  public class TransitionPaths
  {
    public Paths : list[StateEvent * TransitionPath] {get;set;default []}
    public State : FsmState;

    public this(st : FsmState)
    {
      State = st
    }

    public TraverseTransitions(recursive : bool = false) : void
    {
      def trans = State.transitions.Exclude(x => x.Used || x.IsCompletion);
      trans.Iter(x => x.TraversePath(recursive));
      def paths = trans.Map(x => (x.Trigger, x.Path));
      //this.paths = paths;
      Paths = paths
    }

    //public Actions : IEnumerable[FsmAction]
    //{
    //  get
    //  {
    //    def act = Paths.Split()[1].SelectMany(x => x.Actions);
    //    act.Distinct()
    //  }
    //}

    //public ActionNodes : IEnumerable[PathNode]
    //{
    //  get
    //  {
    //    Paths.Split()[1].SelectMany(x => x.Path.Path)
    //  }
    //}

  }

}
