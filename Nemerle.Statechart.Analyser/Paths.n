using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{

  using FsmState;

  [Record]
  public variant PathNode
  {
    | Empty
    | Sequence {seq : list[PathNode];}
    | Entry
      {
        action : StateAction.Entry;
        inline : list[PathNode * bool] = [];

        this (action : StateAction.Entry)
        {
          this.action = action;
        }

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }

      }

    | Exit
      {
        action : StateAction.Exit;
        inline : list[PathNode * bool] = [];

        this (action : StateAction.Exit)
        {
          this.action = action;
        }

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }


      }

    | Action
      {
        actions : Actions;

        override ToString() : string {$"PathNode+Action$(actions)"}
      }
    | ClearHistory
      {
        history : list[StateHistory];

        override ToString() : string {$"PathNode+ClearHistory$history"}
      }
    | SaveHistory
      {
        history : list[StateHistory];

        override ToString() : string {$"PathNode+SaveHistory$history"}
      }

    | RunDoActivity
      {
        activity : StateAction.Do;

        override ToString() : string {$"$(activity)Run"}
      }

    | StopDoActivity
      {
        activity : StateAction.Do;

        override ToString() : string {$"$(activity)Stop"}
      }
    | RegionExit
      {
        states_in : list[ConcurrentSubRegion];
        region : ConcurrentRegion;

        override ToString() : string {$"RegionExit$(region)In$states_in"}
      }

    public static Equals(a : PathNode, b : PathNode) : bool
    {
      | (Sequence(lst), Sequence(lst2)) => lst.Equals(lst2, Equals)
      | (n1, n2) => n1.ToString() == n2.ToString()
    }

    public static Compare(a : PathNode, b : PathNode) : int
    {
      | (Sequence(lst), Sequence(lst2)) => if (lst.Equals(lst2, Equals)) 0 else -1
      | (n1, n2) => string.Compare(n1.ToString(), n2.ToString())
    }

    public static @+(a : PathNode, b : PathNode) : PathNode
    {
      Sequence([a, b])
    }

    public Unsequenced : list[PathNode]
    {
      get
      {
        Fold([], (a, _) => a, (a, t) => if (t is Empty) a else t :: a)
        //match (this)
        //{
        //  | Sequence(lst) => lst |>< Unsequenced
        //  | Empty => []
        //  | x => [x]
        //}
      }
    }

    //public Clone() : PathNode
    //{
    //  PathNode.Sequence(Unsequenced)
    //}

    public Fold[T](init : T, 
                  seq : list[T] * Sequence -> T,
                  node : PathNode -> T) : T
    {

      def stack = SCG.Stack();

      def loop(st, _)
      {
        match (st)
        {
          | Sequence(n) as t => def acc = stack.Pop(n.Length);
              def acc = seq(acc, t);
              stack.Push(acc);
              acc
          | n                => def acc = node(n);
              stack.Push(acc);
              acc
        }
      }

      Iterator.FoldLeft(init, loop)
    }

    public Fold[T](init : T, 
                  seq  : T * Sequence -> T,
                  node : T * PathNode -> T) : T
    {

      def loop(st, acc)
      {
        match (st)
        {
          | Sequence as t => seq(acc, t)
          | n             => node(acc, n)
        }
      }

      Iterator.FoldLeft(init, loop)
    }

    public Iterator : IEnumerable[PathNode]
    {
      get
      {
        def child = SCG.Stack();
        def parent = SCG.Stack();

        def loop()
        {
          if (child.IsEmpty()) () else 
          {
            def curr = child.Pop();
            parent.Push(curr);
            match (curr)
            {
              | Sequence(n)            => foreach (s in n) child.Push(s);loop()
              | n                      => child.Push(n);loop()
            }
          }
        }

        child.Push(this);
        loop();
        parent
      }
    }

    public Actions : list[string]
    {
      get
      {
        def get_act(a, n)
        {
          match (n)
          {
            | Entry(action = act)
            | Exit(action = act)
            | Action(actions = act) => act.ActionList + a
            | _                     => a
          }
        }

        Fold([], (a, _) => a, get_act)
        //match (this)
        //{
        //  | Entry(action = act)
        //  | Exit(action = act)
        //  | Action(actions = act) => act.ActionList
        //  | Sequence(seq)         => seq |>< Actions
        //  | _                     => []
        //}
      }
    }

  }

  public variant CheckNode
  {
    | Empty
    | Sequence {nodes : list[CheckNode];}
    | RegionStates {states : list[FsmState];}
    | Join {join : PseudoStateNode.Join;tran : StateTransition;}
    | Guard {tran : list[GuardNode];}

    public static @+(a : CheckNode, b : CheckNode) : CheckNode
    {
      Sequence([a, b])
    }

  }


  /// <summary>
  /// Description of TransitionPath.
  /// </summary>
  public class TransitionPaths
  {
    [Accessor]
    mutable paths : list[StateEvent * TransitionPath];
    [Accessor]
    state : FsmState;

    public this(st : FsmState)
    {
      state = st;
    }

    public TraverseTransitions(an : FsmAnalyser, recursive : bool = false) : void
    {
      def trans = state.all_transitions.Exclude(_.UsedInGenerate);
      trans.Iter(_.TraversePath(an, recursive));
      def paths = trans |> (Trigger, Path);
      this.paths = paths;
    }

    public Actions : list[string]
    {
      get
      {
        (paths.Split()[1] |>< Actions).RemoveDuplicatesSort((x, y) => x.CompareTo(y))
      }
    }

    public ActionNodes : list[PathNode]
    {
      get
      {
        paths.Split()[1] |> Path
      }
    }

  }

}
