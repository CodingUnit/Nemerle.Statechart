using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{

  using FsmState;

  [Record]
  public variant PathNode
  {
    | Empty
    //| Sequence {seq : IEnumerable[PathNode];}
    | Entry
      {
        action : StateAction.Entry;
        inline : list[PathNode * bool] = [];

        this (action : StateAction.Entry)
        {
          this.action = action;
        }

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }

      }

    | Exit
      {
        action : StateAction.Exit;
        inline : list[PathNode * bool] = [];

        this (action : StateAction.Exit)
        {
          this.action = action;
        }

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }


      }

    | Action
      {
        actions : Actions;

        override ToString() : string {$"PathNode+Action$(actions)"}
      }
    | ClearHistory
      {
        history : IEnumerable[StateHistory];

        override ToString() : string {$"PathNode+ClearHistory$history"}
      }
    | SaveHistory
      {
        history : list[StateHistory];

        override ToString() : string {$"PathNode+SaveHistory$history"}
      }

    | RunDoActivity
      {
        activity : StateAction.Do;

        override ToString() : string {$"$(activity)Run"}
      }

    | StopDoActivity
      {
        activity : StateAction.Do;

        override ToString() : string {$"$(activity)Stop"}
      }
    | RegionExit
      {
        states_in : IEnumerable[ConcurrentSubRegion];
        region : ConcurrentRegion;

        override ToString() : string {$"RegionExit$(region)In$states_in"}
      }

    //public static Equals(a : PathNode, b : PathNode) : bool
    //{
    //  | (Sequence(lst), Sequence(lst2)) => lst.Equals(lst2, Equals)
    //  | (n1, n2)                        => n1.ToString() == n2.ToString()
    //}

    //public static Compare(a : PathNode, b : PathNode) : int
    //{
    //  | (Sequence(lst), Sequence(lst2)) => if (lst.ForAll2(lst2, Equals)) 0 else -1
    //  | (n1, n2)                        => string.Compare(n1.ToString(), n2.ToString())
    //}

    //public static @+(a : PathNode, b : PathNode) : PathNode
    //{
    //  match (a, b)
    //  {
    //    | (Sequence(a), Sequence(b)) => Sequence(a.Concat(b))
    //    | (Sequence(a), b)           => Sequence(a.Append(b))
    //    | (a, Sequence(b))           => Sequence(b.AddBefore(a))
    //    | (a, b)                     => Sequence(TraverseUtils.DoubleElement(a, b))
    //  }
    //  //Sequence([a, b])
    //}

    //public Unsequenced : IEnumerable[PathNode]
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | Sequence(lst) => lst
    //      | Empty         => Enumerable.Empty()
    //      | x             => TraverseUtils.SingleElement(x)
    //    }
    //  }
    //}

    //public Clone() : PathNode
    //{
    //  PathNode.Sequence(Unsequenced)
    //}

    //public Fold[T](init : T, 
    //              seq : list[T] * Sequence -> T,
    //              node : PathNode -> T) : T
    //{

    //  def stack = SCG.Stack();

    //  def loop(st, _)
    //  {
    //    match (st)
    //    {
    //      | Sequence(n) as t => def acc = stack.Pop(n.Length);
    //          def acc = seq(acc, t);
    //          stack.Push(acc);
    //          acc
    //      | n                => def acc = node(n);
    //          stack.Push(acc);
    //          acc
    //    }
    //  }

    //  Iterator.FoldLeft(init, loop)
    //}

    public Actions : IEnumerable[string]
    {
      get
      {
        match (this)
        {
          | Entry(action = act)
          | Exit(action = act)
          | Action(actions = act) => act.ActionList
          | _                     => Enumerable.Empty()
        }
      }
    }

    public static PathActions(this path : IEnumerable[PathNode]) : IEnumerable[string]
    {

      path.SelectMany(_.Actions)
        //match (this)
        //{
        //  | Sequence(n) => n.SelectMany(get_act)
        //  | n           => get_act(n)
        //}

    }

  }

  public variant CheckNode
  {
    | Empty
    | Sequence {nodes : IEnumerable[CheckNode];}
    | RegionStates {states : IEnumerable[FsmState];}
    | Join {join : PseudoStateNode.Join;tran : StateTransition;}
    | Guard {tran : IEnumerable[GuardNode];}

    public static @+(a : CheckNode, b : CheckNode) : CheckNode
    {
      | (Sequence(a), Sequence(b)) => Sequence(a.Concat(b))
      | (Sequence(a), b)           => Sequence(a.Append(b))
      | (a, Sequence(b))           => Sequence(b.AddBefore(a))
      | (a, b)                     => Sequence(TraverseUtils.DoubleElement(a, b))
    }

  }


  /// <summary>
  /// Description of TransitionPath.
  /// </summary>
  [Record]
  public class TransitionPaths
  {
    [NeedChange]
    public Paths : list[StateEvent * TransitionPath];
    public State : FsmState;

    public this(st : FsmState)
    {
      State = st
    }

    public TraverseTransitions(recursive : bool = false) : list[StateTransition] * TransitionPaths
    {
      def trans = State.all_transitions.Exclude(_.UsedInGenerate);
      def path = trans.Map(_.TraversePath(recursive));
      def paths = path |> (Trigger, Path);
      //this.paths = paths;
      (path, ChangePaths(paths))
    }

    public Actions : IEnumerable[string]
    {
      get
      {
        def act = Paths.Split()[1].SelectMany(_.Actions);//.RemoveDuplicatesSort((x, y) => x.CompareTo(y))
        act.Distinct()
      }
    }

    public ActionNodes : IEnumerable[PathNode]
    {
      get
      {
        Paths.Split()[1].SelectMany(x => x.Path.Path)
      }
    }

  }

}
