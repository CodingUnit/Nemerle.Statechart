using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;


namespace Nemerle.Statechart
{

  using FsmState;

  public enum PathKind
  {
    | Entry
    | Exit
    | Action
  }

  [Record]
  public class TranPath
  {
    public state : string;
    public nodes : list[PathNode] {get;set;}
    public kind  : PathKind;
    
    public IsEmpty : bool
    {
      get
      {
        nodes.IsEmpty()
      }
    }
  }

  [Record]
  public variant PathNode
  {
    //| Empty
    //| Sequence {seq : IEnumerable[PathNode];}
    | Entry
      {
        action : FsmAction;
        //inline : list[PathNode * bool] = [];

        //this (action : Actions)
        //{
        //  this.action = action;
        //}

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }

      }

    | Exit
      {
        action : FsmAction;
        //inline : list[PathNode * bool] = [];

        //this (action : Actions)
        //{
        //  this.action = action;
        //}

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }


      }

    | Action
      {
        action : FsmAction;

        override ToString() : string {$"PathNode+Action$(action)"}
      }
    | ClearHistory
      {
        history : list[HPseudoState.History];

        override ToString() : string {$"PathNode+ClearHistory$history"}
      }
    | SaveHistory
      {
        history : list[HPseudoState.History];

        override ToString() : string {$"PathNode+SaveHistory$history"}
      }

    | RunDoActivity
      {
        activity : StateAction.Do;

        override ToString() : string {$"$(activity)Run"}
      }

    | StopDoActivity
      {
        activity : StateAction.Do;

        override ToString() : string {$"$(activity)Stop"}
      }
    //| RegionExit
    //  {
    //    states_in : IEnumerable[FsmState];
    //    region : FsmState;

    //    override ToString() : string {$"RegionExit$(region)In$states_in"}
    //  }

    //public Kind : PathKind;

    public state : string;

    public PathAction : option[FsmAction]
    {
      get
      {
        match (this)
        {
          | Entry(action = act)
          | Exit(action = act)
          | Action(action = act)  => Some(act)
          | _                     => None()
        }
      }
    }

    public static PathActions(this path : IEnumerable[PathNode]) : IEnumerable[FsmAction]
    {
      path.FilterValues(_.PathAction)
      //path.SelectMany(_.Actions)
    }

  }

  public variant CheckNode
  {
    | Empty
    | Sequence {nodes : list[CheckNode];}
    | RegionStates {states : list[FsmState];}
    | Join {join : PseudoStateNode;tran : StateTransition;}
    | Guard {tran : GuardNode;}

    public static @+(a : CheckNode, b : CheckNode) : CheckNode
    {
      | (Sequence(a), Sequence(b)) => Sequence(a.Concat(b).NToList())
      | (Sequence(a), b)           => Sequence(a.Append(b).NToList())
      | (a, Sequence(b))           => Sequence(b.AddBefore(a).NToList())
      | (a, b)                     => Sequence(ListUtils.DoubleElement(a, b).NToList())
    }

  }


  ///// <summary>
  ///// Description of TransitionPath.
  ///// </summary>
  //[Record]
  //public class TransitionPaths
  //{
  //  //public Paths : list[TransitionPath] {get;set;default []}
  //  public State : FsmState;

  //  //public this(st : FsmState)
  //  //{
  //  //  State = st
  //  //}

  //  public TraverseTransitions(recursive : bool = false) : void
  //  {
  //    def trans = State.transitions.Exclude(x => x.Used || x.IsCompletion);
  //    trans.Iter(x => x.TraversePath(recursive));
  //  }

  //}

}
