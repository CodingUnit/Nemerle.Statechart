using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{

  using FsmState;

  [Record]
  public variant PathNode
  {
    | Empty
    //| Sequence {seq : IEnumerable[PathNode];}
    | Entry
      {
        action : Actions;
        inline : list[PathNode * bool] = [];

        state  : FsmState;
        
        //this (action : Actions)
        //{
        //  this.action = action;
        //}

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }

      }

    | Exit
      {
        action : Actions;
        inline : list[PathNode * bool] = [];
        state  : FsmState;
        
        //this (action : Actions)
        //{
        //  this.action = action;
        //}

        Name : string
        {
          get
          {
            $"$(action)"
          }
        }

        override ToString() : string
        {
          Name
        }


      }

    | Action
      {
        actions : Actions;

        override ToString() : string {$"PathNode+Action$(actions)"}
      }
    | ClearHistory
      {
        history : list[PseudoStateNode.History];

        override ToString() : string {$"PathNode+ClearHistory$history"}
      }
    | SaveHistory
      {
        history : list[PseudoStateNode.History];

        override ToString() : string {$"PathNode+SaveHistory$history"}
      }

    | RunDoActivity
      {
        activity : StateAction.Do;

        state : FsmState;
        override ToString() : string {$"DoActivity$(state)Run"}
      }

    | StopDoActivity
      {
        activity : StateAction.Do;

        state : FsmState;
        override ToString() : string {$"DoActivity$(state)Stop"}
      }
    | RegionExit
      {
        states_in : IEnumerable[FsmState];
        region : FsmState;

        override ToString() : string {$"RegionExit$(region)In$states_in"}
      }

    //public static Equals(a : PathNode, b : PathNode) : bool
    //{
    //  | (Sequence(lst), Sequence(lst2)) => lst.Equals(lst2, Equals)
    //  | (n1, n2)                        => n1.ToString() == n2.ToString()
    //}

    //public static Compare(a : PathNode, b : PathNode) : int
    //{
    //  | (Sequence(lst), Sequence(lst2)) => if (lst.ForAll2(lst2, Equals)) 0 else -1
    //  | (n1, n2)                        => string.Compare(n1.ToString(), n2.ToString())
    //}

    //public static @+(a : PathNode, b : PathNode) : PathNode
    //{
    //  match (a, b)
    //  {
    //    | (Sequence(a), Sequence(b)) => Sequence(a.Concat(b))
    //    | (Sequence(a), b)           => Sequence(a.Append(b))
    //    | (a, Sequence(b))           => Sequence(b.AddBefore(a))
    //    | (a, b)                     => Sequence(TraverseUtils.DoubleElement(a, b))
    //  }
    //  //Sequence([a, b])
    //}

    //public Unsequenced : IEnumerable[PathNode]
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | Sequence(lst) => lst
    //      | Empty         => Enumerable.Empty()
    //      | x             => TraverseUtils.SingleElement(x)
    //    }
    //  }
    //}

    //public Clone() : PathNode
    //{
    //  PathNode.Sequence(Unsequenced)
    //}

    //public Fold[T](init : T, 
    //              seq : list[T] * Sequence -> T,
    //              node : PathNode -> T) : T
    //{

    //  def stack = SCG.Stack();

    //  def loop(st, _)
    //  {
    //    match (st)
    //    {
    //      | Sequence(n) as t => def acc = stack.Pop(n.Length);
    //          def acc = seq(acc, t);
    //          stack.Push(acc);
    //          acc
    //      | n                => def acc = node(n);
    //          stack.Push(acc);
    //          acc
    //    }
    //  }

    //  Iterator.FoldLeft(init, loop)
    //}

    public Actions : IEnumerable[FsmAction]
    {
      get
      {
        match (this)
        {
          | Entry(action = act)
          | Exit(action = act)
          | Action(actions = act) => act.actions
          | _                     => Enumerable.Empty()
        }
      }
    }

    public static PathActions(this path : IEnumerable[PathNode]) : IEnumerable[FsmAction]
    {

      path.SelectMany(_.Actions)
        //match (this)
        //{
        //  | Sequence(n) => n.SelectMany(get_act)
        //  | n           => get_act(n)
        //}

    }

  }

  public variant CheckNode
  {
    | Empty
    | Sequence {nodes : list[CheckNode];}
    | RegionStates {states : list[FsmState];}
    | Join {join : PseudoStateNode;tran : StateTransition;}
    | Guard {tran : list[GuardNode];}

    public static @+(a : CheckNode, b : CheckNode) : CheckNode
    {
      | (Sequence(a), Sequence(b)) => Sequence(a.Concat(b).NToList())
      | (Sequence(a), b)           => Sequence(a.Append(b).NToList())
      | (a, Sequence(b))           => Sequence(b.AddBefore(a).NToList())
      | (a, b)                     => Sequence(TraverseUtils.DoubleElement(a, b).NToList())
    }

  }


  /// <summary>
  /// Description of TransitionPath.
  /// </summary>
  [Record]
  public class TransitionPaths
  {
    public Paths : list[StateEvent * TransitionPath] {get;set;default []}
    public State : FsmState;

    public this(st : FsmState)
    {
      State = st
    }

    public TraverseTransitions(recursive : bool = false) : void
    {
      def trans = State.transitions.Exclude(x => x.Used);// || x.IsCompletion);
      trans.Iter(x => x.TraversePath(recursive));
      def paths = trans.Map(x => (x.Trigger, x.Path));
      //this.paths = paths;
      Paths = paths
    }

    public Actions : IEnumerable[FsmAction]
    {
      get
      {
        def act = Paths.Split()[1].SelectMany(x => x.Actions);//.RemoveDuplicatesSort((x, y) => x.CompareTo(y))
        act.Distinct()
      }
    }

    public ActionNodes : IEnumerable[PathNode]
    {
      get
      {
        Paths.Split()[1].SelectMany(x => x.Path.Path)
      }
    }

  }

}
