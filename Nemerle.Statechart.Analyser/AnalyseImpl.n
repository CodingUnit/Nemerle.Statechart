using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using FsmState;
  using PseudoStateNode;
  
  public interface IdObject
  {
    Num : int {get;}
  }
  
  [Record]
  public variant FsmError
  {
    //| Sequence {seq : IEnumerable[FsmError];}
    //| UnknownState {state : FsmState;name : FsmState;tran : StateTransition;}
    | StateNotFound {state : FsmState;}
    | SeveralState {states : list[FsmState];}
    | DuplicateTransition {tran : list[NodeValue[FsmState, StateTransition]];}
    | DuplicateHistory {state : FsmState;history : NodeValue[FsmState, PseudoStateNode];}
    | RegionMustContainInitial {reg : GeneralTree[FsmState];tran : NodeValue[FsmState, StateTransition];}
    | SubRegionsMustContainInitial {reg : list[GeneralTree[FsmState]];tran : NodeValue[FsmState, StateTransition];}
    | UnknownTerminateTransition {node : NodeValue[FsmState, StateTransition];}
    | ForkMustGoToRegion {fork : NodeValue[FsmState, PseudoStateNode];}
    | ForkMustGoToSeparateRegion {fork : NodeValue[FsmState, PseudoStateNode];}
    | UnknownNode {tran : NodeValue[FsmState, StateTransition];}
    | JoinTransitionMustHaveSameTrigger {join : NodeValue[FsmState, PseudoStateNode];tran : list[NodeValue[FsmState, StateTransition]];}
    | JoinTransitionMustLeaveRegion {join : NodeValue[FsmState, PseudoStateNode];tran : list[NodeValue[FsmState, StateTransition]];}
    | TransitionCrossOrthogonalBoundaryOfSameRegion {tran : NodeValue[FsmState, StateTransition];}
    | DefaultTransitionMustGoToState {tran : NodeValue[FsmState, StateTransition];history : NodeValue[FsmState, PseudoStateNode];}
    | JunctionElseMustBeLast {junction : NodeValue[FsmState, PseudoStateNode];}
    | JunctionElseMustAfterAnotherGuard {junction : NodeValue[FsmState, PseudoStateNode];}
    | EmptyJunction {junction : NodeValue[FsmState, PseudoStateNode];}
    | JunctionActionMaybeLast {junction : NodeValue[FsmState, PseudoStateNode];action : list[Actions];}
    | ChoiceElseMustBeLast {choice : NodeValue[FsmState, PseudoStateNode];}
    | ChoiceElseMustAfterAnotherGuard {junction : NodeValue[FsmState, PseudoStateNode];}
    | EmptyChoice {junction : NodeValue[FsmState, PseudoStateNode];}
    | ChoiceActionMaybeLast {junction : NodeValue[FsmState, PseudoStateNode];action : list[Actions];}
    | SubMachineStateNotFound {fsm : FsmState.SubMachine;state : string;}
    | UnknownTarget {tran : NodeValue[FsmState, StateTransition]; target : TransitionTarget;}
  }

  [Record]
  public variant FsmWarning
  {
    | HistoryNotUsed {hist : NodeValue[FsmState, PseudoStateNode];}
    | StateNotUsed {state : GeneralTree[FsmState];}
    | TransitionNotUsed {tran : NodeValue[FsmState, StateTransition];}
    | TransitionOverriden {tran : StateTransition;by : StateTransition;}
    | RegionNotUsed {regions : GeneralTree[FsmState];}
    | NoConcurrentActivity {act : StateAction.Do;}
  }

  public variant ParseError
  {
    | DuplicateActivity {node : StateNode.DoActivity;}
    | UnknownElement {node : StateNode;}
    | UnknownMachineFlag {flag : string;}
  }
  
  [Record]
  class FsmErrorException : Exception
  {
    public error : FsmError;
    
    public this() {}
  }
  
  
}
