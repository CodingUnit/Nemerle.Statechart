using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of StateMapDecls.
  /// </summary>
  partial class StateMap
  {

    CreateAndResolvePreDecl(tar : TransitionTarget, tr : StateTransition, mach : bool = false) : TransitionTarget
    {
      match (tar)
      {
        | TransitionTarget.PseudoState(p) as t => 
              def p = match (p)
              {
                | PseudoStateNode.Terminate as p => def pseudo = PseudoStates.FindType();
                                                    pseudo.IfDefault(p, x => state_tree.AddPseudo(x));
                        // search for terminate in automata
                | Junction(IsUnnamed = true, name = n) as j =>  
                                                      def super = tr.StateObtainPseudoStateFromThis;//st.Super;
                                                      def find = super.pseudo_states.FindTypeWhen(x => x.name == n);
                                                      find.IfDefault(j, x => {super.AddPseudo(x);x.state = super})
                | ExitPoint(name = n) as p => 
                    def st = tr.From;
                    st.pseudo_states.FindTypeWhen(x => x.name == n).IfDefault(p, x => st.AddPseudo(x));
                // another pseudo state is not used
                | t => t
              }
              t.ChangeNode(p)

        | TransitionTarget.Final as t    => def st = tr.From; // begining of transition
                                      def super = st.Super; // if transition is initial use super this state or super state of this
                                        // search for final state in super
                                      if (super.IsTopState && !mach) CreateAndResolvePreDecl(TransitionTarget.PseudoState(PseudoStateNode.Terminate(0, state_tree)), tr, mach) else
                                      {
                                        def st = match (super.sub_states.Find(_.IsFinal))
                                        {
                                          // if find select it
                                          | Some(st) => st
                                          | _        => def fin = FsmState(Analyser, StateType.Final()); // else create and add and select
                                                        fin.name = $"$(super)Final";
                                                        super.Add(fin);
                                                        fin
                                        }
                                      t.ChangeState(st)
                                      }
        | _ => null

      }
    }

    CheckRelocateTran(tr : StateTransition) : void
    {
      | StateTransition(RelocateFrom = Some(PseudoStateNode(NativeName = Some(n)))) => 
          match (GetPseudo(tr.From, n.SplitToList('.')))
          {
            | null                                        => Analyser.AddError(FsmError.RelocatePseudoNotFound(tr))
            | PseudoStateNode.ExitPoint(tran = Some) as p => Analyser.AddError(FsmError.RelocatePseudoAlreadyHaveTarget(tr, p))
            | PseudoStateNode.ExitPoint(state = st) as p  => tr.From.DeleteTransition(tr);
                                                             p.tran = Some(tr);
                                                             tr.FromPseudo = Some(p);
                                                             tr.From = st;
                                                             tr.Source = st;
                                                             tr.kind = TransitionKind.Local;
            | p                                           => Analyser.AddError(FsmError.RelocateSourceNotSupported(p))
          }
      | _                                        => ()
    }

    CreatePreDecls(mach : bool = false) : void
    {
      foreach (tr in Transitions)
      {
        match (CreateAndResolvePreDecl(tr.To, tr, mach))
        {
          | null => ()
          | t    => tr.To = t
        }
      }
      foreach (tr in Transitions) CheckRelocateTran(tr)
    }

  }
}
