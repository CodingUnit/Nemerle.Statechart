using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of StateMapFuncs.
  /// </summary>
  partial class StateMap
  {   
    
    public Get(state : list[string]) : FsmState
    {
      def merge_name(n)
      {
        $<#..$(n;".")#>
      }

      def get_loop(st : list[_], lst, path)
      {
        | (st, head :: tail, p) => 
              def path = head :: p;
              match (get_all_state(st, head), tail)
              {
                | ([], _)    => Analyser.AddError(FsmError.StateNotFound(FsmState(merge_name(path.Rev()), Analyser, StateType.State()))); null
                | ([st], []) => st
                | ([st], _)  => get_loop(st.sub_states.NToList(), tail, path)
                | (lst, _)   => Analyser.AddError(FsmError.SeveralState(lst.Map(x => FsmState(merge_name((x.NativeName :: p).Rev()), Analyser, StateType.State()))));
                                null
              }
        | _                => null
      }

      get_loop(States.NToList(), state, [])
    }

    public GetPseudo(full_name : list[string]) : PseudoStateNode
    {
      def pseudo_name = full_name.Last();
      def state = GetParent(full_name);
      def pseudo = state.pseudo_states.Filter(x => if (x.NativeName is Some(n)) n == pseudo_name else false);
      match (pseudo)
      {
        | []  => Analyser.AddError(FsmError.PseudoStateNotFound($<#..$(full_name;".")#>)); null
        | [p] => p
        | lst => Analyser.AddError(FsmError.SeveralPseudoStates(lst)); null
      }
    }
    
    public GetParent(state : list[string]) : FsmState
    {
      Get(state.ChopLast().NToList())
    }    

    
    get_all_state(map : IEnumerable[FsmState], state : string) : list[FsmState]
    {
      def name = state ?? FsmState.TopStateName;
      def (name, sub_name) = if (name != FsmState.TopStateName) 
                              {
                                def sub =  name.GetSub('[', ']');
                                if (sub != null) (name.GetSub('['), sub) else (name, null)
                              } else (name, null);
      def name = if (sub_name != null) $"$(name)SubRegion$sub_name" else name;
      map.Filter(x => x.NativeName == name)
    }

    public Get(state : string) : FsmState
    {
      def st = state.SplitToList('.');
      Get(st)
    }
	
    GetNamed(n : string, st : FsmState) : TransitionTarget
    {
      // TODO: разрешение с помощью супер состояний
      def (states, pseudo) = if (st != null) (st.sub_states, st.pseudo_states) else 
                            (States, PseudoStates);
      match (states.Find(x => x.NativeName == n))
      {
        | Some(st) => TransitionTarget.State(st)
        | _        => ResolvePseudoIn(n, pseudo)
      }
    }        
    
    ResolvePseudoIn(n : string, st : IEnumerable[PseudoStateNode]) : TransitionTarget
    {
      match (GetPseudoIn(n, st))
      {
        | null    => null
        | t       => TransitionTarget.PseudoState(t)
      }
    }
       
    GetPseudoIn(n : string, st : IEnumerable[PseudoStateNode]) : PseudoStateNode
    {
      def states = st.Filter(x => x.NativeName.HasValue);
      match (states.Find(x => x.NativeName.Value == n))
      {
        | Some(t) => t
        | _       => null
      }
    }
    
  }
}
