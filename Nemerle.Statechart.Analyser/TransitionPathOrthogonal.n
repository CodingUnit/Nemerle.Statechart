using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{

  using CheckNode;
  using StateTransition;
  using PathNode;
  using TransitionDestination;
  using FsmState;

  /// <summary>
  /// Description of TransitionPathOrthogonal.
  /// </summary>
  public partial class TransitionPath
  {

    TraverseJoinTransition(join : PseudoStateNode.Join, tr : StateTransition) : TransitionDestination
    {
      | (Join(joined_tran = jtran, transition = tran), StateTransition(Source = src)) =>

          tr.omit_guard = true;
          tr.Used = true;
          DefExitPath(src, st);
          traverser?.Add(tran);
          def (node, tran) = if (tr.FromRegion : object == jtran.Last().FromRegion)
          {
            tr.AddCheck(CheckNode.Join(join, tr));
            (JoinedTransition(join, tran), tr)
          } else
          if (tr.FromRegion: object == jtran.First().FromRegion)
          {
            tr.AddCheck(RegionStates(jtran.Map(x => x.From)));
            def has_guard = jtran.Exists(x => x.guard.HasValue);
            when (has_guard) tr.AddCheck(Guard(jtran.FilterValues(x => x.Guard).NToList()));
            (Join(join), tr)
          }
          else
          {
            tr.AddCheck(Join(join, tr));
            (Join(join), tr)
          }
          transition = tran;
          node
     
    }

    TraverseFork(fork : PseudoStateNode.Fork, targets : list[TransitionTarget]) : TransitionDestination
    {
      | (NodeValue(Value = Fork(fork_tran = ftran)), t) => 

        def st = t.Map(x => x.ToState);
        def reg = st.Map(x => x.PartOfSubRegions());
        def sreg = reg.Map(x => x.Last());
        def reg = sreg.Head.ContainedIn();
        traverser?.Add(ftran);
        Fork(reg, ftran)
        | _ => null
    }

    TraverseOrthogonalRegion(reg : FsmState) : TransitionDestination
    {
      def initial = reg.SubRegions().Map(x => x.InitialTransitions());
      when (!initial.All(x => !x.IsEmpty())) throw FsmErrorException(FsmError.RegionMustContainInitial(reg, transition));
      def init = initial.Flatten();
      init.Iter(_.TraversePath());
      //def sub = reg.SubRegions();//.Map(x => x.UpdateTransitions(init) :> ConcurrentSubRegion);
      //def reg = reg.ChangeSubRegions(sub);
      def target = Region(reg);
      if (transition.Value is Initial) target else TraverseCompletionTransition(target, target)
    }

    TraverseCompletionTransition(target : TransitionDestination, to : TransitionDestination) : TransitionDestination
    {
      match (target)
      {
        | Region(GeneralTree(Data = ConcurrentRegion) as st) =>
          def sr = st.SubRegions();
          def init = sr.SelectMany(x => x.InitialTransitions());
          def st = init.Map(x => x.Value.Destination);
          def st = st.Map(TraverseCompletionTransition(_, to));
          match (st.Find(_ is CheckAfter))
          {
          | Some(c) => c
          | _       => to
          }

        | SubRegion(reg = s)
        | State(s) => 

            def tr = s.join_completion_transitions();
            if (tr.IsEmpty()) to else
            {
            def (reg, joined) = match (tr.First().Value.To)
            {
              | TransitionTarget.PseudoState(node = NodeValue(Value = Join(joined_tran = tran, region = reg))) => (reg, tran)
              | _                                                           => (null, null)
            }
            traverser?.Add(tr);
            ForceStateChange(TransitionPostConditions.RegionCompletion(reg, joined), to)
            }

        | _ => to// end state
      }
    }

    TraverseSubRegion(reg : FsmState, to : TransitionTarget, tran : StateTransition) : TransitionDestination
    {
      match (reg.Data)
      {
        | ConcurrentSubRegion =>

          def region = reg.ContainedIn();
          def st = to.ToState;
          def omitted = region.RegionsExcept(st); // other omitted regions
          def initial = omitted.Map(x => x.InitialTransitions());
          when (!initial.All(_ is _ :: _)) throw FsmErrorException(FsmError.SubRegionsMustContainInitial(omitted.NToList(), transition));
          def init = initial.Flatten();
          traverser?.Add(init);
          def target = TraverseTarget(to, tran);
          def res = SubRegion(reg, target, tran.Value.From);
          TraverseCompletionTransition(target, res)

        | _ => null
      }
    }

    TraverseWithinRegionTransition(tran : StateTransition) : TransitionDestination
    {
      def to = TraverseOrdinaryTransition(tran);
      TraverseCompletionTransition(to, to)
    }

    TraverseTransitionFromRegion(_reg : FsmState, tran : StateTransition) : TransitionDestination
    {
      //| (ConcurrentSubRegion, StateTransition(Source = src, From = from)) =>
      def src = tran.Parent;
      def from = tran.Value.From;
      DefPath(src, from, tran);
      tran.Used(true);
      ForceStateChange(TraverseTargetReg(tran.Value.To, tran)) // traversing transition target
    }

  }
}
