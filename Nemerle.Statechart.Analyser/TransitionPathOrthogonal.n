using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  using CheckNode;
  using StateTransition;
  using PathNode;
  using TransitionDestination;
  using FsmState;

  /// <summary>
  /// Description of TransitionPathOrthogonal.
  /// </summary>
  public partial class TransitionPath
  {

    TraverseJoinTransition(join : PseudoStateNode.Join, tr : StateTransition) : TransitionDestination
    {
      | (Join(joined_tran = jtran, state = st, transition = tran), StateTransition(Source = src)) =>

          def tr = tr.ChangeUsedOmitGuard(true, true);
          DefExitPath(src, st);
          traverser?.Add(tran);
          def (node, tran) = if (tr.FromRegion == jtran.Last().FromRegion)
          {
            def tr = tr.AddCheck(Join(join, tr));
            (JoinedTransition(join, tran), tr)
          } else
          if (tr.FromRegion == jtran.First().FromRegion)
          {
            def tr = tr.AddCheck(RegionStates(jtran |> From));
            def has_guard = jtran.Exists(x => x.SourceGuard.HasValue);
            def tr = if (has_guard) tr.AddCheck(Guard(jtran.FilterValues(_.Guard))); else tr;
            (Join(join), tr)
          }
          else
          {
            def tr=  tr.AddCheck(Join(join, tr));
            (Join(join), tr)
          }
          transition = tran;
          node
    }

    TraverseFork(fork : PseudoStateNode.Fork, targets : list[TransitionTarget]) : TransitionDestination
    {
      | (Fork(fork_tran = ftran), t) => 

        def st = t |> ToState;
        def reg = st |> PartOfSubRegions;
        def sreg = reg |> Last();
        def reg = sreg.Head.contained_in;
        traverser?.Add(ftran);
        Fork(reg, ftran)
    }

    TraverseOrthogonalRegion(reg : ConcurrentRegion) : TransitionDestination
    {
      def initial = reg.sub_regions |> initial;
      when (!initial.All(x => !x.IsEmpty())) throw FsmErrorException(FsmError.RegionMustContainInitial(reg, transition));
      def init = initial.Flatten();
      def init = init.Map(_.TraversePath());
      def sub = reg.sub_regions.Map(x => x.UpdateTransitions(init) :> ConcurrentSubRegion);
      def reg = reg.ChangeSubRegions(sub);
      def target = Region(reg);
      if (transition is Initial) target else TraverseCompletionTransition(target, target)
    }

    TraverseCompletionTransition(target : TransitionDestination, to : TransitionDestination) : TransitionDestination
    {
      match (target)
      {
        | Region(ConcurrentRegion(sub_regions = sr)) =>

          def init = sr.SelectMany(_.initial);
          def st = init.Map(_.Destination);
          def st = st |> TraverseCompletionTransition(_, to);
          match (st.Find(_ is CheckAfter))
          {
          | Some(c) => c
          | _       => to
          }

        | SubRegion(reg = FsmState(join_completion_transitions = (_ :: _) as tr))
        | State(FsmState(join_completion_transitions = (_ :: _) as tr)) => 

            def (reg, joined) = match (tr.Head.To)
            {
              | PseudoState(Join(joined_tran = tran, region = reg)) => (reg, tran)
              | _                                                   => (null, null)
            }
            traverser?.Add(tr);
            ForceStateChange(TransitionPostConditions.RegionCompletion(reg, joined), to)

        | _ => to// end state
      }
    }

    TraverseSubRegion(reg : FsmState, to : TransitionTarget, tran : StateTransition) : TransitionDestination
    {
      match (reg)
      {
        | ConcurrentSubRegion as reg =>

          def region = reg.contained_in;
          def st = to.ToState;
          def omitted = region.RegionsExcept(st); // other omitted regions
          def initial = omitted |> initial;
          when (!initial.All(_ is _ :: _)) throw FsmErrorException(FsmError.SubRegionsMustContainInitial(omitted, transition));
          def init = initial.Flatten();
          traverser?.Add(init);
          def target = TraverseTarget(to, tran);
          def res = SubRegion(reg, target, transition.From);
          TraverseCompletionTransition(target, res)

        | _ => null
      }
    }

    TraverseWithinRegionTransition(tran : StateTransition) : TransitionDestination
    {
      def to = TraverseOrdinaryTransition(tran);
      TraverseCompletionTransition(to, to)
    }

    TraverseTransitionFromRegion(reg : ConcurrentSubRegion, tran : StateTransition) : TransitionDestination
    {
      | (ConcurrentSubRegion, StateTransition(Source = src, From = from)) =>

          DefPath(src, from, tran);
          def tran = tran.ChangeUsed(true);
          ForceStateChange(TraverseTargetReg(tran.To, tran)) // traversing transition target
    }

  }
}
