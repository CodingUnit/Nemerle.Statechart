// transitionactions.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{

  using ListUtils;
  using PseudoStateNode;
  /// <summary>
  /// Description of TransitionActions.
  /// </summary>
  public partial variant StateTransition
  {

    public this(an : FsmAnalyser) 
    {
      this.analyser = an
    }

    
    public this(st : GeneralTree[FsmState], tran : StateNode.Transition)
    {
      def an = st.Analyser();
      this.analyser = an;
      //From = st;
      From = st;
      node = tran;
      when (tran != null)
      {
        guard = tran.guard;
        action = tran.action;
      }
      To = if (tran.to != null) TransitionTarget.Create(st, tran.to) else TransitionTarget.Nowhere(analyser);
    }

    public this(st : GeneralTree[FsmState], to : GeneralTree[FsmState])
    {
      this(st, TransitionTarget.State(st.Data.analyser, to))//TransitionTarget.State(st.analyser, to))
    }

    public this(st : GeneralTree[FsmState], to : TransitionTarget)
    {
      this(st.Analyser());
      //From = st;
      To = to;
      From = st
    }

    public node : StateNode.Transition;

    public this(tran : StateTransition)
    {
      this(tran.analyser);
      //From = tran.From;
      To = tran.To;
      guard = tran.guard;
      action = tran.action;
      omit_guard = tran.omit_guard;
      //ParentCrossed = tran.ParentCrossed;
      From = tran.From;
      Local = tran.Local;
      //ImplicitFrom = tran.ImplicitFrom;
    }

    //[NeedChange]
    //[Accessor]
    //public num : int;

    //public From : GeneralTree[FsmState];

    //public static Change(this changed : StateTransition) : void
    //{
    //  changed.Source.Update(x => x.UpdateTransition(changed))
    //}

    [NeedChange]
    [NeedChange(To)]
    public From : GeneralTree[FsmState];
    [NeedChange]
    public guard : option[GuardNode] = None();
    [NeedChange]
    public action : option[Actions] = None();
    [NeedChange]
    public To : TransitionTarget;
    [NeedChange]
    public ActualTo : GeneralTree[FsmState];
    [NeedChange]
    public Path : TransitionPath;

    [NeedChange]
    public clones : list[StateTransition] = [];

    [NeedChange(ActualTo, Path)]
    [NeedChange]
    public Destination : TransitionDestination;

    public PostConditions : TransitionPostConditions
    {
      get
      {
        Destination?.PostConditions
      }
    }

    [NeedChange]
    public omit_guard : bool;

    public Guard : option[GuardNode]
    {
      get
      {
        if (omit_guard) None() else guard
      }
    }

    public FriendlyTriggerName : string
    {
      get
      {
        match (this)
        {
          | Transition(TriggerName = null) => "Completion"
          | Transition(TriggerName = trig)
          | Internal(TriggerName = trig) => trig
          | Initial => "Initial"
          | Default => "Default"
          | History => "History"
        }
      }
    }

    //public IsCrossed : bool
    //{
    //  get
    //  {                
    //        !ParentCrossed.IsEmpty()
    //  }
    //}

    public IsCompletion : bool
    {
      get
      {
        FriendlyTriggerName == "Completion"
      }
    }

    name : string
    {
      get
      {
        match (this)
        {
          | Transition(From = st)            => $"Transition$(st.Data)To$(To)By$(FriendlyTriggerName)"
          | Internal(TriggerName = t)        => $"InternalTransition$(From)By$(t)"
          | Initial                          => $"InitialTransitionFrom$(From)To$To"
          | History                          => $"HistoryFrom$(From)To$ToState"
          | Default(history = h)             => 
              match (Destination)
              {
                | History(NodeValue(Parent = st)) => $"DefaultTransition$(h)To$st"
                | _                               => $"DefaultTransition$(h)To$ActualTo"
              }
        }
      }
    }

  
    public Name : string
    {
      get
      {
        if (NeedGuardedName) GuardedName else name;
      }
    }

    public GuardedName : string
    {
      get
      {
        match (Guard)
        {
          | Some(g) => $"$(name)With$g"
          | _       => name
        }
      }
    }

    public static GuardComparer : StateTransition * StateTransition -> int = (g1, g2) => g2.Guard.Compare(g1.Guard, (x, y) => x.CompareTo(y));

    public static Comparer : StateTransition * StateTransition -> int  =  (t1, t2)  => t1.Name.CompareTo(t2.Name);

    public static FullComparer(t1 : StateTransition, t2 : StateTransition) : int
    {
      def eq = if (t1.ActionList.Equals(t2.ActionList, _ == _)) 0 else -1;
      Comparer(t1, t2) + GuardComparer(t1, t2) + eq
    }

    //public ToChoice : IEnumerable[StateTransition]
    //{
    //  get
    //  {
    //    match (Destination)
    //    {
    //      | Choice(_, tran, _) => tran
    //      | _                  => Enumerable.Empty()
    //    }
    //  }
    //}

    public ToState : GeneralTree[FsmState]
    {
      get
      {
        match (To)
        {
          | TransitionTarget.State(st)  => st
          | _                           => null
        }
      }
    }

    public ToPseudo : NodeValue[FsmState, PseudoStateNode]
    {
      get
      {
        match (To)
        { 
          | PseudoState(node) => node
          | _                 => null
        }
      }
    }

    /// <summary>
    /// Concrete State for where transition ends known at compile time
    /// </summary>
    public AtLeastStaticTo : GeneralTree[FsmState]
    {
      get
      {
        match (To)
        {
          | Final(st)
          | State(st)       => st
          //| History(PseudoStateNode.History(state = st))
          | PseudoState(st) => st.Parent
          //| JunctionNode(state = st)
          | _                 => null
        }

      }
    }

    [NeedChange]
    public Local : bool;


    public PathNode : IEnumerable[PathNode]
    {
      get
      {
        match (this)
        {
          | Internal(ActionNode = node) => TraverseUtils.SingleElement(node)
          | _                           => Path.Path.Path
        }
      }
    }

    public PathNodeRecursive : IEnumerable[PathNode]
    {
      get
      {
        match (Destination)
        {
          | null               => PathNode
          //| JunctionNode(node) => PathNode.Concat(node.Paths)
          | _                  => PathNode
        }
      }
    }

    public Trigger : StateEvent
    {
      get
      {
        match (this)
        {
          | Transition(trigger = t)
          | Internal(trigger = t) => t
          | _                     => null
        }
      }
    }

    public MaybeInlined : bool
    {
      get
      {
        def path_inlined(p)
        {
          def false_paths(p)
          {
            | PathNode.Entry
            | Exit  => true
            | _     => false
          }

          !p.Exists(false_paths) && p.PathActions().IsEmpty()
        }

        def path_ok = path_inlined(Path.Path.Path) && Guards.IsEmpty();
        def targ_ok = match (Destination)
                       {
                         | ForceStateChange                                  => false
                         //| JunctionNode(DecisionNode(Paths = p, Guards = g)) => path_inlined(p) && g is [] 
                         | _                                                 => true
                       }
        path_ok && targ_ok
      }
    }

    public Guards : IEnumerable[GuardNode]
    {
      get
      {
        def to = To.Guards;
        match (guard)
        {
          | Some(g) => to.AddBefore(g)
          | _       => to
        }
      }
    }

    public analyser : FsmAnalyser;

    public Statemap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }

    
    public TargetTraverse(func : TransitionTarget -> TransitionTarget) : StateTransition
    {
        ChangeTo(To.Traverse(func))
    }


    public ActionList : list[string]
    {
      get
      {
        action.MapDefault(_.actions, [])
      }
    }

    public Actions : IEnumerable[string]
    {
      get
      {
        match (this)
        {
          | Internal(ActionNode = a) => a.Actions
          | _                        => Path.Actions
        }
      }
    }

    public WithinRegion : bool
    {
      get
      {
        match (AtLeastTo.PartOfRegion(), From.PartOfRegion())
        {
          | (Some(r), Some(reg)) => r == reg : object
          | _                    => false
        }
      }
    }

    public OutOfRegion : bool
    {
      get
      {
        match (AtLeastTo.PartOfRegion(), From.PartOfRegion())
        {
          | (Some(r), Some(reg)) => r != reg : object
          | (Some, None)         => true
          | _                    => false
        }
      }
    }    

    /// <summary>
    /// State for which at least transition proceed known at compile time
    /// </summary>
    public AtLeastTo : GeneralTree[FsmState]
    {
      get
      {
        def check_dest(d)
        {
          | null => match (To)
              {
                | TransitionTarget.Final(st) => st
                //| History(PseudoStateNode.History(state = st))
                | PseudoState(node) => node.Parent
                | State(st)         => st
                | _                 => null
              }
          | TransitionDestination.State when ActualTo != null => ActualTo
          | State(st) => st
          | Choice(_, _, Some(st))
          | Choice(st, _, _)
          | Fork(st, _)
          | Region(st)
          | Final(state = st) => st
          | CheckAfter(before = st)
          | ForceStateChange(st)
          | SubRegion(state = st) => check_dest(st)
          | Terminate(j)
          | Join(j)    
          | History(j) => j.Parent
          | _ => null
        }

        check_dest(Destination)
      }
    }

    [NeedChange]
    [Accessor]
    public executeCheck : CheckNode = CheckNode.Empty();

    public AddCheck(node : CheckNode) : StateTransition
    {
      ChangeExecuteCheck(executeCheck + node)
    }

    public static completion_evt : StateEvent = StateEvent(TransitionEvent(null, 0));

    public Clone() : StateTransition
    {
      ChangeTo(To.Clone())
    }
    
    public override ToString() : string
    {
      Name
    }

    /// </summary>        
    [NeedChange]
    public NeedGuardedName : bool;
    public static NameComparer : StateTransition * StateTransition -> bool = (x, y) => x.Name == y.Name;

  }

}
