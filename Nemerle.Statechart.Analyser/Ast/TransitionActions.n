using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{

  using ListUtils;
  using PseudoStateNode;
  /// <summary>
  /// Description of TransitionActions.
  /// </summary>
  public partial variant StateTransition
  {

    public this(an : FsmAnalyser) 
    {
      this.analyser = an
    }

    public this(st : GeneralTree[FsmState], tran : StateNode.Transition)
    {
      this(FsmNode.State(st), tran)
    }
    
    public this(st : FsmNode, tran : StateNode.Transition)
    {
      def an = st.Analyser;
      this(an);
      //From = st;
      From = st;
      node = tran;
      when (tran != null)
      {
        guard = tran.guard;
        action = tran.action;
      }
      To = if (tran.to != null) TransitionTarget.Create(st.StateDecl, tran.to) else TransitionTarget.Nowhere(analyser);
    }

    public this(st : GeneralTree[FsmState], to : GeneralTree[FsmState])
    {
      this(FsmNode.State(st), TransitionTarget.State(st.Data.analyser, to))//TransitionTarget.State(st.analyser, to))
    }

    public this(st : FsmNode, to : TransitionTarget)
    {
      this(st.Analyser);
      //From = st;
      To = to;
      From = st
    }

    public node : StateNode.Transition;

    public this(tran : StateTransition)
    {
      this(tran.analyser);
      //From = tran.From;
      guard = tran.guard;
      action = tran.action;
      To = tran.To;
      omit_guard = tran.omit_guard;
      //ParentCrossed = tran.ParentCrossed;
      From = tran.From;
      Local = tran.Local;
      //ImplicitFrom = tran.ImplicitFrom;
    }

    //[NeedChange]
    //[Accessor]
    //public num : int;

    //public From : GeneralTree[FsmNode];

    //public static Change(this changed : StateTransition) : void
    //{
    //  changed.Source.Update(x => x.UpdateTransition(changed))
    //}

    [NeedChange]
    public From : FsmNode;
    
    [NeedChange]
    public guard : option[GuardNode] = None();
    [NeedChange]
    public action : option[Actions] = None();
    [NeedChange]
    public To : TransitionTarget;
    [NeedChange]
    public ActualTo : GeneralTree[FsmState];
    [NeedChange]
    public Path : TransitionPath;

    [NeedChange]
    public clones : list[StateTransition] = [];

    [NeedChange(ActualTo, Path)]
    [NeedChange]
    public Destination : TransitionDestination;

    public PostConditions : TransitionPostConditions
    {
      get
      {
        Destination?.PostConditions
      }
    }

    [NeedChange]
    public omit_guard : bool;

    public Guard : option[GuardNode]
    {
      get
      {
        if (omit_guard) None() else guard
      }
    }

    public SourceGuard : option[GuardNode]
    {
      get
      {
        guard
      }
    }

    public FriendlyTriggerName : string
    {
      get
      {
        match (this)
        {
          | Transition(TriggerName = null) => "Completion"
          | Transition(TriggerName = trig)
          | Internal(TriggerName = trig) => trig
          | Initial => "Initial"
          | Default => "Default"
          | History => "History"
        }
      }
    }

    //public IsCrossed : bool
    //{
    //  get
    //  {                
    //        !ParentCrossed.IsEmpty()
    //  }
    //}

    public IsCompletion : bool
    {
      get
      {
        FriendlyTriggerName == "Completion"
      }
    }

    name : string
    {
      get
      {
        match (this)
        {
          | Transition(From = FsmNode.State(st))       => $"Transition$(st.Data)To$(To)By$(FriendlyTriggerName)"
          | Transition(From = FsmNode.PseudoState(st)) => $"Transition$(st.Value)To$(To)"
          | Internal(TriggerName = t)        => $"InternalTransition$(From)By$(t)"
          | Initial                          => $"InitialTransitionFrom$(From)To$To"
          | History                          => $"HistoryFrom$(From)To$ToState"
          | Default(history = h)             => 
              match (Destination)
              {
                | History(NodeValue(Parent = st)) => $"DefaultTransition$(h)To$st"
                | _                               => $"DefaultTransition$(h)To$ActualTo"
              }
        }
      }
    }

    public Name : string
    {
      get
      {
        if (NeedGuardedName) GuardedName else name;
      }
    }

    public GuardedName : string
    {
      get
      {
        match (Guard)
        {
          | Some(g) => $"$(name)With$g"
          | _       => name
        }
      }
    }

    public static GuardComparer : StateTransition * StateTransition -> int = (g1, g2) => g2.Guard.Compare(g1.Guard, (x, y) => x.CompareTo(y));

    public static Comparer : StateTransition * StateTransition -> int  =  (t1, t2)  => t1.Name.CompareTo(t2.Name);

    public static FullComparer(t1 : StateTransition, t2 : StateTransition) : int
    {
      def eq = if (t1.ActionList.Equals(t2.ActionList, _ == _)) 0 else -1;
      Comparer(t1, t2) + GuardComparer(t1, t2) + eq
    }

    ///// <summary>
    ///// Transitions from parents crossed by events with this state
    ///// </summary>
    //[NeedChange]
    //public ParentCrossed : list[StateTransition] = [];

    public ToChoice : IEnumerable[StateTransition]
    {
      get
      {
        match (Destination)
        {
          | Choice(_, tran, _) => tran
          | _                  => Enumerable.Empty()
        }
      }
    }

    public ToState : GeneralTree[FsmState]
    {
      get
      {
        match (To)
        {
          | TransitionTarget.State(st)  => st
          | _                           => null
        }
      }
    }

    public ToPseudo : NodeValue[FsmState, PseudoStateNode]
    {
      get
      {
        match (To)
        { 
          | PseudoState(node) => node
          | _                 => null
        }
      }
    }

    /// <summary>
    /// Concrete State for where transition ends known at compile time
    /// </summary>
    public AtLeastStaticTo : GeneralTree[FsmState]
    {
      get
      {
        match (To)
        {
          | Final(st)
          | State(st)       => st
          //| History(PseudoStateNode.History(state = st))
          | PseudoState(st) => st.Parent
          //| JunctionNode(state = st)
          | _                 => null
        }

      }
    }

    //[NeedChange]
    //public PathEdges : GeneralTree[FsmNode];
    
    //public CreatePathEdges() : StateTransition
    //{
    //  def create_junc_tree(j : TreeJunctionNode)
    //  {
    //    | Node()
    //  }
      
      
    //  def unfold(n)
    //  {
    //    | TransitionTarget.PseudoState(n) => match (n.Value)
    //                                         {
    //                                           | PseudoStateNode.Fork(t, _) => t
    //                                           | PseudoStateNode.Join(target = t) => TraverseUtils.SingleElement(t)
    //                                           | PseudoStateNode.Junction(tree = t) => def t = t.Fold(create_junc_tree);
                                                                                       
    //                                         }
    //                                         null
    //  }
      
    //  tree.Unfold(unfold);
      
    //  this
    //}
    //public TargetIdObjects : IEnumerable[IdObject]
    //{
    //  get
    //  {
    //    To.IdObjects
    //  }
    //}

    /// <summary>
    /// Beginning state from which real executes transition
    /// </summary>
    /// <remarks>
    /// (from From differs, what Source shows current active state from which executes transition, not from beginning on diagram
    /// From determines beginning state from which follow out transition
    /// Source as a rule is nested state or same as From, if From not have sub states
    /// </remarks>
    //public Source : GeneralTree[FsmState];

    [NeedChange]
    public Local : bool;


    //public ChangeCopyAndNum(copy : int) : StateTransition
    //{
    //  def func(p)
    //  {
    //    p.ChangeNode(p => p.ChangeNumCopy(analyser.statemap.GetNextGlobalNum(), copy))
    //  }

    //  def to = To.Reduce(pseudo_state = func, junction = (t, _) => func(t));
    //  ChangeTo(to)
    //}

    //public SetNewId() : StateTransition
    //{
    //  ChangeNum(analyser.statemap.GetNextGlobalNum())
    //}

    public PathNode : IEnumerable[PathNode]
    {
      get
      {
        match (this)
        {
          | Internal(ActionNode = node) => TraverseUtils.SingleElement(node)
          | _                           => Path.Path.Path
        }
      }
    }

    public PathNodeRecursive : IEnumerable[PathNode]
    {
      get
      {
        match (Destination)
        {
          | null               => PathNode
          | JunctionNode(node) => PathNode.Concat(node.Paths)
          | _                  => PathNode
        }
      }
    }

    public Trigger : StateEvent
    {
      get
      {
        match (this)
        {
          | Transition(trigger = t)
          | Internal(trigger = t) => t
          | _                     => null
        }
      }
    }

    public MaybeInlined : bool
    {
      get
      {
        def path_inlined(p)
        {
          def false_paths(p)
          {
            | PathNode.Entry
            | Exit  => true
            | _     => false
          }

          !p.Exists(false_paths) && p.PathActions().IsEmpty()
        }

        def path_ok = path_inlined(Path.Path.Path) && Guards.IsEmpty();
        def targ_ok = match (Destination)
                       {
                         | ForceStateChange                                  => false
                         | JunctionNode(DecisionNode(Paths = p, Guards = g)) => path_inlined(p) && g is [] 
                         | _                                                 => true
                       }
        path_ok && targ_ok
      }
    }

    public Guards : IEnumerable[GuardNode]
    {
      get
      {
        def to = To.Guards;
        match (SourceGuard)
        {
          | Some(g) => to.AddBefore(g)
          | _       => to
        }
        //SourceGuard %:: To.Guards
          //| TransitionTarget.PseudoState(PseudoStateNode.Merge(to = TransitionTarget.JunctionNode(Guards = g)))
          //| TransitionTarget.PseudoState(PseudoStateNode.Junction(Guards = g)) => g.Append(SourceGuard)//SourceGuard %:: g
          //| _                                                                  => Enumerable.Empty().Append(SourceGuard)//SourceGuard %:: []
      }
    }

    public analyser : FsmAnalyser;

    public Statemap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }

    
    public TargetTraverse(func : TransitionTarget -> TransitionTarget) : StateTransition
    {
        def traverse(n)
        {
          match (n.Data)
          {
            | TreeJunctionNode.Target(target = t) as node => n.Update(_ => node.ChangeTarget(func(t)))
            | _                                           => ()
          }
        }
        
        def to = func(To);
        def tran = if (to != null) ChangeTo(to) else this;
        match (to)
        {
          | null                                                                                        => ()
          | TransitionTarget.PseudoState(NodeValue(Value = PseudoStateNode.Junction(tree = t)))         => t.GetBreadthFirstEnumerable().Iter(traverse);
          | TransitionTarget.PseudoState(NodeValue(Value = PseudoStateNode.Fork(target = t) as j) as n) => n.Update(_ => j.ChangeTarget(t.Map(func)));
          | TransitionTarget.PseudoState(NodeValue(Value = PseudoStateNode.Join(target = t) as j) as n) => n.Update(_ => j.ChangeTarget(func(t)));
          | _                                                                                           => ()
        }
        tran
    }

//blic UpdateTargets(old_t : FsmState, new_t : FsmState) : StateTransition
    //{
    //  def old_num = old_t.Num;

    //  def check_target(tar)
    //  {
    //    | TransitionTarget.State(st) as t when (st.Num == old_t.Num) => t.ChangeState(new_t)
    //    | Qualified(_, State(st) as t) when (st.Num == old_t.Num)    => t.ChangeState(new_t)
    //    | Final(st) as t when (st.Num == old_t.Num)                  => 
    //        match (new_t)
    //        {
    //          | FsmState.Final as st => t.ChangeState(st)
    //          | _                    => null
    //        }
    //    | PseudoState(node) as t when (node.state.Num == old_t.Num)  => t.ChangeNode(node.ChangeState(new_t))
    //    | _                                                          => null
    //  }

    //  def from = if (From.Num == old_num) new_t else From;
    //  def src  = if (Source.Num == old_num) new_t else Source;
    //  def tr   = ChangeFromSource(from, src);
    //  tr.TargetTraverse(check_target)
    //}

    public ActionList : list[string]
    {
      get
      {
        action.MapDefault(_.actions, [])
      }
    }

    public Actions : IEnumerable[string]
    {
      get
      {
        match (this)
        {
          | Internal(ActionNode = a) => a.Actions
          | _                        => Path.Actions
        }
      }
    }

    public WithinRegion : bool
    {
      get
      {
        match (AtLeastTo.PartOfRegion(), From.PartOfRegion())
        {
          | (Some(r), Some(reg)) => r == reg : object
          | _                    => false
        }
      }
    }

    public OutOfRegion : bool
    {
      get
      {
        match (AtLeastTo.PartOfRegion(), From.PartOfRegion())
        {
          | (Some(r), Some(reg)) => r != reg : object
          | (Some, None)         => true
          | _                    => false
        }
      }
    }    

    /// <summary>
    /// State for which at least transition proceed known at compile time
    /// </summary>
    public AtLeastTo : GeneralTree[FsmState]
    {
      get
      {
        def check_dest(d)
        {
          | null => match (To)
              {
                | TransitionTarget.Final(st) => st
                //| History(PseudoStateNode.History(state = st))
                | PseudoState(node) => node.Parent
                | State(st)         => st
                | _                 => null
              }
          | TransitionDestination.State when ActualTo != null => ActualTo
          | State(st) => st
          | Choice(_, _, Some(st))
          | Choice(st, _, _)
          | Fork(st, _)
          | Region(st)
          | Final(state = st) => st
          | CheckAfter(before = st)
          | ForceStateChange(st)
          | SubRegion(state = st) => check_dest(st)
          | Terminate(j)
          | Join(j)    
          | History(j) => j.Parent
          | _ => null
        }

        check_dest(Destination)
      }
    }

    [NeedChange]
    [Accessor]
    public executeCheck : CheckNode = CheckNode.Empty();

    public AddCheck(node : CheckNode) : StateTransition
    {
      ChangeExecuteCheck(executeCheck + node)
    }

    public static completion_evt : StateEvent = StateEvent(TransitionNode.Event(0, null));

    ///// <summary>
    ///// Shows that transition is used
    ///// </summary>
    //[NeedChange(omit_guard)]
    //[NeedChange]
    //public used : bool;

    ////public Updated : StateTransition
    ////{
    ////  get
    ////  {
    ////    def trans = match (this)
    ////                 {
    ////                   | Internal   => Source.internal_tran
    ////                   | Initial    => Source.initial
    ////                   | Transition => Source.transitions
    ////                   | _          => Source.all_transitions_with_init
    ////                 }
    ////    match (trans.Find(x => x.Num == Num))
    ////    {
    ////      | Some(tr) => tr
    ////      | _        => null
    ////    }
    ////  }
    ////}

    //public Used : bool
    //{
    //  get
    //  {
    //    used
    //  }
    //}

    //public Used : bool
    //{
    //  get
    //  {
    //    used || clones.Exists(_.Used)
    //  }
    //  set
    //  {
    //    used = value
    //  }
    //}

    //public UsedInGenerate : bool
    //{
    //  get
    //  {
    //    Used
    //  }
    //}

    ///// <summary>
    ///// Used in Choice of crossed transitions
    ///// </summary>
    //[NeedChange]
    //public UsedInChoice : bool;
    /// <summary>
    /// Shows that transition is cross for other
    /// </summary>
    //[NeedChange]
    //public CrossFor : bool;

    //[NeedChange]
    //public NotWork : bool;

    public Clone() : StateTransition
    {
      ChangeTo(To.Clone())
    }
    
    public override ToString() : string
    {
      Name
    }

    //public FromRegion : GeneralTree[FsmState]
    //{
    //  get
    //  {
    //    From.PartOfSubRegion()
    //  }
    //}
    /// <summary>
    /// Shows what need name with GuardNode out of name crossing
    /// </summary>        
    [NeedChange]
    public NeedGuardedName : bool;
    public static NameComparer : StateTransition * StateTransition -> bool = (x, y) => x.Name == y.Name;

  }

}
