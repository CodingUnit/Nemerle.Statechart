// transitionactions.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{

  using ListUtils;
  using PseudoStateNode;
  /// <summary>
  /// Description of TransitionActions.
  /// </summary>
  public partial class StateTransition
  {

    public this(an : FsmAnalyser) 
    {
      this.analyser = an
    }

    public this(st : PseudoStateNode, evt : option[TransitionEvent], tran : StateNode.Transition)
    {
      this(st.state, evt, tran);
      FromPseudo = Some(st);
    }

    public this(st : FsmState, evt : option[TransitionEvent], tran : StateNode.Transition)
    {
      def an = st.analyser;
      this.analyser = an;
      Source = st;
      From = st;
      trigger = evt.Map(StateEvent);
      type = tran.type;
      node = tran;
      when (tran != null)
      {
        guard = tran.guard;
        action = tran.action.MapDefault(_.actions, []);
      }
      To = if (tran.to != null) TransitionTarget.Create(st, tran.to) else TransitionTarget.Nowhere();
    }

    public this(st : FsmState, to : FsmState, type : TransitionType)
    {
      this(st, TransitionTarget.State(to), type)
    }

    public this(st : PseudoStateNode, to : FsmState, type : TransitionType)
    {
      this(st.state, TransitionTarget.State(to), type);
      FromPseudo = Some(st);
    }

    public this(st : FsmState, to : TransitionTarget, type : TransitionType)
    {
      this(st.analyser);
      //From = st;
      To = to;
      From = st;
      this.type = type;
      Source = From;
    }

    public this(tran : StateTransition)
    {
      this(tran.analyser);
      To = tran.To;
      guard = tran.guard;
      action = tran.action;
      //omit_guard = tran.omit_guard;
      From = tran.From;
      Source = tran.Source;
      //Path = tran.Path;
      Destination = tran.Destination;
      ActualTo = tran.ActualTo;
      node = tran.node;
      //Path = tran.Path;
      type = tran.type;
      executeCheck = tran.executeCheck;
      NeedGuardedName = tran.NeedGuardedName;
      trigger = tran.trigger;
      FromPseudo = tran.FromPseudo;
      internal_kind = tran.internal_kind;
      DecisionTree = tran.DecisionTree;
    }

    public node : StateNode.Transition;

    public type : TransitionType;
    public trigger : option[StateEvent];
    // state in from start transition in real time app
    public Source : FsmState {get;set;}
    // state in from arrow start in diagram
    public From : FsmState {get;set;}
    public guard : GuardNode {get;set;default GuardNode.Empty(-1)}
    public action : list[FsmAction] {get;set;default []}


    public To : TransitionTarget {get;set;}
    public FromPseudo : option[PseudoStateNode] = None();// {get;set;default None()}

    public internal_kind : TransitionKind {get;set;}

    public ActualTo : FsmState {get;set;}

    public Path : list[PathSequence] 
    {
      get
      {
        DecisionTree.Fold([], (x, a) => x.path :: a)
      }
    }
    public Destination : TransitionDestination {get;set;}
    //public omit_guard : bool {get;set;}
    public analyser : FsmAnalyser;
    //[NeedChange]
    public executeCheck : CheckNode {get;set;default CheckNode.Empty()} 
    //[NeedChange]
    //public clones : list[StateTransition] = [];

    public DecisionTree : DecisionNode {get;set;}
    //[NeedChange]
    public Local : bool
    {
      get
      {
        type == TransitionType.Local
      }
    }

/// </summary>            
    public NeedGuardedName : bool {get;set;default false}

    //TriggerName : string
    //{
    //  get
    //  {
    //    trigger.Name
    //  }
    //}

    public PostConditions : TransitionPostConditions
    {
      get
      {
        Destination?.PostConditions
      }
    }

    //public Guard : option[GuardNode]
    //{
    //  get
    //  {
    //    guard//if (omit_guard) None() else guard
    //  }
    //}

    public FriendlyTriggerName : string
    {
      get
      {
        match (trigger)
        {
          | None       => "Completion"
          //| Transition(TriggerName = trig)
          | Some(trig) => trig.Name
          //| Initial => "Initial"
          //| Default => "Default"
          //| History => "History"
        }
      }
    }

    //public IsCrossed : bool
    //{
    //  get
    //  {                
    //        !ParentCrossed.IsEmpty()
    //  }
    //}

    public IsCompletion : bool
    {
      get
      {
        FriendlyTriggerName == "Completion"
      }
    }

    public IsInitial : bool
    {
      get
      {
        FromPseudo is Some(PseudoStateNode.Initial)
      }
    }

    name : string
    {
      get
      {
        match (type, FromPseudo)
        {
          | (Internal, None)                         => $"InternalTransition$(From)By$FriendlyTriggerName"
          | (Transition, None)                       => $"Transition$(Source)To$(To)By$FriendlyTriggerName"
          | (_, Some(PseudoStateNode.Initial))       => $"InitialTransitionFrom$(From)To$To"
          | (_, Some(PseudoStateNode.History as h))  => 
              match (Destination)
              {
                | History(state = st) => $"DefaultTransition$(h)To$st"
                | _                   => $"DefaultTransition$(h)To$ActualTo"
              }
          | (Local, _) when (internal_kind == TransitionKind.History) => $"HistoryFrom$(From)To$ToState"
          | _                                                         => throw InvalidOperationException("invalid transition name")
        }
      }
    }


    public Name : string
    {
      get
      {
        if (NeedGuardedName) GuardedName else name;
      }
    }

    public GuardedName : string
    {
      get
      {
        match (guard)
        {
          | GuardNode.Empty => name
          | g               => $"$(name)With$(g.Name)"
        }
      }
    }

    public static GuardComparer : StateTransition * StateTransition -> int = (g1, g2) => g2.guard.CompareTo(g1.guard);

    public static Comparer : StateTransition * StateTransition -> int  =  (t1, t2)  => t1.Name.CompareTo(t2.Name);

    //public static FullComparer(t1 : StateTransition, t2 : StateTransition) : int
    //{
    //  def eq = if (t1.ActionList.Equals(t2.ActionList, _ == _)) 0 else -1;
    //  Comparer(t1, t2) + GuardComparer(t1, t2) + eq
    //}

    //public ToChoice : IEnumerable[StateTransition]
    //{
    //  get
    //  {
    //    match (Destination)
    //    {
    //      | Choice(_, tran, _) => tran
    //      | _                  => Enumerable.Empty()
    //    }
    //  }
    //}

    public ToState : FsmState
    {
      get
      {
        match (To)
        {
          | TransitionTarget.State(st)  => st
          | _                           => null
        }
      }
    }

    public ToPseudo : PseudoStateNode
    {
      get
      {
        match (To)
        { 
          | PseudoState(node) => node
          | _                 => null
        }
      }
    }

    public ToJunction : PseudoStateNode.Junction
    {
      get
      {
        match (ToPseudo)
        {
          | null => null
          | PseudoStateNode.Junction as j => j
          | _    => null
        }
      }
    }

    public EmptyDecisionTarget : DecisionNode
    {
      get
      {
        DecisionNode.Target(action, null, From, To, null)
      }
    }

    public StateObtainPseudoState(st : FsmState) : FsmState
    {
      if (Local) st else st.Super;
    }

    public StateObtainPseudoStateFromThis : FsmState
    {
      get
      {
        StateObtainPseudoState(From)
      } 
    }
    /// <summary>
    /// Concrete State for where transition ends known at compile time
    /// </summary>
    public AtLeastStaticTo : FsmState
    {
      get
      {
        match (To)
        {
          | Final(st)
          | State(st)       => st
          //| History(PseudoStateNode.History(state = st))
          //| PseudoState(Junction) => null
          | PseudoState(st)   => st.state
          //| JunctionNode(state = st)
          | _                 => null
        }

      }
    }

    public SimpleDecisionTree : TransitionTarget
    {
      get
      {
        match (DecisionTree)
        {
          | DecisionNode.Target(target = t)
          | DecisionNode.Condition(body = DecisionNode.Target(target = t), else_node = None) when (!t.IsJunction) => t
          | _                                                                                                     => null
        }
      }
    }

    //public PathNode : IEnumerable[PathNode]
    //{
    //  get
    //  {
    //    match (type)
    //    {
    //      | Internal => action.Select(PathNode.Action(From, _))//TraverseUtils.SingleElement(node)
    //      | _        => Path.Path.Path
    //    }
    //  }
    //}

    //public PathNodeRecursive : IEnumerable[PathNode]
    //{
    //  get
    //  {
    //    match (Destination)
    //    {
    //      | null               => PathNode
    //      //| JunctionNode(node) => PathNode.Concat(node.Paths)
    //      | _                  => PathNode
    //    }
    //  }
    //}

    public Trigger : StateEvent
    {
      get
      {
        match (trigger)
        {
          | Some(t) => t
          | _       => null
        }
      }
    }

    //public MaybeInlined : bool
    //{
    //  get
    //  {
    //    def path_inlined(p)
    //    {
    //      def false_paths(p)
    //      {
    //        | PathNode.Entry
    //        | Exit  => true
    //        | _     => false
    //      }

    //      !p.Exists(false_paths) && p.PathActions().IsEmpty()
    //    }

    //    def path_ok = path_inlined(Path.Path.Path) && Guards.IsEmpty();
    //    def targ_ok = match (Destination)
    //                   {
    //                     | ForceStateChange                                  => false
    //                    //| JunctionNode(DecisionNode(Paths = p, Guards = g)) => path_inlined(p) && g is [] 
    //                     | _                                                 => true
    //                   }
    //    path_ok && targ_ok
    //  }
    //}

    public Guards : IEnumerable[GuardNode]
    {
      get
      {
        def to = To.Guards;
        match (guard)
        {
          | Empty => to
          | _     => to.AddBefore(guard)
        }
      }
    }



    public Statemap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }


    //public TargetTraverse(func : TransitionTarget -> TransitionTarget) : void
    //{
    //  To = To.Traverse(func)
    //}

    public Actions : IEnumerable[FsmAction]
    {
      get
      {
        Path.SelectMany(x => x.action_nodes.FilterValues(x => x.PathAction))
        //match (type)
        //{
        //  | Internal => action
        //  | _        => 
        //}
      }
    }

    public WithinRegion : bool
    {
      get
      {
        match (AtLeastTo.PartOfRegion, From.PartOfRegion)
        {
          | (Some(r), Some(reg)) => r == reg : object
          | _                    => false
        }
      }
    }

    public OutOfRegion : bool
    {
      get
      {
        match (AtLeastTo.PartOfRegion, From.PartOfRegion)
        {
          | (Some(r), Some(reg)) => r != reg : object
          | (Some, None)         => true
          | _                    => false
        }
      }
    }    

    /// <summary>
    /// State for which at least transition proceed known at compile time
    /// </summary>
    public AtLeastTo : FsmState
    {
      get
      {
        def check_dest(d)
        {
          | null => match (To)
              {
                | TransitionTarget.Final(st) => st
                //| History(PseudoStateNode.History(state = st))
                | PseudoState(node) => node.state
                | State(st)         => st
                | _                 => null
              }
          | TransitionDestination.State when ActualTo != null => ActualTo
          | State(st) => st
          | Choice(_, _, Some(st))
          | Choice(st, _, _)
          | Fork(st, _)
          | Region(st)
          | Final(state = st) => st
          | CheckAfter(before = st)
          | ForceStateChange(st)
          | SubRegion(state = st) => check_dest(st)
          | TransitionExecute(t) => t.AtLeastTo
          | Terminate(j)
          | Join(j)
          | History(j) => j.state
          | _ => null
        }

        check_dest(Destination)
      }
    }



    public AddCheck(node : CheckNode) : void
    {
      executeCheck = executeCheck + node
    }

    public static completion_evt : StateEvent = StateEvent(TransitionEvent(null, 0));

    public Used : bool
    {
      get
      {
        analyser.Used[this]
      }
      set
      {
        analyser.Used[this] = value
      }
    }

    public Clone() : StateTransition
    {
      StateTransition(this)
      //match (this)
      //{
      //  | Initial        => Initial(this)
      //  | Default(h)     => Default(this, h)
      //  | Transition(e)  => Transition(this, e)
      //  | History as h   => History(h)
      //  | Internal(t)    => Internal(this, t)
      //}
    }

    public override ToString() : string
    {
      Name
    }


    public static NameComparer : StateTransition * StateTransition -> bool = (x, y) => x.Name == y.Name;

    public TraversePath(recursive : bool = false) : void
    {
      def path = TransitionPath(this, recursive);
      path.Traverse();
      //def tran = path.Transition;
      //tran.ChangePath(path)
    }

    public FromRegion : option[FsmState]
    {
      get
      {
        Source.PartOfSubRegion
      }
    }

    public CreateSimpleDecisionTree() : void
    {
      match (guard)
      {
        | GuardNode.Empty      => DecisionTree = EmptyDecisionTarget;
        | GuardNode.Expr as g  => def target = EmptyDecisionTarget;
                                  DecisionTree = DecisionNode.Condition(action, null, From, g, target, None())
        | _                    => throw InvalidOperationException("GuardNode.Else is not permitted on this stage")
      }
    }

    public InitSimpleDecisionTree(path : PathSequence) : void
    {
      when (SimpleDecisionTree != null)
      foreach (n in DecisionTree.GetBreadthFirstEnumerable())
      {
        | DecisionNode.Target as t => t.destination = Destination;
                                      n.path = path;
        | _                        => n.path = path;
      }
    }

    public static GetPseudo[T](this tran : IEnumerable[StateTransition]) : IEnumerable[T] where T : PseudoStateNode
    {
      def get_pseudo(t, lst)
      {
        match (t)
        {
          | StateTransition(To = TransitionTarget.PseudoState(p)) when (p is T) => p :> T :: lst
          | _                                                                   => lst
        }
      }

      tran.FoldLeft([], get_pseudo).Distinct()
    }

    public static Compare(comparer : StateTransition * StateTransition -> int) :  StateTransition *  StateTransition -> int
    {
      (x, y) => comparer(x, y)
    }
  }

}
