using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  using ListUtils;
  using PseudoStateNode;
  /// <summary>
  /// Description of TransitionActions.
  /// </summary>
  public partial variant StateTransition
  {

    public this(an : FsmAnalyser) 
    {
      this.analyser = an
    }

    public this(st : FsmState, tran : StateNode.Transition)
    {
      this(st.analyser);
      From = st;
      Source = st;
      node = tran;
      when (tran != null)
      {
        guard = tran.guard;
        action = tran.action;
      }
      To = if (tran.to != null) TransitionTarget.Create(st.analyser, st, tran.to) else null
    }
    
    public this(st : FsmState, to : FsmState)
    {
      this(st, TransitionTarget.State(st.analyser, to))
    }

    public this(st : FsmState, to : TransitionTarget)
    {
      this(st.analyser);
      From = st;
      To = to;
      Source = st;
    }

    public node : StateNode.Transition;

    public this(tran : StateTransition)
    {
      this(tran.analyser);
      From = tran.From;
      guard = tran.guard;
      action = tran.action;
      To = tran.To;
      omit_guard = tran.omit_guard;
      ParentCrossed = tran.ParentCrossed;
      Source = tran.Source;
      Local = tran.Local;
      //ImplicitFrom = tran.ImplicitFrom;
    }

    [NeedChange]
    public Num : int;

    [NeedChange(Source)]
    [NeedChange(To)]
    [NeedChange]
    public From : FsmState;
    [NeedChange]
    public guard : option[GuardNode] = None();
    [NeedChange]
    public action : option[Actions] = None();
    [NeedChange]
    public To : TransitionTarget;
    [NeedChange]
    public ActualTo : FsmState;
    [NeedChange]
    public Path : TransitionPath;

    [NeedChange]
    public clones : list[StateTransition] = [];
    
    [NeedChange(ActualTo)]
    [NeedChange]
    public Destination : TransitionDestination;

    public PostConditions : TransitionPostConditions
    {
      get
      {
        Destination?.PostConditions
      }
    }

    [NeedChange]
    public omit_guard : bool;

    public Guard : option[GuardNode]
    {
      get
      {
        if (omit_guard) None() else guard
      }
    }

    public SourceGuard : option[GuardNode]
    {
      get
      {
        guard
      }
    }

    public FriendlyTriggerName : string
    {
      get
      {
        match (this)
        {
          | Transition(TriggerName = null) => "Completion"
          | Transition(TriggerName = trig)
          | Internal(TriggerName = trig) => trig
          | Initial => "Initial"
          | Default => "Default"
          | History => "History"
        }
      }
    }

    public IsCrossed : bool
    {
      get
      {                
            !ParentCrossed.IsEmpty()
      }
    }

    public IsCompletion : bool
    {
      get
      {
        FriendlyTriggerName == "Completion"
      }
    }

    name : string
    {
      get
      {
        match (this)
        {
          | Transition(implicit_from = null) => $"Transition$(Source)To$(To)By$(FriendlyTriggerName)"
          | Transition(implicit_from = src)  => $"Transition$(src)To$(To)"
          | Internal(TriggerName = t)        => $"InternalTransition$(From)By$(t)"
          | Initial                          => $"InitialTransitionFrom$(From)To$To"
          | History                          => $"HistoryFrom$(From)To$ToState"
          | Default(history = h)             => 
              match (Destination)
              {
                | History(StateHistory where (state = st)) => $"DefaultTransition$(h)To$st"
                | _ => $"DefaultTransition$(h)To$ActualTo"
              }
        }
      }
    }

    public Name : string
    {
      get
      {
        if (NeedGuardedName) GuardedName else name;
      }
    }

    public GuardedName : string
    {
      get
      {
        match (Guard)
        {
          | Some(g) => $"$(name)With$g"
          | _       => name
        }
      }
    }

    public static GuardComparer : StateTransition * StateTransition -> int = (g1, g2) => g2.Guard.Compare(g1.Guard, (x, y) => x.CompareTo(y));

    public static Comparer : StateTransition * StateTransition -> int  =  (t1, t2)  => t1.Name.CompareTo(t2.Name);

    public static FullComparer(t1 : StateTransition, t2 : StateTransition) : int
    {
      def eq = if (t1.ActionList.Equals(t2.ActionList, _ == _)) 0 else -1;
      Comparer(t1, t2) + GuardComparer(t1, t2) + eq
    }

    /// <summary>
    /// Transitions from parents crossed by events with this state
    /// </summary>
    [NeedChange]
    public ParentCrossed : list[StateTransition] = [];

    public HistoryTarget : StateHistory
    {
      get
      {
        match (To)
        {
          | TransitionTarget.History(hist)  => hist
          | _                               => null
        }
      }
    }

    public ToChoice : IEnumerable[StateTransition]
    {
      get
      {
        match (Destination)
        {
          | Choice(_, tran, _) => tran
          | _                  => Enumerable.Empty()
        }
      }
    }

    public ToState : FsmState
    {
      get
      {
        match (To)
        {
          | TransitionTarget.State(st)  => st
          | _                           => null
        }
      }
    }

    /// <summary>
    /// Concrete State for where transition ends known at compile time
    /// </summary>
    public AtLeastStaticTo : FsmState
    {
      get
      {
        match (To)
        {
          | Final(st)
          | History(StateHistory(state = st))
          | PseudoState(PseudoStateNode(state = st))
          | JunctionNode(state = st)
          | State(st) => st.Updated
          | _         => null
        }

      }
    }

    /// <summary>
    /// Beginning state from which real executes transition
    /// </summary>
    /// <remarks>
    /// (from From differs, what Source shows current active state from which executes transition, not from beginning on diagram
    /// From determines beginning state from which follow out transition
    /// Source as a rule is nested state or same as From, if From not have sub states
    /// </remarks>
    [NeedChange]
    public Source : FsmState;

    [NeedChange]
    public Local : bool;

    public TraversePath(recursive : bool = false) : StateTransition
    {
      def path = TransitionPath(this, analyser, recursive);
      path.Traverse();
      def tran = path.Transition;
      tran.ChangePath(path)
    }

    public SetNewId() : StateTransition
    {
      ChangeNum(analyser.statemap.GetNewTransitionId(this))
    }
    
    public PathNode : IEnumerable[PathNode]
    {
      get
      {
        match (this)
        {
          | Internal(ActionNode = node) => TraverseUtils.SingleElement(node)
          | _                           => Path.Path.Path
        }
      }
    }

    public PathNodeRecursive : IEnumerable[PathNode]
    {
      get
      {
        match (Destination)
        {
          | null               => PathNode
          | JunctionNode(node) => PathNode.Concat(node.Paths)
          | _                  => PathNode
        }
      }
    }

    public Trigger : StateEvent
    {
      get
      {
        match (this)
        {
          | Transition(trigger = t)
          | Internal(trigger = t) => t
          | _                     => null
        }
      }
    }

    public MaybeInlined : bool
    {
      get
      {
        def path_inlined(p)
        {
          def false_paths(p)
          {
            | PathNode.Entry
            | Exit  => true
            | _     => false
          }

          !p.Exists(false_paths) && p.PathActions().IsEmpty()
        }

        def path_ok = path_inlined(Path.Path.Path) && Guards.IsEmpty();
        def targ_ok = match (Destination)
                       {
                         | ForceStateChange                                  => false
                         | JunctionNode(DecisionNode(Paths = p, Guards = g)) => path_inlined(p) && g is [] 
                         | _                                                 => true
                       }
        path_ok && targ_ok
      }
    }

    public Guards : IEnumerable[GuardNode]
    {
      get
      {
        def to = To.Guards;
        match (SourceGuard)
        {
          | Some(g) => to.AddBefore(g)
          | _       => to
        }
        //SourceGuard %:: To.Guards
          //| TransitionTarget.PseudoState(PseudoStateNode.Merge(to = TransitionTarget.JunctionNode(Guards = g)))
          //| TransitionTarget.PseudoState(PseudoStateNode.Junction(Guards = g)) => g.Append(SourceGuard)//SourceGuard %:: g
          //| _                                                                  => Enumerable.Empty().Append(SourceGuard)//SourceGuard %:: []
      }
    }

    public analyser : FsmAnalyser;
    public Statemap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }

    public UpdateReference() : StateTransition
    {
      def from = if (From != null) 
                  {
                    Statemap.Get(From);
                  } else null;
      def to = To.UpdateReference();
      ChangeFromTo(from, to)
    }

    /// !!! mutable
    public TargetTraverse(func : TransitionTarget * StateTransition -> TransitionTarget, manual_rebuild : bool = false) : StateTransition
    {
      if (To != null) 
      {
        def to = To.ReduceSingle(manual_rebuild, (p, _) => func(p, this));
        ChangeTo(to)
      } else this
    }

    //public UpdateTargets(old_t : FsmState, new_t : FsmState) : StateTransition
    //{
    //  def old_num = old_t.Num;
      
    //  def check_target(tar)
    //  {
    //    | TransitionTarget.State(st) as t when (st.Num == old_t.Num) => t.ChangeState(new_t)
    //    | Qualified(_, State(st) as t) when (st.Num == old_t.Num)    => t.ChangeState(new_t)
    //    | Final(st) as t when (st.Num == old_t.Num)                  => 
    //        match (new_t)
    //        {
    //          | FsmState.Final as st => t.ChangeState(st)
    //          | _                    => null
    //        }
    //    | PseudoState(node) as t when (node.state.Num == old_t.Num)  => t.ChangeNode(node.ChangeState(new_t))
    //    | _                                                          => null
    //  }

    //  def from = if (From.Num == old_num) new_t else From;
    //  def src  = if (Source.Num == old_num) new_t else Source;
    //  def tr   = ChangeFromSource(from, src);
    //  tr.TargetTraverse(check_target)
    //}

    public ActionList : list[string]
    {
      get
      {
        action.MapDefault(_.actions, [])
      }
    }

    public Actions : IEnumerable[string]
    {
      get
      {
        match (this)
        {
          | Internal(ActionNode = a) => a.Actions
          | _                        => Path.Actions
        }
      }
    }

    public WithinRegion : bool
    {
      get
      {
        match (AtLeastTo, From)
        {
          | (FsmState(PartOfRegion = Some(r)), FsmState(PartOfRegion = Some(reg))) => r == reg
          | _                                                                      => false
        }
      }
    }    

    public OutOfRegion : bool
    {
      get
      {
        match (AtLeastTo, From)
        {
          | (FsmState(PartOfRegion = Some(r)), FsmState(PartOfRegion = Some(reg))) => r != reg
          | (FsmState(PartOfRegion = Some), FsmState(PartOfRegion = None))         => true
          | _                                                                      => false
        }
      }
    }    

    /// <summary>
    /// State for which at least transition proceed known at compile time
    /// </summary>
    public AtLeastTo : FsmState
    {
      get
      {
        def check_dest(d)
        {
          | null => match (To)
              {
                | Final(st)
                | History(StateHistory(state = st))
                | PseudoState(PseudoStateNode(state = st))
                | JunctionNode(state = st)
                | State(st) => st
                | _         => null
              }
          | TransitionDestination.State when ActualTo != null => ActualTo
          | State(st) => st
          | Choice(_, _, Some(st))
          | Choice(st, _, _)
          | Fork(st, _)
          | History(StateHistory(state = st))
          | Region(ConcurrentRegion as st)
          | Join(Join(state = st))
          | Final(state = st)
          | Terminate(PseudoStateNode.Terminate(state = st)) => st
          | CheckAfter(before = st)
          | ForceStateChange(st)
          | SubRegion(state = st) => check_dest(st)
          | _ => null
        }

        check_dest(Destination)
      }
    }

    [NeedChange]
    [Accessor]
    public executeCheck : CheckNode = CheckNode.Empty();

    public AddCheck(node : CheckNode) : StateTransition
    {
      ChangeExecuteCheck(executeCheck + node)
    }

    public static completion_evt : StateEvent = StateEvent(TransitionNode.Event(0, null));

    /// <summary>
    /// Shows that transition is used
    /// </summary>
    [NeedChange(omit_guard)]
    [NeedChange]
    public used : bool;
    
    public Updated : StateTransition
    {
      get
      {
        def trans = match (this)
        {
          | Internal   => Source.Updated.internal_tran
          | Initial    => Source.Updated.initial
          | Transition => Source.Updated.transitions
          | _          => Source.Updated.all_transitions_with_init
        }
        match (trans.Find(x => x.Num == Num))
        {
          | Some(tr) => tr
          | _        => null
        }
      }
    }
    
    public Used : bool
    {
      get
      {
        used
      }
    }

    //public Used : bool
    //{
    //  get
    //  {
    //    used || clones.Exists(_.Used)
    //  }
    //  set
    //  {
    //    used = value
    //  }
    //}

    public UsedInGenerate : bool
    {
      get
      {
        Used
      }
    }

    /// <summary>
    /// Used in Choice of crossed transitions
    /// </summary>
    [NeedChange]
    public UsedInChoice : bool;
    /// <summary>
    /// Shows that transition is cross for other
    /// </summary>
    [NeedChange]
    public CrossFor : bool;

    [NeedChange]
    public NotWork : bool;

    public override ToString() : string
    {
      Name
    }

    public FromRegion : FsmState.ConcurrentSubRegion
    {
      get
      {
        From.PartOfSubRegion.Value
      }
    }
    /// <summary>
    /// Shows what need name with GuardNode out of name crossing
    /// </summary>        
    [NeedChange]
    public NeedGuardedName : bool;
    public static NameComparer : StateTransition * StateTransition -> bool = (x, y) => x.Name == y.Name;

  }

}
