using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;
using NC = Nemerle.Collections;

namespace Nemerle.Statechart
{

  using ListUtils;

  public class NodeValue[T, V]
  {
    public Value : V {get;set;}
    
    public Parent : SimpleTreeNode[T] {get;set;}
    
    public this(parent : SimpleTreeNode[T], val : V) 
    {
      Parent = parent;
      Value = val;
    }
    
    public Update(func : V -> V) : void
    {
      Value = func(Value)
    }
  }
  
  public class ValueMap[T, V]
  {
    [Accessor]
    map : NC.Hashtable[SimpleTreeNode[T], list[NodeValue[T, V]]] = NC.Hashtable();
    
    public Add(node : SimpleTreeNode[T], val : IEnumerable[NodeValue[T, V]]) : void
    {
      map[node] = map[node].Concat(val).NToList()
    }

    public Add(node : SimpleTreeNode[T], val : NodeValue[T, V]) : void
    {
      map[node] = val :: map[node]
    }
    
    public Rem(node : SimpleTreeNode[T], val : IEnumerable[NodeValue[T, V]]) : void
    {
      map[node] = map[node].Except(val).NToList()
    }
    
    public Clear(node : SimpleTreeNode[T]) : void
    {
      map[node] = []
    }
    
    public Values : IEnumerable[NodeValue[T, V]]
    {
      get
      {
        map.SelectMany(_.Value)
      }
    }
    
    public Item[index : SimpleTreeNode[T]] : list[NodeValue[T, V]]
    {
      get
      {
        map[index]
      }
      set
      {
        map[index] = value
      }
    }
  }
  /// <summary>
  /// Description of FsmNode.
  /// </summary>
  public variant FsmNode
  {
    | State       { [NeedChange] node : SimpleTreeNode[FsmState]; }
    | PseudoState { [NeedChange] node : NodeValue[FsmState, PseudoStateNode]; }

    //public Analyser : FsmAnalyser
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | State(node)       => node.Value.analyser
    //      | PseudoState(node) => node.analyser
    //    }
    //  }
    //}

    public StateNode : SimpleTreeNode[FsmState]
    {
      get
      {
        match (this)
        {
          | State(node) => node
          | _           => null
        }
      }
    }


    //public CompareTo(node : FsmNode) : int
    //{
    //  match (this, node)
    //  {
    //    | (State(a), State(b))             => a.Value.CompareTo(b.Value)
    //    | (PseudoState(a), PseudoState(b)) => a.Num - b.Num
    //    | (_, _)                           => -1
    //  }
    //}

    public static PartOfRegion(this node : SimpleTreeNode[FsmNode]) : option[FsmState]
    {
      node.Parents().FindType()
    }

    public static PartOfSubRegion(this node : SimpleTreeNode[FsmNode]) : option[FsmState]
    {
      node.Parents().FindType()
    }

    public static ParentState(this node : SimpleTreeNode[FsmNode]) : SimpleTreeNode[FsmState]
    {
      match (node.Parent)
      {
        | null                                      => null
        | SimpleTreeNode(Value = FsmNode.State(st)) => st
        | _                                         => null
      }
    }

  }

  public class TreeNode
  {
    public static Parents[T](this node : SimpleTreeNode[T]) : IEnumerable[SimpleTreeNode[T]]
    {
      def loop(node)
      {
        if (node != null) 
        {
          yield node;
          loop(node.Parent)
        } else ()

      }

      loop(node.Parent)
    }

    public static Update[T](this node : SimpleTreeNode[T], change : T -> T) : void
    {
      node.Value = change(node.Value)
    }

    public static Clone[T](this node : SimpleTreeNode[T]) : SimpleTreeNode[T]
    {
      def folder(n, acc)
      {
        def node = SimpleTreeNode(n.Value);
        if (acc != null) node.Children.AddRange(acc); else ();
        node
      }

      Fold(node, null, folder)
    }

    public static Fold[T, TAcc](this node : SimpleTreeNode[T], init : TAcc, folder : SimpleTreeNode[T] * list[TAcc] -> TAcc) : TAcc
    {
      def fold(n, acc)
      {
        def (chacc, tail) = acc.PopRev(n.Children.Count());
        folder(n, chacc) :: tail
      }

      node.GetPostOrderEnumerable().FoldLeft([init], fold).Head
    }

    public static Reduce[T](this node : SimpleTreeNode[T], folder : SimpleTreeNode[T] -> T, type : TreeTraversalType = TreeTraversalType.PostOrder) : void
    {
      def reduce(n)
      {
        n.Value = folder(n)
      }

      node.GetEnumerable(type).Iter(reduce)
    }

    public static Unfold[T](this node : SimpleTreeNode[T], func : T -> IEnumerable[T]) : void
    {
      def unfold(n)
      {
        def childs = func(n.Value);
        def nodes = childs.Select(SimpleTreeNode);
        n.Children.AddRange(nodes);
        nodes
      }

      def lst = SCG.Queue();

      def loop()
      {
        if (lst.IsEmpty()) () else 
        {
          def node = lst.Dequeue();
          def childs = node.GetBreadthFirstEnumerable().SelectMany(unfold);
          childs.Iter(lst.Enqueue);
          loop()
        }
      }

      lst.Enqueue(node);
      loop()
    }

  }

  [Record]
  public variant TreeJunctionNode
  {
    | Node 
    | Target { target : TransitionTarget; }

    public pos    : int;
    public guard  : GuardNode;
    public action : list[Actions] = [];
    

    public static Create(node : PseudoStateAstNode.Junction) : SimpleTreeNode[TreeJunctionNode]
    {
      def nodes = node.node.Map(SimpleTreeNode);
      def jnode = SimpleTreeNode();
      jnode.Children.AddRange(nodes);

      def fold(n)
      {
        | JunctionNode(to = TargetType.PseudoState(Junction(node = n))) => n
        | _                                                             => Enumerable.Empty()
      }

      jnode.Unfold(fold);

      def fold(n, sb)
      {
        def node = match (n.Value)
                    {
                      | JunctionNode(p, g, a, TargetType.PseudoState(Junction)) => def a = if (a is Some(a)) a :: [] else []; 
                                                                                   Node(p, g, a)
                      | JunctionNode(p, g, a, t)                                => def a = if (a is Some(a)) a :: [] else []; 
                                                                                   Target(p, g, a, TransitionTarget.Create(t))
                    }
        def node = SimpleTreeNode(node);
        node.Children.AddRange(sb);
        node
      }

      jnode.Fold(null, fold)
    }

  }
}
