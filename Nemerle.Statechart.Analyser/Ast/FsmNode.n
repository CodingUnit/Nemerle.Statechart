using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{

  /// <summary>
  /// Description of FsmNode.
  /// </summary>
  public variant FsmNode
  {
    | State       { [NeedChange] node : SimpleTreeNode[FsmState]; }
    | PseudoState { [NeedChange] node : PseudoStateNode; }

    public StateNode : FsmState
    {
      get
      {
        match (this)
        {
          | State(node) => node.Value
          | _           => null
        }
      }
      set
      {
        match (this)
        {
          | State(node) => node.Value = value
          | _           => ()
        }
      }
    }


    public CompareTo(node : FsmNode) : int
    {
      match (this, node)
      {
        | (State(a), State(b))             => a.Value.CompareTo(b.Value)
        | (PseudoState(a), PseudoState(b)) => a.Num - b.Num
        | (_, _)                           => -1
      }
    }

    public static PartOfRegion(this node : SimpleTreeNode[FsmNode]) : option[FsmState.ConcurrentRegion]
    {
      node.Parents().FindType()
    }

    public static PartOfSubRegion(this node : SimpleTreeNode[FsmNode]) : option[FsmState.ConcurrentSubRegion]
    {
      node.Parents().FindType()
    }

  }

  public class TreeNode
  {
    public static Parents[T](this node : SimpleTreeNode[T]) : IEnumerable[T]
    {
      def loop(node)
      {
        if (node != null) 
        {
          yield node.Value;
          loop(node.Parent)
        } else ()

      }

      loop(node.Parent)
    }

    public static Update[T](this node : SimpleTreeNode[T], change : T -> T) : void
    {
      node.Value = change(node.Value)
    }

    
    public static Fold[T, TAcc](this node : SimpleTreeNode[T], folder : T * list[TAcc] -> TAcc) : TAcc
    {
      def fold(n, acc)
      {
        def (chacc, tail) = acc.PopRev(n.Children.Count());
        folder(n.Value, chacc) :: tail
      }
      
      node.GetPostOrderEnumerable().FoldLeft([], fold).Head
    }
  }

  [Traversable]
  public variant JunctionNode
  {
    | Node 
    | Target { target : FsmNode; }

    public guard  : GuardNode;
    public action : option[Actions] = None();

    public GetChild() : IEnumerable[JunctionNode]
    {
      Enumerable.Empty()
    }

    public Rebuild(_ : IEnumerable[JunctionNode]) : JunctionNode
    {
      this
    }

  }
}
