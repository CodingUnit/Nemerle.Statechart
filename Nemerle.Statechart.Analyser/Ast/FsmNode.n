using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{

  /// <summary>
  /// Description of FsmNode.
  /// </summary>
  public variant FsmNode
  {
    | State       { [NeedChange] node : SimpleTreeNode[FsmState]; }
    | PseudoState { [NeedChange] node : PseudoStateNode; }

    public StateNode : FsmState
    {
      get
      {
        match (this)
        {
          | State(node) => node.Value
          | _           => null
        }
      }
      set
      {
        match (this)
        {
          | State(node) => node.Value = value
          | _           => ()
        }
      }
    }


    public CompareTo(node : FsmNode) : int
    {
      match (this, node)
      {
        | (State(a), State(b))             => a.Value.CompareTo(b.Value)
        | (PseudoState(a), PseudoState(b)) => a.Num - b.Num
        | (_, _)                           => -1
      }
    }
    
    public static PartOfRegion(this node : SimpleTreeNode[FsmNode]) : option[FsmState.ConcurrentRegion]
    {
      node.Parents().FindType()
    }
    
    public static PartOfSubRegion(this node : SimpleTreeNode[FsmNode]) : option[FsmState.ConcurrentSubRegion]
    {
      node.Parents().FindType()
    }
  }

  public class TreeNode
  {
    public static Parents[T](this node : SimpleTreeNode[T]) : IEnumerable[T]
    {
      def loop(node)
      {
        if (node != null) 
        {
          yield node.Value;
          loop(node.Parent)
        } else ()
        
      }
      
      loop(node.Parent)
    }
    
    public static Update[T](this node : SimpleTreeNode[T], change : T -> T) : void
    {
      node.Value = change(node.Value)
    }
    
  }
  
  public variant JunctionNode
  {
    | Node 
    | Target { target : FsmNode; }

    guard  : GuardNode;
    action : option[Actions] = None();

  }
}
