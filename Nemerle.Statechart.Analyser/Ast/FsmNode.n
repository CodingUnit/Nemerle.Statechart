using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;
using NC = Nemerle.Collections;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{

  using ListUtils;

  public class NodeValue[T, V]
  {
    public Value : V {get;set;}

    public Parent : GeneralTree[T] {get;set;}

    public this(parent : GeneralTree[T], val : V) 
    {
      Parent = parent;
      Value = val;
    }

    public Clone() : NodeValue[T, V]
    {
      NodeValue(Parent, Value)
    }

    public Update(func : V -> V) : void
    {
      Value = func(Value)
    }
  }

  public class ValueMap[T, V]
  {
    [Accessor]
    map : NC.Hashtable[GeneralTree[T], list[NodeValue[T, V]]] = NC.Hashtable();

    public Add(node : GeneralTree[T], val : IEnumerable[NodeValue[T, V]]) : void
    {
      map[node] = map[node].Concat(val).NToList()
    }

    public Add(node : GeneralTree[T], val : NodeValue[T, V]) : void
    {
      map[node] = val :: map[node]
    }

    public Rem(node : GeneralTree[T], val : IEnumerable[NodeValue[T, V]]) : void
    {
      map[node] = map[node].Except(val).NToList()
    }

    public Clear(node : GeneralTree[T]) : void
    {
      map[node] = []
    }

    public Values : IEnumerable[NodeValue[T, V]]
    {
      get
      {
        map.SelectMany(_.Value)
      }
    }

    public Item[index : GeneralTree[T]] : list[NodeValue[T, V]]
    {
      get
      {
        map[index]
      }
      set
      {
        map[index] = value
      }
    }
  }
  /// <summary>
  /// Description of FsmNode.
  /// </summary>
  public variant FsmNode
  {
    | State       { [NeedChange] node : GeneralTree[FsmState]; }
    | PseudoState { [NeedChange] node : NodeValue[FsmState, PseudoStateNode]; }

    //public Analyser : FsmAnalyser
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | State(node)       => node.Value.analyser
    //      | PseudoState(node) => node.analyser
    //    }
    //  }
    //}

    public StateNode : GeneralTree[FsmState]
    {
      get
      {
        match (this)
        {
          | State(node) => node
          | _           => null
        }
      }
    }


    //public CompareTo(node : FsmNode) : int
    //{
    //  match (this, node)
    //  {
    //    | (State(a), State(b))             => a.Value.CompareTo(b.Value)
    //    | (PseudoState(a), PseudoState(b)) => a.Num - b.Num
    //    | (_, _)                           => -1
    //  }
    //}
    public static GetState(this node : FsmNode) : GeneralTree[FsmState]
    {
      | FsmNode.State(st)       => st
      | FsmNode.PseudoState(st) => st.Parent

    }

    public static PartOfRegion(this node : FsmNode) : option[GeneralTree[FsmState]]
    {
      node.GetState().PartOfRegion()
    }

    public static PartOfSubRegion(this node : FsmNode) : option[GeneralTree[FsmState]]
    {
      node.GetState().PartOfSubRegion()
    }

    public static ParentState(this node : GeneralTree[FsmNode]) : GeneralTree[FsmState]
    {
      match (node.Parent)
      {
        | null                                      => null
        | GeneralTree(Data = FsmNode.State(st)) => st
        | _                                         => null
      }
    }

  }

  public module TreeNode
  {
    public Parents[T](this node : GeneralTree[T]) : IEnumerable[GeneralTree[T]]
    {
      def loop(node)
      {
        if (node != null) 
        {
          yield node;
          loop(node.Parent)
        } else ()

      }

      loop(node.Parent)
    }

    public Update[T](this node : GeneralTree[T], change : T -> T) : void
    {
      node.Data = change(node.Data)
    }

    public Update[T](this node : BinaryTree[T], change : T -> T) : void
    {
      node.Data = change(node.Data)
    }

    public Reduce[T](this node : GeneralTree[T], folder : GeneralTree[T] * list[GeneralTree[T]] -> GeneralTree[T]) : GeneralTree[T]
    {
      //def folder(n, acc)
      //{
      //  folder(n, acc);
      //  //if (acc != null) node.AddRange(acc); else ();
      //}

      Fold(node, null, folder)
    }

    public Fold[T, TAcc](this node : GeneralTree[T], init : TAcc, folder : GeneralTree[T] * list[TAcc] -> TAcc) : TAcc
    {
      def fold(n, acc)
      {
        def (chacc, tail) = acc.PopRev(n.ChildNodes.Count());
        folder(n, chacc) :: tail
      }

      node.GetPostOrderEnumerable().FoldLeft([init], fold).Head
    }

    public Fold[T, TAcc](this node : BinaryTree[T], init : TAcc, folder : BinaryTree[T] * TAcc * TAcc -> TAcc) : TAcc where TAcc : class
    {
      def fold(n, acc)
      {
        //def left = if (n.Left != null) (Some(acc.Head), acc.Tail); else (null)
        match (n.Left, n.Right, acc)
        {
          | (null, null, a)          => folder(n, null, null) :: a
          | (null, _, a :: tail)     => folder(n, null, a)    :: tail
          | (_, null, a :: tail)     => folder(n, a, null)    :: tail
          | (_, _, ll :: rr :: tail) => folder(n, ll, rr)     :: tail
          | _                        => acc
        }
        //def (chacc, tail) = acc.PopRev(n.Count);
      }

      node.GetPostOrderEnumerable().FoldLeft([init], fold).Head
    }

    public Fold[T, TAcc](this node : BinaryTree[T], folder : T -> TAcc) : BinaryTree[TAcc] where TAcc : class
    {
      def create(t, l, r)
      {
        BinaryTree(folder(t.Data), l, r)
      }

      Fold(node, null, create)
    }

    public Reduce[T](this node : GeneralTree[T], folder : GeneralTree[T] -> T, type : TreeTraversalType = TreeTraversalType.PostOrder) : void
    {
      def reduce(n)
      {
        n.Data = folder(n)
      }

      node.GetEnumerable(type).Iter(reduce)
    }

    public Reduce[T](this node : BinaryTree[T], folder : BinaryTree[T] -> T) : void
    {
      def reduce(n)
      {
        n.Data = folder(n)
      }

      node.GetBreadthFirstEnumerable().Iter(reduce)
    }

    public Reduce[T](this node : BinaryTree[T], folder : BinaryTree[T] * BinaryTree[T] * BinaryTree[T] -> BinaryTree[T]) : BinaryTree[T]
    {
      node.Fold(null, folder)
      //node.GetBreadthFirstEnumerable().Iter(reduce)
    }

    public Unfold[T](this node : BinaryTree[T], func : T -> list[T], merge : list[T] -> BinaryTree[T]) : void
    {

      def loop(acc)
      {
        | []           => ()
        | head :: tail =>

            def tail = match (func(head.Data))
            {
              | []  => tail
              | lst => def new_node = merge(lst);
                      head.Right = new_node;
                      new_node :: tail
            }

            loop(tail)
        //childs.Iter(lst.Enqueue);
        //childs.FoldBack(null, (x, a) => BinaryTree(x, a, null));
      }

      loop(node :: [])

    }
  }

  [Record]
  public variant TreeJunctionNode
  {
    | Node 
    | Target 
      { 
        target : TransitionTarget; 

        dest   : TransitionDestination;
      }

    public pos    : int;
    public guard  : GuardNode;
    [NeedChange]
    public action : list[Actions] = [];
    public type : JunctionType;

    public static Create(node : PseudoStateAstNode.Junction) : BinaryTree[TreeJunctionNode]
    {
      def convert(n)
      {
        match (n)
        {
          | JunctionNode(p, g, a, TargetType.PseudoState(Junction)) => def a = if (a is Some(a)) a :: [] else []; 
                                                                      Node(p, g, a, node.type)
          | JunctionNode(p, g, a, t)                                => def a = if (a is Some(a)) a :: [] else []; 
                                                                      Target(p, g, a, node.type, TransitionTarget.Create(t), null)
        }                                                                          
      }

      def merge(n)
      {
        n.FoldBack(null, (x, a) => BinaryTree(x, a, null));
      }

      def jnode = merge(node.node);

      def fold(n : JunctionNode)
      {
        | JunctionNode(to = TargetType.PseudoState(Junction(node = n))) => n
        | _                                                             => []
      }

      jnode.Unfold(fold, merge);
      jnode.Fold(convert)
    }

  }
}
