using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  using ListUtils;
  using PseudoStateNode;
  using GuardNode;

  /// <summary>
  /// Description of DecisionNodeImpl.
  /// </summary>
  public partial variant DecisionNode
  {
    public static create_decision_tree(an : FsmAnalyser, node : PseudoStateNode.Junction) : DecisionNode
    {
      //def create_target(n)
      //{
      //  //DecisionNode.Target(n.analyser, [], n, n.analyser.statemap.GetNextGlobalNum())
      //}
      def create_junction_node(n : SimpleTreeNode[TreeJunctionNode], acc : list[DecisionNode])
      {
        def create_node(n, acc)
        {
          match (n, acc)
          {
            | (DecisionNode.Target(condition = GuardNode.Else) as t, null) => t
            | (DecisionNode.Target(condition = g, actions = a) as t, null) => DecisionNode.Condition(an, a, g, t.ChangeActionsCondition([], null), None())
            | (DecisionNode.Target(condition = g, actions = a) as t, acc)  => DecisionNode.Condition(an, a, g, t.ChangeActionsCondition([], null), Some(acc))
            | (DecisionNode.Condition as t, null)                          => t.ChangeElseNode(None())
            | (DecisionNode.Condition as t, acc)                           => t.ChangeElseNode(Some(acc))
          }
        }
        
        match (n.Value)
        {
          | TreeJunctionNode.Node(guard = g, action = a)               => //DecisionNode.Condition(an, g, a, toacc, Some(nacc))
                                                                          def node = acc.FoldBack(null, create_node);
                                                                          DecisionNode.Condition(an, a, g, node, None())
          | TreeJunctionNode.Target(guard = g, action = a, target = t) => DecisionNode.Target(an, a, g, t)
                                                                          //DecisionNode.Condition(an, g, a, DecisionNode.Target(an, [], t), )
          | _                                                          => null
        }
      }

      def tree = node.tree.Fold(null, create_junction_node);

      //create_states(tree);
      tree
    }

    //public static create_states(tar : DecisionNode) : void
    //{

    //  def check_node(n)
    //  {
    //    def set_state(n, st)
    //    {
    //      match (n)
    //      {
    //        | DecisionNode.Condition(state = null) as t
    //        | DecisionNode.Target(state = null) as t    => t.state = st
    //        | _                                         => ()
    //      }
    //    }

    //    def child = n.GetChild();
    //    child.Iter(set_state(_, n.state));
    //  }

    //  tar.LevelOrderIterator().Iter(check_node);
    //}

    public static create_junc_tree_node(an : FsmAnalyser, target : NodeValue[FsmState, PseudoStateNode]) : DecisionNode
    {
      //def junc = target.JunctionPseudo;
      def targ = target.Value :> PseudoStateNode.Junction;
      
      def check_node_decision(n : DecisionNode)
      {
        | DecisionNode.Condition(condition = Else, else_node = Some) => 
            an.AddError(if (targ.type == JunctionType.Junction) FsmError.JunctionElseMustBeLast(target) else FsmError.ChoiceElseMustBeLast(target))

        | Condition(condition = Empty, actions = []) => 
            an.AddError(if (targ.type == JunctionType.Junction) FsmError.EmptyJunction(target) else FsmError.EmptyChoice(target))

        | Condition(condition = GuardNode.Empty, actions = _ :: _ as a, else_node = Some) => 
            an.AddError(if (targ.type == JunctionType.Junction) FsmError.JunctionActionMaybeLast(target, a) else FsmError.ChoiceActionMaybeLast(target, a))

        | Condition(condition = GuardNode.Empty, else_node = Some)
        | Condition(body = DecisionNode.Condition(condition = Else)) => 
            an.AddError(if (targ.type == JunctionType.Junction) FsmError.JunctionElseMustAfterAnotherGuard(target) else FsmError.ChoiceElseMustAfterAnotherGuard(target))

        | _ => ()
      }

      def add_act(x, a)
      {
        x.ChangeActions(a.Concat(x.actions).NToList())
      }

      def create_actions(n)
      {
        | DecisionNode.Condition(actions = a, body = b, else_node = Some(els), type = JunctionType.Junction) as n => 
            def body = add_act(b, a);
            def els  = add_act(els, a);
            n.ChangeBodyActionsElseNode(body, [], Some(els))

        | DecisionNode.Condition(actions = a, body = b, type = JunctionType.Junction) as n => 
            def body = add_act(b, a);
            n.ChangeBodyActions(body, [])

        | _ => null
      }

      def merge_tree_node(n, b, e)
      {
        | (DecisionNode.Condition(condition = GuardNode.Else, actions = []), b, None)                         => b
        | (Condition(actions = act) as n, DecisionNode.Condition(actions = a, body = b, else_node = None), e) => 
            n.ChangeBodyActionsElseNode(b, act.Concat(a).NToList(), e)

        | (Condition as n, _, _)                                                                              => n.ChangeBodyElseNode(b, e)
      }

      def merge_tree_target(n)
      {
        n
      }

      def tree  = create_decision_tree(an, targ); // create decision tree
      tree.Reduce(true, merge_tree_node, merge_tree_target); // merge tree nodes
      //def old_nodes = tree.LevelOrderIterator();
      //old_nodes.Iter(check_node_decision);
      //def new_nodes = tree.LevelOrderMap(create_actions);
      //def node_map = old_nodes.MakeArrayMap(new_nodes, an.statemap.GlobalId, _.Num);
      //tree.ReduceSingle((x, _) => node_map[x.Num])
    }

    //public static Create(an : FsmAnalyser, node : TransitionTarget.PseudoState) : DecisionNode
    //{
    //  create_junc_tree_node(an, node)
    //}

  }
}
