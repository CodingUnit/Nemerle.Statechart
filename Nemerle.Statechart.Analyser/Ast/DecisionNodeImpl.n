using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using ListUtils;
  using PseudoStateNode;
  using GuardNode;

  /// <summary>
  /// Description of DecisionNodeImpl.
  /// </summary>
  public partial variant DecisionNode
  {

    public static create_decision_tree(target : PseudoStateNode.Junction) : void
    {
      
      
      def create_tree(node, a) : DecisionNode
      {
        match (node)
        {
          | FsmJunctionNode.Node(path = seq, guard = g, nodes = n) => 
              def a = if (a != null) Some(a) else None();
              DecisionNode.Condition(seq, g, n.FoldBack(null, create_tree), a)
          | Target(path = seq, target = t, dest = d)               => DecisionNode.Target(seq, t, d)
        }
      } 
              
      def check(n)
      {
        | FsmJunctionNode.Target(guard = GuardNode.Else) as n => n.guard = GuardNode.Empty(-1);
                                                                 n
        | FsmJunctionNode.Target(guard = GuardNode.Expr as g) as n => 
           n.guard = GuardNode.Empty(-1);
           FsmJunctionNode.Node(g, [], n.state, n.Parent, n.path, [n])
        | _ => n
      }
      
      def check_node(n)
      {
        | FsmJunctionNode.Node(nodes = n) as node => def n = n.Map(check);
                                                     node.nodes = n;
        | _ => ()
      }
      
      target.tree.Iter(check_node);
      def tree = create_tree(target.tree, null);
      def tree = if (tree is DecisionNode.Condition(condition = GuardNode.Empty, else_node = None, body = b)) b else tree;
      target.decision_tree = tree;
    }

  }
}
