using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  using ListUtils;
  using PseudoStateNode;
  using GuardNode;

  /// <summary>
  /// Description of DecisionNodeImpl.
  /// </summary>
  public partial variant DecisionNode
  {
    public static create_decision_tree(node : PseudoStateNode.Junction) : DecisionNode
    {
      //def create_target(n)
      //{
      //  //DecisionNode.Target(n.analyser, [], n, n.analyser.statemap.GetNextGlobalNum())
      //}

      def create_junction_node(n, acc)
      {
          | (JunctionNode.Node(guard = g, action = a), toacc :: [])        => DecisionNode.Condition(node.analyser, g, node.analyser.GetNextNum(), a.ToList(), toacc, None())
          | (JunctionNode.Node(guard = g, action = a), toacc :: nacc :: _) => DecisionNode.Condition(node.analyser, g, node.analyser.GetNextNum(), a.ToList(), toacc, Some(nacc))
          | (Target(t), _)                                                 => DecisionNode.Target(node.analyser, [], t, node.analyser.GetNextNum())
          | _                                                              => null
      }

      def tree = node.tree.Fold(create_junction_node);

      create_states(tree);
      tree
    }

    public static create_states(tar : DecisionNode) : void
    {

      def check_node(n)
      {
        def set_state(n, st)
        {
          match (n)
          {
            | DecisionNode.Condition(state = null) as t
            | DecisionNode.Target(state = null) as t    => t.state = st
            | _                                         => ()
          }
        }

        def child = n.GetChild();
        child.Iter(set_state(_, n.state));
      }

      tar.LevelOrderIterator().Iter(check_node);
    }

    public static create_junc_tree_node(an : FsmAnalyser, target : PseudoStateNode.Junction) : DecisionNode
    {
      //def junc = target.JunctionPseudo;
      
      def check_node_decision(n : DecisionNode)
      {
        | DecisionNode.Condition(condition = Else, else_node = Some) => 
            an.AddError(if (target.type == JunctionType.Junction) FsmError.JunctionElseMustBeLast(target) else FsmError.ChoiceElseMustBeLast(target))

        | Condition(condition = Empty, actions = []) => 
            an.AddError(if (target.type == JunctionType.Junction) FsmError.EmptyJunction(target) else FsmError.EmptyChoice(target))

        | Condition(condition = GuardNode.Empty, actions = _ :: _ as a, else_node = Some) => 
            an.AddError(if (target.type == JunctionType.Junction) FsmError.JunctionActionMaybeLast(target, a) else FsmError.ChoiceActionMaybeLast(target, a))

        | Condition(Empty, _, Some)
        | Condition(body = DecisionNode.Condition(Else, _, _)) => 
            an.AddError(if (target.type == JunctionType.Junction) FsmError.JunctionElseMustAfterAnotherGuard(target) else FsmError.ChoiceElseMustAfterAnotherGuard(target))

        | _ => ()
      }

      def add_act(x, a)
      {
        x.ChangeActions(a.Concat(x.actions).NToList())
      }

      def create_actions(n)
      {
        | DecisionNode.Condition(actions = a, body = b, else_node = Some(els), type = JunctionType.Junction) as n => 
            def body = add_act(b, a);
            def els  = add_act(els, a);
            n.ChangeBodyActionsElseNode(body, [], Some(els))

        | DecisionNode.Condition(actions = a, body = b, type = JunctionType.Junction) as n => 
            def body = add_act(b, a);
            n.ChangeBodyActions(body, [])

        | _ => null
      }

      def merge_tree_node(n, b, e)
      {
        | (DecisionNode.Condition(condition = GuardNode.Else, actions = []), b, None)                         => b
        | (Condition(actions = act) as n, DecisionNode.Condition(actions = a, body = b, else_node = None), e) => 
            n.ChangeBodyActionsElseNode(b, act.Concat(a).NToList(), e)

        | (Condition as n, _, _)                                                                              => n.ChangeBodyElseNode(b, e)
      }

      def merge_tree_target(n)
      {
        n
      }

      def tree  = create_decision_tree(target); // create decision tree
      def tree  = tree.Reduce(true, merge_tree_node, merge_tree_target); // merge tree nodes
      def old_nodes = tree.LevelOrderIterator();
      old_nodes.Iter(check_node_decision);
      def new_nodes = tree.LevelOrderMap(create_actions);
      def node_map = old_nodes.MakeArrayMap(new_nodes, an.statemap.GlobalId, _.Num);
      tree.ReduceSingle((x, _) => node_map[x.Num])
    }

    //public static Create(an : FsmAnalyser, node : TransitionTarget.PseudoState) : DecisionNode
    //{
    //  create_junc_tree_node(an, node)
    //}

  }
}
