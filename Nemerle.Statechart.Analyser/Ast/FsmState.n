using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;
using System.Reflection;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  [Record]
  [DebuggerDisplay("State  =  {Name}")]
  public partial variant FsmState
  {
    | State
      {
        this(name : string)
        {
          this(StateNode.State(name), null, null, true)
        }

      }

    | Final
      {
          //this(st : Final, reference : bool = false, ncopy : bool = false)
          //{
          //  base(st, reference, clone);
          //}
        this(state : StateNode.Final, an : FsmAnalyser)
        {
          base(state.state, Enumerable.Empty(), an, false)
        }

        this(super : FsmState, an : FsmAnalyser, reference : bool =  false)
        {
          base(super, null, an, reference)
        }

      }

    | ConcurrentSubRegion
      {
        index : int;

        [TraverseIgnore] 
        [NeedChange(index)] 
        contained_in : ConcurrentRegion;

        this(st : StateNode.State, an : FsmAnalyser)
        {
          base(st, null, an, false)
            //do_activity = st.do_activity |> StateAction.Do(_.action.ActionList, this, _.flags);
            //internal_tran = Internal.Create(this, st.internal_tran);
            //entry = st.entry |> StateAction.Entry(_.action.ActionList, this, _.attrib);
            //exit = st.exit |> StateAction.Exit(_.action.ActionList, this, _.attrib);
            //history = StateHistory.Create(this, st.history);
            //transitions = Transition.Create(this, st.transitions);
            //initial = st.initial |> Initial(this, _);
            //pseudo_states = st.pseudo_states |> PseudoStateNode.Create(_.node, this, null);
            //sub_states = st.sub_states |> State(_, this, false);
            //sub_states.Iter(x => x.super_state = this);
            //super_state = region;
        }

        //transitions_to_final : IEnumerable[StateTransition]
        //{
        //  get
        //  {
        //      (LivedSubStatesNested.FoldLeft(Enumerable.Empty(), (x, a) => x.transitions.Where(x => x.ActualTo is Final))
        //  }
        //}

      }

    | ConcurrentRegion
      {
        [NeedChange]
        sub_regions : IEnumerable[ConcurrentSubRegion] = Enumerable.Empty();

        this(state : StateNode.State, sr : IEnumerable[FsmState.ConcurrentSubRegion], an : FsmAnalyser)
        {
          base(state, [], an, false);
          sub_regions = sr.MapIndex((x, i) => x.ChangeContainedInIndex(this, i));
        }


          /// <summary>
          /// Indicates that maybe external transitions from some points of orthogonal state out of region not only completion
          /// </summary>
        MayTakePlaceForcedTransitions : bool 
        {
          get
          {
            all_transitions_nested.Exists(_.OutOfRegion)
          }
        }

        NeedHistorySave : bool
        {
          get
          {
              !ParticipateInHistory.IsEmpty()
          }
        }

          /// <summary>
          /// Indicates that maybe transitions from outer states forking control to this orthogonal region
          /// </summary>
        MayForkingFromOut : bool 
        {
          get
          {
            def is_this(r)
            {
              | null => false
              | _    => match (r.PartOfRegion)
                  {
                    | Some(r) when (r == this) => true
                    | _                        => false
                  }
            }

            analyser.forks.Exists(x => x.target.Exists(x => is_this(x.ToState)))
          }
        }

        public static get_pattern(reg : IEnumerable[ConcurrentSubRegion]) : string
        {
          def idx = reg.Select(_.index).OrderBy(x => x).NToList();
          $<#..$(idx;"")#>
        }


        RegionExcept(st : IEnumerable[ConcurrentSubRegion]) : ConcurrentSubRegion
        {
          match (sub_regions.Exclude(st, _ == _))
          {
            | [sub]     => sub
            | head :: _ => head
            | _         => null
          }
        }

        RegionsExcept(st : IEnumerable[FsmState]) : IEnumerable[ConcurrentSubRegion]
        {
          sub_regions.Where(x => !x.AllSubStates.Exists(y => st.Exists(y == _)) && !st.Exists(_ == x))
        }

        RegionsExcept(st : FsmState) : IEnumerable[ConcurrentSubRegion]
        {
          sub_regions.Where(x => !x.AllSubStates.Contains(st) && x != st)
        }

        Joins : IEnumerable[PseudoStateNode.Join]
        {
          get
          {
            def get_join(t, lst)
            {
              match (t)
              {
                | StateTransition(To = TransitionTarget.PseudoState(Join as j)) => j :: lst
                | _                                                             => lst
              }
            }

            def tran = AllLivedSubStatesNested.FoldLeft([], (x, a) => x.all_transitions.FoldLeft(a, get_join));
            tran.RemoveDuplicatesSort((x, y) => x.name.CompareTo(y.name));
          }
        }

        HaveJoinTransitions : bool
        {
          get
          {
              !Joins.IsEmpty()
          }
        }

        HaveFinalCompletion : bool
        {
          get
          {
            def st = SuperStatesInclude;
            HaveFinal && st.Exists(x => !x.completion_transitions.IsEmpty())
          }
        }


        FinalStates : IEnumerable[FsmState]
        {
          get
          {
            if (HaveFinal) sub_regions.Select(x => x.FinalSubState.Value) else Enumerable.Empty()
          }
        }

      }

    | InlinedSubMachineInstance
      {
        instance_of : InlinedSubMachine;

        // inst : accumulated base state machine
        // ret : instance and base state machine accumulator
        InitInline(inst : list[FsmState]) : FsmState * list[FsmState]
        {
          def find_inst   = match (inst.Find(x => x.Num == instance_of.Num))
                            {
                              | Some(t) => t
                              | _       => null
                            }
          def instance_of = instance_of.Updated;
          def base_inst   = (find_inst ?? instance_of) :> InlinedSubMachine;
          
          def num         = base_inst.NCopy + 1; // increment copy number

          def copy_state(st, sub)
          {
            def st = st.ChangeCloneFor(st);
            def st = match (st, instance_of)
            {                                                            // change name, number and transitions to outer world to this instance
              | (FsmState(Num = n), FsmState(Num = n2)) when (n == n2) => st.ChangeNameTransitionsNum(name, transitions, Num); 
              | _                                                      => st.ChangeCopyNum(num).SetNewId() 
            }
            
            def sub    = sub.Map(_.ChangeSuperState(st));
            // set new identificator for state
            def init   = st.initial.Map(x => x.ChangeFromSource(st, st).SetNewId());
            def tran   = st.transitions.Map(x => x.ChangeFromSource(st, st).SetNewId());
            def intern = st.internal_tran.Map(x => x.ChangeFromSource(st, st).SetNewId());
            def hist   = st.history.Map(_.ChangeState(st));
            def en     = st.entry.Map(_.ChangeState(st));
            def ex     = st.exit.Map(_.ChangeState(st));
            st.ChangeTransitionsSubStatesHistoryInitialEntryExitInternalTran(tran, sub, hist, init,  en, ex, intern)
          }

          def st          = instance_of.ReduceSingle(true, copy_state); // copy state and its content, changing references accordingly
          def new_st      = st.AllStates.ToArray(); // take all states in new sm copy
          def old_st      = instance_of.AllStates.ToArray();
          
          def retarget_transitions(s, _)
          {
            def find_state(st)
            {
              match (old_st.IndexOf(x => x.Num == st.Num))
              {
                | -1 => st
                | n  => new_st[n]
              }
            }

            def check_target(tar)
            {
              | TransitionTarget.State(st) as t                       => t.ChangeState(find_state(st))
              | Qualified(_, State(st) as t)                          => t.ChangeState(find_state(st))
              | JunctionNode(state = st) as t                         => t.ChangeState(find_state(st))
              | Final(st) as t                                        => 
                  match (find_state(st))
                  {
                    | Final as st => t.ChangeState(st)
                    | _           => null
                  }
                  
              | PseudoState(PseudoStateNode(state = st) as node) as t => t.ChangeNode(node.ChangeState(find_state(st)))
              | _                                                     => null
            }

            def check_tran(tr)
            {
              tr.TargetTraverse(check_target)
            }

            def s        = s.TraverseTargets(check_target);
            def hist     = s.history.Map(x => x.ChangeDefault(x.default.Map(check_tran)));
            s.ChangeHistory(hist)
          }
          
          def st           = st.ReduceSingle(retarget_transitions); // retarget transitions to new place state
          def new_st       = st.AllStates.ToArray(); // take all states in new sm copy
          
          def update_base_inst(s, _)
          {
            def check_tran(tr, ntran)
            {
              tr.ZipLazy(ntran).Map((i, n) => i.ChangeClones(n :: i.clones));
            }
            
            match (new_st.Find(o => o.cloneFor.Num == s.Num))
            {
              | Some(st) => // // if it is state machine instance don't touch external transitions
                            def trans     = if (st.Num != Num) check_tran(s.transitions, st.transitions) else s.transitions;
                            def int_trans = check_tran(s.internal_tran, st.internal_tran);
                            def init      = check_tran(s.initial, st.initial);
                            s.ChangeClonesInitialInternalTranTransitions(st :: s.clones, init, int_trans, trans)
                            
              | _        => null
            }
          }
          
          def base_inst   = base_inst.ReduceSingle(update_base_inst); // updating base instance clones information
          
          // if have processed base sm type exclude it
          def inst = if (find_inst != null) inst.Exclude(x => x.Num == base_inst.Num) else inst;
          // updates state map
          (st, base_inst :: inst) // add base sm type to accumulator
           
        }

      }
    | SubMachine
      {
        type : string;

        [NeedChange(proc_events)] ref_sub_states : array[string] = array[];
        proc_events                              : array[string] = array[];

        this(st : StateNode.State, an : FsmAnalyser)
        {
          base(st, [], an, false);
          def (StateNode.State(type = StateType.SubMachine(type = t))) = st;
          this.type = t;
        }

        scanned : bool
        {
          get
          {
            !ref_sub_states.IsEmpty() || !proc_events.IsEmpty()
          }
        }

        Scan() : SubMachine
        {
          if (!scanned)
          {
            def type = Type.GetType(type);
            def st = type.GetField("ContainsStates");
            def ref_sub_states = st.GetValue(null) :> array[string];
            def evt = type.GetField("ProcessEvents");
            def proc_events = evt.GetValue(null) :> array[string];
            ChangeRefSubStatesProcEvents(ref_sub_states, proc_events)
          } else this
        }


        override UpdateReference() : FsmState
        {
          def st  = base.UpdateReference();
          def fsm = analyser.States.FilterType();
          match (fsm.Find(x => x.type == type))
          {
            | Some(InlinedSubMachine as f) => InlinedSubMachineInstance ^& (instance_of = f)
            | _                            => st
          }
        }

      }

    | InlinedSubMachine
      {
        type : string;
        
        NCopy : int
        {
          get
          {
            clones.Length
          }
        }

        //this(st : StateNode.State, an : FsmAnalyser, reference : bool = false)
        //{
        //  base(st, [], an, reference);
        //  def (StateNode.State(type = StateType.InlinedSubMachine(type = t))) = st;
        //  this.type = t;
        //}
      }  
  }

}
