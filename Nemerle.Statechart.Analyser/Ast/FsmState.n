using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;
using System.Reflection;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  [Record]
  [DebuggerDisplay("State  =  {Name}")]
  public partial variant FsmState
  {
    | State
      {
        //this(name : string, an : FsmAnalyser)
        //{
        //   base(StateNode.State(name), null, an, true)
        //}

      }

    | Final
      {
          //this(st : Final, reference : bool = false, ncopy : bool = false)
          //{
          //  base(st, reference, clone);
          //}
          
        this(state : StateNode.Final, an : FsmAnalyser)
        {
          base(state.state, Enumerable.Empty(), an)
        }

      }

    | ConcurrentSubRegion
      {

        //this(st : StateNode.State, sub : IEnumerable[FsmState], an : FsmAnalyser)
        //{
        //  base(st, sub, an)
        //}

      }

    | ConcurrentRegion
      {
        //[NeedChange]
        //sub_regions : list[ConcurrentSubRegion] = [];

        this(state : StateNode.State, an : FsmAnalyser)
        {
          base(state, [], an);
          //sub_regions = sr;//.MapIndex((x, i) => x.ChangeIndex(i));
        }


          /// <summary>
          /// Indicates that maybe transitions from outer states forking control to this orthogonal region
          /// </summary>
        MayForkingFromOut : bool 
        {
          get
          {
            def is_this(r)
            {
              | null => false
              | _    => match (r.PartOfRegion)
                  {
                    | Some(r) when (r == this) => true
                    | _                        => false
                  }
            }

            analyser.forks.Exists(x => x.target.Exists(x => is_this(x.ToState)))
          }
        }

        public static get_pattern(reg : IEnumerable[ConcurrentSubRegion]) : string
        {
          def idx = reg.Select(_.index).OrderBy(x => x).NToList();
          $<#..$(idx;"")#>
        }


        RegionExcept(st : IEnumerable[ConcurrentSubRegion]) : ConcurrentSubRegion
        {
          match (sub_regions.Exclude(st, _ == _))
          {
            | [sub]     => sub
            | head :: _ => head
            | _         => null
          }
        }

        RegionsExcept(st : IEnumerable[FsmState]) : IEnumerable[ConcurrentSubRegion]
        {
          sub_regions.Where(x => !x.AllSubStates.Exists(y => st.Exists(y == _)) && !st.Exists(_ == x))
        }

        RegionsExcept(st : FsmState) : IEnumerable[ConcurrentSubRegion]
        {
          sub_regions.Where(x => !x.AllSubStates.Contains(st) && x != st)
        }

        Joins : IEnumerable[PseudoStateNode.Join]
        {
          get
          {
            def get_join(t, lst)
            {
              match (t)
              {
                | StateTransition(To = TransitionTarget.PseudoState(ReferenceNode(Value = Join as j))) => j :: lst
                | _                                                                                    => lst
              }
            }

            def tran = AllLivedSubStatesNested.FoldLeft([], (x, a) => x.all_transitions.FoldLeft(a, get_join));
            tran.RemoveDuplicatesSort((x, y) => x.name.CompareTo(y.name));
          }
        }

        HaveJoinTransitions : bool
        {
          get
          {
            !Joins.IsEmpty()
          }
        }

        HaveFinalCompletion : bool
        {
          get
          {
            def st = SuperStatesInclude;
            HaveFinal && st.Exists(x => !x.completion_transitions.IsEmpty())
          }
        }


        FinalStates : IEnumerable[FsmState]
        {
          get
          {
            if (HaveFinal) sub_regions.Select(x => x.FinalSubState.Value) else Enumerable.Empty()
          }
        }

      }

    | InlinedSubMachineInstance
      {
        [NeedChange]
        instance_of_num : InlinedSubMachine;

        instance_of : InlinedSubMachine
        {
          get
          {
            instance_of_num.Updated :> InlinedSubMachine
          }
        }
      }
    | SubMachine
      {
        type : string;

        [NeedChange(proc_events)] ref_sub_states : array[string] = array[];
        proc_events                              : array[string] = array[];

        this(st : StateNode.State, an : FsmAnalyser)
        {
          base(st, [], an);
          def (StateNode.State(type = StateType.SubMachine(type = t))) = st;
          this.type = t;
        }

        scanned : bool
        {
          get
          {
            !ref_sub_states.IsEmpty() || !proc_events.IsEmpty()
          }
        }

        Scan() : SubMachine
        {
          if (!scanned)
          {
            def type = Type.GetType(type);
            def st = type.GetField("ContainsStates");
            def ref_sub_states = st.GetValue(null) :> array[string];
            def evt = type.GetField("ProcessEvents");
            def proc_events = evt.GetValue(null) :> array[string];
            ChangeRefSubStatesProcEvents(ref_sub_states, proc_events)
          } else this
        }


        Instance(f : InlinedSubMachine) : FsmState
        {
           InlinedSubMachineInstance ^& (instance_of_num = f)
        }

      }

    | InlinedSubMachine
      {
        type : string;
        
        NCopy : int
        {
          get
          {
            clones.Length
          }
        }

        //this(st : StateNode.State, an : FsmAnalyser, reference : bool = false)
        //{
        //  base(st, [], an, reference);
        //  def (StateNode.State(type = StateType.InlinedSubMachine(type = t))) = st;
        //  this.type = t;
        //}
      }  
  }

}
