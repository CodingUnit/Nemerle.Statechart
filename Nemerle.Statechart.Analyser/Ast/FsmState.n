using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;
using System.Reflection;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  [Record]
  [DebuggerDisplay("State  =  {Name}")]
  public partial variant FsmState
  {
    | State  
      {
        this(name : string)
        {
          this(StateNode.State(name), null, null, true)
        }

      }

    | Final
      {
          //this(st : Final, reference : bool = false, ncopy : bool = false)
          //{
          //  base(st, reference, clone);
          //}

        this(super : FsmState, an : FsmAnalyser, reference : bool =  false)
        {
          base(super, $"$(super)Final", an, reference);
        }

      }

    | ConcurrentSubRegion
      {
        index : int;
        [NeedChange(index)] contained_in : ConcurrentRegion;

        this(st : StateNode.State, an : FsmAnalyser)
        {
          base(st, null, an, false);
            //do_activity = st.do_activity |> StateAction.Do(_.action.ActionList, this, _.flags);
            //internal_tran = Internal.Create(this, st.internal_tran);
            //entry = st.entry |> StateAction.Entry(_.action.ActionList, this, _.attrib);
            //exit = st.exit |> StateAction.Exit(_.action.ActionList, this, _.attrib);
            //history = StateHistory.Create(this, st.history);
            //transitions = Transition.Create(this, st.transitions);
            //initial = st.initial |> Initial(this, _);
            //pseudo_states = st.pseudo_states |> PseudoStateNode.Create(_.node, this, null);
            //sub_states = st.sub_states |> State(_, this, false);
            //sub_states.Iter(x => x.super_state = this);
            //super_state = region;
        }

        transitions_to_final : list[StateTransition]
        {
          get
          {
              (LivedSubStatesNested |>< transitions).Filter(x => x.ActualTo is Final)
          }
        }

        FinalState : option[FsmState]
        {
          get
          {
            sub_states.Find(_ is Final)
          }
        }
      }

    | ConcurrentRegion
      {
//         sub_regions_num : list[int] = [];

        sub_regions : IEnumerable[ConcurrentSubRegion] = Enumerable.Empty();

          //{
          //  get
          //  {
          //    sub_regions_num |> statemap[_] :> ConcurrentSubRegion
          //  }
          //}
        this(state : StateNode.State, sr : IEnumerable[FsmState.ConcurrentSubRegion], an : FsmAnalyser)
        {
          base(state, [], an, false);
          sub_regions = sr.MapIndex((x, i) => x.ChangeContainedInIndex(this, i));
        }


          /// <summary>
          /// Indicates that maybe external transitions from some points of orthogonal state out of region not only completion
          /// </summary>
        MayTakePlaceForcedTransitions : bool 
        {
          get
          {
            all_transitions_nested.Exists(_.OutOfRegion)
          }
        }

        NeedHistorySave : bool
        {
          get
          {
              !ParticipateInHistory.IsEmpty()
          }
        }

          /// <summary>
          /// Indicates that maybe transitions from outer states forking control to this orthogonal region
          /// </summary>
        MayForkingFromOut : bool 
        {
          get
          {
            def is_this(r)
            {
              | null => false
              | _ => match (r.PartOfRegion)
                  {
                    | Some(r) when (r == this) => true
                    | _ => false
                  }
            }

            analyser.forks.Exists(x => x.target.Exists(x => is_this(x.ToState)))
          }
        }

        static get_pattern(reg : list[ConcurrentSubRegion]) : string
        {
          def idx = (reg |> index).Sort(_ - _);
          $<#..$(idx;"")#>; 
        }


        RegionExcept(st : list[ConcurrentSubRegion]) : ConcurrentSubRegion
        {
          match (sub_regions.Exclude(st, _ == _))
          {
            | [sub] => sub
            | head :: _ => head
            | _ => null
          }
        }

        RegionsExcept(st : list[FsmState]) : list[ConcurrentSubRegion]
        {
          sub_regions.Filter(x => !x.AllSubStates.Exists(y => st.Exists(y == _)) && !st.Exists(_ == x))
        }

        RegionsExcept(st : FsmState) : list[ConcurrentSubRegion]
        {
          sub_regions.Filter(x => !x.AllSubStates.Contains(st) && x != st)
        }

        Joins : list[PseudoStateNode.Join]
        {
          get
          {
            def get_join(t, lst)
            {
              match (t)
              {
                | StateTransition where (To = TransitionTarget.PseudoState(Join as j)) => j :: lst
                | _ => lst
              }
            }

            def tran = AllLivedSubStatesNested.Map(x => x.all_transitions.FoldLeft([], get_join)).Flatten();
            tran.RemoveDuplicatesSort((x, y) => x.name.CompareTo(y.name));
          }
        }

        HaveJoinTransitions : bool
        {
          get
          {
              !Joins.IsEmpty()
          }
        }

        HaveFinalCompletion : bool
        {
          get
          {
            def st = SuperStatesInclude;
            HaveFinal && st.Exists(x => !x.completion_transitions.IsEmpty())
          }
        }


        FinalStates : list[FsmState]
        {
          get
          {
            if (HaveFinal) sub_regions |> FinalState.Value else []
          }
        }

      }

    | InlinedSubMachineInstance
      {
        instance_of : InlinedSubMachine;

        InitInline(an : FsmAnalyser) : InlinedSubMachineInstance * FsmAnalyser
        {
            //def update_pseudo(tar, _, new_st)
            //{
            //  match (tar)
            //  {
            //    | TransitionTarget.PseudoState(node) as t when (node == new_st) => t.ChangeNode(new_st)
            //    | _ => null
            //  }
            //}
           
          def num = instance_of.ncopy + 1;
          def st = instance_of.ChangeCopyNum(num); // clone the inline sub machine instance

          def copy_state(_, st)
          {
            def init = st.Initial.Select(x : StateTransition => x.Clone(num));
            def tran = st.transitions.Select(x => x.Clone(num));
            def intern = st.internal_tran.Select(x => x.Clone(num));
            def hist = st.history.Map(x => x.ChangeReferenceState(true, st));
            def en = st.entry.Map(x => x.ChangeState(st));
            def ex = st.exit.Map(x => x.ChangeState(st));
            st.ChangeTransitionsHistoryInitialEntryExitInternalTran(tran, hist, init, en, ex, intern)
          }
          
          def st = st.FoldThis(copy_state);
          def do_act = st.do_activity; // take data from it except transitions to outer world
          def inter_tran = st.internal_tran;
          def entry = st.entry;
          def exit = st.exit;
          def init = st.Initial;
          def history = st.history;
          def sub_st = st.sub_states;
          def tran = st.all_transitions_nested;
          def tran = tran.Concat(st.AllHistory.FilterValues(_.default));
          def old = instance_of.AllStates;
          def ren_st = st.AllStates.ZipLazy(old); // take old and new copy
            //def pst = st.AllPseudoStates |> (CloneFor, _);
          def sub_st = sub_st.Map(x => x.ChangeSuperState(this)); // change super state to this
            //pst.Iter((ost, nst) => tran.Iter(x => x.TargetTraverse(update_pseudo(_, ost, nst)))); // update pseudo states in this sub machine
          def an = ren_st.FoldLeft(an, ((ost, nst), a) => tran.FoldLeft(a, (x, a) => x.UpdateTargets(a, ost, nst))); // change targets according to rename in new location
          def nst = ren_st.MapLazy((x, y) => y.ChangeCloneFor(x));
          def pseudo = st.pseudo_states;
          def st = InlinedSubMachineInstance ^& (do_activity = do_act, sub_states = sub_st, history = history, 
                  pseudo_states = pseudo, Initial = init, entry = entry, exit = exit, internal_tran = inter_tran, 
                  analyser = an);
          def map = an.statemap.CheckNew(nst);
          def an = an.ChangeStatemap(map);
            //UpdateReference(Analyser.Statemap, true);
          (st, an.UpdateStateMap()) // updates state map
        }

      }
    | SubMachine
      {
        type : string;

        [NeedChange(proc_events)] ref_sub_states : array[string] = array[];
        proc_events : array[string] = array[];

        this(st : StateNode.State, an : FsmAnalyser)
        {
          base(st, [], an, false);
          def (StateNode.State(type = StateType.SubMachine(type = t))) = st;
          this.type = t;
        }

        scanned : bool
        {
          get
          {
              !ref_sub_states.IsEmpty() || !proc_events.IsEmpty()
          }
        }

        Scan() : SubMachine
        {
          if (!scanned)
          {
            def type = Type.GetType(type);
            def st = type.GetField("ContainsStates");
            def ref_sub_states = st.GetValue(null) :> array[string];
            def evt = type.GetField("ProcessEvents");
            def proc_events = evt.GetValue(null) :> array[string];
            ChangeRefSubStatesProcEvents(ref_sub_states, proc_events)
          } else this
        }


        override UpdateReference(sub : IEnumerable[FsmState], an : FsmAnalyser) : FsmState * FsmAnalyser
        {
          def (st, an) = base.UpdateReference(sub, an);
          def fsm = an.States.FilterType();
          match (fsm.Find(x => x.type == type))
          {
            | Some(InlinedSubMachine as f) => def st = InlinedSubMachineInstance ^& (instance_of = f);
                (st, an)
            | _ => (st, an)
          }
        }

      }

    | InlinedSubMachine
      {
        type : string;
        ncopy : int;

        //this(st : StateNode.State, an : FsmAnalyser, reference : bool = false)
        //{
        //  base(st, [], an, reference);
        //  def (StateNode.State(type = StateType.InlinedSubMachine(type = t))) = st;
        //  this.type = t;
        //}
      }  
  }

}
