using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;
using System.Reflection;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  [Record]
  [DebuggerDisplay("State  =  {Name}")]
  public partial variant FsmState
  {
    | State
      {
        //this(name : string, an : FsmAnalyser)
        //{
        //   base(StateNode.State(name), null, an, true)
        //}

      }

    | Final
      {
          //this(st : Final, reference : bool = false, ncopy : bool = false)
          //{
          //  base(st, reference, clone);
          //}
          
        this(state : StateNode.Final, an : FsmAnalyser)
        {
          base(state.state, Enumerable.Empty(), an)
        }

      }

    | ConcurrentSubRegion
      {

        //this(st : StateNode.State, sub : IEnumerable[FsmState], an : FsmAnalyser)
        //{
        //  base(st, sub, an)
        //}

      }

    | ConcurrentRegion
      {
        //[NeedChange]
        //sub_regions : list[ConcurrentSubRegion] = [];

        this(state : StateNode.State, an : FsmAnalyser)
        {
          base(state, [], an);
          //sub_regions = sr;//.MapIndex((x, i) => x.ChangeIndex(i));
        }


          /// <summary>
          /// Indicates that maybe transitions from outer states forking control to this orthogonal region
          /// </summary>
        MayForkingFromOut : bool 
        {
          get
          {
            def is_this(r)
            {
              | null => false
              | _    => match (r.PartOfRegion)
                  {
                    | Some(r) when (r == this) => true
                    | _                        => false
                  }
            }

            analyser.forks.Exists(x => x.target.Exists(x => is_this(x.ToState)))
          }
        }


      }

    | InlinedSubMachineInstance
      {
        [NeedChange]
        instance_of_num : InlinedSubMachine;

        instance_of : InlinedSubMachine
        {
          get
          {
            instance_of_num.Updated :> InlinedSubMachine
          }
        }
      }
    | SubMachine
      {
        type : string;

        [NeedChange(proc_events)] ref_sub_states : array[string] = array[];
        proc_events                              : array[string] = array[];

        this(st : StateNode.State, an : FsmAnalyser)
        {
          base(st, [], an);
          def (StateNode.State(type = StateType.SubMachine(type = t))) = st;
          this.type = t;
        }

        scanned : bool
        {
          get
          {
            !ref_sub_states.IsEmpty() || !proc_events.IsEmpty()
          }
        }

        Scan() : SubMachine
        {
          if (!scanned)
          {
            def type = Type.GetType(type);
            def st = type.GetField("ContainsStates");
            def ref_sub_states = st.GetValue(null) :> array[string];
            def evt = type.GetField("ProcessEvents");
            def proc_events = evt.GetValue(null) :> array[string];
            ChangeRefSubStatesProcEvents(ref_sub_states, proc_events)
          } else this
        }


        Instance(f : InlinedSubMachine) : FsmState
        {
           InlinedSubMachineInstance ^& (instance_of_num = f)
        }

      }

    | InlinedSubMachine
      {
        type : string;
        
        NCopy : int
        {
          get
          {
            clones.Length
          }
        }

        //this(st : StateNode.State, an : FsmAnalyser, reference : bool = false)
        //{
        //  base(st, [], an, reference);
        //  def (StateNode.State(type = StateType.InlinedSubMachine(type = t))) = st;
        //  this.type = t;
        //}
      }  
  }

}
