using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;
using System.Reflection;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  [Record]
  [DebuggerDisplay("State  =  {Name}")]
  public partial variant FsmState
  {
    | State
      {
        this(name : string, an : FsmAnalyser)
        {
           base(StateNode.State(name), null, an, true)
        }

      }

    | Final
      {
          //this(st : Final, reference : bool = false, ncopy : bool = false)
          //{
          //  base(st, reference, clone);
          //}
        this(state : StateNode.Final, an : FsmAnalyser)
        {
          base(state.state, Enumerable.Empty(), an, false)
        }

        public static GetName(super : string) : string
        {
          $"$(super)Final"
        }
        
        new this(super : string, an : FsmAnalyser, reference : bool =  false)
        {
          base(GetName(super), an, reference)
        }

      }

    | ConcurrentSubRegion
      {
        index : int;

        [TraverseIgnore] 
        [NeedChange(index)] 
        contained_in : ConcurrentRegion;

        this(st : StateNode.State, sub : IEnumerable[FsmState], an : FsmAnalyser)
        {
          base(st, sub, an, false)
        }

      }

    | ConcurrentRegion
      {
        [NeedChange]
        sub_regions : list[ConcurrentSubRegion] = [];

        this(state : StateNode.State, sr : list[FsmState.ConcurrentSubRegion], an : FsmAnalyser)
        {
          base(state, [], an, false);
          sub_regions = sr.MapIndex((x, i) => x.ChangeContainedInIndex(this, i));
        }

          /// <summary>
          /// Indicates that maybe external transitions from some points of orthogonal state out of region not only completion
          /// </summary>
        MayTakePlaceForcedTransitions : bool 
        {
          get
          {
            all_transitions_nested.Exists(_.OutOfRegion)
          }
        }

        NeedHistorySave : bool
        {
          get
          {
            !ParticipateInHistory.IsEmpty()
          }
        }

          /// <summary>
          /// Indicates that maybe transitions from outer states forking control to this orthogonal region
          /// </summary>
        MayForkingFromOut : bool 
        {
          get
          {
            def is_this(r)
            {
              | null => false
              | _    => match (r.PartOfRegion)
                  {
                    | Some(r) when (r == this) => true
                    | _                        => false
                  }
            }

            analyser.forks.Exists(x => x.target.Exists(x => is_this(x.ToState)))
          }
        }

        public static get_pattern(reg : IEnumerable[ConcurrentSubRegion]) : string
        {
          def idx = reg.Select(_.index).OrderBy(x => x).NToList();
          $<#..$(idx;"")#>
        }


        RegionExcept(st : IEnumerable[ConcurrentSubRegion]) : ConcurrentSubRegion
        {
          match (sub_regions.Exclude(st, _ == _))
          {
            | [sub]     => sub
            | head :: _ => head
            | _         => null
          }
        }

        RegionsExcept(st : IEnumerable[FsmState]) : IEnumerable[ConcurrentSubRegion]
        {
          sub_regions.Where(x => !x.AllSubStates.Exists(y => st.Exists(y == _)) && !st.Exists(_ == x))
        }

        RegionsExcept(st : FsmState) : IEnumerable[ConcurrentSubRegion]
        {
          sub_regions.Where(x => !x.AllSubStates.Contains(st) && x != st)
        }

        Joins : IEnumerable[PseudoStateNode.Join]
        {
          get
          {
            def get_join(t, lst)
            {
              match (t)
              {
                | StateTransition(To = TransitionTarget.PseudoState(Join as j)) => j :: lst
                | _                                                             => lst
              }
            }

            def tran = AllLivedSubStatesNested.FoldLeft([], (x, a) => x.all_transitions.FoldLeft(a, get_join));
            tran.RemoveDuplicatesSort((x, y) => x.name.CompareTo(y.name));
          }
        }

        HaveJoinTransitions : bool
        {
          get
          {
            !Joins.IsEmpty()
          }
        }

        HaveFinalCompletion : bool
        {
          get
          {
            def st = SuperStatesInclude;
            HaveFinal && st.Exists(x => !x.completion_transitions.IsEmpty())
          }
        }


        FinalStates : IEnumerable[FsmState]
        {
          get
          {
            if (HaveFinal) sub_regions.Select(x => x.FinalSubState.Value) else Enumerable.Empty()
          }
        }

      }

    | InlinedSubMachineInstance
      {
        [NeedChange]
        instance_of : InlinedSubMachine;

      }
    | SubMachine
      {
        type : string;

        [NeedChange(proc_events)] ref_sub_states : array[string] = array[];
        proc_events                              : array[string] = array[];

        this(st : StateNode.State, an : FsmAnalyser)
        {
          base(st, [], an, false);
          def (StateNode.State(type = StateType.SubMachine(type = t))) = st;
          this.type = t;
        }

        scanned : bool
        {
          get
          {
            !ref_sub_states.IsEmpty() || !proc_events.IsEmpty()
          }
        }

        Scan() : SubMachine
        {
          if (!scanned)
          {
            def type = Type.GetType(type);
            def st = type.GetField("ContainsStates");
            def ref_sub_states = st.GetValue(null) :> array[string];
            def evt = type.GetField("ProcessEvents");
            def proc_events = evt.GetValue(null) :> array[string];
            ChangeRefSubStatesProcEvents(ref_sub_states, proc_events)
          } else this
        }


        override UpdateReference() : FsmState
        {
          def st  = base.UpdateReference();
          def fsm = analyser.States.FilterType();
          match (fsm.Find(x => x.type == type))
          {
            | Some(InlinedSubMachine as f) => InlinedSubMachineInstance(st, f)
            | _                            => st
          }
        }

      }

    | InlinedSubMachine
      {
        type : string;
        
        NCopy : int
        {
          get
          {
            clones.Length
          }
        }

        //this(st : StateNode.State, an : FsmAnalyser, reference : bool = false)
        //{
        //  base(st, [], an, reference);
        //  def (StateNode.State(type = StateType.InlinedSubMachine(type = t))) = st;
        //  this.type = t;
        //}
      }  
  }

}
