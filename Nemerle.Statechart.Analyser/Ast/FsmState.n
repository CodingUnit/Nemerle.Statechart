// fsmstate.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using Nemerle.Statechart;
using System.Reflection;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;

  [Record]
  [DebuggerDisplay("State  =  {Name}")]
  public partial variant FsmState
  {
    | State
      {
        //this(name : string, an : FsmAnalyser)
        //{
        //   base(StateNode.State(name), null, an, true)
        //}

      }

    | Final
      {
          //this(st : Final, reference : bool = false, ncopy : bool = false)
          //{
          //  base(st, reference, clone);
          //}
          
       }

    | ConcurrentSubRegion
      {

        //this(st : StateNode.State, sub : IEnumerable[FsmState], an : FsmAnalyser)
        //{
        //  base(st, sub, an)
        //}

      }

    | ConcurrentRegion
      {
        //[NeedChange]
        //sub_regions : list[ConcurrentSubRegion] = [];

        //this(state : StateNode.State, an : FsmAnalyser)
        //{
        //  base(state, [], an);
        //  //sub_regions = sr;//.MapIndex((x, i) => x.ChangeIndex(i));
        //}



      }

    | InlinedSubMachineInstance
      {
        [NeedChange]
        instance_of : GeneralTree[FsmState];

      }
    | SubMachine
      {
        type : string;

        [NeedChange(proc_events)] ref_sub_states : array[string] = array[];
        proc_events                              : array[string] = array[];

        this(st : StateNode.State, an : FsmAnalyser)
        {
          base(st, an);
          def (StateNode.State(type = StateType.SubMachine(type = t))) = st;
          this.type = t;
        }

        scanned : bool
        {
          get
          {
            !ref_sub_states.IsEmpty() || !proc_events.IsEmpty()
          }
        }

        Scan() : SubMachine
        {
          if (!scanned)
          {
            def type = Type.GetType(type);
            def st = type.GetField("ContainsStates");
            def ref_sub_states = st.GetValue(null) :> array[string];
            def evt = type.GetField("ProcessEvents");
            def proc_events = evt.GetValue(null) :> array[string];
            ChangeRefSubStatesProcEvents(ref_sub_states, proc_events)
          } else this
        }


        Instance(f : GeneralTree[FsmState]) : void
        {
          def st = InlinedSubMachineInstance ^& (instance_of = f);
          //def f = f.Clone();
          f.Data = st
        }

      }

    | InlinedSubMachine
      {
        type : string;
        

        //this(st : StateNode.State, an : FsmAnalyser, reference : bool = false)
        //{
        //  base(st, [], an, reference);
        //  def (StateNode.State(type = StateType.InlinedSubMachine(type = t))) = st;
        //  this.type = t;
        //}
      }  
  }

}
