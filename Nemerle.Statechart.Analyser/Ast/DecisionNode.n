using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  using ListUtils;

  [Record]
  public variant DecisionNode
  {
    | Condition 
      {
        [NeedChange(body, else_node)] condition : GuardNode;
        [NeedChange(else_node)] body : DecisionNode;
        else_node : DecisionNode;

      }
    | Action
      {
        [NeedChange(body)] condition : option[GuardNode];
        [NeedChange] body : DecisionNode;
      }
    | Else
      {
        [NeedChange] body : DecisionNode;
      }
    | Target 
      {
        [NeedChange] target : TransitionTarget;
        [NeedChange] destination : TransitionDestination;

      }

    public level : int;
    public state : FsmState;
    public actions : list[Actions] = [];
    public PrevState : FsmState;

    public this() {}

    public SetCopy(n : int) : DecisionNode
    {
      //def inc(t, an)
      //{
      //  match (t)
      //  {
      //    | Target(t, d)      => def t = t.SetCopy(n);
      //                           (Target(t, d), an)
      //    | _                 => (this, an)
      //  }
      //}

      FoldThis(_ => null, _ => null, (t, _, o) => o.ChangeTarget(t.SetCopy(n)), _ => null)
      //Fold((c, b, e) => Condition(level, state, actions, j.PrevState, j.node_path, j.out_path, c, nb, ne), an) else node, )
      //Map(an, inc)
    }

    public ActionNode : PathNode
    {
      get
      {
        PathNode.Sequence(actions.MapLazy(PathNode.Action))
      }
    }

    public Actions : PathNode
    {
      get
      {
        //def act = Iterator |> ActionNode;
        //Fold((_, a, b, x) => x.ActionNode + a + b, (a, x) => x.ActionNode + a, (_, _, x) => x.ActionNode, (_, a, x) => x.ActionNode + a);
        //Fold(PathNode.Empty(), (a, _, c) => a + c.ActionNode, (a, e) => a + e.ActionNode, (a, _, _, x) => a + x.ActionNode, (a, _, x) => a + x.ActionNode)
        PathNode.Sequence(Iterator.MapLazy(_.ActionNode))
      }
    }

    //public Map(an : FsmAnalyser, func : DecisionNode * FsmAnalyser -> DecisionNode * FsmAnalyser) : DecisionNode * FsmAnalyser
    //{
    //  def (node, an) = func(this, an);
    //  def node = node ?? this;
    //  match (node)
    //  {
    //    | Condition(c, b, e) as j => 
    //        def (nb, an) = b.Map(an, func);
    //        def (ne, an) = e.Map(an, func);
    //        if (nb != b : object || ne != e : object) 
    //          (Condition(level, state, actions, j.PrevState, j.node_path, j.out_path, c, nb, ne), an) else (node, an)
    //    | Else(b) as j => 
    //        def (nb, an) = b.Map(an, func);
    //        if (nb != b : object) (Else(level, state, actions,  j.PrevState, j.node_path, j.out_path,nb), an) else (node, an)

    //    | Action(c, b) as j => 
    //        def (nb, an) = b.Map(an, func);
    //        if (nb != b : object) (Action(level, state, actions, j.PrevState, j.node_path, j.out_path, c, nb), an) else (node, an)

    //    | Target => (node, an)

    //  }
    //}

//let XFoldTree nodeF leafV tree = 
    //let rec Loop t cont = 
    //    match t with 
    //    | Node(x,left,right) -> Loop left  (fun lacc ->  
    //                            Loop right (fun racc -> 
    //                            cont (nodeF x lacc racc t))) // note ‘t’
    //    | Leaf -> cont (leafV t) // note ‘t’
    //Loop tree (fun x -> x)
// Can express the usual Fold in terms of XFold:
// FoldTree : (‘a -> ‘r -> ‘r -> ‘r) -> ‘r -> Tree<’a> -> ‘r
//let FoldTree nodeF leafV tree = 
    //XFoldTree (fun x l r _ -> nodeF x l r) (fun _ -> leafV) tree         

    public FoldThis(cond : GuardNode * DecisionNode * DecisionNode * DecisionNode.Condition -> DecisionNode, 
                    els : DecisionNode * DecisionNode.Else -> DecisionNode, 
                    targ : TransitionTarget * TransitionDestination * DecisionNode.Target -> DecisionNode, 
                    act : option[GuardNode] * DecisionNode * DecisionNode.Action -> DecisionNode) : DecisionNode
    {
      def xnode(n, nb, ne, ot)
      {
        match (n)
        {
          | null                            => ot
          | Condition as j                  => j.ChangeBodyElseNode(nb, ne)
          | DecisionNode.Action as j        => j.ChangeBody(nb)
          | Else as j                       => j.ChangeBody(nb)
          | x                               => x
        }
      }

      def loop(e, cont)
      {
        match (e)
        {
          | Target(x, d) as t     => cont(xnode(targ(x, d, t), null, null, t))

          | Condition(c, b, e) as t => loop(b, bacc => 
                                               loop(e, eacc => 
                                                       cont(xnode(cond(c, bacc, eacc, t), bacc, eacc, t))))

          | Else(b) as t       => loop(b, bacc => 
                                          cont(xnode(els(bacc, t), bacc, null, t)))

          | Action(c, b) as t  => loop(b, bacc => 
                                          cont(xnode(act(c, bacc, t), bacc, null, t)))
        }
      }

      loop(this, x => x)
    }

    public Fold[T](cond : GuardNode * T * T * Condition -> T, 
                  els : T * Else -> T, 
                  targ : TransitionTarget * TransitionDestination * Target -> T, 
                  act : option[GuardNode] * T * DecisionNode.Action -> T) : T
    {
      def loop(e, cont)
      {
        match (e)
        {
          | Target(x, d)       as t => cont(targ(x, d, t))
          | Condition(c, b, e) as t => loop(b, bacc => 
                                               loop(e, eacc => 
                                                       cont(cond(c, bacc, eacc, t))))

          | Else(b)            as t => loop(b, bacc => cont(els(bacc, t)))
          | Action(c, b)       as t => loop(b, bacc => cont(act(c, bacc, t)))
        }
      }

      loop(this, x => x)
    }

    public Fold[T](init : T, 
                  cond : T * GuardNode * Condition -> T, 
                  els : T * Else -> T, 
                  targ : T * TransitionTarget * TransitionDestination * Target -> T, 
                  act : T * option[GuardNode] * DecisionNode.Action -> T) : T
    {
      def loop(e, acc, cont)
      {
        match (e)
        {
          | Target(x, d)       as t => cont(targ(acc, x, d, t))
          | Condition(c, b, e) as t => loop(b, acc, bacc => 
                                               loop(e, bacc, eacc => 
                                                       cont(cond(eacc, c, t))))

          | Else(b)            as t => loop(b, acc, bacc => cont(els(bacc, t)))
          | Action(c, b)       as t => loop(b, acc, bacc => cont(act(bacc, c, t)))
        }
      }

      loop(this, init, x => x)
    }
    
    public Iterator : IEnumerable[DecisionNode]
    {
      get
      {
        yield this;
        match (this)
        {
          | Condition(body = b, else_node = null)
          | Action(body = b)
          | Else(body = b)                        => foreach (i in b.Iterator) yield i
          | Condition(body = b, else_node = els)  => foreach (i in b.Iterator) yield i;
              foreach (i in els.Iterator) yield i
          | Target => ()
        }
      }
    }

    public Guards : list[GuardNode]
    {
      get
      {
        //def get_guard(n)
        //{
        //  | Condition(c, _, _)
        //  | Action(Some(c), _) => Some(c)
        //  | _ => None()
        //}

        Fold([], (a, g, _) => g :: a, (a, _) => a, (a, _, _, _) => a, (a, g, _) => g %:: a)
        //Iterator.FilterValues(get_guard)
      }
    }


    public ThisPath : PathNode
    {
      get
      {
        ActionNode
        //PathNode.Sequence(actions |> PathNode.Action(_))
      }
    }

    public Paths : PathNode
    {
      get
      {
        Fold((_, a, b, x) => x.Path + a + b, (a, x) => x.Path + a, (_, _, x) => x.Path, (_, a, x) => x.Path + a)
        //PathNode.Sequence(Iterator |> Path)
      }
    }

    [NeedChange(out_path)]
    public node_path : PathNode = PathNode.Empty();
    public out_path : PathNode = PathNode.Empty();

    public ThisOutPath : PathNode
    {
      get
      {
        ThisPath + node_path
      }
    }

    public Path : PathNode
    {
      get
      {
        node_path + ThisPath + out_path
      }
    }

    //public Traverse(func : DecisionNode -> void) : void
    //{
    //  Iterator.Iter(func)
    //}

    static contains_decision(n : TransitionTarget.JunctionNode) : bool
    {
      match (n.guard)
      {
        | None
        | Some(GuardNode.Else) => false
        | _ => true
      }
    }

    static create_junc_tree_node(n : TransitionTarget.JunctionNode, 
                                aa : list[Actions], 
                                lev : int, 
                                st : FsmState, 
                                prevst : FsmState, 
                                els : DecisionNode, 
                                err : list[FsmError]) : DecisionNode * list[FsmError]
    {

      def get_sub_node(t, aa, lev, st, els, err)
      {
        match (t)
        {
          | TransitionTarget.PseudoState(Junction(to = n, state = st, type = JunctionType.Junction)) => 
              def prevst = st;
                //def st = nst ?? j.state =. st;
              create_junc_tree_node(n, aa, lev + 1, st, prevst, els, err)

          | PseudoState(Junction(to = n, state = st, type = JunctionType.Choice)) => 
              def prevst = st;
                //def st = nst ?? c.state =. st;
              create_choice_tree_node(n, lev + 1, st, prevst, els, err)

          | PseudoState(Merge(to = TransitionTarget.JunctionNode as n, state = st)) => 
              def prevst = st;
                //def st = nst ?? m.state =. st;
              create_junc_tree_node(n, aa, lev + 1, st, prevst, els, err)

          | _ => (Target(lev, st, aa.Rev(), prevst, PathNode.Empty(), PathNode.Empty(), t, null), err)
        }
      }

      match (n)
      {
        | JunctionNode(guard = Some(Else), parent = Junction(type = JunctionType.Junction) as p, next = Some()) => 
            (null, FsmError.JunctionElseMustBeLast(p) :: err)

        | JunctionNode(Some(Else), a, t, Junction(type = JunctionType.Junction) as p, None(), _) as j => 

            def n = p.Nodes.FilterLazy(_ == j);

              // if same node not contains other previous decision node
            if (!n.Exists(contains_decision)) 
            {
              (null, FsmError.JunctionElseMustAfterAnotherGuard(p) :: err)
            } else
            {
              def (n, err) = get_sub_node(t, a %:: aa, lev, st, els, err);
              (Else(lev, st, [], prevst, PathNode.Empty(), PathNode.Empty(), n), err)
            }

        | JunctionNode(Some(g), a, t, _, None(), _) => 
            def (n, err) = get_sub_node(t, a %:: aa, lev, st, els, err);
            (Condition(lev, st, [], prevst, PathNode.Empty(), PathNode.Empty(), g, n, els), err)

        | JunctionNode(Some(g), a, t, _, Some(n), _) => 
            def (els, err) = create_junc_tree_node(n, aa, lev, st, prevst, els, err);
            def (n, err) = get_sub_node(t, a %:: aa, lev, st, els, err);
            (Condition(lev, st, [], prevst, PathNode.Empty(), PathNode.Empty(), g, n, els), err)

            // if no guards or actions there is error
        | JunctionNode(None(), None(), _, Junction(type = JunctionType.Junction) as p, _, _) => (null, FsmError.EmptyJunction(p) :: err)
        | JunctionNode(None(), None(), _, _, _, _) => (null, err)
            // if single action node and not decision, taking sub node collecting action
        | JunctionNode(None(), Some(a), t, Junction(type = JunctionType.Junction), None(), _) => 
            get_sub_node(t, a :: aa, lev, st, els, err)
            // if last action node it is else
        | JunctionNode(None(), Some(a), t, _, None(), _) => 
            def (n, err) = get_sub_node(t, a :: aa , lev, st, els, err);
            (Else(lev, st, [], prevst, PathNode.Empty(), PathNode.Empty(), n), err)
            // if action have other nodes after it
        | JunctionNode(None(), Some(a), _, Junction(type = JunctionType.Junction) as p, _, _) => (null, FsmError.JunctionActionMaybeLast(p, a) :: err);
        | JunctionNode(None(), Some(), _, _, _, _) => (null, err)
        //| [] => (null, err)
      }
    }

    static create_choice_tree_node(n : TransitionTarget.JunctionNode, lev : int, st : FsmState, prevst : FsmState, els : DecisionNode, err : list[FsmError]) : DecisionNode * list[FsmError]
    {

      def get_sub_node(t, lev, st, prevst, els, err)
      {
        match (t)
        {
            // TODO: разобраться с prevst
          | TransitionTarget.PseudoState(Junction(to = n, state = st, type = JunctionType.Junction)) => 
              def prevst = st ?? prevst;
                //def st = nst ?? j.state =. st;
              create_junc_tree_node(n, [], lev + 1, st, prevst, els, err)

          | PseudoState(Junction(to = n, state = st, type = JunctionType.Choice)) => 
              def prevst = st ?? prevst;
                //def st = nst ?? c.state =. st;
              create_choice_tree_node(n, lev + 1, st, prevst, els, err)

          | PseudoState(Merge(to = TransitionTarget.JunctionNode(g, a, t, _, _, _), state = st)) => 
              def prevst = st ?? prevst;
                //def st = nst ?? m.state =. st;
              def (n, err) = get_sub_node(t, lev + 1, st, prevst, els, err);
              (DecisionNode.Action(lev, st, a %:: [], prevst, PathNode.Empty(), PathNode.Empty(), g, n), err)

          | _ => (Target(lev, st, [], prevst, PathNode.Empty(), PathNode.Empty(), t, null), err)
        }
      }


      match (n)
      {
        | JunctionNode(guard = Some(Else), parent = Junction(type = JunctionType.Choice) as p, next = Some()) => 
            (null, FsmError.ChoiceElseMustBeLast(p) :: err)

        | JunctionNode(Some(Else), a, t, Junction(type = JunctionType.Choice) as p, None(), _) as j => 

            def n = p.Nodes.FilterLazy(_ == j);
              // if same node not contains other previous decision node
            if (!n.Exists(contains_decision)) 
            {
              (null, FsmError.ChoiceElseMustAfterAnotherGuard(p) :: err)
            } else
            {
              def a = a %:: [];
              def (node, err) = get_sub_node(t, lev, st, prevst, els, err);
                // if new node is in another state
              def (st, prevst, (node, err)) = if (st != node.state)
                                              {
                                          // cache it, process path before, traverse it with new values of state
                                                def prevst = st;
                                                def st = node.state;
                                                (st, prevst, get_sub_node(t, lev, st, prevst, els, err))
                                              } else (st, prevst, (node, err));
              def st = if (st != prevst) st else null;
              def prevst = prevst ?? (t.transition?.From ?? st);
              (Else(lev, st, a, prevst, PathNode.Empty(), PathNode.Empty(), node), err)
            }

        | JunctionNode(Some(g), a, t, _, Some(n), _) => 
            def a = a %:: [];
            def st = if (st != prevst) st else null;
            def prevst = prevst ?? (t.transition?.From ?? st);
            def (n, err) = create_choice_tree_node(n, lev, st, prevst, els, err);
            def (node, err) = get_sub_node(t, lev, st, prevst, els, err);
            (Condition(lev, st, a, prevst, PathNode.Empty(), PathNode.Empty(), g, node, n), err)

            // if no guards or actions there is error
        | JunctionNode(None(), None(), _, Junction(type = JunctionType.Choice) as p, _, _) => 
            (null, FsmError.EmptyChoice(p) :: err)

        | JunctionNode(None(), None(), t, _, None(), _) => 
            get_sub_node(t, lev, st, prevst, els, err)
            // if single action node and not decision, taking sub node collecting action
        | JunctionNode(None(), Some(), t, Junction(type = JunctionType.Choice), None(), _)  => 
            get_sub_node(t, lev, st, prevst, els, err)
            // if last action node it is else
        | JunctionNode(None(), Some(a), t, _, None(), _) =>
            def (node, err) = get_sub_node(t, lev, st, prevst, els, err);
                                      // if another pseudostate state 
            def (st, prevst, (node, err)) = if (st != node.state)
                                            {
                                              def prevst = st;
                                              def st = node.state;
                                        // cache it, process path before, traverse it with new values of state
                                              (st, prevst, get_sub_node(t, lev, st, prevst, els, err))
                                            } else (st, prevst, (node, err));
            def st = if (st != prevst) st else null;
            def prevst = prevst ?? (t.transition?.From ?? st);
            (Else(lev, st, [a], prevst, PathNode.Empty(), PathNode.Empty(), node), err)

            // if action have other nodes after it
        | JunctionNode(None(), Some(a), _, Junction(type = JunctionType.Choice) as p, _ ,_) => (null, FsmError.ChoiceActionMaybeLast(p, a) :: err)
        | JunctionNode(None(), _, _, _, _, _) => (null, err)
        | _ => (null, err)
      }
    }

    public static Create(node : PseudoStateNode.Junction, analyser : FsmAnalyser) : DecisionNode * FsmAnalyser
    {
      def (n, e) = match (node)
                    {
                      | PseudoStateNode.Junction(type = JunctionType.Junction) => create_junc_tree_node(node.to, [], 0, node.state, null, null, [])
                      | PseudoStateNode.Junction(type = JunctionType.Choice)   => create_choice_tree_node(node.to, 0, node.state, null, null, [])
                    }
      (n, analyser.AddErrors(e))
    }
  }

}
