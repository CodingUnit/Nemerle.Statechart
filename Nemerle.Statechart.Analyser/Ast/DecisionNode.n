using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{

  using ListUtils;

  #if 0
  [Traversable]
  [Record]
  public partial variant DecisionNode
  {
    | Condition 
      {
        [NeedChange(else_node, actions)]
        [NeedChange(else_node)] 
        [NeedChange(actions)] 
        [NeedChange] 
        body : DecisionNode;
        [NeedChange] 
        else_node : option[DecisionNode];
        //[TraverseIgnore]
        //parent : PseudoStateNode;
        
        this(an : FsmAnalyser, cond : GuardNode, act : list[Actions], body : DecisionNode, els : option[DecisionNode])//, par : PseudoStateNode)
        {
          base(an, act, cond);
          //condition = cond;
          this.body = body;
          this.else_node = els;
          //parent = par;
        }
      }
    | Target 
      {
        [NeedChange] target : TransitionTarget;
        [NeedChange(node_path, out_path)] [NeedChange] destination : TransitionDestination;

        this(an : FsmAnalyser, act : list[Actions], guard : GuardNode, tar : TransitionTarget)
        {
          base(an, act, guard);
          target = tar
        }
        
      }

      public this(an : FsmAnalyser, act : list[Actions], guard : GuardNode)
      {
        //state = st;
        this.condition = guard;
        analyser = an;
        actions = act;
      }
      
    //[NeedChange]
    //[Accessor]
    //public num : int;
    
    //public level : int;
    //[NeedChange]
    //public state : FsmState
    //{
    //  get
    //  {
    //    analyser.statemap.ParentFor(Num)
    //  }
    //  set
    //  {
    //    analyser.statemap.ParentFor(Num, value)
    //  }
    //}
    
    [NeedChange] public condition : GuardNode;
      
    [NeedChange(condition)]
    [NeedChange]
    public actions : list[Actions] = [];
    //[NeedChange]
    //public PrevState : FsmState;

    
    public LevelNodes : IEnumerable[DecisionNode]
    {
      get
      {
        def loop(n)
        {
          | Condition(else_node = Some(e)) => yield n;loop(e)
          | _                              => yield n;
        }
    
      loop(this);
     }
    } 
    
    [NeedChange]
    type : JunctionType;

    public analyser : FsmAnalyser;
    //public this(an : FsmAnalyser) { analyser = an }

    public ActionNode : IEnumerable[PathNode]
    {
      get
      {
        actions.Select(PathNode.Action)
      }
    }

    public GetChild() : IEnumerable[DecisionNode]
    {
      match (this)
      {
        | Condition(body = b, else_node = Some(els))  => TraverseUtils.DoubleElement(b, els)
        | Condition(body = b)                         => TraverseUtils.SingleElement(b)
        | Target                                      => Enumerable.Empty()
      }

    }

    public Rebuild(child : IEnumerable[DecisionNode]) : DecisionNode
    {
      match (this)
      {
        | Condition(else_node = Some as n) as t => def (a, b) = child.TakeTwo();
                                                   t.ChangeBodyElseNode(a, n.ChangeValue(b))
                                              
        | Condition as t                        => t.ChangeBody(child.First())
        | Target as t                           => t
      }
    }
    
    public Guards : IEnumerable[GuardNode]
    {
      get
      {
        ConditionParts.Select(_.condition)
        //Fold([], condition = (t, a) => t.condition :: a)
      }
    }

    public ThisPath : IEnumerable[PathNode]
    {
      get
      {
        ActionNode
      }
    }

    public Paths : IEnumerable[PathNode]
    {
      get
      {
        TargetParts.SelectMany(_.Path)
        //Fold(Enumerable.Empty(), (t, a) => a.Concat(t.Path));
      }
    }

    [NeedChange(out_path)]
    [NeedChange]
    public node_path : IEnumerable[PathNode] = Enumerable.Empty();
    public out_path  : IEnumerable[PathNode] = Enumerable.Empty();

    
    //public analyser : FsmAnalyser;
    
    public ThisOutPath : IEnumerable[PathNode]
    {
      get
      {
        ThisPath + node_path
      }
    }

    public Path : IEnumerable[PathNode]
    {
      get
      {
        node_path + ThisPath + out_path
      }
    }

    //static contains_decision(n : TransitionTarget.JunctionNode) : bool
    //{
    //  match (n.guard)
    //  {
    //    | Empty
    //    | GuardNode.Else => false
    //    | _              => true
    //  }
    //}


  }

  #endif
}
