using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  [Record]
  public class StateHistory : IdObject
  {
    
    public this(st : FsmState, num : int, hist : StateNode.History)
    {
      this(st.analyser);
      history = hist;
      this.num = num;
      //state = if (hist.state != null) FsmState.State(hist.state, null, analyser, true); else st;
      type = hist.type;
      default = history.default |> StateTransition.Default(st, this, _).Create();
    }

    public history : StateNode.History;
    
    public state : FsmState
    {
      get
      {
        statemap.ParentFor(Num)
      }
    }
    
    [NeedChange]
    public default : option[StateTransition];
    
    [NeedChange]
    [Accessor]
    public num : int;
    
    //[NeedChange(default)]
    //[NeedChange] public state : FsmState;
    public type : HistoryType;
    //[NeedChange] public reference : bool;

    [NeedChange] public Used : bool;

    public analyser : FsmAnalyser;
    
    public statemap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }
    
    public this(an : FsmAnalyser) { analyser = an }
    //public this(hist : StateHistory, clone : bool = false, ncopy : int = 0)
    //{
    //  history = hist.history;
    //  default = if (clone) hist.default.Map(x => x.Clone(ncopy) :> StateTransition.Default) else hist.default;
    //  state = hist.state;
    //  type = hist.type;
    //  reference = hist.reference;
    //  Used = hist.Used;
    //}

    public static Create(st : FsmState, hist : TwoOption[StateNode.History]) : TwoOption[StateHistory]
    {
      hist.Map(Create(st, st.statemap.GetNextGlobalNum(), _))
    }

    public static Create(st : FsmState, num : int, hist : StateNode.History) : StateHistory
    {
      StateHistory(st, num, hist)
    }

    //[Accessor] clone_for : StateHistory;

    public static @==(a : StateHistory, b : StateHistory) : bool
    {
      a.Num == b.Num//a.Name == b.Name && a.type == b.type && a.state == b.state
    }

    public static @!=(a : StateHistory, b : StateHistory) : bool
    {
       !(@==(a, b))
    }

    
    public BothHistories(st : FsmState) : bool
    {
        st.BothHistories
    }

    public Name : string
    {
      get
      {
        def type = match (type)
                    {
                      | HistoryType.Deep     => "Deep"
                      | Shallow              => "Shallow"
                      | None                 => ""
                    }

        if (state.history.IsOne) $"$(state)History" else $"$(state)$(type)History"
      }
    }

    public SimpleName : string
    {
      get
      {
        $"$(state)History"
      }
    }

    public override ToString() : string
    {
      Name
    }

    public SubStatesParticipateInHistory : IEnumerable[FsmState]
    {
      get
      {
        state.SubStatesParticipateIn(this)
      }
    }

    //public ChangeState(st : FsmState) : void
    //{
    //  analyser.statemap.ParentFor(Num, st)
    //}
    //public SubStatesParticipateInHistoryIndirect : IEnumerable[FsmState]
    //{
    //    st.Updated.SubStatesParticipateIn(this)
    //}

    public Updated : StateHistory
    {
      get
      {
        state.GetHistory(this)
      }
    }
    
    public UpdateReference(st : FsmState) : StateHistory
    {
      //def hist = if (history.reference) state.GetHistory(this) else this;
      //ChangeState(st);
      def default = default.Map(_.UpdateReference(st));
      ChangeDefault(default)
    }

  }
}
