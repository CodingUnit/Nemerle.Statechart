using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;
  /// <summary>
  /// Description of FsmStateActions.
  /// </summary>
  public partial variant FsmState
  {

    public static StateEquals(this st1 : FsmState, st2 : FsmState) : bool
    {
      | (FsmState(Num = nn, Name = n1), FsmState(Num = nn2, Name = n2)) when (nn == -1 || nn2 == -1) => n1 == n2
      | (FsmState(Num = n1), FsmState(Num = n2))                                                     => n1 == n2
    }
    
    public all_transitions_nested : IEnumerable[StateTransition]
    {
      get
      {
        Iterator().SelectMany(_.all_transitions_with_init)
        //all_transitions_with_init + (AllSubStates |>< all_transitions_with_init)
      }
    }

    public transitions_nested : IEnumerable[StateTransition]
    {
      get
      {
        def tran = AllLivedSubStatesNested.SelectMany(_.transitions);
        transitions.Concat(tran)
      }
    }

    public completion_transitions : IEnumerable[StateTransition]
    {
      get
      {
        change_transitions.Where(_.IsCompletion)
      }
    }

    public change_transitions : IEnumerable[StateTransition]
    {
      get
      {
        transitions
        //super_state_cross_transitions + transitions
      }
    }

    public all_transitions : IEnumerable[StateTransition]
    {
      get
      {
        change_transitions.Concat(internal_tran)
      }
    }

    public all_runnable_transitions : IEnumerable[StateTransition]
    {
      get
      {
        all_transitions.Exclude(_.IsCompletion)
      }
    }
    
    public static create_transition_group(tr : IEnumerable[StateTransition]) : IEnumerable[(string * IEnumerable[StateTransition])]
    {
      single_func
      {
        tr.GroupBy(x => x.FriendlyTriggerName);
        __.Select(x => (x.First().FriendlyTriggerName, x));
      }
    }

    public CloneFor : FsmState
    {
      get
      {
        if (cloneFor != null) statemap.Get(cloneFor) else null
      }
    }
    
    public HaveFinal : bool
    {
      get
      {
        match (this)
        {
          | ConcurrentRegion(sub_regions = r) => r.All(x => x.HaveFinal)
          | _                                 => sub_states.Exists(_ is Final)
        }
      }
    }

    public FinalSubState : option[FsmState.Final]
    {
      get
      {
        sub_states.FindType()
      }
    }
    
    public grouped_transitions : IEnumerable[string * IEnumerable[StateTransition]]
    {
      get
      {
        create_transition_group(all_transitions)
      }
    }

    //public this_cross_transitions : IEnumerable[string * IEnumerable[StateTransition]]
    //{
    //  get
    //  {
    //    create_transition_group(this_transitions).Where((_, x)  => x.M)
    //  }
    //}

    public work_transition_group : IEnumerable[string * IEnumerable[StateTransition]]
    {
      get
      {
        create_transition_group(work_transitions)
      }
    }

    //public cross_transitions : IEnumerable[string * IEnumerable[StateTransition]]
    //{
    //  get
    //  {
    //    grouped_transitions.Where((_, x)  => x.Length > 1)
    //  }
    //}

    /// <summary>
    /// Transitions defined direct from this state
    /// </summary>
    public this_transitions : IEnumerable[StateTransition]
    {
      get
      {
        all_transitions.Where(x  => x.From == this)
      }
    }

    
    public GetHistory(type : StateHistory) : StateHistory
    {
      match (history)
      {
        | One(h)     => h
        | Two(f, s)  => if (f.type == type.type) f else s
        | _          => null
      }
    }

    /// <summary>
    /// State comparing
    /// </summary>
    public CompareTo(b : FsmState) : int
    {
      string.Compare(Name, b.Name)
    }

    public static @==(a : FsmState, b : FsmState) : bool
    {
      a : object == b
      //| (null, null)  => true
      //| (a, null)  => a : object  ==  null
      //| (null, b)  => b : object  ==  null
      //| (a, b)  => a.Name == b.Name
    }

    public static @!=(a : FsmState, b : FsmState) : bool
    {
        !(@==(a, b))
    }

    public HaveHistoryPaths : bool
    {
      get
      {
        HistoryPaths != null && !HistoryPaths.IsEmpty()
      }
    }

    public all_transitions_with_init : IEnumerable[StateTransition]
    {
      get
      {
        all_transitions.Concat(initial)
      }
    }
    /// <summary>
    /// Normal and Internal Transitions
    /// </summary>
    public combined_transitions : IEnumerable[StateTransition]
    {
      get
      {
        transitions.Concat(internal_tran)
      }
    }

    //public incoming_transitions : IEnumerable[StateTransition]
    //{
    //  get
    //  {
    //    analyser.States.SelectMany(x => x.all_transitions.Where(x => x.AtLeastTo == this))
    //  }
    //}

    /// <summary>
    /// Work transitions
    /// </summary>
    public work_transitions : IEnumerable[StateTransition]
    {
      get
      {
        if (Lived)
        {
          single_func
          {
            transitions.Concat(internal_tran);
            __.Exclude(_.CrossFor);
            __.Exclude(_.NotWork);
            __.Where(_.UsedInGenerate)
          }
        } else Enumerable.Empty()
      }
    }

    /// <summary>
    /// All sub states at all nesting levels
    /// </summary>
    public AllSubStates : IEnumerable[FsmState]
    {
      get
      {
        Iterator().ChopLast()
        //sub_states + (sub_states |>< AllSubStates)
      }
    }

    /// <summary>
    /// All sub states include this at all nesting levels
    /// </summary>
    public AllStates : IEnumerable[FsmState]
    {
      get
      {
         Iterator()
        //sub_states + (sub_states |>< AllSubStates)
      }
    }

    //public AllPseudoStates : list[PseudoStateNode]
    //{
    //  get
    //  {
    //    pseudo_states + (sub_states |>< AllPseudoStates)
    //  }
    //}

    /// <summary>
    /// All lived sub states
    /// </summary>
    public AllLivedSubStates : IEnumerable[FsmState]
    {
      get
      {
        AllSubStates.Where(_.Lived)
      }
    }

  // /// <summary>
    ///// All lived sub states
    ///// </summary>
  // public AllLivedSubStatesNotRegions : list[FsmState]
  // {
  //   get
  //   {
  //     AllLivedSubStates.Exclude(_ is ConcurrentRegion)
  //     //def lived = LivedSubStates;
  //     //def (reg, not_reg) = sub_states.Partition(_ is ConcurrentRegion);
  //     //def reg = reg.Filter(_.LivedNested);
  //     //def not_reg = not_reg |>< AllLivedSubStatesNotRegions;
  //     //lived + reg + not_reg
  //   }
  // }

    /// <summary>
    /// Direct lived sub states without consider of living nesting states of this substates
    /// </summary>
    public LivedSubStates : IEnumerable[FsmState]
    {
      get
      {
        sub_states.Where(_.Lived)
      }
    }

    /// <summary>
    /// All Lived substates with consider of nesting state life on all nesting levels
    /// </summary>
    public AllLivedSubStatesNested : IEnumerable[FsmState]
    {
      get
      {
        AllSubStates.Where(_.LivedNested)
        //sub_states.Filter(_.LivedNested) + (sub_states |>< AllLivedSubStatesNested)
      }
    }

    public Lived : bool
    {
      get
      {
        lived || clones.Exists(x => x.Updated.Lived)
      }
    }
    
    /// <summary>
    /// Is it Lived state, consider on nesting lived states
    /// </summary>
    public LivedNested : bool
    {
      get
      {
        Lived || !AllLivedSubStates.IsEmpty()
      }
    }

    /// <summary>
    /// Direct lived substates with consider of nesting state life
    /// </summary>
    public LivedSubStatesNested : IEnumerable[FsmState]
    {
      get
      {
        sub_states.Where(_.LivedNested)
      }
    }

    /// <summary>
    /// Sub states included in the history of this state
    /// </summary>
    public SubStatesParticipateInHistory : IEnumerable[FsmState]
    {
      get
      {
        history.Value.SelectMany(SubStatesParticipateIn)
      }
    }

    public SubStatesParticipateIn(hist : StateHistory) : IEnumerable[FsmState]
    {
      | StateHistory.Deep     => AllLivedSubStates
      | StateHistory.Shallow  => LivedSubStatesNested
      | _                     => Enumerable.Empty()
    }

    /// <summary>
    /// History pseudo-states in which participate this state
    /// </summary>
    public ParticipateInHistory : IEnumerable[StateHistory]
    {
      get
      {
        analyser.HistoryStates.Where(x => x.SubStatesParticipateInHistory.Contains(this))
      }
    }

    public SuperStates : IEnumerable[FsmState]
    {
      get
      {
        SuperStatesCalc
      }
    }
    
    SuperStatesCalc : IEnumerable[FsmState]
    {
      get
      {
        def loop(p)
        {
          | null  => ()
          | p     => yield p;
                     loop(p.Super)
        }

        loop(Super)
      }
    }

    public SuperStatesFromTop : IEnumerable[FsmState]
    {
      get
      {
        Enumerable.Reverse(SuperStates)
      }
    }

    public SuperStatesFromTopInclude : IEnumerable[FsmState]
    {
      get
      {
        SuperStatesFromTop.Append(this)
      }
    }

    /// <summary>
    /// Use both types of history in state
    /// </summary>
    public BothHistories : bool
    {
      get
      {
        history.IsTwo
      }
    }

    public UsedHistory : IEnumerable[StateHistory]
    {
      get
      {
        history.Value.Where(_.Used)
      }
    }

    public IsSubStateOf(st : FsmState) : bool
    {
      SuperStates.Exists(_ == st)
    }

    public static CreateState(st : StateNode.State, sub : IEnumerable[FsmState], an : FsmAnalyser) : FsmState
    {
      match (st)
      {
        | StateNode.State(type = StateType.State) as st                => State(st, sub, an, false)
        | StateNode.State(type = StateType.InlinedSubMachine(t)) as st => InlinedSubMachine(st, sub, an, false, t)
        | StateNode.State(type = StateType.SubRegion) as st            => ConcurrentSubRegion(st, sub, an)
        | StateNode.State(type = StateType.SubMachine(t)) as st        => SubMachine(st, sub, an, false, t, array[], array[])
        | _                                                            => throw InvalidOperationException("unknown state type")
      }
      //if (st != null) State(st, null, true) else state
    }

    //public static CreateState(st : StateNode.State, state : FsmState) : FsmState
    //{
    //  if (st != null) State(st, null, true) else state
    //}

    public region_exit_path : IEnumerable[PathNode]
    {
      get
      {
        match (PartOfRegion)
        {
          | Some(r) => def (exit, _) = TransitionPath.FindPath(this, r, Enumerable.Empty(), Enumerable.Empty()); // exit state nested in region
                       TransitionPath.ExitNodeCreate(this, exit); // create exit state node
                       
          | _       => Enumerable.Empty()
        }
      }
    }
  }
}
