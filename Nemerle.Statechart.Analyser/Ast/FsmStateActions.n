using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;
  /// <summary>
  /// Description of FsmStateActions.
  /// </summary>
  public partial variant FsmState
  {

    public static StateEquals(this st1 : FsmState, st2 : FsmState) : bool
    {
      | (st, st2) when (st.Num == -1 || st2.Num == -1) => st.Name == st2.Name
      | (st, st2)                                      => st.Num == st2.Num
    }
    
    public all_transitions_with_default : IEnumerable[StateTransition]
    {
      get
      {
        all_transitions_with_init + DefaultTransitions
      }
    }
    


    //public transitions_nested : IEnumerable[StateTransition]
    //{
    //  get
    //  {
    //    def tran = AllLivedSubStatesNested.SelectMany(_.transitions);
    //    transitions.Concat(tran)
    //  }
    //}

    public completion_transitions : IEnumerable[StateTransition]
    {
      get
      {
        change_transitions.Where(_.IsCompletion)
      }
    }

    public change_transitions : IEnumerable[StateTransition]
    {
      get
      {
        transitions
        //super_state_cross_transitions + transitions
      }
    }

    public all_transitions : IEnumerable[StateTransition]
    {
      get
      {
        change_transitions.Concat(internal_tran)
      }
    }

    public all_runnable_transitions : IEnumerable[StateTransition]
    {
      get
      {
        all_transitions.Exclude(_.IsCompletion)
      }
    }
    
    public static create_transition_group(tr : IEnumerable[NodeValue[FsmState, StateTransition]]) : IEnumerable[(string * IEnumerable[StateTransition])]
    {
      single_func
      {
        tr.GroupBy(x => x.FriendlyTriggerName);
        __.Select(x => (x.First().FriendlyTriggerName, x));
      }
    }

    public CloneFor : FsmState
    {
      get
      {
        if (cloneFor != null) statemap.Get(cloneFor) else null
      }
    }
    
    
    public grouped_transitions : IEnumerable[string * IEnumerable[StateTransition]]
    {
      get
      {
        create_transition_group(all_transitions)
      }
    }

    //public this_cross_transitions : IEnumerable[string * IEnumerable[StateTransition]]
    //{
    //  get
    //  {
    //    create_transition_group(this_transitions).Where((_, x)  => x.M)
    //  }
    //}

    public work_transition_group : IEnumerable[string * IEnumerable[StateTransition]]
    {
      get
      {
        create_transition_group(work_transitions)
      }
    }

    //public cross_transitions : IEnumerable[string * IEnumerable[StateTransition]]
    //{
    //  get
    //  {
    //    grouped_transitions.Where((_, x)  => x.Length > 1)
    //  }
    //}


    
    public GetHistory(type : PseudoStateNode.History) : PseudoStateNode.History
    {
      match (history)
      {
        | One(h)     => h
        | Two(f, s)  => if (f.type == type.type) f else s
        | _          => null
      }
    }

    /// <summary>
    /// State comparing
    /// </summary>
    public CompareTo(b : FsmState) : int
    {
      if (Num != -1 && b.Num != -1) Num - b.Num else string.Compare(Name, b.Name)
    }

    public static @==(a : FsmState, b : FsmState) : bool
    {
      | (null, null)  => true
      | (a, null)     => a : object  ==  null
      | (null, b)     => b : object  ==  null
      | (a, b) when a.Num != -1 && b.Num != -1 => a.Num == b.Num
      | (a, b)                                 => a.Name == b.Name
    }

    public static @!=(a : FsmState, b : FsmState) : bool
    {
        !(@==(a, b))
    }

    public HaveHistoryPaths : bool
    {
      get
      {
        HistoryPaths != null && !HistoryPaths.IsEmpty()
      }
    }

    public TransitionByNum(num : int) : StateTransition
    {
      match (all_transitions_with_init.Find(x => x.Num == num))
      {
        | Some(t) => t
        | _       => null
      }
    }
    
    public TransitionByNumChange(num : int, tran : StateTransition -> StateTransition) : FsmState
    {
      def check_tran(tr)
      {
        if (tr.Num == num)
        {
          tran(tr)
        } else tr
      }
      
      TransitionMap(check_tran)
    }
    
    public all_transitions_with_init : IEnumerable[StateTransition]
    {
      get
      {
        all_transitions.Concat(initial)
      }
    }
    /// <summary>
    /// Normal and Internal Transitions
    /// </summary>
    public combined_transitions : IEnumerable[StateTransition]
    {
      get
      {
        transitions.Concat(internal_tran)
      }
    }

    public incoming_transitions : IEnumerable[StateTransition]
    {
      get
      {
        analyser.States.SelectMany(x => x.all_transitions.Where(x => x.AtLeastTo == this))
      }
    }

    /// <summary>
    /// Work transitions
    /// </summary>
    public work_transitions : IEnumerable[StateTransition]
    {
      get
      {
        if (Lived)
        {
          single_func
          {
            transitions.Concat(internal_tran);
            __.Exclude(_.CrossFor);
            __.Exclude(_.NotWork);
            __.Where(_.UsedInGenerate)
          }
        } else Enumerable.Empty()
      }
    }

 
  // /// <summary>
    ///// All lived sub states
    ///// </summary>
  // public AllLivedSubStatesNotRegions : list[FsmState]
  // {
  //   get
  //   {
  //     AllLivedSubStates.Exclude(_ is ConcurrentRegion)
  //     //def lived = LivedSubStates;
  //     //def (reg, not_reg) = sub_states.Partition(_ is ConcurrentRegion);
  //     //def reg = reg.Filter(_.LivedNested);
  //     //def not_reg = not_reg |>< AllLivedSubStatesNotRegions;
  //     //lived + reg + not_reg
  //   }
  // }

    

    public Lived : bool
    {
      get
      {
        lived || clones.Exists(x => x.Updated.Lived)
      }
    }
    




    /// <summary>
    /// Use both types of history in state
    /// </summary>
    public BothHistories : bool
    {
      get
      {
        history.IsTwo
      }
    }

    public UsedHistory : IEnumerable[PseudoStateNode.History]
    {
      get
      {
        history.Value.Where(_.Used)
      }
    }


    public static CreateState(st : StateNode.State, an : FsmAnalyser) : FsmState
    {
      match (st)
      {
        | StateNode.State(type = StateType.State) as st                => State(st, sub, an)
        | StateNode.State(type = StateType.InlinedSubMachine(t)) as st => InlinedSubMachine(st, sub, an, t)
        | StateNode.State(type = StateType.SubRegion) as st            => ConcurrentSubRegion(st, sub, an)
        | StateNode.State(type = StateType.SubMachine(t)) as st        => SubMachine(st, sub, an, t, array[], array[])
        | _                                                            => throw InvalidOperationException("unknown state type")
      }
      //if (st != null) State(st, null, true) else state
    }

    //public static CreateState(st : StateNode.State, state : FsmState) : FsmState
    //{
    //  if (st != null) State(st, null, true) else state
    //}

    public region_exit_path : IEnumerable[PathNode]
    {
      get
      {
        match (PartOfRegion)
        {
          | Some(r) => def (exit, _) = TransitionPath.FindPath(this, r, Enumerable.Empty(), Enumerable.Empty()); // exit state nested in region
                       TransitionPath.ExitNodeCreate(this, exit); // create exit state node
                       
          | _       => Enumerable.Empty()
        }
      }
    }
  }
}
