using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  using StateTransition;
  using ListUtils;
  /// <summary>
  /// Description of FsmStateActions.
  /// </summary>
  public partial variant FsmState
  {

    public all_transitions_nested : IEnumerable[StateTransition]
    {
      get
      {
        Iterator().FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.all_transitions_with_init))
        //all_transitions_with_init + (AllSubStates |>< all_transitions_with_init)
      }
    }

    public transitions_nested : IEnumerable[StateTransition]
    {
      get
      {
        def tran = AllLivedSubStatesNested.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.transitions));
        transitions.Concat(tran)
      }
    }

    public completion_transitions : IEnumerable[StateTransition]
    {
      get
      {
        change_transitions.Filter(_.IsCompletion)
      }
    }

    public change_transitions : IEnumerable[StateTransition]
    {
      get
      {
        transitions
        //super_state_cross_transitions + transitions
      }
    }

    public all_transitions : IEnumerable[StateTransition]
    {
      get
      {
        change_transitions.Concat(internal_tran)
      }
    }

    public static create_transition_group(tr : IEnumerable[StateTransition]) : IEnumerable[(string * IEnumerable[StateTransition])]
    {
      single_func
      {
        tr.GroupBy(x => x.FriendlyTriggerName);
        __.Select(x => (x.First().FriendlyTriggerName, x));
      }
    }

    public HaveFinal : bool
    {
      get
      {
        match (this)
        {
          | ConcurrentRegion(sub_regions = r) => r.All(x => x.HaveFinal)
          | _ => sub_states.Exists(_ is Final)
        }
      }
    }

    public grouped_transitions : IEnumerable[string * IEnumerable[StateTransition]]
    {
      get
      {
        create_transition_group(all_transitions)
      }
    }

    public this_cross_transitions : IEnumerable[string * IEnumerable[StateTransition]]
    {
      get
      {
        create_transition_group(this_transitions).Where((_, x)  => x.Length > 1)
      }
    }

    public work_transition_group : IEnumerable[string * IEnumerable[StateTransition]]
    {
      get
      {
        create_transition_group(work_transitions)
      }
    }

    public cross_transitions : IEnumerable[string * IEnumerable[StateTransition]]
    {
      get
      {
        grouped_transitions.Where((_, x)  => x.Length > 1)
      }
    }

    /// <summary>
    /// Transitions defined direct from this state
    /// </summary>
    public this_transitions : IEnumerable[StateTransition]
    {
      get
      {
        all_transitions.Filter(x  => x.From == this)
      }
    }

    public GetHistory(type : StateHistory) : StateHistory
    {
      match (history)
      {
        | One(h)  => h
        | Two(f, s)  => if (f.Type == type.Type) f else s
        | _  => null
      }
    }

    /// <summary>
    /// State comparing
    /// </summary>
    public CompareTo(b : FsmState) : int
    {
      string.Compare(Name, b.Name)
    }

    public static @==(a : FsmState, b : FsmState) : bool
    {
      a : object == b
      //| (null, null)  => true
      //| (a, null)  => a : object  ==  null
      //| (null, b)  => b : object  ==  null
      //| (a, b)  => a.Name == b.Name
    }

    public static @!=(a : FsmState, b : FsmState) : bool
    {
        !(@==(a, b))
    }

    public HaveHistoryPaths : bool
    {
      get
      {
        HistoryPaths != null && HistoryPaths is _ :: _
      }
    }

    public all_transitions_with_init : IEnumerable[StateTransition]
    {
      get
      {
        all_transitions.Concat(Initial)
      }
    }
    /// <summary>
    /// Normal and Internal Transitions
    /// </summary>
    public combined_transitions : IEnumerable[StateTransition]
    {
      get
      {
        transitions.Concat(internal_tran)
      }
    }

    public incoming_transitions : IEnumerable[StateTransition]
    {
      get
      {
        analyser.States |>< all_transitions.Filter(x => x.AtLeastTo == this)
      }
    }

    /// <summary>
    /// Work transitions
    /// </summary>
    public work_transitions : IEnumerable[StateTransition]
    {
      get
      {
        if (Lived)
        {
          single_func
          {
            transitions.Concat(internal_tran);
            __.Exclude(_.CrossFor);
            __.Exclude(_.NotWork);
            __.Where(_.UsedInGenerate)
          }
        } else Enumerable.Empty()
      }
    }

    /// <summary>
    /// All sub states at all nesting levels
    /// </summary>
    public AllSubStates : IEnumerable[FsmState]
    {
      get
      {
        LevelOrderIterator().Skip(1)
        //sub_states + (sub_states |>< AllSubStates)
      }
    }

    /// <summary>
    /// All sub states include this at all nesting levels
    /// </summary>
    public AllStates : IEnumerable[FsmState]
    {
      get
      {
        LevelOrderIterator()
        //sub_states + (sub_states |>< AllSubStates)
      }
    }

    //public AllPseudoStates : list[PseudoStateNode]
    //{
    //  get
    //  {
    //    pseudo_states + (sub_states |>< AllPseudoStates)
    //  }
    //}

    /// <summary>
    /// All lived sub states
    /// </summary>
    public AllLivedSubStates : IEnumerable[FsmState]
    {
      get
      {
        AllSubStates.Filter(_.Lived)
      }
    }

  // /// <summary>
    ///// All lived sub states
    ///// </summary>
  // public AllLivedSubStatesNotRegions : list[FsmState]
  // {
  //   get
  //   {
  //     AllLivedSubStates.Exclude(_ is ConcurrentRegion)
  //     //def lived = LivedSubStates;
  //     //def (reg, not_reg) = sub_states.Partition(_ is ConcurrentRegion);
  //     //def reg = reg.Filter(_.LivedNested);
  //     //def not_reg = not_reg |>< AllLivedSubStatesNotRegions;
  //     //lived + reg + not_reg
  //   }
  // }

    /// <summary>
    /// Direct lived sub states without consider of living nesting states of this substates
    /// </summary>
    public LivedSubStates : IEnumerable[FsmState]
    {
      get
      {
        sub_states.Filter(_.Lived)
      }
    }

    /// <summary>
    /// All Lived substates with consider of nesting state life on all nesting levels
    /// </summary>
    public AllLivedSubStatesNested : IEnumerable[FsmState]
    {
      get
      {
        AllSubStates.Filter(_.LivedNested)
        //sub_states.Filter(_.LivedNested) + (sub_states |>< AllLivedSubStatesNested)
      }
    }

    /// <summary>
    /// Is it Lived state, consider on nesting lived states
    /// </summary>
    public LivedNested : bool
    {
      get
      {
        Lived || !AllLivedSubStates.IsEmpty()
      }
    }

    /// <summary>
    /// Direct lived substates with consider of nesting state life
    /// </summary>
    public LivedSubStatesNested : IEnumerable[FsmState]
    {
      get
      {
        sub_states.Filter(_.LivedNested)
      }
    }

    /// <summary>
    /// Sub states included in the history of this state
    /// </summary>
    public SubStatesParticipateInHistory : IEnumerable[FsmState]
    {
      get
      {
        history.MapToList(SubStatesParticipateIn).Flatten()
      }
    }

    public SubStatesParticipateIn(hist : StateHistory) : IEnumerable[FsmState]
    {
      | StateHistory.Deep     => AllLivedSubStates//AllLivedSubStatesNotRegions
      | StateHistory.Shallow  => LivedSubStatesNested
      | _                     => []
    }

    /// <summary>
    /// History pseudo-states in which participate this state
    /// </summary>
    public ParticipateInHistory : IEnumerable[StateHistory]
    {
      get
      {
        analyser.HistoryStates.Filter(x  => x.SubStatesParticipateInHistory.Contains(this))
      }
    }

    public SuperStates : IEnumerable[FsmState]
    {
      get
      {
        SuperStatesFromTop.Reverse()
      }
    }

    public SuperStatesFromTop : IEnumerable[FsmState]
    {
      get
      {
        def loop(p)
        {
          match (p)
          {
            | null  => ()
            | p  => yield p;
                    loop(p.super_state)
          }
        }

        loop(super_state)
      }
    }

    public SuperStatesFromTopInclude : IEnumerable[FsmState]
    {
      get
      {
        def loop(p)
        {
          match (p)
          {
            | null  => ()
            | p     => yield p;
                       loop(p.super_state)
          }
        }

        loop(this)
      }
    }

    /// <summary>
    /// Use both types of history in state
    /// </summary>
    public BothHistories : bool
    {
      get
      {
        history.IsTwo
      }
    }

    public UsedHistory : IEnumerable[StateHistory]
    {
      get
      {
        history.Value.Where(_.Used)
      }
    }

    public IsSubStateOf(st : FsmState) : bool
    {
      SuperStates.Exists(_ == st)
    }

    public static CreateState(st : StateNode.State, sub : IEnumerable[FsmState], an : FsmAnalyser) : FsmState
    {
      match (st)
      {
        | StateNode.State(type = StateType.State) as st                => State(st, sub, an, false)
        | StateNode.State(type = StateType.InlinedSubMachine(t)) as st => InlinedSubMachine(st, sub, an, false, t, 0)
        | StateNode.State(type = StateType.SubRegion) as st            => ConcurrentSubRegion(st, sub, an, false, 0, null)
        | StateNode.State(type = StateType.SubMachine(t)) as st        => SubMachine(st, sub, an, false, t, array[], array[])
        | _                                                            => throw InvalidOperationException("unknown state type")
      }
      //if (st != null) State(st, null, true) else state
    }

    //public static CreateState(st : StateNode.State, state : FsmState) : FsmState
    //{
    //  if (st != null) State(st, null, true) else state
    //}

    public region_exit_path : PathNode
    {
      get
      {
        match (PartOfRegion)
        {
          | Some(r) => 
              def (exit, _) = TransitionPath.FindPath(this, r, [], []); // exit state nested in region
              TransitionPath.ExitNodeCreate(this, exit); // create exit state node
          | _       => null
        }
      }
    }
  }
}
