using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using PseudoStateAstNode;
  using FsmState;
  using PseudoStateNode;
  
  [Record]
  public variant TransitionTarget
  {
    | History 
        {
          history : StateHistory;
         
          override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
          {
            if (history.reference) 
             {
               def (st, an) = an.statemap.Get(history.state.Name, an);
               def tar = if (st != null) ChangeHistory(st.GetHistory(history)) else this;
               (tar, an)
             } else (this, an)
          }

          override ToString() : string
          {
            $"$(history.state)History"
          }
          
          this(tran : StateTransition, st : FsmState, type : TargetType.History)
          {
            base(tran);
            history = StateHistory.Create(st, type.history, true)
          }
        }
    | Final
        {
          state : FsmState.Final;

          override ToString() : string
          {
            $"$(state)"
          }
          
          this(tran : StateTransition)
          {
            base(tran)
          }
          
          public override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
          {
            if (state != null && state.reference) 
            {
              def (st, an) = an.statemap.Get(state.NativeName, an);
              def tar = if (st != null) ChangeState(st :> FsmState.Final) else this;
              (tar, an)
            } else (this, an)
          }
        }
    | PseudoState
        {
          node : PseudoStateNode;

          this(tran : StateTransition, st : FsmState, node : TargetType.PseudoState)
          {
            //def init_target(t)
            //{
            //  //t.transition = tran
            //}
            
            base(tran);
            this.node = PseudoStateNode.Create(node.node, st, transition);
            //Traverse(init_target)
          }

          override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
          {
            def (n, an) = node.UpdateReference(an);
            def tar = if (n != node : object) PseudoState(transition, n) else this;
            (tar, an)
          }
          
          override ToString() : string
          {
            node.ToString()
          }
        }
    | State 
        {
          state : FsmState;
          
          override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
          {
            
            if (state.reference) 
            {
              def map = an.statemap;
              def (st, an) = map.Get(state.Name, an);
              def tar =  if (st != null) ChangeState(st) else this;
              (tar, an)
            } else (this, an)
          }

          Name : string
          {
            get
            {
              state.Name
            }
          }
          
          override ToString() : string
          {
            state.ToString();
          }
          
          this(tran : StateTransition, type : TargetType.State)
          {
            base(tran);
            state = FsmState.State(type.state, null, true);
          }
          
        }
    
    | Named
        {
          state : FsmState;
          name : string;

          // TODO: вообще могут быть ссылки null если все immutable
          override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
          {
            if (state != null && state.reference) 
            {
              def map = an.statemap;
              def (st, an) = map.Get(state.Name, an);
              def tar = if (st != null) ChangeState(st) else this;
              (tar, an)
           } else (this, an)
          }

          Name : string
          {
            get
            {
              $"Named$state.$name"
            }
          }
          
          override ToString() : string
          {
            Name
          }
          
          this(tran : StateTransition, st : FsmState, type : TargetType.Named)
          {
            base(tran);
            state = CreateState(type.parent, st);
            name = type.name;
          }

        }
    
    | Qualified 
        {
          parent : string;
          target : TransitionTarget;
      
          override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
          {
            def map = an.statemap;
            match (target)
            {
              | State(st) as t when (st.reference) => 
                 def (st, an) = map.Get($"$parent.$(st.NativeName)", an);
                 def tar = if (st != null) t.ChangeState(st) else this;
                 (tar, an)
              | _ => target.UpdateReference(an)
            }
          }
      
          override ToString() : string
          {
            $"$parent.$target"
          }
      
        }
    | SubMachine 
        {
          [NeedChange] machine : FsmState.SubMachine;
          state : string;
          
          override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
          {
            match (machine)
            {
              | FsmState where (reference = true, Name = n) => 
                 def (st, an) = an.statemap.Get(n, an);
                 def tar = if (st != null) ChangeMachine(st :> FsmState.SubMachine) else this;
                 (tar, an)
              | _ => (this, an)
            }
          }
      
          override ToString() : string
          {
            $"$machine.$state"
          }
      
        }
    
    public static Create(state : FsmState, tran : StateTransition, target : TargetType) : TransitionTarget
    {
      match (target)
      {
        | PseudoState as t                  => PseudoState(tran, state, t)
        | History     as t                  => History(tran, state, t)
        | Final                             => Final(tran)
        | State       as t                  => State(tran, t)
        | Named       as t                  => Named(tran, state, t)
        | SubMachine(m, s)                  => SubMachine(tran, SubMachine(m, null), s)
        | Qualified(parent = p, target = t) => Qualified(tran, p, Create(state, tran, t))
      }
    }
    
    public CompareTo(target : TransitionTarget) : int
    {
      CompareTo(this, target)
    }

    public static CompareTo(t1 : TransitionTarget, target : TransitionTarget) : int
    {
      | (History(h1), History(h2))                            => h1.Name.CompareTo(h2.Name)
      | (Final(st1), Final(st2))                              => st1.Name.CompareTo(st2.Name)
      | (PseudoState(n1), PseudoState(n2))                    => n1.ToString().CompareTo(n2.ToString())
      | (State(st1), State(st2))                              => st1.Name.CompareTo(st2.Name)
      | (SubMachine(m, s), SubMachine(m2, s2)) when (m == m2) => s.CompareTo(s2)
      | _                                                     => -1
    }

    public static @==(a : TransitionTarget, b : TransitionTarget) : bool
    {
      | (History(h1), History(h2))             => h1 == h2
      | (State(st1), State(st2))
      | (Final(st1), Final(st2))               => st1 == st2
      | (PseudoState(n1), PseudoState(n2))     => n1 == n2
      | (Named(st, n), Named(st2, n2))         => st == st2 && n == n2
      | (Qualified(p, t), Qualified(p2, t2))   => p == p2 && t == t2
      | (SubMachine(m, s), SubMachine(m2, s2)) => m == m2 && s == s2
      | _                                      => false
    }
    
    public PartOfSubRegion : option[ConcurrentSubRegion]
    {
      get
      {
        match (ToState)
        {
          | null => None()
          | ConcurrentSubRegion as st => Some(st)
          | st => st.PartOfSubRegion
        }
      }
    }
    
    public ToState : FsmState
    {
      get
      {
        match (this)
        {
          | PseudoState(PseudoStateNode where (state = st))
          | History(StateHistory where (state = st))
          | Final(state = st)
          | SubMachine(st, _)
          | State(state = st)  => st
          | Named              => null
          | Qualified(_, t)    => t.ToState
        }
      }
    }
    
    //public Clone(ncopy : int = 0) : TransitionTarget
    //{
    //  def tar = match (this)
    //  {
    //    | PseudoState(node = n, transition = t)               => PseudoState(t, n.Clone(ncopy))
    //    | History(transition = t, history = h)                => History(t, h)
    //    | Final(state = st, transition = t)                   => Final(t, st)
    //    | SubMachine(machine = m, state = st, transition = t) => SubMachine(t, m, st)
    //    | State(state = st, transition = t)                   => State(t, st)
    //    | Named(state = st, transition = t, name = n)         => Named(t, st, n)
    //    | Qualified(transition = tr, parent = p, target = t)  => Qualified(tr, p, t.Clone(ncopy))
    //  }
    //  tar.clone_for = this;
    //  tar
    //}
    
    public transition : StateTransition;
    
    public Traverse(analyser : FsmAnalyser, func : TransitionTarget * FsmAnalyser -> TransitionTarget * FsmAnalyser) : TransitionTarget * FsmAnalyser
    {
      def check_target(tr, p, j, t, a)
      {
        
        def check_change(tr, p, j, ot, a)
        {
          match (func(ot, a), tr, j)
          {
            | ((null, a), _, _)                                  => (ot, a)
            | ((nt, a), _, null) when (nt.GetType() != ot.GetType()) => check_target(tr, p, j, nt, a)
            | ((nt, a), _, _)                                    => (nt, a)
          }
        }
        
        def check_node(p, n, a)
        {
          //def to = check_change(null, p, n, n.to);
          def to = n.to;
          match (check_target(null, p, n, to, a))
          {
           | (nto, a) when (nto : object != to) => (n.ChangeTo(nto), a)
           | (_, a) => (n, a)
          }
        }
      
        def traverse(p, n, a)
        { // TODO: избежать лишних изменений
          n.FoldLeft(([], a), (n, (nl, a)) => {def (nn, na) = check_node(p, n, a); (nn :: nl, na) })
        }
      
        match (check_change(tr, p, j, t, a))
        {
          | (TransitionTarget.PseudoState(Merge(node = n)) as p, a) => def (n, a) = check_node(p, n, a); 
              (p.ChangeNode(n), a)
          | (PseudoState(Junction(nodes = n) as j) as p, a) => 
             def (n, a) = traverse(p, n, a);
             (p.ChangeNode(j.ChangeNodes(n)), a)   // TODO: проверить как часто создается и зачем
             
          | (PseudoState(Choice(nodes = n) as c) as p, a)   => 
             def (n, a) = traverse(p, n, a);
             (p.ChangeNode(c.ChangeNodes(n)), a)
             
          | x => x

        }
      
      }
    
      check_target(this, null, null, this, analyser)
    }
   
    public SetCopy(ncopy : int) : TransitionTarget
    {
      def inc(t, an)
      {
        match (t)
        {
          | PseudoState(n)    as p => def t = n.SetCopy(ncopy);
                                      p.ChangeNode(t)
          | x                      => x
        }
      }
      
      //Traverse(an, inc)
    }
    //[RecordIgnore] 
    //[Accessor]
    //clone_for : TransitionTarget;
    
    public FoldThis(pseudo : PseudoStateNode * TransitionTarget.PseudoState -> TransitionTarget, 
                    hist : StateHistory * TransitionTarget.History -> TransitionTarget, 
                    final : FsmState.Final * TransitionTarget.Final -> TransitionTarget, 
                    state : FsmState * TransitionTarget.State -> TransitionTarget,
                    named : FsmState * string * TransitionTarget.History -> TransitionTarget,
                    machine : FsmState.SubMachine * string * TransitionTarget.SubMachine -> TransitionTarget,
                    qual : string * TransitionTarget * TransitionTarget.Qualified -> TransitionTarget) : TransitionTarget
    {
        //| PseudoState as t                  => PseudoState(tran, state, t)
        //| History     as t                  => History(tran, state, t)
        //| Final                             => Final(tran)
        //| State       as t                  => State(tran, t)
        //| Named       as t                  => Named(tran, state, t)
        //| SubMachine(m, s)                  => SubMachine(tran, SubMachine(m, null), s)
        //| Qualified(parent = p, target = t) => Qualified(tran, p, Create(state, tran, t))
      
      def xnode(n, b, e, ot)
      {
        match (n)
        {
          | null 
          | x when (x : object == ot)                                              => ot
          //| PseudoState(tran, st, n) as j when (nb : object != b || ne : object != e) => Condition(j.level, j.state, j.actions, j.PrevState, j.node_path, j.out_path, nc, nb, ne)
          //| DecisionNode.Action(c, nb) as j when (nb : object != b)                => Action(j.level, j.state, actions,  j.PrevState, j.node_path, j.out_path, c, nb)
          //| Else(nb) as j when (nb : object != b)                                  => Else(j.level, j.state, actions,  j.PrevState, j.node_path, j.out_path, nb)
          | x                                                                      => x
        }
      }
      
      def loop(e, cont)
      {

        def loop_pseudo(ee, econt)
        {
          
        }
        
        match (e)
        {
          | PseudoState(Junction(n, nn, p, t)) => //loop_pseudo(nn, )//cont(xnode(pseudo(n, t), null, null, t))
          | PseudoState(n) as t                => cont(xnode(pseudo(n, t), null, null, t))
        
        //| History     as t                  => History(tran, state, t)
        //| Final                             => Final(tran)
        //| State       as t                  => State(tran, t)
        //| Named       as t                  => Named(tran, state, t)
        //| SubMachine(m, s)                  => SubMachine(tran, SubMachine(m, null), s)
        //| Qualified(parent = p, target = t) => Qualified(tran, p, Create(state, tran, t))
          
          //| Target(x, d) as t     => cont(xnode(targ(x, d, t), null, null, t))
          
          //| PseudoState(tran, st, n) as t => cont(xnode(pseudo(tran, n, t), bacc, eacc, t))
                                                  
          //| Else(b) as t       => loop(b, bacc => 
           //                         cont(xnode(els(bacc, t), bacc, null, t)))
                                    
          //| Action(c, b) as t  => loop(b, bacc => 
            //                        cont(xnode(act(c, bacc, t), bacc, null, t)))
        }
      }

      loop(this, x => x)
    }
    
    public virtual UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
    {
      (this, an)
    }
     
  }
  

}
