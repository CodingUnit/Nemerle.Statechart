using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;


namespace Nemerle.Statechart
{
  using PseudoStateModelNode;
  using FsmState;
  using PseudoStateNode;
  using ListUtils;

  public enum TransitionKind
  {
    | Normal
    | History
  }
  //[Traversable(All)]
  [Record]
  public partial variant TransitionTarget
  {
    //[TraverseIgnore]
    | Nowhere

    | Final
      {
        [NeedChange]
        state : FsmState;
        
        //state : FsmState
        //{
        //  get
        //  {
        //    value.node.Value
        //  }
        //}
        
        override ToString() : string
        {
          $"$(base.ToString())Final$(state)"
        }

      }
      
    //[Traverse(junction(value = PseudoStateNode.Junction(_)))]
    //[Traverse(merge(node = PseudoStateNode.Merge(_)))]
    | PseudoState
      {
        [NeedChange]
        node : PseudoStateNode;

        //value : PseudoStateNode
        //{
        //  get
        //  {
        //    node.
        //  }
        //}
        
        //JunctionPseudo : PseudoStateNode.Junction
        //{
        //  get
        //  {
        //    if (value is PseudoStateNode.Junction as t) t else null
        //  }
        //}
        
        //ChangeNode(pseudo : PseudoStateNode -> PseudoStateNode) : PseudoState
        //{
        //  ChangeNode(pseudo(node./))
        //}
        
        this(st : FsmState, node : TargetType.PseudoState)
        {
          //base(st.analyser);
          this.node = PseudoStateNode.Create(st, node.node);
        }

        override ToString() : string
        {
          $"$(base.ToString())$node"
        }
      }
      
    | State 
      {
        [NeedChange]
        state : FsmState;

        //state : FsmState
        //{
        //  get
        //  {
        //    value.node.Value
        //  }
        //}
        
        //public static SetState(st : FsmState, tran : StateTransition, nst : FsmState) : FsmState
        //{
        //  st.TransitionByNumChange(tran.Num, tr => tr.ChangeTo((tr.To :> State).ChangeState(nst)))
        //}
        
        //public static GetState(st : FsmState, tran : StateTransition) : FsmState
        //{
        //  match (st.TransitionByNum(tran.Num).To)
        //  {
        //    | State(st) => st
        //    | _         => null
        //  }
        //}
        //state : FsmState
        //{
        //  get
        //  {
        //    state_num.Updated
        //  }
        //}

        Name : string
        {
          get
          {
            $"$state"
          }
        }

        override ToString() : string
        {
          $"$(base.ToString())$Name"
        }

        //this(an : FsmAnalyser, type : TargetType.State)
        //{
        //  //base(an);
        //  state = FsmState(type.state, Enumerable.Empty(), an);
        //}

        
      }

    | Named
      {
        state : FsmState;
        name  : string;

        Name : string
        {
          get
          {
            $"Named$state.$name"
          }
        }

        override ToString() : string
        {
          Name
        }

        this(st : FsmState, type : TargetType.Named)
        {
          //base(st.analyser);
          state = st;//CreateState(type.parent, [], null);
          name = type.name;
        }

      }

    | Qualified 
      {
        parent : string;
        [NeedChange] target : TransitionTarget;

        override ToString() : string
        {
          $"$parent.$target"
        }

      }
      
    //| SubMachine 
    //  {
    //    [NeedChange] machine : FsmState;//ReferenceNode[FsmState.SubMachine];
        
    //    state : string;

    //    override ToString() : string
    //    {
    //      $"$(machine).$state"
    //    }

    //  }
    //| JunctionNode
    //  {
    //    [NeedChange] to           : TransitionTarget;
    //    //parent                    : PseudoStateNode;
    //    [NeedChange(to)] next     : option[JunctionNode];
    //    //[NeedChange] state        : FsmState;
    //    [NeedChange] decisionTree : DecisionNode;
        
    //    type                      : JunctionType;
        
    //    Actions : IEnumerable[PathNode]
    //    {
    //      get
    //      {
    //        decisionTree.ActionNode
    //      }
    //    }
        
    //    public static Create(st : FsmState, to : TargetType.JunctionNode) : JunctionNode
    //    {
    //      def an = st.analyser;
    //      match (to)
    //      {
    //        | TargetType.JunctionNode(g, a, t, n) => JunctionNode(an, g, a, Create(st, t), n.Map(Create(st, _)), null, JunctionType.Junction)
    //      } 
    //    }

    //    //Guards : list[GuardNode]
    //    //{
    //    //  get
    //    //  {
    //    //    to.Fold([guard], null, null, null, null, null, null, null, null, null, (a, t) => t.guard :: a)
    //    //    //def g = match (to)
    //    //    //         {
    //    //    //           | TransitionTarget.PseudoState(Merge(to = TransitionTarget.JunctionNode(Guards = g)))
    //    //    //           | TransitionTarget.PseudoState(Junction(Guards = g)) => g.NToList()
    //    //    //           | _                                                  => []
    //    //    //         }
    //    //    //guard :: g//guard :: g
    //    //  }
    //    //}

    //    //override UpdateReference() : TransitionTarget
    //    //{
    //    //  def nto = to.UpdateReference();
    //    //  ChangeTo(nto)
    //    //}

    //    public GetName(state : FsmState) : string
    //    {
    //        $"JunctionNode$state"
    //    }
        
    //    override ToString() : string
    //    {
    //      $"$(type) JunctionNode [$guard] / $action => $to"
    //    }
        
    //  }


  }


}
