using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using PseudoStateAstNode;
  using FsmState;
  using PseudoStateNode;
  using ListUtils;

  [Traversable(All)]
  [Record]
  public partial variant TransitionTarget
  {
    [TraverseIgnore]
    | Nowhere

    | Final
      {
        [NeedChange] state_num : FsmState;
        
        state : FsmState
        {
          get
          {
            state_num.Updated
          }
        }

        override ToString() : string
        {
          $"$(base.ToString())-$state"
        }

      }
      
    [Traverse(junction(node = PseudoStateNode.Junction(_)))]
    //[Traverse(merge(node = PseudoStateNode.Merge(_)))]
    | PseudoState
      {
        [NeedChange] node : PseudoStateNode;

        public static GetHistory(st : FsmState, tran : StateTransition) : PseudoStateNode.History
        {
          match (st.TransitionByNum(tran.Num).To)
          {
            | PseudoState(PseudoStateNode.History as node) => node
            | _                                            => null
          }
        }
        
        public static SetHistory(st : FsmState, tran : StateTransition, hist : PseudoStateNode.History) : FsmState
        {
          st.TransitionByNumChange(tran.Num, tr => tr.ChangeTo((tr.To :> PseudoState).ChangeNode(hist)))
        }
        
        JunctionPseudo : PseudoStateNode.Junction
        {
          get
          {
            if (node is PseudoStateNode.Junction as t) t else null
          }
        }
        
        ChangeNode(pseudo : PseudoStateNode -> PseudoStateNode) : PseudoState
        {
          ChangeNode(pseudo(node))
        }
        
        this(st : FsmState, node : TargetType.PseudoState)
        {
          def an = st.analyser;
          base(an);
          this.node = PseudoStateNode.Create(st, node.node);
        }

        override ToString() : string
        {
          $"$(base.ToString())$node"
        }
      }
      
    | State 
      {
        [NeedChange]
        state : FsmState;
        
        public static SetState(st : FsmState, tran : StateTransition, nst : FsmState) : FsmState
        {
          st.TransitionByNumChange(tran.Num, tr => tr.ChangeTo((tr.To :> State).ChangeState(nst)))
        }
        
        public static GetState(st : FsmState, tran : StateTransition) : FsmState
        {
          match (st.TransitionByNum(tran.Num).To)
          {
            | State(st) => st
            | _         => null
          }
        }
        //state : FsmState
        //{
        //  get
        //  {
        //    state_num.Updated
        //  }
        //}

        Name : string
        {
          get
          {
            state.Name
          }
        }

        override ToString() : string
        {
          $"$(base.ToString())-$state"
        }

        this(an : FsmAnalyser, type : TargetType.State)
        {
          base(an);
          state = FsmState.State(type.state, Enumerable.Empty(), an);
        }

        
      }

    | Named
      {
        [NeedChange] 
        state : FsmState;
        name  : string;

          // TODO: вообще могут быть ссылки null если все immutable
        //override UpdateReference(_ : FsmState) : TransitionTarget
        //{
        //  def st = StateMap.Get(state);
        //   ChangeState(st)
        //}

        Name : string
        {
          get
          {
            $"Named$state.$name"
          }
        }

        override ToString() : string
        {
          Name
        }

        this(st : FsmState, type : TargetType.Named)
        {
          base(st.analyser);
          state = st;//CreateState(type.parent, [], null);
          name = type.name;
        }

      }

    | Qualified 
      {
        parent : string;
        [TraverseIgnore]
        [NeedChange] target : TransitionTarget;

        //override UpdateReference(st : FsmState) : TransitionTarget
        //{
        //  //match (target)
        //  //{
        //  //  | State(state = st) as t => 
        //  //      def st = StateMap.Get($"$parent.$(st.NativeName)");
        //  //      if (st != null) t.ChangeState(st) else this;
                
        //    target.UpdateReference(st)
//      //    }
        //}

        override ToString() : string
        {
          $"$parent.$target"
        }

      }
      
    | SubMachine 
      {
        [NeedChange] machine_num : FsmState.SubMachine;
        
        machine : FsmState.SubMachine
        {
          get
          {
            StateMap.Get(machine_num) :> FsmState.SubMachine
          }
        }
        
        state : string;

        //override UpdateReference(_ : FsmState) : TransitionTarget
        //{
        //  def st = StateMap.Get(machine);
        //  if (st != null) ChangeMachineNum(st :> FsmState.SubMachine) else this;
        //}

        override ToString() : string
        {
          $"$machine.$state"
        }

      }
    | JunctionNode
      {
        guard                     : GuardNode;
        action                    : option[Actions] = None();
        [NeedChange] to           : TransitionTarget;
        //parent                    : PseudoStateNode;
        [NeedChange(to)] next     : option[JunctionNode];
        //[NeedChange] state        : FsmState;
        [NeedChange] decisionTree : DecisionNode;
        
        type                      : JunctionType;
        
        Actions : IEnumerable[PathNode]
        {
          get
          {
            decisionTree.ActionNode
          }
        }
        
        public static Create(st : FsmState, to : TargetType.JunctionNode) : JunctionNode
        {
          def an = st.analyser;
          match (to)
          {
            | TargetType.JunctionNode(g, a, t, n) => JunctionNode(an, g, a, Create(st, t), n.Map(Create(st, _)), null, JunctionType.Junction)
          } 
        }

        //Guards : list[GuardNode]
        //{
        //  get
        //  {
        //    to.Fold([guard], null, null, null, null, null, null, null, null, null, (a, t) => t.guard :: a)
        //    //def g = match (to)
        //    //         {
        //    //           | TransitionTarget.PseudoState(Merge(to = TransitionTarget.JunctionNode(Guards = g)))
        //    //           | TransitionTarget.PseudoState(Junction(Guards = g)) => g.NToList()
        //    //           | _                                                  => []
        //    //         }
        //    //guard :: g//guard :: g
        //  }
        //}

        //override UpdateReference() : TransitionTarget
        //{
        //  def nto = to.UpdateReference();
        //  ChangeTo(nto)
        //}

        public GetName(state : FsmState) : string
        {
            $"JunctionNode$state"
        }
        
        override ToString() : string
        {
          $"$(type) JunctionNode [$guard] / $action => $to"
        }
        
      }


  }


}
