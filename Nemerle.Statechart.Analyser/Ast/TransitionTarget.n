using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using PseudoStateAstNode;
  using FsmState;
  using PseudoStateNode;
  using ListUtils;

  [Record]
  public variant TransitionTarget
  {
    | History 
      {
        [NeedChange] history : StateHistory;

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          if (history.reference) 
          {
            def (st, an) = an.statemap.Get(history.state.Name, an);
            def tar = if (st != null) ChangeHistory(st.GetHistory(history)) else this;
            (tar, an)
          } else (this, an)
        }

        override ToString() : string
        {
          $"$(history.state)History"
        }

        this(tran : StateTransition, st : FsmState, type : TargetType.History)
        {
          base(tran);
          history = StateHistory.Create(st, type.history, true)
        }
      }
    | Final
      {
        [NeedChange] state : FsmState.Final;

        override ToString() : string
        {
          $"$(state)"
        }

        this(tran : StateTransition)
        {
          base(tran)
        }

        public override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          if (state != null && state.reference) 
          {
            def (st, an) = an.statemap.Get(state.NativeName, an);
            def tar = if (st != null) ChangeState(st :> FsmState.Final) else this;
            (tar, an)
          } else (this, an)
        }
      }
    | PseudoState
      {
        [NeedChange] node : PseudoStateNode;

        this(tran : StateTransition, st : FsmState, node : TargetType.PseudoState)
        {
          base(tran);
          this.node = PseudoStateNode.Create(node.node, st, transition);
        }

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          def (n, an) = node.UpdateReference(an);
          def tar = if (n != node : object) PseudoState(transition, n) else this;
          (tar, an)
        }

        override ToString() : string
        {
          node.ToString()
        }
      }
    | State 
      {
        [NeedChange] state : FsmState;

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          if (state.reference) 
          {
            def map = an.statemap;
            def (st, an) = map.Get(state.Name, an);
            def tar =  if (st != null) ChangeState(st) else this;
            (tar, an)
          } else (this, an)
        }

        Name : string
        {
          get
          {
            state.Name
          }
        }

        override ToString() : string
        {
          state.ToString();
        }

        this(tran : StateTransition, type : TargetType.State)
        {
          base(tran);
          state = FsmState.State(type.state, null, true);
        }

      }

    | Named
      {
        [NeedChange] state : FsmState;
        name : string;

          // TODO: вообще могут быть ссылки null если все immutable
        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          if (state != null && state.reference) 
          {
            def map = an.statemap;
            def (st, an) = map.Get(state.Name, an);
            def tar = if (st != null) ChangeState(st) else this;
            (tar, an)
          } else (this, an)
        }

        Name : string
        {
          get
          {
            $"Named$state.$name"
          }
        }

        override ToString() : string
        {
          Name
        }

        this(tran : StateTransition, st : FsmState, type : TargetType.Named)
        {
          base(tran);
          state = CreateState(type.parent, st);
          name = type.name;
        }

      }

    | Qualified 
      {
        parent : string;
        [NeedChange] target : TransitionTarget;

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          def map = an.statemap;
          match (target)
          {
            | State(st) as t when (st.reference) => 
                def (st, an) = map.Get($"$parent.$(st.NativeName)", an);
                def tar = if (st != null) t.ChangeState(st) else this;
                (tar, an)
            | _ => target.UpdateReference(an)
          }
        }

        override ToString() : string
        {
          $"$parent.$target"
        }

      }
    | SubMachine 
      {
        [NeedChange] machine : FsmState.SubMachine;
        state : string;

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          match (machine)
          {
            | FsmState where (reference = true, Name = n) => 
                def (st, an) = an.statemap.Get(n, an);
                def tar = if (st != null) ChangeMachine(st :> FsmState.SubMachine) else this;
                (tar, an)
            | _ => (this, an)
          }
        }

        override ToString() : string
        {
          $"$machine.$state"
        }

      }
    | JunctionNode
      {
        guard : option[GuardNode];
        action : option[Actions];
        [NeedChange] to : TransitionTarget;
        parent : PseudoStateNode;
        [NeedChange(to)] next : option[JunctionNode];
        state : FsmState;

        public static Create(st : FsmState, par : PseudoStateNode, to : TargetType.JunctionNode, tran : StateTransition) : JunctionNode
        {
          match (to)
          {
            | TargetType.JunctionNode(g, a, t, n) => JunctionNode(tran, g, a, Create(st, tran, t), par, n.Map(x => Create(st, par, x, tran)), st)
          } 
        }

        Guards : list[GuardNode]
        {
          get
          {
            def g = match (to)
                     {
                       | TransitionTarget.PseudoState(Merge(to = TransitionTarget.JunctionNode(Guards = g)))
                       | TransitionTarget.PseudoState(Junction(Guards = g)) => g
                       | _ => []
                     }
            guard %:: g
          }
        }

        public UpdateRef(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {   
          def (nto, an) = to.UpdateReference(an);
          def (st, an) = base.UpdateReference(an);
          def st = match (st)
                    {
                      | JunctionNode as j when (j : object != this || nto : object != to) => j.ChangeTo(nto)//JunctionNode(st, copy, guard, action, nto, parent)
                      | _                                                                 => this
                    }
          (st, an)
        }

        public override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {   
          UpdateRef(an);
        }
      }

    public static Create(state : FsmState, tran : StateTransition, target : TargetType) : TransitionTarget
    {
      match (target)
      {
        | PseudoState as t                  => PseudoState(tran, state, t)
        | History     as t                  => History(tran, state, t)
        | Final                             => Final(tran)
        | State       as t                  => State(tran, t)
        | Named       as t                  => Named(tran, state, t)
        | SubMachine(m, s)                  => SubMachine(tran, SubMachine(m, null), s)
        | Qualified(parent = p, target = t) => Qualified(tran, p, Create(state, tran, t))
        | JunctionNode(g, a, t, n)          => JunctionNode(tran, g, a, Create(state, tran, t), null, n.Map(x => Create(state, tran, x) :> JunctionNode), state)
      }
    }

    public CompareTo(target : TransitionTarget) : int
    {
      CompareTo(this, target)
    }

    public static CompareTo(t1 : TransitionTarget, target : TransitionTarget) : int
    {
      | (History(h1), History(h2))                            => h1.Name.CompareTo(h2.Name)
      | (Final(st1), Final(st2))                              => st1.Name.CompareTo(st2.Name)
      | (PseudoState(n1), PseudoState(n2))                    => n1.ToString().CompareTo(n2.ToString())
      | (State(st1), State(st2))                              => st1.Name.CompareTo(st2.Name)
      | (SubMachine(m, s), SubMachine(m2, s2)) when (m == m2) => s.CompareTo(s2)
      | (Qualified(p, t), Qualified(p2, t2)) when (p == p2)   => t.CompareTo(t2)
      | _                                                     => -1
    }

    public static @==(a : TransitionTarget, b : TransitionTarget) : bool
    {
      | (History(h1), History(h2))             => h1 == h2
      | (State(st1), State(st2))
      | (Final(st1), Final(st2))               => st1 == st2
      | (PseudoState(n1), PseudoState(n2))     => n1 == n2
      | (Named(st, n), Named(st2, n2))         => st == st2 && n == n2
      | (Qualified(p, t), Qualified(p2, t2))   => p == p2 && t == t2
      | (SubMachine(m, s), SubMachine(m2, s2)) => m == m2 && s == s2
      | _                                      => false
    }

    public PartOfSubRegion : option[ConcurrentSubRegion]
    {
      get
      {
        match (ToState)
        {
          | null => None()
          | ConcurrentSubRegion as st => Some(st)
          | st => st.PartOfSubRegion
        }
      }
    }

    public ToState : FsmState
    {
      get
      {
        match (this)
        {
          | PseudoState(PseudoStateNode where (state = st))
          | History(StateHistory where (state = st))
          | Final(state = st)
          | SubMachine(st, _)
          | JunctionNode(state = st)
          | State(state = st)  => st
          | Named              => null
          | Qualified(_, t)    => t.ToState
        }
      }
    }

    //public Clone(ncopy : int = 0) : TransitionTarget
    //{
    //  def tar = match (this)
    //  {
    //    | PseudoState(node = n, transition = t)               => PseudoState(t, n.Clone(ncopy))
    //    | History(transition = t, history = h)                => History(t, h)
    //    | Final(state = st, transition = t)                   => Final(t, st)
    //    | SubMachine(machine = m, state = st, transition = t) => SubMachine(t, m, st)
    //    | State(state = st, transition = t)                   => State(t, st)
    //    | Named(state = st, transition = t, name = n)         => Named(t, st, n)
    //    | Qualified(transition = tr, parent = p, target = t)  => Qualified(tr, p, t.Clone(ncopy))
    //  }
    //  tar.clone_for = this;
    //  tar
    //}

    public transition : StateTransition;

    //public Traverse(analyser : FsmAnalyser, func : TransitionTarget * FsmAnalyser -> TransitionTarget * FsmAnalyser) : TransitionTarget * FsmAnalyser
    //{
    //  def check_target(tr, p, j, t, a)
    //  {

    //    def check_change(tr, p, j, ot, a)
    //    {
    //      match (func(ot, a), tr, j)
    //      {
    //        | ((null, a), _, _)                                  => (ot, a)
    //        | ((nt, a), _, null) when (nt.GetType() != ot.GetType()) => check_target(tr, p, j, nt, a)
    //        | ((nt, a), _, _)                                    => (nt, a)
    //      }
    //    }

    //    def check_node(p, n, a)
    //    {
    //      //def to = check_change(null, p, n, n.to);
    //      def to = n.to;
    //      match (check_target(null, p, n, to, a))
    //      {
    //       | (nto, a) when (nto : object != to) => (n.ChangeTo(nto), a)
    //       | (_, a) => (n, a)
    //      }
    //    }

    //    def traverse(p, n, a)
    //    { // TODO: избежать лишних изменений
    //      n.FoldLeft(([], a), (n, (nl, a)) => {def (nn, na) = check_node(p, n, a); (nn :: nl, na) })
    //    }

    //    match (check_change(tr, p, j, t, a))
    //    {
    //      | (TransitionTarget.PseudoState(Merge(node = n)) as p, a) => def (n, a) = check_node(p, n, a); 
    //          (p.ChangeNode(n), a)
    //      | (PseudoState(Junction(nodes = n) as j) as p, a) => 
    //         def (n, a) = traverse(p, n, a);
    //         (p.ChangeNode(j.ChangeNodes(n)), a)   // TODO: проверить как часто создается и зачем

    //      | (PseudoState(Choice(nodes = n) as c) as p, a)   => 
    //         def (n, a) = traverse(p, n, a);
    //         (p.ChangeNode(c.ChangeNodes(n)), a)

    //      | x => x

    //    }

    //  }

    //  check_target(this, null, null, this, analyser)
    //}

    //public Traverse(func : TransitionTarget -> TransitionTarget) : TransitionTarget
    //{
    //  //def check_pseudo(p, pt)
    //  //{
    //  //  //def check(t, on)
    //  //  //{
    //  //  //  match (t.Traverse(func))
    //  //  //  {
    //  //  //    //| x when (x : object != t) => 
    //  //  //  }
    //  //  //}

    //  //  match (p)
    //  //  {
    //  //    //| Merge as n => def nn = n.FoldThis((_, _, _, _, x) => x, 
    //  //    //                                    (_, _, _, _, x) => x, 
    //  //    //                                    (_, _, x) => x, 
    //  //    //                                    (t, _, x) => x, 
    //  //    //                                    (_, t, _, _, _, x) => check(t, x), 
    //  //    //                                    x => x, 
    //  //    //                                    x => x,
    //  //    //                                    x => x, 
    //  //    //                                    (_, _, _, t, x) => x);

    //  //    //| oState(Junction(nodes = n) as j) as p, a) => 
    //  //       //def (n, a) = traverse(p, n, a);
    //  //       //(p.ChangeNode(j.ChangeNodes(n)), a)   // TODO: проверить как часто создается и зачем

    //  //    //| (PseudoState(Choice(nodes = n) as c) as p, a)   => 
    //  //      // def (n, a) = traverse(p, n, a);
    //  //      // (p.ChangeNode(c.ChangeNodes(n)), a)
    //  //  }
    //  //}

    //  FoldThis(check_pseudo, (_, x) => x, (_, x) => x, (_, x) => x, (_, _, x) => x, (_, _, x) => x, (_, _, x) => x)
    //}

    public SetCopy(ncopy : int) : TransitionTarget
    {
      //def inc(t, an)
      //{
      //  match (t)
      //  {
      //    | PseudoState(n)    as p => def t = n.SetCopy(ncopy);
      //                                p.ChangeNode(t)
      //    | x                      => x
      //  }
      //}
// t.ChangeNode(x.SetCopy(ncopy))
      FoldThis((_, t) => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
               (_, t) => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
               t => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
               null, 
               null, 
               null, 
               null,
               null, 
               null, 
               null)
      //Traverse(an, inc)
    }
    //[RecordIgnore] 
    //[Accessor]
    //clone_for : TransitionTarget;

    public FoldThis(merge    : TransitionTarget * TransitionTarget.PseudoState -> TransitionTarget,
                    junction : TransitionTarget * TransitionTarget.PseudoState -> TransitionTarget,
                    pseudo : PseudoState -> TransitionTarget, 
                    hist : History -> TransitionTarget, 
                    final : TransitionTarget.Final -> TransitionTarget, 
                    state : TransitionTarget.State -> TransitionTarget,
                    named : Named -> TransitionTarget,
                    machine : TransitionTarget.SubMachine -> TransitionTarget,
                    qual : TransitionTarget * Qualified -> TransitionTarget,
                    junc_node : TransitionTarget * option[TransitionTarget] * JunctionNode -> TransitionTarget
                    ) : TransitionTarget
    {
      def xnode(n, nt, njt, nn : TransitionTarget, ot)
      {
        def n = n ?? ot;
        match (n)
        {
          | Qualified as t                                              => t.ChangeTarget(nt)
          | PseudoState(Merge as p) as t                                => t.ChangeNode(p.ChangeTo(njt))
          | PseudoState(Junction as p) as t                             => t.ChangeNode(p.ChangeTo(njt))
          | JunctionNode as t                                           => t.ChangeNextTo(if (nn != null) Some(nn :> JunctionNode) else None(), nt)
          | x                                                           => x
        }
      }

      def stack = SCG.Stack();
      
      def loop(e, _)
      {
        match (e)
        {
          | PseudoState(Merge as p) as t            => def tacc = stack.Pop();
                                                       def acc = if (merge != null) xnode(merge(tacc, t), tacc, null, null, t) else t.ChangeNode(p.ChangeTo(tacc :> JunctionNode));
                                                       stack.Push(acc);
                                                       acc
          | PseudoState(Junction as p) as t         => def tacc = stack.Pop();
                                                       def acc = if (merge != null) xnode(junction(tacc, t), tacc, null, null, t) else t.ChangeNode(p.ChangeTo(tacc :> JunctionNode));
                                                       stack.Push(acc);
                                                       acc
          | PseudoState      as t                   => def acc = if (pseudo != null) xnode(pseudo(t), null, null, null, t) else t;
                                                       stack.Push(acc);
                                                       acc 
          | History          as t                   => def acc = if (hist != null) xnode(hist(t), null, null, null, t) else t;
                                                       stack.Push(acc);
                                                       acc
          | Final            as t                   => def acc = if (final != null) xnode(final(t), null, null, null, t) else t;
                                                       stack.Push(acc);
                                                       acc
          | State            as t                   => def acc = if (state != null) xnode(state(t), null, null, null, t) else t;
                                                       stack.Push(acc);
                                                       acc
          | Named            as t                   => def acc = if (named != null) xnode(named(t), null, null, null, t) else t;
                                                       stack.Push(acc);
                                                       acc
          | SubMachine       as t                   => def acc = if (machine != null) xnode(machine(t), null, null, null, t) else t;
                                                       stack.Push(acc);
                                                       acc
          | Qualified as t                          => def tacc = stack.Pop();
                                                       def acc = if (qual != null) xnode(qual(tacc, t), null, null, null, t) else t.ChangeTarget(tacc);
                                                       stack.Push(acc);
                                                       acc
          | JunctionNode(next = Some()) as  t       => def toacc = stack.Pop();
                                                       def nacc = stack.Pop();
                                                       def acc = if (junc_node != null) xnode(junc_node(toacc, Some(nacc), t), toacc, null, nacc, t) else t.ChangeNextTo(Some(nacc :> JunctionNode), toacc);
                                                       stack.Push(acc);
                                                       acc
          | JunctionNode as t                       => def toacc = stack.Pop();
                                                       def acc = if (junc_node != null) xnode(junc_node(toacc, None(), t), toacc, null, null, t) else t.ChangeTo(toacc);
                                                       stack.Push(acc);
                                                       acc
        }
      }

      Iterator.FoldLeft(null, loop)
    }

    public Fold[T](init : T,
                   merge    : T * TransitionTarget.PseudoState -> T,
                   junction : T * TransitionTarget.PseudoState -> T,
                   pseudo : PseudoState -> T, 
                   hist : History -> T, 
                   final : TransitionTarget.Final -> T, 
                   state : TransitionTarget.State -> T,
                   named : Named -> T,
                   machine : TransitionTarget.SubMachine -> T,
                   qual : T * Qualified -> T,
                   junc_node : T * option[T] * JunctionNode -> T
                   ) : T
    {
      def stack : SCG.Stack[T] = SCG.Stack();
      
      def loop(e, _) : T
      {
        match (e)
        {
          | PseudoState(Merge) as t                 => def tacc = stack.Pop();
                                                       def acc = merge(tacc, t);
                                                       stack.Push(acc);
                                                       acc
          | PseudoState(Junction) as t              => def tacc = stack.Pop();
                                                       def acc = junction(tacc, t);
                                                       stack.Push(acc);
                                                       acc
          | PseudoState      as t                   => def acc = pseudo(t);
                                                       stack.Push(acc);
                                                       acc 
          | History          as t                   => def acc = hist(t);
                                                       stack.Push(acc);
                                                       acc
          | Final            as t                   => def acc = final(t);
                                                       stack.Push(acc);
                                                       acc
          | State            as t                   => def acc = state(t);
                                                       stack.Push(acc);
                                                       acc
          | Named            as t                   => def acc = named(t);
                                                       stack.Push(acc);
                                                       acc
          | SubMachine       as t                   => def acc = machine(t);
                                                       stack.Push(acc);
                                                       acc
          | Qualified as t                          => def tacc = stack.Pop();
                                                       def acc = qual(tacc, t);
                                                       stack.Push(acc);
                                                       acc
          | JunctionNode(next = Some()) as  t       => def toacc = stack.Pop();
                                                       def nacc = stack.Pop();
                                                       def acc = junc_node(toacc, Some(nacc), t);
                                                       stack.Push(acc);
                                                       acc
          | JunctionNode as t                       => def toacc = stack.Pop();
                                                       def acc = junc_node(toacc, None(), t);
                                                       stack.Push(acc);
                                                       acc
        }
      }

      Iterator.FoldLeft(init, loop)
    }

    public Fold[T](init : T,
                   merge    : T * TransitionTarget.PseudoState -> T,
                   junction : T * TransitionTarget.PseudoState -> T,
                   pseudo : T * PseudoState -> T, 
                   hist : T * History -> T, 
                   final : T * TransitionTarget.Final -> T, 
                   state : T * TransitionTarget.State -> T,
                   named : T * Named -> T,
                   machine : T * TransitionTarget.SubMachine -> T,
                   qual : T * Qualified -> T,
                   junc_node : T * JunctionNode -> T
                   ) : T
    {
      def loop(e, acc)
      {
        match (e)
        {
          | PseudoState(Merge) as t            => if (merge != null) merge(acc, t) else acc
          | PseudoState(Junction) as t         => if (junction != null) junction(acc, t) else acc
          | PseudoState      as t              => if (pseudo != null) pseudo(acc, t) else acc
          | History          as t              => if (hist != null) hist(acc, t) else acc
          | Final            as t              => if (final != null) final(acc, t) else acc
          | State            as t              => if (state != null) state(acc, t) else acc
          | Named            as t              => if (named != null) named(acc, t) else acc
          | SubMachine       as t              => if (machine != null) machine(acc, t) else acc
          | Qualified as t                     => if (qual != null) qual(acc, t) else acc
          | JunctionNode(next = Some()) as  t  => if (junc_node != null) junc_node(acc, t) else acc
          | JunctionNode as t                  => if (junc_node != null) junc_node(acc, t) else acc
        }
      }

      Iterator.FoldLeft(init, loop)
    }

    public FoldThis(an : FsmAnalyser,
                    merge    : TransitionTarget * PseudoState * FsmAnalyser -> TransitionTarget * FsmAnalyser,
                    junction : TransitionTarget * PseudoState * FsmAnalyser -> TransitionTarget * FsmAnalyser,
                    pseudo   : PseudoState * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    hist     : History * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    final    : TransitionTarget.Final * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    state    : TransitionTarget.State * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    named    : Named * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    machine  : TransitionTarget.SubMachine * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    qual     : TransitionTarget * Qualified * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    junc_node : TransitionTarget * option[TransitionTarget] * JunctionNode * FsmAnalyser -> TransitionTarget * FsmAnalyser
                    ) : TransitionTarget * FsmAnalyser
    {
      def xnode((n, an), nt, njt, nn : TransitionTarget, ot)
      {
        def n = n ?? ot;
        def n = match (n)
        {
          | TransitionTarget.Qualified as t                             => t.ChangeTarget(nt)
          | PseudoState(Merge as p) as t                                => t.ChangeNode(p.ChangeTo(njt))
          | PseudoState(Junction as p) as t                             => t.ChangeNode(p.ChangeTo(njt))
          | JunctionNode as t                                           => t.ChangeNextTo(if (nn != null) Some(nn :> JunctionNode) else None(), nt)
          | x                                                           => x
        }
        (n, an)
      }

      def stack = SCG.Stack();
      
      def loop(e, an)
      {
        match (e)
        {
          | PseudoState(Merge as p) as t            => def tacc = stack.Pop();
                                                       def (acc, an) = if (merge != null)  xnode(merge(tacc, t, an), tacc, null, null, t) else (t.ChangeNode(p.ChangeTo(tacc :> JunctionNode)), an);
                                                       stack.Push(acc);
                                                       an
          | PseudoState(Junction as p) as t         => def tacc = stack.Pop();
                                                       def (acc, an) = if (merge != null)  xnode(junction(tacc, t, an), tacc, null, null, t) else (t.ChangeNode(p.ChangeTo(tacc :> JunctionNode)), an);
                                                       stack.Push(acc);
                                                       an
          | PseudoState      as t                   => def (acc, an) = if (pseudo != null) xnode(pseudo(t, an), null, null, null, t) else (t, an);
                                                       stack.Push(acc);
                                                       an 
          | History          as t                   => def (acc, an) = if (hist != null) xnode(hist(t, an), null, null, null, t) else (t, an);
                                                       stack.Push(acc);
                                                       an 
          | Final            as t                   => def (acc, an) = if (final != null) xnode(final(t, an), null, null, null, t) else (t, an);
                                                       stack.Push(acc);
                                                       an 
          | State            as t                   => def (acc, an) = if (state != null) xnode(state(t, an), null, null, null, t) else (t, an);
                                                       stack.Push(acc);
                                                       an
          | Named            as t                   => def (acc, an) = if (named != null) xnode(named(t, an), null, null, null, t) else (t, an);
                                                       stack.Push(acc);
                                                       an
          | SubMachine       as t                   => def (acc, an) = if (machine != null) xnode(machine(t, an), null, null, null, t) else (t, an);
                                                       stack.Push(acc);
                                                       an
          | Qualified as t                          => def tacc = stack.Pop();
                                                       def (acc, an) = if (qual != null) xnode(qual(tacc, t, an), null, null, null, t) else (t, an);
                                                       stack.Push(acc);
                                                       an
          | JunctionNode(next = Some()) as  t       => def toacc = stack.Pop();
                                                       def nacc = stack.Pop();
                                                       def (acc, an) = if (junc_node != null) xnode(junc_node(toacc, Some(nacc), t, an), toacc, null, nacc, t) else (t, an);
                                                       stack.Push(acc);
                                                       an
          | JunctionNode as t                       => def toacc = stack.Pop();
                                                       def (acc, an) = if (junc_node != null) xnode(junc_node(toacc, None(), t, an), toacc, null, null, t) else (t, an);
                                                       stack.Push(acc);
                                                       an
        }
      }

      def an = Iterator.FoldLeft(an, loop);
      def acc = stack.Pop();
      (acc, an)
    }

    public Iterator : IEnumerable[TransitionTarget]
    {
      get
      {
        def child = SCG.Stack();
        def parent = SCG.Stack();

        def loop()
        {
          if (child.IsEmpty()) () else 
          {
            def curr = child.Pop();
            parent.Push(curr);
            match (curr)
            {
              | JunctionNode(to = to, next = Some(n)) => child.Push(to);
                                                         child.Push(n);
              | PseudoState(Merge(to = n))
              | PseudoState(Junction(to = n))
              | JunctionNode(to =  n)
              | Qualified(_, n)                       => child.Push(n)
              | _                                     => ()
            }
            loop()
          }
        }

        child.Push(this);
        loop();
        parent
      }
    }

    public virtual UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
    {
      (this, an)
    }

  }


}
