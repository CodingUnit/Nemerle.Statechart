using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;


namespace Nemerle.Statechart
{
  using PseudoStateModelNode;
  using FsmState;
  using PseudoStateNode;
  using ListUtils;

  public enum TransitionKind
  {
    | Normal
    | History
  }
  //[Traversable(All)]
  [Record]
  public partial variant TransitionTarget
  {
    //[TraverseIgnore]
    | Nowhere

    | Final
      {
        [NeedChange]
        state : FsmState;
      }
      
    | PseudoState
      {
        [NeedChange]
        node : PseudoStateNode;

        this(tran : StateTransition, st : FsmState, node : TargetType.PseudoState)
        {
          //base(st.analyser);
          def st = if (tran != null) 
          {
            if (tran.Local) st else st.Super
          } else st;
          this.node = PseudoStateNode.Create(st, node.node);
        }

      }
      
    | State 
      {
        [NeedChange]
        state : FsmState;

        //Name : string
        //{
        //  get
        //  {
        //    $"$state"
        //  }
        //}

        
      }

    | Named
      {
        state : FsmState;
        name  : string;

        this(st : FsmState, type : TargetType.Named)
        {
          //base(st.analyser);
          state = st;//CreateState(type.parent, [], null);
          name = type.name;
        }

      }

    | Qualified 
      {
        parent : string;
        [NeedChange] target : TransitionTarget;

      }
      
    //| SubMachine 
    //  {
    //    [NeedChange] machine : FsmState;//ReferenceNode[FsmState.SubMachine];
        
    //    state : string;

    //    override ToString() : string
    //    {
    //      $"$(machine).$state"
    //    }

    //  }
    //| JunctionNode
    //  {
    //    [NeedChange] to           : TransitionTarget;
    //    //parent                    : PseudoStateNode;
    //    [NeedChange(to)] next     : option[JunctionNode];
    //    //[NeedChange] state        : FsmState;
    //    [NeedChange] decisionTree : DecisionNode;
        
    //    type                      : JunctionType;
        
    //    Actions : IEnumerable[PathNode]
    //    {
    //      get
    //      {
    //        decisionTree.ActionNode
    //      }
    //    }
        
    //    public static Create(st : FsmState, to : TargetType.JunctionNode) : JunctionNode
    //    {
    //      def an = st.analyser;
    //      match (to)
    //      {
    //        | TargetType.JunctionNode(g, a, t, n) => JunctionNode(an, g, a, Create(st, t), n.Map(Create(st, _)), null, JunctionType.Junction)
    //      } 
    //    }

    //    //Guards : list[GuardNode]
    //    //{
    //    //  get
    //    //  {
    //    //    to.Fold([guard], null, null, null, null, null, null, null, null, null, (a, t) => t.guard :: a)
    //    //    //def g = match (to)
    //    //    //         {
    //    //    //           | TransitionTarget.PseudoState(Merge(to = TransitionTarget.JunctionNode(Guards = g)))
    //    //    //           | TransitionTarget.PseudoState(Junction(Guards = g)) => g.NToList()
    //    //    //           | _                                                  => []
    //    //    //         }
    //    //    //guard :: g//guard :: g
    //    //  }
    //    //}

    //    //override UpdateReference() : TransitionTarget
    //    //{
    //    //  def nto = to.UpdateReference();
    //    //  ChangeTo(nto)
    //    //}

    //    public GetName(state : FsmState) : string
    //    {
    //        $"JunctionNode$state"
    //    }
        
    //    override ToString() : string
    //    {
    //      $"$(type) JunctionNode [$guard] / $action => $to"
    //    }
        
    //  }


  }


}
