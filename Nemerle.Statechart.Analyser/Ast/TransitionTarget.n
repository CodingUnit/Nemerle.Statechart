using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using PseudoStateAstNode;
  using FsmState;
  using PseudoStateNode;
  using ListUtils;

  [Traversable(All)]
  [Record]
  public partial variant TransitionTarget
  {
    | History 
      {
        [NeedChange] history : StateHistory;

        override UpdateReference() : TransitionTarget
        {
          if (history.reference) 
          {
            def st = StateMap.Get(history.state.Name);
            if (st != null) ChangeHistory(st.GetHistory(history)) else this;
          } else this
        }

        override ToString() : string
        {
          $"$(history.state)History"
        }

        this(st : FsmState, type : TargetType.History)
        {
          base(st.analyser);
          history = StateHistory.Create(st, type.history, true)
        }
      }
    | Final
      {
        [NeedChange] state : FsmState.Final;

        override ToString() : string
        {
          $"$(state)"
        }

        public override UpdateReference() : TransitionTarget
        {
          if (state != null) 
          {
            def st = StateMap.Get(state.NativeName);
            if (st != null) ChangeState(st :> FsmState.Final) else this;
          } else this
        }
      }
    [Traverse(junction(node = PseudoStateNode.Junction(_)))]
    [Traverse(merge(node = PseudoStateNode.Merge(_)))]
    | PseudoState
      {
        [NeedChange] node : PseudoStateNode;

        this(st : FsmState, node : TargetType.PseudoState)
        {
          base(st.analyser);
          this.node = PseudoStateNode.Create(st.analyser, node.node, st);
        }

        override UpdateReference() : TransitionTarget
        {
          ChangeNode(node.UpdateReference())
        }

        override ToString() : string
        {
          node.ToString()
        }
      }
      
    | State 
      {
        [NeedChange] state : FsmState;

        override UpdateReference() : TransitionTarget
        {
          def st = StateMap.Get(state.Name);
          if (st != null) ChangeState(st) else this
        }

        Name : string
        {
          get
          {
            state.Name
          }
        }

        override ToString() : string
        {
          state.ToString()
        }

        this(an : FsmAnalyser, type : TargetType.State)
        {
          base(an);
          state = FsmState.State(type.state, null, an, true);
        }

      }

    | Named
      {
        [NeedChange] state : FsmState;
        name : string;

          // TODO: вообще могут быть ссылки null если все immutable
        override UpdateReference() : TransitionTarget
        {
          if (state != null) 
          {
            def st = StateMap.Get(state.Name);
            if (st != null) ChangeState(st) else this;
          } else this
        }

        Name : string
        {
          get
          {
            $"Named$state.$name"
          }
        }

        override ToString() : string
        {
          Name
        }

        this(st : FsmState, type : TargetType.Named)
        {
          base(st.analyser);
          state = st;//CreateState(type.parent, [], null);
          name = type.name;
        }

      }

    | Qualified 
      {
        parent : string;
        [NeedChange] target : TransitionTarget;

        override UpdateReference() : TransitionTarget
        {
          match (target)
          {
            | State(st) as t => 
                def st = StateMap.Get($"$parent.$(st.NativeName)");
                if (st != null) t.ChangeState(st) else this;
                
            | _ => target.UpdateReference()
          }
        }

        override ToString() : string
        {
          $"$parent.$target"
        }

      }
    | SubMachine 
      {
        [NeedChange] machine : FsmState.SubMachine;
        state : string;

        override UpdateReference() : TransitionTarget
        {
          match (machine)
          {
            | FsmState(Name = n) => 
                def st = StateMap.Get(n);
                if (st != null) ChangeMachine(st :> FsmState.SubMachine) else this;
          }
        }

        override ToString() : string
        {
          $"$machine.$state"
        }

      }
    | JunctionNode
      {
        guard                 : GuardNode;
        action                : option[Actions] = None();
        [NeedChange] to       : TransitionTarget;
        parent                : PseudoStateNode;
        [NeedChange(to)] next : option[JunctionNode];
        [NeedChange] state    : FsmState;

        [NeedChange] decisionTree : DecisionNode;
        
        type                  : JunctionType;
        
        Actions : IEnumerable[PathNode]
        {
          get
          {
            decisionTree.ActionNode
          }
        }
        
        public static Create(an : FsmAnalyser, st : FsmState, par : PseudoStateNode, to : TargetType.JunctionNode) : JunctionNode
        {
          match (to)
          {
            | TargetType.JunctionNode(g, a, t, n) => JunctionNode(an, g, a, Create(an, st, t), par, n.Map(x => Create(an, st, par, x)), st, null, JunctionType.Junction)
          } 
        }

        //Guards : list[GuardNode]
        //{
        //  get
        //  {
        //    to.Fold([guard], null, null, null, null, null, null, null, null, null, (a, t) => t.guard :: a)
        //    //def g = match (to)
        //    //         {
        //    //           | TransitionTarget.PseudoState(Merge(to = TransitionTarget.JunctionNode(Guards = g)))
        //    //           | TransitionTarget.PseudoState(Junction(Guards = g)) => g.NToList()
        //    //           | _                                                  => []
        //    //         }
        //    //guard :: g//guard :: g
        //  }
        //}

        override UpdateReference() : TransitionTarget
        {
          def nto = to.UpdateReference();
          ChangeTo(nto)
        }

        override ToString() : string
        {
          $"JunctionNode$state"
        }
      }


  }


}
