using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using PseudoStateAstNode;
  using FsmState;
  using PseudoStateNode;
  using ListUtils;

  [Record]
  public variant TransitionTarget
  {
    | History 
      {
        [NeedChange] history : StateHistory;

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          if (history.reference) 
          {
            def (st, an) = an.statemap.Get(history.state.Name, an);
            def tar = if (st != null) ChangeHistory(st.GetHistory(history)) else this;
            (tar, an)
          } else (this, an)
        }

        override ToString() : string
        {
          $"$(history.state)History"
        }

        this(tran : StateTransition, st : FsmState, type : TargetType.History)
        {
          base(tran);
          history = StateHistory.Create(st, type.history, true)
        }
      }
    | Final
      {
        [NeedChange] state : FsmState.Final;

        override ToString() : string
        {
          $"$(state)"
        }

        this(tran : StateTransition)
        {
          base(tran)
        }

        public override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          if (state != null && state.reference) 
          {
            def (st, an) = an.statemap.Get(state.NativeName, an);
            def tar = if (st != null) ChangeState(st :> FsmState.Final) else this;
            (tar, an)
          } else (this, an)
        }
      }
    | PseudoState
      {
        [NeedChange] node : PseudoStateNode;

        this(tran : StateTransition, st : FsmState, node : TargetType.PseudoState)
        {
            //def init_target(t)
            //{
            //  //t.transition = tran
            //}

          base(tran);
          this.node = PseudoStateNode.Create(node.node, st, transition);
            //Traverse(init_target)
        }

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          def (n, an) = node.UpdateReference(an);
          def tar = if (n != node : object) PseudoState(transition, n) else this;
          (tar, an)
        }

        override ToString() : string
        {
          node.ToString()
        }
      }
    | State 
      {
        [NeedChange] state : FsmState;

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {

          if (state.reference) 
          {
            def map = an.statemap;
            def (st, an) = map.Get(state.Name, an);
            def tar =  if (st != null) ChangeState(st) else this;
            (tar, an)
          } else (this, an)
        }

        Name : string
        {
          get
          {
            state.Name
          }
        }

        override ToString() : string
        {
          state.ToString();
        }

        this(tran : StateTransition, type : TargetType.State)
        {
          base(tran);
          state = FsmState.State(type.state, null, true);
        }

      }

    | Named
      {
        [NeedChange] state : FsmState;
        name : string;

          // TODO: вообще могут быть ссылки null если все immutable
        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          if (state != null && state.reference) 
          {
            def map = an.statemap;
            def (st, an) = map.Get(state.Name, an);
            def tar = if (st != null) ChangeState(st) else this;
            (tar, an)
          } else (this, an)
        }

        Name : string
        {
          get
          {
            $"Named$state.$name"
          }
        }

        override ToString() : string
        {
          Name
        }

        this(tran : StateTransition, st : FsmState, type : TargetType.Named)
        {
          base(tran);
          state = CreateState(type.parent, st);
          name = type.name;
        }

      }

    | Qualified 
      {
        parent : string;
        [NeedChange] target : TransitionTarget;

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          def map = an.statemap;
          match (target)
          {
            | State(st) as t when (st.reference) => 
                def (st, an) = map.Get($"$parent.$(st.NativeName)", an);
                def tar = if (st != null) t.ChangeState(st) else this;
                (tar, an)
            | _ => target.UpdateReference(an)
          }
        }

        override ToString() : string
        {
          $"$parent.$target"
        }

      }
    | SubMachine 
      {
        [NeedChange] machine : FsmState.SubMachine;
        state : string;

        override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {
          match (machine)
          {
            | FsmState where (reference = true, Name = n) => 
                def (st, an) = an.statemap.Get(n, an);
                def tar = if (st != null) ChangeMachine(st :> FsmState.SubMachine) else this;
                (tar, an)
            | _ => (this, an)
          }
        }

        override ToString() : string
        {
          $"$machine.$state"
        }

      }
    | JunctionNode
      {
        guard : option[GuardNode];
        action : option[Actions];
        [NeedChange] to : TransitionTarget;
        parent : PseudoStateNode;
        [NeedChange(to)] next : option[JunctionNode];
        state : FsmState;

        public static Create(st : FsmState, par : PseudoStateNode, to : TargetType.JunctionNode, tran : StateTransition) : JunctionNode
        {
          match (to)
          {
           | TargetType.JunctionNode(g, a, t, n) => JunctionNode(tran, g, a, Create(st, tran, t), par, n.Map(x => Create(st, par, x, tran)), st)
          } 
        }
        
        Guards : list[GuardNode]
        {
          get
          {
            def g = match (to)
                     {
                       | TransitionTarget.PseudoState(Merge(to = TransitionTarget.JunctionNode(Guards = g)))
                       | TransitionTarget.PseudoState(Junction(Guards = g)) => g
                       | _ => []
                     }
            guard %:: g
          }
        }

        public UpdateRef(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {   
          def (nto, an) = to.UpdateReference(an);
          def (st, an) = base.UpdateReference(an);
          def st = match (st)
                    {
                      | JunctionNode as j when (j : object != this || nto : object != to) => j.ChangeTo(nto)//JunctionNode(st, copy, guard, action, nto, parent)
                      | _                                                                 => this
                    }
          (st, an)
        }

        public override UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
        {   
          UpdateRef(an);
        }
      }

    public static Create(state : FsmState, tran : StateTransition, target : TargetType) : TransitionTarget
    {
      match (target)
      {
        | PseudoState as t                  => PseudoState(tran, state, t)
        | History     as t                  => History(tran, state, t)
        | Final                             => Final(tran)
        | State       as t                  => State(tran, t)
        | Named       as t                  => Named(tran, state, t)
        | SubMachine(m, s)                  => SubMachine(tran, SubMachine(m, null), s)
        | Qualified(parent = p, target = t) => Qualified(tran, p, Create(state, tran, t))
      }
    }

    public CompareTo(target : TransitionTarget) : int
    {
      CompareTo(this, target)
    }

    public static CompareTo(t1 : TransitionTarget, target : TransitionTarget) : int
    {
      | (History(h1), History(h2))                            => h1.Name.CompareTo(h2.Name)
      | (Final(st1), Final(st2))                              => st1.Name.CompareTo(st2.Name)
      | (PseudoState(n1), PseudoState(n2))                    => n1.ToString().CompareTo(n2.ToString())
      | (State(st1), State(st2))                              => st1.Name.CompareTo(st2.Name)
      | (SubMachine(m, s), SubMachine(m2, s2)) when (m == m2) => s.CompareTo(s2)
      | _                                                     => -1
    }

    public static @==(a : TransitionTarget, b : TransitionTarget) : bool
    {
      | (History(h1), History(h2))             => h1 == h2
      | (State(st1), State(st2))
      | (Final(st1), Final(st2))               => st1 == st2
      | (PseudoState(n1), PseudoState(n2))     => n1 == n2
      | (Named(st, n), Named(st2, n2))         => st == st2 && n == n2
      | (Qualified(p, t), Qualified(p2, t2))   => p == p2 && t == t2
      | (SubMachine(m, s), SubMachine(m2, s2)) => m == m2 && s == s2
      | _                                      => false
    }

    public PartOfSubRegion : option[ConcurrentSubRegion]
    {
      get
      {
        match (ToState)
        {
          | null => None()
          | ConcurrentSubRegion as st => Some(st)
          | st => st.PartOfSubRegion
        }
      }
    }

    public ToState : FsmState
    {
      get
      {
        match (this)
        {
          | PseudoState(PseudoStateNode where (state = st))
          | History(StateHistory where (state = st))
          | Final(state = st)
          | SubMachine(st, _)
          | State(state = st)  => st
          | Named              => null
          | Qualified(_, t)    => t.ToState
        }
      }
    }

    //public Clone(ncopy : int = 0) : TransitionTarget
    //{
    //  def tar = match (this)
    //  {
    //    | PseudoState(node = n, transition = t)               => PseudoState(t, n.Clone(ncopy))
    //    | History(transition = t, history = h)                => History(t, h)
    //    | Final(state = st, transition = t)                   => Final(t, st)
    //    | SubMachine(machine = m, state = st, transition = t) => SubMachine(t, m, st)
    //    | State(state = st, transition = t)                   => State(t, st)
    //    | Named(state = st, transition = t, name = n)         => Named(t, st, n)
    //    | Qualified(transition = tr, parent = p, target = t)  => Qualified(tr, p, t.Clone(ncopy))
    //  }
    //  tar.clone_for = this;
    //  tar
    //}

    public transition : StateTransition;

    //public Traverse(analyser : FsmAnalyser, func : TransitionTarget * FsmAnalyser -> TransitionTarget * FsmAnalyser) : TransitionTarget * FsmAnalyser
    //{
    //  def check_target(tr, p, j, t, a)
    //  {

    //    def check_change(tr, p, j, ot, a)
    //    {
    //      match (func(ot, a), tr, j)
    //      {
    //        | ((null, a), _, _)                                  => (ot, a)
    //        | ((nt, a), _, null) when (nt.GetType() != ot.GetType()) => check_target(tr, p, j, nt, a)
    //        | ((nt, a), _, _)                                    => (nt, a)
    //      }
    //    }

    //    def check_node(p, n, a)
    //    {
    //      //def to = check_change(null, p, n, n.to);
    //      def to = n.to;
    //      match (check_target(null, p, n, to, a))
    //      {
    //       | (nto, a) when (nto : object != to) => (n.ChangeTo(nto), a)
    //       | (_, a) => (n, a)
    //      }
    //    }

    //    def traverse(p, n, a)
    //    { // TODO: избежать лишних изменений
    //      n.FoldLeft(([], a), (n, (nl, a)) => {def (nn, na) = check_node(p, n, a); (nn :: nl, na) })
    //    }

    //    match (check_change(tr, p, j, t, a))
    //    {
    //      | (TransitionTarget.PseudoState(Merge(node = n)) as p, a) => def (n, a) = check_node(p, n, a); 
    //          (p.ChangeNode(n), a)
    //      | (PseudoState(Junction(nodes = n) as j) as p, a) => 
    //         def (n, a) = traverse(p, n, a);
    //         (p.ChangeNode(j.ChangeNodes(n)), a)   // TODO: проверить как часто создается и зачем

    //      | (PseudoState(Choice(nodes = n) as c) as p, a)   => 
    //         def (n, a) = traverse(p, n, a);
    //         (p.ChangeNode(c.ChangeNodes(n)), a)

    //      | x => x

    //    }

    //  }

    //  check_target(this, null, null, this, analyser)
    //}

    //public Traverse(func : TransitionTarget -> TransitionTarget) : TransitionTarget
    //{
    //  //def check_pseudo(p, pt)
    //  //{
    //  //  //def check(t, on)
    //  //  //{
    //  //  //  match (t.Traverse(func))
    //  //  //  {
    //  //  //    //| x when (x : object != t) => 
    //  //  //  }
    //  //  //}

    //  //  match (p)
    //  //  {
    //  //    //| Merge as n => def nn = n.FoldThis((_, _, _, _, x) => x, 
    //  //    //                                    (_, _, _, _, x) => x, 
    //  //    //                                    (_, _, x) => x, 
    //  //    //                                    (t, _, x) => x, 
    //  //    //                                    (_, t, _, _, _, x) => check(t, x), 
    //  //    //                                    x => x, 
    //  //    //                                    x => x,
    //  //    //                                    x => x, 
    //  //    //                                    (_, _, _, t, x) => x);

    //  //    //| oState(Junction(nodes = n) as j) as p, a) => 
    //  //       //def (n, a) = traverse(p, n, a);
    //  //       //(p.ChangeNode(j.ChangeNodes(n)), a)   // TODO: проверить как часто создается и зачем

    //  //    //| (PseudoState(Choice(nodes = n) as c) as p, a)   => 
    //  //      // def (n, a) = traverse(p, n, a);
    //  //      // (p.ChangeNode(c.ChangeNodes(n)), a)
    //  //  }
    //  //}

    //  FoldThis(check_pseudo, (_, x) => x, (_, x) => x, (_, x) => x, (_, _, x) => x, (_, _, x) => x, (_, _, x) => x)
    //}

    public SetCopy(ncopy : int) : TransitionTarget
    {
      //def inc(t, an)
      //{
      //  match (t)
      //  {
      //    | PseudoState(n)    as p => def t = n.SetCopy(ncopy);
      //                                p.ChangeNode(t)
      //    | x                      => x
      //  }
      //}
// t.ChangeNode(x.SetCopy(ncopy))
      FoldThis((_, t) => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
               (_, t) => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
               t => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
               _ => null, 
               _ => null, 
               _ => null, 
               _ => null,
               _ => null, 
               _ => null, 
               _ => null)
      //Traverse(an, inc)
    }
    //[RecordIgnore] 
    //[Accessor]
    //clone_for : TransitionTarget;

    public FoldThis(merge    : TransitionTarget * TransitionTarget.PseudoState -> TransitionTarget,
                    junction : TransitionTarget * TransitionTarget.PseudoState -> TransitionTarget,
                    pseudo : PseudoState -> TransitionTarget, 
                    hist : History -> TransitionTarget, 
                    final : TransitionTarget.Final -> TransitionTarget, 
                    state : TransitionTarget.State -> TransitionTarget,
                    named : Named -> TransitionTarget,
                    machine : TransitionTarget.SubMachine -> TransitionTarget,
                    qual : TransitionTarget * Qualified -> TransitionTarget,
                    junc_node : TransitionTarget * option[TransitionTarget] * JunctionNode -> TransitionTarget
                    ) : TransitionTarget
    {
      def xnode(n, oot, nx, ot)
      {
        match (n)
        {
          | null 
          | x when (x : object == ot)                                              => ot
          | Qualified(_, nt)            as t when nt : object != oot             => t.ChangeTarget(t)
          | PseudoState(Merge(to = nt) as p) as t when nt : object != oot        => t.ChangeNode(p.ChangeTo(nt))
          | PseudoState(Junction(to = nt) as p) as t when nt : object != oot     => t.ChangeNode(p.ChangeTo(nt))
          | JunctionNode(to = nt, next = nn) as t 
                   when nt : object != oot || nx : object != nn                  => t.ChangeNextTo(nn, nt)
          | x                                                                    => x
        }
      }


      def loop(e, cont)
      {

        match (e)
        {
          | PseudoState(Merge(to = n) as p) as t    => loop(n, tacc => cont(xnode(merge(tacc, t), tacc, null, t)))
          | PseudoState(Junction(to = n) as p) as t => loop(n, tacc => cont(xnode(junction(tacc, t), tacc, null, t)))
          | PseudoState      as t                   => cont(xnode(pseudo(t), null, null, t))
          | History          as t                   => cont(xnode(hist(t), null, null, t))
          | Final            as t                   => cont(xnode(final(t), null, null, t))
          | State            as t                   => cont(xnode(state(t), null, null, t))
          | Named            as t                   => cont(xnode(named(t), null, null, t))
          | SubMachine       as t                   => cont(xnode(machine(t), null, null, t))
          | Qualified(_, tt) as t                   => loop(tt, tacc => cont(xnode(qual(tacc, t), tacc, null, t)))
          | JunctionNode(to = to, next = Some(n)) as t => loop(to, 
                                                                toacc => loop(n, 
                                                                              nacc => cont(xnode(junc_node(toacc, Some(nacc), t), toacc, nacc, t))))
          | JunctionNode(to = to)       as t           => loop(to, 
                                                               toacc => cont(xnode(junc_node(toacc, None(), t), toacc, null, t)))
        }
      }

      loop(this, x => x)
    }

    public Fold[T](
                  merge    : T * PseudoStateNode.Merge * TransitionTarget.PseudoState -> T,
                  junction : T * PseudoStateNode.Junction * TransitionTarget.PseudoState -> T,
                  pseudo   : PseudoStateNode * TransitionTarget.PseudoState -> T, 
                  hist     : StateHistory * TransitionTarget.History -> T, 
                  final    : FsmState.Final * TransitionTarget.Final -> T, 
                  state    : FsmState * TransitionTarget.State -> T,
                  named    : FsmState * string * TransitionTarget.Named -> T,
                  machine  : FsmState.SubMachine * string * TransitionTarget.SubMachine -> T,
                  qual     : string * T * TransitionTarget.Qualified -> T,
                  junc_node : option[GuardNode] * option[Actions] * T * PseudoStateNode * option[T] * FsmState * JunctionNode -> T
                  ) : T
    {      
      def loop(e, cont)
      {
        match (e)
        {
          | PseudoState(Merge(to = n) as p)       as t => loop(n, tacc => cont(merge(tacc, p, t)))
          | PseudoState(Junction(to = n) as p)    as t => loop(n, tacc => cont(junction(tacc, p, t)))
          | PseudoState(n)                        as t => cont(pseudo(n, t))
          | History(h)                            as t => cont(hist(h, t))
          | Final(s)                              as t => cont(final(s, t))
          | State(s)                              as t => cont(state(s, t))
          | Named(s, n)                           as t => cont(named(s, n, t))
          | SubMachine(m, s)                      as t => cont(machine(m, s, t))
          | Qualified(p, tt)                      as t => loop(tt, tacc => cont(qual(p, tacc, t)))
          | JunctionNode(g, a, to, p, Some(n), s) as t => loop(to, 
                                                                toacc => loop(n, 
                                                                              nacc => cont(junc_node(g, a, toacc, p, Some(nacc), s, t))))
          | JunctionNode(g, a, to, p, _, s)       as t => loop(to, 
                                                               toacc => cont(junc_node(g, a, toacc, p, None(), s, t)))
        }
      }

      loop(this, x => x)
    }

    //public Fold[T](
    //              init     : T,
    //              merge    : T * PseudoStateNode.Merge * TransitionTarget.PseudoState * T -> T,
    //              junction : T * PseudoStateNode.Junction * TransitionTarget.PseudoState * T -> T,
    //              pseudo   : PseudoStateNode * TransitionTarget.PseudoState * T -> T, 
    //              hist     : StateHistory * TransitionTarget.History * T -> T, 
    //              final    : FsmState.Final * TransitionTarget.Final * T -> T, 
    //              state    : FsmState * TransitionTarget.State * T -> T,
    //              named    : FsmState * string * TransitionTarget.Named -> T,
    //              machine  : FsmState.SubMachine * string * TransitionTarget.SubMachine -> T,
    //              qual     : string * T * TransitionTarget.Qualified -> T,
    //              junc_node : option[GuardNode] * option[Actions] * T * PseudoStateNode * option[T] * FsmState * JunctionNode -> T
    //              ) : T
    //{      
    //  def loop(e, cont)
    //  {
    //    match (e)
    //    {
    //      | PseudoState(Merge(to = n) as p)       as t => loop(n, tacc => cont(merge(tacc, p, t)))
    //      | PseudoState(Junction(to = n) as p)    as t => loop(n, tacc => cont(junction(tacc, p, t)))
    //      | PseudoState(n)                        as t => cont(pseudo(n, t))
    //      | History(h)                            as t => cont(hist(h, t))
    //      | Final(s)                              as t => cont(final(s, t))
    //      | State(s)                              as t => cont(state(s, t))
    //      | Named(s, n)                           as t => cont(named(s, n, t))
    //      | SubMachine(m, s)                      as t => cont(machine(m, s, t))
    //      | Qualified(p, tt)                      as t => loop(tt, tacc => cont(qual(p, tacc, t)))
    //      | JunctionNode(g, a, to, p, Some(n), s) as t => loop(to, 
    //                                                            toacc => loop(n, 
    //                                                                          nacc => cont(junc_node(g, a, toacc, p, Some(nacc), s, t))))
    //      | JunctionNode(g, a, to, p, _, s)       as t => loop(to, 
    //                                                           toacc => cont(junc_node(g, a, toacc, p, None(), s, t)))
    //    }
    //  }

    //  loop(this, x => x)
    //}
    
    public FoldThis(an : FsmAnalyser,
                    merge    : TransitionTarget * TransitionTarget.PseudoState * FsmAnalyser -> TransitionTarget * FsmAnalyser,
                    junction : TransitionTarget * TransitionTarget.PseudoState * FsmAnalyser -> TransitionTarget * FsmAnalyser,
                    pseudo   : PseudoState * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    hist     : History * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    final    : TransitionTarget.Final * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    state    : TransitionTarget.State * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    named    : Named * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    machine  : TransitionTarget.SubMachine * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    qual     : TransitionTarget * Qualified * FsmAnalyser -> TransitionTarget * FsmAnalyser, 
                    junc_node : TransitionTarget * option[TransitionTarget] * JunctionNode * FsmAnalyser -> TransitionTarget * FsmAnalyser
                    ) : TransitionTarget * FsmAnalyser
    {
      def xnode((n, an), oot, nx, ot)
      {
        def n = match (n)
        {
          | null 
          | x when (x : object == ot)                                              => ot
          | Qualified(_, nt)            as t when nt : object != oot             => t.ChangeTarget(t)
          | PseudoState(Merge(to = nt) as p) as t when nt : object != oot        => t.ChangeNode(p.ChangeTo(nt))
          | PseudoState(Junction(to = nt) as p) as t when nt : object != oot     => t.ChangeNode(p.ChangeTo(nt))
          | JunctionNode(to = nt, next = nn) as t 
                   when nt : object != oot || nx : object != nn                  => t.ChangeNextTo(nn, nt)
          | x                                                                    => x
        }
        (n, an)
      }


      def loop(e, an, cont)
      {

        match (e)
        {
          | PseudoState(Merge(to = n) as t          => loop(n, an, (tacc, an) => cont(xnode(merge(tacc, t, an), tacc, null, t)))
          | PseudoState(Junction(to = n)) as t      => loop(n, an, (tacc, an) => cont(xnode(junction(tacc, t, an), tacc, null, t)))
          | PseudoState      as t                   => cont(xnode(pseudo(t, an), null, null, t))
          | History          as t                   => cont(xnode(hist(t, an), null, null, t))
          | Final            as t                   => cont(xnode(final(t, an), null, null, t))
          | State            as t                   => cont(xnode(state(t, an), null, null, t))
          | Named            as t                   => cont(xnode(named(t, an), null, null, t))
          | SubMachine       as t                   => cont(xnode(machine(t, an), null, null, t))
          | Qualified(_, tt) as t                   => loop(tt, an, (tacc, an) => cont(xnode(qual(tacc, t, an), tacc, null, t)))
          | JunctionNode(to = to, next = Some(n)) as t => loop(to, an,
                                                                (toacc, an) => loop(n, an,
                                                                               (nacc, an) => cont(xnode(junc_node(toacc, Some(nacc), t, an), toacc, nacc, t))))
          | JunctionNode(to =  to)                as t => loop(to, an,
                                                               (toacc, an) => cont(xnode(junc_node(toacc, None(), t, an), toacc, null, t)))
        }
      }

      loop(this, an, x => x)
    }
    
    public virtual UpdateReference(an : FsmAnalyser) : TransitionTarget * FsmAnalyser
    {
      (this, an)
    }

  }


}
