using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using PseudoStateAstNode;
  using FsmState;
  using PseudoStateNode;
  using ListUtils;

  [Traversable(All)]
  [Record]
  public variant TransitionTarget
  {
    | History 
      {
        [NeedChange] history : StateHistory;

        override UpdateReference() : TransitionTarget
        {
          if (history.reference) 
          {
            def st = StateMap.Get(history.state.Name);
            def tar = if (st != null) ChangeHistory(st.GetHistory(history)) else this;
            tar
          } else this
        }

        override ToString() : string
        {
          $"$(history.state)History"
        }

        this(tran : StateTransition, st : FsmState, type : TargetType.History)
        {
          base(tran, tran.analyser);
          history = StateHistory.Create(st, type.history, true)
        }
      }
    | Final
      {
        [NeedChange] state : FsmState.Final;

        this(tran : StateTransition, an : FsmAnalyser)
        {
          base(tran, an)
        }
        
        override ToString() : string
        {
          $"$(state)"
        }

        public override UpdateReference() : TransitionTarget
        {
          if (state != null) 
          {
            def st = StateMap.Get(state.NativeName);
            if (st != null) ChangeState(st :> FsmState.Final) else this;
          } else this
        }
      }
    [Traverse(junction(node = PseudoStateNode.Junction(_)))]
    [Traverse(merge(node = PseudoStateNode.Merge(_)))]
    | PseudoState
      {
        [NeedChange] node : PseudoStateNode;

        this(tran : StateTransition, st : FsmState, node : TargetType.PseudoState)
        {
          base(tran, tran.analyser);
          this.node = PseudoStateNode.Create(st.analyser, node.node, st, transition);
        }

        override UpdateReference() : TransitionTarget
        {
          def n = node.UpdateReference();
          if (n != node : object) PseudoState(transition, analyser, n) else this
        }

        override ToString() : string
        {
          node.ToString()
        }
      }
    | State 
      {
        [NeedChange] state : FsmState;

        override UpdateReference() : TransitionTarget
        {
          def st = StateMap.Get(state.Name);
          if (st != null) ChangeState(st) else this
        }

        Name : string
        {
          get
          {
            state.Name
          }
        }

        override ToString() : string
        {
          state.ToString();
        }

        this(tran : StateTransition, type : TargetType.State)
        {
          base(tran, tran.analyser);
          state = FsmState.State(type.state, null, analyser, true);
        }

      }

    | Named
      {
        [NeedChange] state : FsmState;
        name : string;

          // TODO: вообще могут быть ссылки null если все immutable
        override UpdateReference() : TransitionTarget
        {
          if (state != null) 
          {
            def st = StateMap.Get(state.Name);
            if (st != null) ChangeState(st) else this;
          } else this
        }

        Name : string
        {
          get
          {
            $"Named$state.$name"
          }
        }

        override ToString() : string
        {
          Name
        }

        this(tran : StateTransition, st : FsmState, type : TargetType.Named)
        {
          base(tran, tran.analyser);
          state = st;//CreateState(type.parent, [], null);
          name = type.name;
        }

      }

    | Qualified 
      {
        parent : string;
        [NeedChange] target : TransitionTarget;

        override UpdateReference() : TransitionTarget
        {
          match (target)
          {
            | State(st) as t => 
                def st = StateMap.Get($"$parent.$(st.NativeName)");
                if (st != null) t.ChangeState(st) else this;
            | _ => target.UpdateReference()
          }
        }

        override ToString() : string
        {
          $"$parent.$target"
        }

      }
    | SubMachine 
      {
        [NeedChange] machine : FsmState.SubMachine;
        state : string;

        override UpdateReference() : TransitionTarget
        {
          match (machine)
          {
            | FsmState(Name = n) => 
                def st = StateMap.Get(n);
                if (st != null) ChangeMachine(st :> FsmState.SubMachine) else this;
          }
        }

        override ToString() : string
        {
          $"$machine.$state"
        }

      }
    | JunctionNode
      {
        guard                 : GuardNode;
        action                : option[Actions];
        [NeedChange] to       : TransitionTarget;
        parent                : PseudoStateNode;
        [NeedChange(to)] next : option[JunctionNode];
        [NeedChange] state    : FsmState;

        public static Create(an : FsmAnalyser, st : FsmState, par : PseudoStateNode, to : TargetType.JunctionNode, tran : StateTransition) : JunctionNode
        {
          match (to)
          {
            | TargetType.JunctionNode(g, a, t, n) => JunctionNode(tran, an, g, a, Create(an, st, tran, t), par, n.Map(x => Create(an, st, par, x, tran)), st)
          } 
        }

        //Guards : list[GuardNode]
        //{
        //  get
        //  {
        //    to.Fold([guard], null, null, null, null, null, null, null, null, null, (a, t) => t.guard :: a)
        //    //def g = match (to)
        //    //         {
        //    //           | TransitionTarget.PseudoState(Merge(to = TransitionTarget.JunctionNode(Guards = g)))
        //    //           | TransitionTarget.PseudoState(Junction(Guards = g)) => g.NToList()
        //    //           | _                                                  => []
        //    //         }
        //    //guard :: g//guard :: g
        //  }
        //}

        UpdateRef() : TransitionTarget
        {   
          def nto = to.UpdateReference();
          def st = base.UpdateReference();
          match (st)
          {
            | JunctionNode as j when (j : object != this || nto : object != to) => j.ChangeTo(nto)//JunctionNode(st, copy, guard, action, nto, parent)
            | _                                                                 => this
          }
        }

        override UpdateReference() : TransitionTarget
        {
          UpdateRef()
        }

        override ToString() : string
        {
          $"JunctionNode$state"
        }
      }

    public static Create(an : FsmAnalyser, state : FsmState, tran : StateTransition, target : TargetType) : TransitionTarget
    {
      match (target)
      {
        | PseudoState as t                  => PseudoState(tran, state, t)
        | History     as t                  => History(tran, state, t)
        | Final                             => Final(tran, an)
        | State       as t                  => State(tran, t)
        | Named       as t                  => Named(tran, state, t)
        | SubMachine(m, s)                  => SubMachine(tran, an, SubMachine(m, null), s)
        | Qualified(parent = p, target = t) => Qualified(tran, an, p, Create(an, state, tran, t))
        | JunctionNode(g, a, t, n)          => JunctionNode(tran, an, g, a, Create(an, state, tran, t), null, n.Map(x => Create(an, state, tran, x) :> JunctionNode), state)
      }
    }

    public CompareTo(target : TransitionTarget) : int
    {
      CompareTo(this, target)
    }

    public static CompareTo(t1 : TransitionTarget, target : TransitionTarget) : int
    {
      | (History(h1), History(h2))                            => h1.Name.CompareTo(h2.Name)
      | (Final(st1), Final(st2))                              => st1.Name.CompareTo(st2.Name)
      | (PseudoState(n1), PseudoState(n2))                    => n1.ToString().CompareTo(n2.ToString())
      | (State(st1), State(st2))                              => st1.Name.CompareTo(st2.Name)
      | (SubMachine(m, s), SubMachine(m2, s2)) when (m == m2) => s.CompareTo(s2)
      | (Qualified(p, t), Qualified(p2, t2)) when (p == p2)   => t.CompareTo(t2)
      | _                                                     => -1
    }

    public static @==(a : TransitionTarget, b : TransitionTarget) : bool
    {
      | (History(h1), History(h2))             => h1 == h2
      | (State(st1), State(st2))
      | (Final(st1), Final(st2))               => st1 == st2
      | (PseudoState(n1), PseudoState(n2))     => n1 == n2
      | (Named(st, n), Named(st2, n2))         => st == st2 && n == n2
      | (Qualified(p, t), Qualified(p2, t2))   => p == p2 && t == t2
      | (SubMachine(m, s), SubMachine(m2, s2)) => m == m2 && s == s2
      | _                                      => false
    }

    public PartOfSubRegion : option[ConcurrentSubRegion]
    {
      get
      {
        match (ToState)
        {
          | null                      => None()
          | ConcurrentSubRegion as st => Some(st)
          | st                        => st.PartOfSubRegion
        }
      }
    }

    public ToState : FsmState
    {
      get
      {
        match (this)
        {
          | PseudoState(PseudoStateNode(state = st))
          | History(StateHistory(state = st))
          | Final(state = st)
          | SubMachine(st, _)
          | JunctionNode(state = st)
          | State(state = st)  => st.Updated
          | Named              => null
          | Qualified(_, t)    => t.ToState
        }
      }
    }

    public transition : StateTransition;

    //public SetCopy(ncopy : int) : TransitionTarget
    //{
    //  Reduce(pseudo_state = t => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
    //         merge = (t, _) => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
    //         junction = (t, _) => t.ChangeNode(t.node.ChangeCopy(ncopy)))
    //}

    public Guards : IEnumerable[GuardNode]
    {
      get
      {
        JunctionNodeParts.Select(_.guard)
      }
    }

    public Rebuild(child : IEnumerable[TransitionTarget]) : TransitionTarget
    {
      match (this)
      {
        | TransitionTarget.Qualified as t => t.ChangeTarget(child.First())
        | PseudoState(Merge as p) as t    => t.ChangeNode(p.ChangeTo(child.First() :> JunctionNode))
        | PseudoState(Junction as p) as t => t.ChangeNode(p.ChangeTo(child.First() :> JunctionNode))
        | JunctionNode(next = Some) as t  => def (f, s) = child.TakeTwo();
            t.ChangeNextTo(if (s != null) Some(s :> JunctionNode) else None(), f)
        | JunctionNode as t               => def f = child.First();
                                            t.ChangeTo(f);
        | _                               => this
      }
    }

    public GetChild() : IEnumerable[TransitionTarget]
    {
      match (this)
      {
        | JunctionNode(to = to, next = Some(n)) => TraverseUtils.DoubleElement(to, n)
        | PseudoState(Merge(to = n))
        | PseudoState(Junction(to = n))
        | JunctionNode(to =  n)
        | Qualified(_, n)                       => TraverseUtils.SingleElement(n)
        | _                                     => Enumerable.Empty()
      }
    }

    public virtual UpdateReference() : TransitionTarget
    {
      this
    }

    public StateMap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }

    public analyser : FsmAnalyser;

  }


}
