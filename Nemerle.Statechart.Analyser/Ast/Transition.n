using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;

namespace Nemerle.Statechart
{  

  [Record]
  public partial variant StateTransition
  {
    | Default
      {
        //history : PseudoStateNode.History
        //{
        //  get
        //  {
        //    match (From)
        //    {
              
        //    }
        //  }
        //}

        //this(tran : Default)
        //{
        //  base(tran)
        //  //history = tran.history;
        //}

        //this(hist : SimpleTreeNode[FsmNode], default : StateNode.Transition)
        //{
        //  base(hist, default);
        //  //history = hist;
        //}
      }

    | Initial
      {

        public static new Create(st : SimpleTreeNode[FsmState], tr : StateNode.Transition) : StateTransition
        {
          match (tr)
          {
            | StateNode.Transition(type = TransitionType.Initial)              => Initial(st, tr)
            | _                                                                => throw InvalidOperationException("invalid transition node")
          }
        }

      }

    [DebuggerDisplay("Transition  =  {Name}")]
    | Transition 
      {
        trigger : StateEvent;
        

        TriggerName : string
        {
          get
          {
            trigger.Name
          }
        }

        this(st : SimpleTreeNode[FsmState], evt : StateEvent, tr : StateNode.Transition)
        {
          base(st, tr);
          trigger = evt;
        }

        //this(st : FsmState, to : FsmState, source : PseudoStateNode)
        //{
        //  base(st.analyser);
        //  From = st;
        //  Source = From;
        //  ImplicitFrom = source;
        //  To = TransitionTarget.State(this, st.analyser, to);
        //}

        this(st : SimpleTreeNode[FsmState], trigger : StateEvent, to : TransitionTarget, source : PseudoStateNode)
        {
          base(st, to);
          this.trigger = trigger;
          implicit_from = source;
        }

        //[NeedChange]
        //public implicit_from : PseudoStateNode;
        //this(tran : Transition)
        //{
        //  base(tran);
        //  trigger = tran.trigger;
        //  node = tran.node;
        //}

        //this(st : FsmState, tr : Transition)
        //{
        //  this(tr);
        //  Source = st;
        //}
      }

    | Internal
      {
        trigger : StateEvent;

        this(tran : Internal)
        {
          base(tran);
          trigger = tran.trigger;
        }

        ActionNode : PathNode
        {
          get
          {
            PathNode.Action(action.Value)
          }
        }

        TriggerName : string
        {
          get
          {
            trigger.Name
          }
        }

        override ToString() : string
        {
          Name
        }

        //this(st : FsmState, tr : Internal)
        //{
        //  this(st, tr);
        //}

        this(from : FsmState, trigger : StateEvent, tran : StateNode.Transition) 
        {
          base(from, tran);
          this.trigger = trigger;
        }


      }

    | History
      {
        history : PseudoStateNode.History;

        this(tran : History)
        {
          base(tran);
          history = tran.history;
        }

        this(hist : PseudoStateNode.History, st : FsmState, to : FsmState)
        {
          base(st, to);
          history = hist;
        }

      }

    public static Create(st : NodeValue[FsmState, PseudoStateNode], trigger : StateEvent, to : TransitionTarget) : StateTransition
    {
      StateTransition.Transition(FsmNode.PseudoState(st), trigger, to)
    }
      
    public static Create(st : FsmNode, trigger : StateEvent, to : TransitionTarget) : StateTransition
    {
      StateTransition.Transition(st, trigger, to)
    }

    public static Create(st : SimpleTreeNode[FsmState], tr : StateNode.Transition) : IEnumerable[StateTransition]
    {
      match (tr)
      {
        | StateNode.Transition(type = TransitionType.Internal, evt = e)    => e.Map(x => Internal(st, StateEvent(x), tr))
        | StateNode.Transition(type = TransitionType.Initial)              => TraverseUtils.SingleElement(Initial(st, tr))
        | StateNode.Transition(type = TransitionType.Transition, evt = e)  => e.Map(x => Transition(st, StateEvent(x), tr))
        | _                                                                => throw InvalidOperationException("invalid transition node")
      }
    }


    public static Create(st : SimpleTreeNode[FsmState], tr : IEnumerable[StateNode.Transition]) : IEnumerable[StateTransition]
    {
      tr.SelectMany(Create(st, _))
    }

    //public static Create(st : FsmState, tr : IEnumerable[StateNode.InternalTransition]) : IEnumerable[StateTransition]
    //{
    //      $[Internal(StateEvent(y), x, st) : StateTransition, x in tr, y in x.evt].Map(x => x.ChangeNum(st.analyser.GetNewTransitionId(x)))
    //}

    //public static Create(st : FsmState, tr : IEnumerable[StateNode.Transition]) : IEnumerable[StateTransition]
    //{ 
    //        $[Transition(st, StateEvent(y), x) : StateTransition, x in tr, y in x.evt].Map(x => x.ChangeNum(st.analyser.GetNewTransitionId(x)))
    //}

    //public Create() : StateTransition
    //{
    //  SetNewId()
    //}

    //public static Create(st : FsmState, trigger : StateEvent, to : TransitionTarget, source : PseudoStateNode) : StateTransition
    //{
    //  def tr = Transition(st, trigger, to, source);
    //  tr.ChangeNum(st.analyser.GetNewTransitionId(tr));
    //}
  }

}
