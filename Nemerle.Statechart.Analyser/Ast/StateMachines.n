using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of StateMachines.
  /// </summary>
  class StateMachines
  {
        // inst : accumulated base state machine
        // ret : instance and base state machine accumulator
    public static InitInline(this st : FsmState.InlinedSubMachineInstance, inst : list[FsmState]) : FsmState * list[FsmState]
    {
      | (FsmState.InlinedSubMachineInstance(instance_of = instance_of, name = name, transitions = transitions, Num = cur_num), _) => 

          def find_inst   = inst.Find(x => x.Num == instance_of.Num).ObjFromOption();
          def instance_of = instance_of.Updated;
          def base_inst   = (find_inst ?? instance_of) :> FsmState.InlinedSubMachine;

          def num         = base_inst.NCopy + 1; // increment copy number

          def copy_state(st, sub)
          {
            def st = st.ChangeCloneFor(st);

            def st = match (st, instance_of)
            {
              | (FsmState.Final, _)                                    => st
                                                                          // change name, number and transitions to outer world to this instance
              | (FsmState(Num = n), FsmState(Num = n2)) when (n == n2) => st.ChangeNameTransitionsNum(name, transitions, cur_num)
              | _                                                      => st.ChangeCopyNum(num).SetNewId() // set new identificator for state
            }

            def change_sub_states(sub : FsmState)
            {
              // if final state change it name to super state and set new id
              | Final as sub => sub.ChangeName(FsmState.Final.GetName(st.Name)).SetNewId()
              | _            => sub
            }

            def sub    = sub.Map(change_sub_states);

            def change_from_source(tr)
            {
              def s =  tr.ChangeSourceNum(st).SetNewId(); 
              s.From = st; 
              s
            }
            
            def init   = st.initial.Map(change_from_source);
            def tran   = st.transitions.Map(change_from_source);
            def intern = st.internal_tran.Map(change_from_source);
            st.history.Iter(_.ChangeState(st));
            def en     = st.entry;
            def ex     = st.exit;
            st.ChangeTransitionsSubStatesInitialEntryExitInternalTran(tran, sub, init,  en, ex, intern)
          }

          def st          = instance_of.ReduceSingle(true, copy_state); // copy state and its content, changing references accordingly
          def new_st      = st.AllStates.ToArray(); // take all states in new sm copy
          def old_st      = instance_of.AllStates.ToArray();

          def retarget_transitions(s, _)
          {
            def find_state(st)
            {
              match (old_st.IndexOf(x => x.Num == st.Num))
              {
                | -1 => st
                | n  => new_st[n]
              }
            }

            def check_target(tar)
            {
              | TransitionTarget.State(state = st) as t               => t.ChangeState(find_state(st))
              | Qualified(_, State(state = st) as t)                  => t.ChangeState(find_state(st))
              | Final(st) as t                                        => t.ChangeState(find_state(st))
              | PseudoState(PseudoStateNode(state = st) as node) as t => node.ChangeState(find_state(st)); 
                                                                         t
              | _                                                     => null
            }

            def check_tran(tr)
            {
              tr.TargetTraverse((x, _) => check_target(x))
            }

            def s        = s.TraverseTargets((x, _) => check_target(x));
            def hist     = s.history.Map(x => x.ChangeDefault(x.default.Map(check_tran)));
            s.ChangeHistory(hist)
          }

          def st           = st.ReduceSingle(retarget_transitions); // retarget transitions to new place state
          def new_st       = st.AllStates.ToArray(); // take all states in new sm copy

          def update_base_inst(s, _)
          {
            def check_tran(tr, ntran)
            {
              tr.ZipLazy(ntran).Map((i, n) => i.ChangeClones(n :: i.clones));
            }

            match (new_st.Find(o => o.cloneFor.Num == s.Num))
            {
              | Some(st) => // // if it is state machine instance don't touch external transitions
                            def trans     = if (st.Num != cur_num) check_tran(s.transitions, st.transitions) else s.transitions;
                            def int_trans = check_tran(s.internal_tran, st.internal_tran);
                            def init      = check_tran(s.initial, st.initial);
                            s.ChangeClonesInitialInternalTranTransitions(st :: s.clones, init, int_trans, trans)

              | _        => throw InvalidOperationException("unknown state machine state")
            }
          }

          def base_inst   = base_inst.ReduceSingle(update_base_inst); // updating base instance clones information

          // if have processed base sm type exclude it
          def inst = if (find_inst != null) inst.Exclude(x => x.Num == base_inst.Num) else inst;
          // updates state map
          (st, base_inst :: inst) // add base sm type to accumulator

    }

  }
}
