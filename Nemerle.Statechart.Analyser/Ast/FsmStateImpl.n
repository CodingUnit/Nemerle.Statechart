using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PseudoStateNode;
  using ListUtils;

  /// <summary>
  /// Description of FsmStateImpl.
  /// </summary>
  //[RefNode]
  public partial variant FsmState
  {
    public override ToString() : string { if (name != null) name else AstName }

    public static GetCopy(this node : GeneralTree[FsmState], to : FsmState, copy : int) : GeneralTree[FsmState]
    {
      //def statemap = node.Data.statemap;
      
      def get_copy(st, ch)
      {
        def nst = GeneralTree(st.Data);
        nst.AddRange(ch);
        def std = nst.Data;
        //def num = statemap.GetNextGlobalNum();
        //def int_tran = st.InternalTransitions.Iter(x => x.Update .SetNewId());
        //def hist = st.history.Map(_.ChangeNumCopy(statemap.GetNextGlobalNum(), copy));
        //def trans = st.transitions.Map(_.SetNewId());
        //def init  = st.initial.Map(_.SetNewId());
        def an = std.analyser;
        def pseudo = st.PseudoStates().Map(x => x.Clone(x => x.Clone()));
        def tran   = st.AllTransitions().Map(x => x.Clone(x => x.Clone()));
        pseudo.Iter(x => x.Update(x => x.ChangeCopy(copy)));
        an.PseudoStates.Add(nst, pseudo);
        an.statemap.Transitions.Add(nst, tran);
        nst.Update(x => x.ChangeCopyNum(copy));
        an.Clones[st] = if (an.Clones.ContainsKey(st)) nst :: an.Clones[st] else  nst :: [];
        nst
        //st.ChangeNumHistoryPseudoStatesCloneForInitialInternalTranTransitionsCopyNum(num, hist, pseudo, st, init, int_tran, trans, copy)
      }

      //def node = node.Clone();
      def st = node.Reduce(get_copy);

      def old_pseudo  = node.AllPseudo();
      def new_pseudo  = st.AllPseudo();

      def pseudo_map = Map(old_pseudo.ZipLazy(new_pseudo));
      //def pseudo_id_map = old_pseudo.MakeArrayMap(new_pseudo, statemap.GlobalId, _.Num);
      //def states_id_map = node.AllStates().MakeArrayMap(st.AllStates(), statemap.GlobalId, _.Num);
      //states_id_map[Num] = to;
      
      def update_junction(j)
      {
        | Junction(tree = t) as j => t.GetBreadthFirstEnumerable().Iter(x => x.Update(x => x.ChangeJunc(pseudo_map.Get(x.junc)))); 
                                     j
        | _                       => j                             
      }
      
      def retarget_transitions(s)
      {
        def check_target(tar)
        {
          | TransitionTarget.State(st) as t               => t.ChangeState(st.Analyser().Clones[st].Head)
              //| Qualified(_, State(state = st) as t)                  => t.ChangeStateNum(find_state(st))
              //| Final(st) as t                         => t.ChangeStateNum(find_state(st))          
          | PseudoState(NodeValue(Value = Junction) as n) as t => def j = pseudo_map.Get(n);
                                                                  j.Update(update_junction);
                                                                  t//t.ChangeNode(p => p.ChangeNumCopy(statemap.GetNextGlobalNum(), copy))
          | PseudoState(node) as t                        => def pseudo = pseudo_map.Get(node);
                                                             def t = t.ChangeNode(pseudo);//t.node.Fix(pseudo_id_map[node.Num].Num)) 
                                                             t
                                                                        //t
          | _                                             => null
        }

        //def check_tran(tr)
        //{
        //  tr.TargetTraverse((x, _) => check_target(x))
        //}

        //def s        = s.AllTransitions().Iter(x : NodeValue[FsmState, StateTransition] => x.Update(y => check_target(y.To)));
        //def hist     = s.history.Map(_.ChangeDefault(check_tran));
        //s.ChangeHistory(hist)
        //s.Data
        s.AllTransitions().Iter(x => x.Update(x => x.TargetTraverse(check_target)))
      }

      st.AllStates().Iter(retarget_transitions); // retarget transitions to new place state
      st
    }

    //public FormatName() : void
    //{
    //  def name = name.SplitToList('.');
    //  this.name = name.Last();
    //}


   
    //public UpdateTransition(tr : StateTransition) : FsmState
    //{
    //  def find(t)
    //  {
    //    if (t.Num == tr.Num) tr else t
    //  }

    //  TransitionMap(find)
    //}
   
    //public UpdateTransitions(tr : IEnumerable[StateTransition]) : FsmState
    //{
    //  def find(tr, trans)
    //  {
    //    match (trans.Find(x => x.Num == tr.Num))
    //    {
    //      | Some(tr) => tr
    //      | _        => tr
    //    }
    //  }

    //  TransitionMap(find(_, tr))
    //}

    //public TraverseTargets(func : TransitionTarget * StateTransition -> TransitionTarget, manual_rebuild : bool = false) : FsmState
    //{
    //  TransitionMap(_.TargetTraverse(func, manual_rebuild))
    //}


    //public TransitionMap(tran_func : StateTransition -> StateTransition) : FsmState
    //{
    //  def init = initial.Map(tran_func);
    //  def tran = transitions.Map(tran_func);
    //  def int_tran = internal_tran.Map(tran_func);
    //  ChangeTransitionsInitialInternalTran(tran, init, int_tran)
    //}
    
    public this(an : FsmAnalyser)
    {
      analyser = an;
    }

    public this(name : string, analyser : FsmAnalyser)
    {
      //super : FsmState, 
      this(analyser);
      this.name = name;
      //this.super_state = super;
      //this.reference = reference;
      //Num = statemap.GetNewStateId(this)
    }

    public this(st : StateNode.State, analyser : FsmAnalyser)
    {
      this(analyser);
      state = st;
      name = st.name;
      //this.reference = reference || state.reference;

      //when (!reference)
      //{
      do_activity = st.do_activity |> StateAction.Do(_.action.actions, _.flags);
      //internal_tran = Internal.Create(this, st.internal_tran).NToList();
      entry = st.entry |> StateAction.Entry(_.action.actions, _.attrib);
      exit = st.exit |> StateAction.Exit(_.action.actions, _.attrib);
      //history = PseudoStateNode.History.Create(this, st.history);
      //transitions = Transition.Create(this, st.transitions).NToList();
      //initial = st.initial.Map(Initial.Create(this, _));
        //def (regs, subst) = st.sub_states.Partition(x => x.regions.HasValue);
        //def regs = regs |> ConcurrentRegion(this, _, _.regions.Value); // TODO: сделать с помощью st_from_node
        //super_state = super;
        //def subst = (subst |> st_from_node(_)) + regs;
        //sub_states = subst.Sort((x, y) => x.source_pos - y.source_pos);
      //sub_states = sub.NToList();//.Map(_.ChangeSuperState(this));
      //pseudo_states = st.pseudo_states |> PseudoStateNode.Create(this, _.node, analyser.statemap.GetNextGlobalNum())
      //}
      //Num = statemap.GetNewStateId(this)
    }

    //public NestedObjects : IEnumerable[IdObject]
    //{
    //  get
    //  {
    //    def obj = all_transitions_with_init.SelectMany(_.TargetIdObjects);
    //    all_transitions_with_init + ChildPseudo + DefaultTransitions + obj
    //  }
    //}

    //public GetPseudo(num : int) : PseudoStateNode
    //{
    // ChildPseudo.Find(x => x.Num == num).WithDefault(null)
    //}
    
    //public ChangePseudo(num : int, func : PseudoStateNode -> PseudoStateNode) : FsmState
    //{
    //  PseudoMap(x => if (x.Num == num) func(x) else x)
    //}
    
    //public PseudoMap(func : PseudoStateNode -> PseudoStateNode) : FsmState
    //{
    //  def st = HistoryMap(x => func(x) :> PseudoStateNode.History);
    //  ChangePseudoStates(st.pseudo_states.Map(func))
    //  //def pseudo = ChildPseudo.Select(func);
    //}
    
    
    //public AddPseudo(node : PseudoStateNode) : FsmState
    //{
    //  ChangePseudoStates(pseudo_states.Append(node).NToList())
    //}
    
    //public ChildPseudo : IEnumerable[PseudoStateNode]
    //{
    //  get
    //  {
    //    history.Value + pseudo_states
    //  }
    //}

    //public ChildObjects : IEnumerable[IdObject]
    //{
    //  get
    //  {
    //    all_transitions_with_init + ChildPseudo + DefaultTransitions
    //  }
    //}


    //public AllChilds : IEnumerable[int]
    //{
    //  get
    //  {
    //    sub_states.Select(_.Num) + ChildNodes
    //  }
    //}
    
    //public ChildNodes : IEnumerable[int]
    //{
    //  get
    //  {
    //    ChildObjects.Select(_.Num)
    //  }
    //}

    //public SetNum(num : int) : FsmState
    //{
    //  def st = ChangeNum(num);
    //  statemap.UpdateRefsToParent(st);
    //  st
    //}

    //public SetNewId() : FsmState
    //{
    //  ChangeNum(statemap.GetNextGlobalNum())
    //}

    //public ChangeHistory(h : PseudoStateNode.History) : FsmState
    //{
    //  def check_hist(hist)
    //  {
    //    if (hist.Num == h.Num)
    //    {
    //      h
    //    } else hist
    //  }
      
    //  HistoryMap(check_hist)
    //}

    //public ChangeHistory(num : int, h : PseudoStateNode -> PseudoStateNode) : FsmState
    //{
    //  def check_hist(hist)
    //  {
    //    if (hist.Num == num)
    //    {
    //      h(hist) :> PseudoStateNode.History
    //    } else hist
    //  }
      
    //  HistoryMap(check_hist)
    //}
    
    //public HistoryMap(hist : PseudoStateNode.History -> PseudoStateNode.History) : FsmState
    //{
    //  ChangeHistory(history.Map(hist))
    //}
    //// copy constructor
    //public this(st : FsmState)
    //{
    //  name = st.name;
    //  analyser = st.analyser;
    //  do_activity = st.do_activity;
    //  internal_tran = st.internal_tran;
    //  entry = st.entry;
    //  exit = st.exit;
    //  //history =  st.history.Map(_.ChangeState(this));
    //  transitions = st.transitions;
    //  initial = st.initial;
    //  //super_state = st.super_state;
    //  sub_states = st.sub_states;//.Map(_.ChangeSuperState(this));
    //  pseudo_states = st.pseudo_states;
    //  Num = st.Num;
    //}



    //[NeedChange]
    //public PathFromOut : StateTransition;
    ///// <summary>
    ///// Indicates what fsm lived in this state and it not only composite for others
    ///// </summary>
    //public Lived : bool 
    //{
    //  get
    //  {
    //    lived || clones.Exists(_.Lived)
    //  }
    //}


    //public hierarchy_pos : int
    //{
    //  get
    //  {
    //    if (calc_hierarchy_pos != -1) calc_hierarchy_pos else SuperStates.Count()
    //  }
    //}

    public source_pos : int
    {
      get
      {
        state.pos
      }
    }

    //public IsTopState : bool
    //{
    //  get
    //  {
    //    Num == statemap.TopNum
    //  }
    //}

    public CopyName : string
    {
      get
      {
        if (copy_num == 0) "" else $"$copy_num"
      }
    }
    

    public AstName : string
    {
      get
      {
        state.name
      }
    }




    public static NameComparer(x : GeneralTree[FsmState], y : GeneralTree[FsmState]) : int { string.Compare(x.Name(), y.Name()) }



    //public GetChild() : IEnumerable[FsmState]
    //{
    //  match (this)
    //  {
    //    | ConcurrentRegion(sub_regions = r) => r.Select(_ : FsmState)
    //    | _                                 => sub_states
    //  }
    //}

    //public Rebuild(child : IEnumerable[FsmState]) : FsmState
    //{
    //  match (this)
    //  {
    //    | ConcurrentRegion as r => r.ChangeSubRegions(child.Map(_ :> FsmState.ConcurrentSubRegion))
    //    | _                     => ChangeSubStates(child.NToList())
    //  }
    //}

    //public UpdateHistory(hist : PseudoStateNode.History) : FsmState
    //{
    //  def hist = history.Map(x => if (x.type == hist.type) hist else x);
    //  ChangeHistory(hist)
    //}
  }
}
