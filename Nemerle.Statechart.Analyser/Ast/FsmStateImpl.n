using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PseudoStateNode;
  /// <summary>
  /// Description of FsmStateImpl.
  /// </summary>
  public partial variant FsmState
  {
    public override ToString() : string {Name}

    public virtual UpdateReference(an : FsmAnalyser) : FsmState * FsmAnalyser
    {
      def map = an.statemap;
      def (super, an) = if (super_state != null && super_state.reference) 
                        {
                          map.Get(super_state.Name, an)
                        } else (super_state, an);
      //def super = if (super.AstName == null) super.ChangeName(TopStateName) else super;
      def an = initial.FoldLeft(an, _.UpdateReference(_));
      def an = transitions.FoldLeft(an, _.UpdateReference(_));
      def an = history.Value.FoldLeft(an, _.UpdateReference(_));
      def sub_states = map.Get(sub_states);
      def (pseudo, an) = pseudo_states.MapThrough(an, _.UpdateReference(_));
      def (sub_states, an) = sub_states.MapThrough(an, _.UpdateReference(_));
      def st = ChangePseudoStatesSubStatesSuperStateAnalyser(pseudo, sub_states, super, an);
      (st, an)
    }

    //public FormatName() : void
    //{
    //  def name = name.SplitToList('.');
    //  this.name = name.Last();
    //}

    public DefineInitial(st : FsmState) : FsmState
    {
      def init = match (this)
                  {
                    | ConcurrentSubRegion(contained_in = r) => Initial(r, st)//initial ::= Initial(r, st)
                    | _ => Initial(this, st)//initial ::= Initial(this, st)
                  }
      ChangeInitial(init :: initial)
    }

    public AddSubState(st : FsmState) : FsmState
    {
      //st.analyser = Analyser;
      if (sub_states.Exists(x => x.Name == st.Name)) this else ChangeSubStates(sub_states + [st])//sub_states = sub_states + [st];
    }

    //public DefineTransition(tr : StateTransition) : void
    //{
    //  | Transition as tr => transitions ::= Transition(this, tr)
    //  | Internal   as tr => internal_tran ::= Internal(this, tr)
    //  | Initial    as tr => initial ::= tr
    //  | _ => ()
    //}

    //public SetCopy(ncopy : int) : FsmState
    //{
    //  def st = match (this)
    //           {
    //             | State               as st => State(st, false, ncopy)
    //             | ConcurrentRegion    as st => ConcurrentRegion(st, ncopy)
    //             | ConcurrentSubRegion as st => ConcurrentSubRegion(st, ncopy)
    //             | InlinedSubMachine   as st => InlinedSubMachine(st, ncopy)
    //             | SubMachine          as st => SubMachine(st, ncopy)
    //             | Final               as st => Final(st, false, ncopy)
    //           }

    //  //clones ::= st;
    //  st.ChangeCopyNumCloneFor(ncopy);
    //  //st.FindCopyName();
    //}

    //public clones : list[FsmState] = [];

    public DefineTransitions(tr : list[StateTransition]) : FsmState
    {
      def (tran, other)   = tr.PartitionType();
      def (intern, other) = other.PartitionType();
      def (init, _)       = other.PartitionType();
      ChangeInternalTranInitialTransitions(intern, init, tran)
          //  | Transition as tr => transitions ::= Transition(this, tr)
    //  | Internal   as tr => internal_tran ::= Internal(this, tr)
    //  | Initial    as tr => initial ::= tr

      //tr.Iter(DefineTransition)
    }

    //public DefineHistoryPath(st : string, nodes : HistoryPath) : void
    //{
    //  history_paths ::= (st, nodes)
    //}

    //public DefineHistoryPathRecurse(st : string, nodes : HistoryPath) : void
    //{
    //  def reg = this is ConcurrentRegion;
    //  when (Lived || reg) DefineHistoryPath(st, nodes);
    //  when (!reg) sub_states.Iter(x  => x.DefineHistoryPathRecurse(st, nodes))
    //}

    public DeleteTransitions(tr : list[StateTransition]) : FsmState
    {
      def (tran, other)     = tr.PartitionType();
      def (int_tran, other) = other.PartitionType();
      def (init, _)         = other.PartitionType();
      def initial           = initial.Exclude(init, (x, y) => StateTransition.FullComparer(x, y) == 0);
      def internal_tran     = internal_tran.Exclude(int_tran, (x, y) => StateTransition.FullComparer(x, y) == 0);
      def transitions       = transitions.Exclude(tran, (x, y) => StateTransition.FullComparer(x, y) == 0);
      ChangeInternalTranInitialTransitions(internal_tran, initial, transitions)
    }

    //public DeleteTransitionsNested(tr : list[StateTransition]) : void
    //{
    //  DeleteTransitions(tr);
    //  AllSubStates.Iter(x => x.DeleteTransitionsNested(tr));
    //}

    public TraverseTransitions(an : FsmAnalyser) : FsmState
    {
      def paths = TransitionPaths(this);
      paths.TraverseTransitions(an, true);
      ChangePaths(paths)
    }

    public this()
    {
    }

    public this(super : FsmState, name : string, reference : bool = false)
    {
      this();
      this.analyser = analyser;
      this.name = name;
      this.super_state = super;
      this.reference = reference
    }

    public this(st : StateNode.State, super : FsmState, analyser : FsmAnalyser, reference : bool = false)
    {
      this(st, super, reference);
      this.analyser = analyser;
    }

    public this(st : StateNode.State, super : FsmState, reference : bool = false)
    {
      this();
      state = st;
      name = st.name;
      this.reference = reference || state.reference;

      def st_from_node(n)
      {
        | StateNode.State(type = SubMachine) => SubMachine(n, this)
        | State(type = InlinedSubMachine)    => InlinedSubMachine(n, this)
        | _                                  => FsmState.State(n, this, false)
      }

      when (!reference)
      {
        do_activity = st.do_activity |> StateAction.Do(_.action.ActionList, this, _.flags);
        internal_tran = Internal.Create(this, st.internal_tran);
        entry = st.entry |> StateAction.Entry(_.action.ActionList, this, _.attrib);
        exit = st.exit |> StateAction.Exit(_.action.ActionList, this, _.attrib);
        history = StateHistory.Create(this, st.history);
        transitions = Transition.Create(this, st.transitions);
        initial = st.initial |> Initial(this, _);
        def (regs, subst) = st.sub_states.Partition(x => x.regions.HasValue);
        def regs = regs |> ConcurrentRegion(this, _, _.regions.Value); // TODO: сделать с помощью st_from_node
        super_state = super;
        def subst = (subst |> st_from_node(_)) + regs;
        sub_states = subst.Sort((x, y) => x.source_pos - y.source_pos);
        pseudo_states = st.pseudo_states |> PseudoStateNode.Create(_.node, this, null)
      }
    }    
    //public this(st : FsmState, reference : bool = false, ncopy : int = 0)
    //{
    //  this();
    //  this.reference = reference;
    //  name = st.name;
    //  analyser = st.analyser;
    //  do_activity = st.do_activity;
    //  internal_tran = if (ncopy != 0) st.internal_tran |> Clone(ncopy) else st.internal_tran;
    //  entry = st.entry |> Clone() :> StateAction.Entry;
    //  exit = st.exit |> Clone() :> StateAction.Exit;
    //  history =  if (ncopy != 0) st.history |> Clone(ncopy) else st.history;
    //  history.Iter(x => x.state = this);
    //  transitions = if (ncopy != 0) st.transitions |> Clone(ncopy) else st.transitions;
    //  initial = if (ncopy != 0) st.initial |> Clone(ncopy) else st.initial;
    //  super_state = st.super_state;
    //  sub_states = if (ncopy != 0) st.sub_states |> ChangeCopyNum(ncopy) else st.sub_states;
    //  sub_states.Iter(x => x.super_state = this);
    //  pseudo_states = if (ncopy != 0) st.pseudo_states |> SetCopy(ncopy) else st.pseudo_states
    //}

    public history_paths : list[string * HistoryPath] // paths from outer history
    {
      get
      {
        //def reg = this is ConcurrentRegion;
        //when (Lived || reg) DefineHistoryPath(st, nodes);
        //when (!reg) sub_states.Iter(x  => x.DefineHistoryPathRecurse(st, nodes))
        def shist = SuperStates.Filter(x => x.ParticipateInHistory.Exists(x => x.Type == HistoryType.Shallow));
        def spaths = shist |>< history_paths;
        def paths = ParticipateInHistory.Map(x => (x.state.name, HistoryPath(x.state, this, x)));
        paths.Iter((_, x) => x.CreatePath(analyser));
        paths + spaths
      }
    }

    public PathFromOut : StateTransition.Initial
    {
      get
      {
        def path = StateTransition.Initial(analyser.TopState, this);
        path.TraversePath(analyser);
        path
      }
    }

    ///// <summary>
    ///// Indicates what fsm lived in this state and it not only composite for others
    ///// </summary>
    //public Lived : bool 
    //{
    //  get
    //  {
    //    lived || clones.Exists(_.Lived)
    //  }
    //}

    public UsedInGenerate : bool
    {
      get
      {
        lived || AllLivedSubStates is _ :: _
      }
    }

    /// <summary>
    /// Hierarchy position
    /// </summary>
    public hierarchy_pos : int
    {
      get
      {
        SuperStates.Length
      }
    }

    public source_pos : int
    {
      get
      {
        state.pos
      }
    }

    public IsTopState : bool
    {
      get
      {
        Name == TopStateName
      }
    }




    CopyName : string
    {
      get
      {
        if (copy_num == 0) "" else $"$copy_num"
      }
    }

    public Name : string
    {
      get
      {
        match (this)
        {
          | Final                               => $"$(super_state)Final$CopyName"
          | State
          | ConcurrentRegion
          | ConcurrentSubRegion                 => NativeName
          | SubMachine(name = n)                => $"SubMachine$n$CopyName"
          | InlinedSubMachine(name = n)         => $"InlinedSubMachine$n$CopyName"
          | InlinedSubMachineInstance(name = n) => $"InlinedSubMachineInstance$n$CopyName"
        }
      }
    }

    public OriginalName : string
    {
      get
      {
        match (this)
        {
          | ConcurrentSubRegion(index = idx, contained_in = r) => $"$(r)SubRegion$idx"
          | _ => if (name != null) name else AstName
        }
      }
    }

    public NativeName : string
    {
      get
      {
        $"$OriginalName$CopyName"
      }
    }

    public join_completion_transitions : list[StateTransition]
    {
      get
      {
        completion_transitions.Filter(x => x.To is TransitionTarget.PseudoState(Join()))
      }
    }

    public AstName : string
    {
      get
      {
        state.name
      }
    }

    /// <summary>
    /// Events for which reacts state
    /// </summary>
    public events : list[StateEvent]
    {
      get
      {
        def evts = work_transitions |> Trigger;
        evts.RemoveDuplicatesSort(_.CompareTo(_))
      }
    }

    /// <summary>
    /// Events for which reacts state or nested states
    /// </summary>
    public events_nested : list[StateEvent]
    {
      get
      {
        def evts = events + (AllLivedSubStates |>< events);
        evts.RemoveDuplicatesSort(_.CompareTo(_));
      }
    }

    public SuperStatesInclude : list[FsmState]
    {
      get
      {
        this :: SuperStates
      }
    }

    public PartOfStateMachine : option[InlinedSubMachine]
    {
      get
      {
        SuperStatesInclude.FindType()[0]
      }
    }

    public AllHistory : list[StateHistory]
    {
      get
      {
        AllSubStates |>< history.Value
      }
    }

    public PartOfSubRegion : option[ConcurrentSubRegion]
    {
      get
      {
        SuperStatesInclude.FindType()[0]
      }
    }

    public PartOfSubRegions : list[ConcurrentSubRegion]
    {
      get
      {
        SuperStatesInclude.FilterType()
      }
    }

    public PartOfTopRegion : option[ConcurrentRegion]
    {
      get
      {
        match (PartOfRegions)
        {
          | [] => None()
          | lst => Some(lst.Last())
        }
      }
    }

    public PartOfRegion : option[ConcurrentRegion]
    {
      get
      {
        SuperStatesInclude.FindType()[0]
      }
    }

    public PartOfRegions : list[ConcurrentRegion]
    {
      get
      {
        SuperStatesInclude.FilterType()
      }
    }

    public GetPathFrom(st : FsmState) : list[FsmState]
    {
      def super = SuperStatesInclude.FirstElems(x => x.Name == st.Name);
      st :: super.Rev()
    }

    public PathName : list[FsmState]
    {
      get
      {
        (this :: SuperStates.SplitLast()[1]).Rev()
      }
    }

    public static NameComparer : FsmState * FsmState -> int = (x, y) => string.Compare(x.Name, y.Name);

    public PartOfRegionsOf(st : FsmState) : list[ConcurrentRegion]
    {
      SuperStatesInclude.FirstElems(_ == st).FilterType();
    }

    public RenameState() : void
    {
      entry.Iter(x => x.state = this);
      exit.Iter(x => x.state = this);
      //history.Map(x => x.state = this)
    }

    public FoldThis(
                state   : FsmState * FsmState * State -> FsmState,
                final   : FsmState * Final            -> FsmState,
                sub_reg : FsmState * FsmState * ConcurrentSubRegion -> FsmState,
                region  : FsmState * FsmState * ConcurrentRegion -> FsmState,
                inlined_subm_inst : FsmState * FsmState * InlinedSubMachineInstance -> FsmState,
                sub_mach : SubMachine -> FsmState,
                inlined_fsm : FsmState * FsmState * InlinedSubMachine -> FsmState
              ) : FsmState
    {

      def xnode(n, sub, nt, nsr, sr, ot)
      {
        match (n)
        {
          | null                            => ot
          | State          as t                                                   
          | InlinedSubMachineInstance as t  
          | InlinedSubMachine as t
          | Final as t                      => t.ChangeSubStateNext(sub, nt)
          | ConcurrentSubRegion as t        => t.ChangeNextSubRegionSubState(nsr, sub)
          | ConcurrentRegion as t           => t.ChangeSubRegionNext(sr, nt)
          | x                               => x
        }
      }

      def loop(st, cont)
      {
        match (st)
        {
          | State(sub_state = sub, next = null) as t                             => loop(sub, subacc => cont(xnode(state(subacc, null, t), subacc, null, null, null, t)))
          | State(sub_state = sub, next = n) as t                                => loop(sub, subacc => 
                                                                                              loop(n, nacc => cont(xnode(state(subacc, nacc, t), subacc, nacc, null, null, t))))
          | Final(next = null) as t                                              => cont(xnode(final(null, t), null, null, null, null, t))
          | Final(next = n) as t                                                 => loop(n, nacc => cont(xnode(final(nacc, t), null, nacc, null, null, t)))

          | ConcurrentSubRegion(sub_state = sub, next_sub_region = null) as t    => loop(sub, subacc => cont(xnode(sub_reg(subacc, null, t), subacc, null, null, null, t)))
          | ConcurrentSubRegion(sub_state = sub, next_sub_region = n) as t       => loop(sub, subacc => 
                                                                                              loop(n, nacc => cont(xnode(sub_reg(subacc, nacc, t), subacc, nacc, null, null, t))))
          | ConcurrentRegion(sub_region = reg, next = null)  as t                => loop(reg, regacc => cont(xnode(region(regacc, null, t), null, null, null, regacc :> ConcurrentSubRegion, t)))
          | ConcurrentRegion(sub_region = reg, next = n)  as t                   => loop(reg, regacc => 
                                                                                              loop(n, nacc => cont(xnode(region(regacc, nacc, t), null, nacc, null, regacc :> ConcurrentSubRegion, t))))
          | InlinedSubMachineInstance(sub_state = sub, next = null) as t         => loop(sub, subacc => cont(xnode(inlined_subm_inst(subacc, null, t), subacc, null, null, null, t)))
          | InlinedSubMachineInstance(sub_state = sub, next = n) as t            => loop(sub, subacc => 
                                                                                              loop(n, nacc => cont(xnode(inlined_subm_inst(subacc, nacc, t), subacc, nacc, null, null, t))))

          | SubMachine as t                                                      => cont(sub_mach(t))
          | InlinedSubMachine(sub_state = sub, next = null) as t                 => loop(sub, subacc => cont(inlined_fsm(subacc, null, t)))
          | InlinedSubMachine(sub_state = sub, next = n) as t                    => loop(sub, subacc => 
                                                                                              loop(n, nacc => cont(inlined_fsm(subacc, nacc, t))))

        }
      }

      loop(this, x => x)
    }

    public FoldThisSuper(
                state   : FsmState * FsmState * FsmState * State -> FsmState,
                final   : FsmState * FsmState * Final            -> FsmState,
                sub_reg : FsmState * FsmState * FsmState * ConcurrentSubRegion -> FsmState,
                region  : FsmState * FsmState * FsmState * ConcurrentRegion -> FsmState,
                inlined_subm_inst : FsmState * FsmState * FsmState * InlinedSubMachineInstance -> FsmState,
                sub_mach : SubMachine -> FsmState,
                inlined_fsm : FsmState * FsmState * FsmState * InlinedSubMachine -> FsmState
              ) : FsmState
    {

      def xnode(n, sub, nt, nsr, sr, ot)
      {
        match (n)
        {
          | null                            => ot
          | State          as t                                                   
          | InlinedSubMachineInstance as t  
          | InlinedSubMachine as t
          | Final as t                      => t.ChangeSubStateNext(sub, nt)
          | ConcurrentSubRegion as t        => t.ChangeNextSubRegionSubState(nsr, sub)
          | ConcurrentRegion as t           => t.ChangeSubRegionNext(sr, nt)
          | x                               => x
        }
      }

      def loop(st, super, cont)
      {
        match (st)
        {
          | State(sub_state = sub, next = null) as t                             => def super = state(super, null, null, t);
                                                                                    loop(sub, super, subacc => cont(xnode(state(super, subacc, null, t), subacc, null, null, null, t)))
          | State(sub_state = sub, next = n) as t                                => def super = state(null, null, null, t);
                                                                                    loop(sub, super, subacc => 
                                                                                              loop(n, super, nacc => cont(xnode(state(super, subacc, nacc, t), subacc, nacc, null, null, t))))
          | Final(next = null) as t                                              => def super = final(super, null, t);
                                                                                    cont(xnode(final(super, null, t), null, null, null, null, t))
          | Final(next = n) as t                                                 => def super = final(super, null, t);
                                                                                    loop(n, super, nacc => cont(xnode(final(super, nacc, t), null, nacc, null, null, t)))

          | ConcurrentSubRegion(sub_state = sub, next_sub_region = null) as t    => def super = sub_reg(super, null, null, t);
                                                                                    loop(sub, super, subacc => cont(xnode(sub_reg(super, subacc, null, t), subacc, null, null, null, t)))
          | ConcurrentSubRegion(sub_state = sub, next_sub_region = n) as t       => def super = sub_reg(super, null, null, t);
                                                                                    loop(sub, super, subacc => 
                                                                                              loop(n, super, nacc => cont(xnode(sub_reg(super, subacc, nacc, t), subacc, nacc, null, null, t))))
          | ConcurrentRegion(sub_region = reg, next = null)  as t                => def super = region(super, null, null, t);
                                                                                    loop(reg, super, regacc => cont(xnode(region(super, regacc, null, t), null, null, null, regacc :> ConcurrentSubRegion, t)))
          | ConcurrentRegion(sub_region = reg, next = n)  as t                   => def super = region(super, null, null, t);
                                                                                    loop(reg, super, regacc => 
                                                                                              loop(n, super, nacc => cont(xnode(region(super, regacc, nacc, t), null, nacc, null, regacc :> ConcurrentSubRegion, t))))
          | InlinedSubMachineInstance(sub_state = sub, next = null) as t         => def super = inlined_subm_inst(super, null, null, t);
                                                                                    loop(sub, super, subacc => cont(xnode(inlined_subm_inst(super, subacc, null, t), subacc, null, null, null, t)))
          | InlinedSubMachineInstance(sub_state = sub, next = n) as t            => def super = inlined_subm_inst(super, null, null, t);
                                                                                    loop(sub, super, subacc => 
                                                                                              loop(n, super, nacc => cont(xnode(inlined_subm_inst(super, subacc, nacc, t), subacc, nacc, null, null, t))))

          | SubMachine as t                                                      => cont(sub_mach(t))
          | InlinedSubMachine(sub_state = sub, next = null) as t                 => def super = inlined_fsm(super, null, null, t);
                                                                                    loop(sub, super, subacc => cont(inlined_fsm(super, subacc, null, t)))
          | InlinedSubMachine(sub_state = sub, next = n) as t                    => def super = inlined_fsm(super, null, null, t);
                                                                                    loop(sub, super, subacc => 
                                                                                              loop(n, super, nacc => cont(inlined_fsm(super, subacc, nacc, t))))

        }
      }

      loop(this, super_state, x => x)
    }
    
    public Fold[T](
                  state   : T * option[T] * State -> T,
                  final   : option[T] * Final     -> T,
                  sub_reg : T * option[T] * ConcurrentSubRegion -> T,
                  region  : T * option[T] * ConcurrentRegion -> T,
                  inlined_subm_inst : T * option[T] * InlinedSubMachineInstance -> T,
                  sub_mach : SubMachine -> T,
                  inlined_fsm : T * option[T] * InlinedSubMachine -> T
                  ) : T
    {

      def loop(st, cont)
      {
        match (st)
        {
          | State(sub_state = sub, next = null)                 as t             => loop(sub, subacc => cont(state(subacc, None(), t)))
          | State(sub_state = sub, next = n) as t                                => loop(sub, subacc => 
                                                                                                 loop(n, nacc => cont(state(subacc, Some(nacc), t))))
          | Final(next = null) as t                                              => cont(final(None(), t))
          | Final(next = n)    as t                                              => loop(n, nacc => cont(final(Some(nacc), t)))
          | ConcurrentSubRegion(sub_state = sub, next_sub_region = null) as t    => loop(sub, subacc => cont(sub_reg(subacc, None(), t)))
          | ConcurrentSubRegion(sub_state = sub, next_sub_region = n)    as t    => loop(sub, subacc => 
                                                                                                 loop(n, nacc => cont(sub_reg(subacc, Some(nacc), t))))
          | ConcurrentRegion(sub_region = reg, next = null)  as t                => loop(reg, regacc => cont(region(regacc, None(), t)))
          | ConcurrentRegion(sub_region = reg, next = n)  as t                   => loop(reg, regacc => 
                                                                                                 loop(n, nacc => cont(region(regacc, Some(nacc), t))))
          | InlinedSubMachineInstance(sub_state = sub, next = null) as t         => loop(sub, subacc => cont(inlined_subm_inst(subacc, None(), t)))
          | InlinedSubMachineInstance(sub_state = sub, next = n) as t            => loop(sub, subacc => 
                                                                                                 loop(n, nacc => cont(inlined_subm_inst(subacc, Some(nacc), t))))

          | SubMachine as t                                                      => cont(sub_mach(t))
          | InlinedSubMachine(sub_state = sub, next = null) as t                 => loop(sub, subacc => cont(inlined_fsm(subacc, None(), t)))
          | InlinedSubMachine(sub_state = sub, next = n) as t                    => loop(sub, subacc => 
                                                                                                 loop(n, nacc => cont(inlined_fsm(subacc, Some(nacc), t))))
        }
      }

      loop(this, x => x)
    }

    //public UpdateFromTarget(target : TransitionTarget) : FsmState
    //{
    //  def update_pseudo(op, p)
    //  {
    //    | (Choice(name = on), Choice(name = n))
    //    | (Junction(name = on), Junction(name = n))
    //    | (Join(name = on), Join(name = n)) 
    //    | (Merge(name = on), Merge(name = n)) when (on == n)                     => p
    //    | (Terminate(state = on), Terminate(state = n)) when (on.Name == n.Name) => p
    //    | _                                                                      => op
    //  }

    //  match (target)
    //  {
    //    | History(h)       => ChangeHistory(history.Map(x => if (x == h) h else x))
    //    | Final(f)         => ChangeSubStates(sub_states.Map(x => if (f.Name == x.Name) f else x))
    //    | PseudoState(p)   => ChangePseudoStates(pseudo_states.Map(update_pseudo(_, p)))
    //    | _                => this
    //  }
    //}
  }
}
