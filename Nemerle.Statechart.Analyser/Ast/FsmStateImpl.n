using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PseudoStateNode;


  /// <summary>
  /// Description of FsmStateImpl.
  /// </summary>
  [Traversable]
  public partial variant FsmState
  {
    public override ToString() : string { Name }

    public virtual UpdateReference(sub : IEnumerable[FsmState]) : FsmState
    {
      def super  = if (super_state != null) 
                    {
                      statemap.Get(super_state.NativeName)
                    } else super_state;
      //sub_states.Map(x => x.);
      //def super = if (super.AstName == null) super.ChangeName(TopStateName) else super;
      def init = initial.Map(_.UpdateReference());
      def tran = transitions.Map(_.UpdateReference());
      def int_tran = internal_tran.Map(_.UpdateReference());
      def hist   = history.Value.Map(_.UpdateReference());
      def pseudo = pseudo_states.Map(_.UpdateReference());
      ChangePseudoStatesSubStatesHistoryInitialInternalTranTransitionsSuperState(pseudo, sub, TwoOption.FromList(hist), init, int_tran, tran, super)
    }

    //public FormatName() : void
    //{
    //  def name = name.SplitToList('.');
    //  this.name = name.Last();
    //}

    public DefineInitial(st : FsmState) : FsmState
    {
      def init = match (this)
                  {
                    | ConcurrentSubRegion(contained_in = r) => Initial(r, st)
                    | _                                     => Initial(this, st)
                  }
      ChangeInitial(TraverseUtils.SingleElement(init))
    }

    public AddSubState(st : FsmState) : FsmState
    {
      //st.analyser = Analyser;
      if (sub_states.Exists(x => x.Name == st.Name)) this else ChangeSubStates(sub_states.Append(st))//sub_states = sub_states + [st];
    }

    //public DefineTransition(tr : StateTransition) : void
    //{
    //  | Transition as tr => transitions ::= Transition(this, tr)
    //  | Internal   as tr => internal_tran ::= Internal(this, tr)
    //  | Initial    as tr => initial ::= tr
    //  | _ => ()
    //}

    //public SetCopy(ncopy : int) : FsmState
    //{
    //  def st = match (this)
    //           {
    //             | State               as st => State(st, false, ncopy)
    //             | ConcurrentRegion    as st => ConcurrentRegion(st, ncopy)
    //             | ConcurrentSubRegion as st => ConcurrentSubRegion(st, ncopy)
    //             | InlinedSubMachine   as st => InlinedSubMachine(st, ncopy)
    //             | SubMachine          as st => SubMachine(st, ncopy)
    //             | Final               as st => Final(st, false, ncopy)
    //           }

    //  //clones ::= st;
    //  st.ChangeCopyNumCloneFor(ncopy);
    //  //st.FindCopyName();
    //}

    //public clones : list[FsmState] = [];

    public DefineTransitions(tr : IEnumerable[StateTransition]) : FsmState
    {
      def (tran, other)   = tr.PartitionType();
      def (intern, other) = other.PartitionType();
      def (init, _)       = other.PartitionType();
      ChangeInternalTranInitialTransitions(intern, init, tran)
          //  | Transition as tr => transitions ::= Transition(this, tr)
    //  | Internal   as tr => internal_tran ::= Internal(this, tr)
    //  | Initial    as tr => initial ::= tr

      //tr.Iter(DefineTransition)
    }

    //public DefineHistoryPath(st : string, nodes : HistoryPath) : void
    //{
    //  history_paths ::= (st, nodes)
    //}

    //public DefineHistoryPathRecurse(st : string, nodes : HistoryPath) : void
    //{
    //  def reg = this is ConcurrentRegion;
    //  when (Lived || reg) DefineHistoryPath(st, nodes);
    //  when (!reg) sub_states.Iter(x  => x.DefineHistoryPathRecurse(st, nodes))
    //}

    public DeleteTransitions(tr : IEnumerable[StateTransition]) : FsmState
    {
      def (tran, other)     = tr.PartitionType();
      def (int_tran, other) = other.PartitionType();
      def (init, _)         = other.PartitionType();
      def initial           = this.initial.Exclude(init, (x, y) => StateTransition.FullComparer(x, y) == 0);
      def internal_tran     = internal_tran.Exclude(int_tran, (x, y) => StateTransition.FullComparer(x, y) == 0);
      def transitions       = transitions.Exclude(tran, (x, y) => StateTransition.FullComparer(x, y) == 0);
      ChangeInternalTranInitialTransitions(internal_tran, initial, transitions)
    }

    public UpdateTransitions(tr : IEnumerable[StateTransition]) : FsmState
    {
      def (tran, other)     = tr.PartitionType();
      def (int_tran, other) = other.PartitionType();
      def (init, _)         = other.PartitionType();

      def find(tr, trans)
      {
        match (trans.Find(x => x.Num == tr.Num))
        {
          | Some(tr) => tr
          | _        => throw InvalidOperationException("unknown transition")
        }
      }

      def init = initial.Map(find(_, init));
      def tran = transitions.Map(find(_, tran));
      def int_tran = int_tran.Map(find(_, int_tran));
      ChangeInternalTranInitialTransitions(int_tran, init, tran)
    }
    //public DeleteTransitionsNested(tr : list[StateTransition]) : void
    //{
    //  DeleteTransitions(tr);
    //  AllSubStates.Iter(x => x.DeleteTransitionsNested(tr));
    //}

    public TraverseTransitions(an : FsmAnalyser) : FsmState
    {
      def paths = TransitionPaths(this);
      def (trans, paths) = paths.TraverseTransitions(an, true);
      UpdateTransitions(trans).ChangePaths(paths)
    }

    public this(an : FsmAnalyser)
    {
      analyser = an;
    }

    public this(super : FsmState, name : string, analyser : FsmAnalyser, reference : bool = false)
    {
      this(analyser);
      this.name = name;
      this.super_state = super;
      this.reference = reference
    }

    public this(st : StateNode.State, sub : IEnumerable[FsmState], analyser : FsmAnalyser, reference : bool = false)
    {
      this(analyser);
      state = st;
      name = st.name;
      this.reference = reference || state.reference;
      //def st_from_node(n)
      //{
      //  | StateNode.State(type = SubMachine) => SubMachine(n, this)
      //  | State(type = InlinedSubMachine)    => InlinedSubMachine(n, this)
      //  | _                                  => FsmState.State(n, this, false)
      //}
      
      
      when (!reference)
      {
        do_activity = st.do_activity |> StateAction.Do(_.action.ActionList, this, _.flags);
        internal_tran = Internal.Create(this, st.internal_tran);
        entry = st.entry |> StateAction.Entry(_.action.ActionList, this, _.attrib);
        exit = st.exit |> StateAction.Exit(_.action.ActionList, this, _.attrib);
        history = StateHistory.Create(this, st.history);
        transitions = Transition.Create(this, st.transitions);
        initial = st.initial.Select(Initial.Create(this, _));
        //def (regs, subst) = st.sub_states.Partition(x => x.regions.HasValue);
        //def regs = regs |> ConcurrentRegion(this, _, _.regions.Value); // TODO: сделать с помощью st_from_node
        //super_state = super;
        //def subst = (subst |> st_from_node(_)) + regs;
        //sub_states = subst.Sort((x, y) => x.source_pos - y.source_pos);
        sub_states = sub.Map(_.ChangeSuperState(this));
        pseudo_states = st.pseudo_states |> PseudoStateNode.Create(analyser, _.node, this, null)
      }
      Num = analyser.GetNewStateId(this)
    }

    public SetNewId() : FsmState
    {
      ChangeNum(analyser.GetNewStateId(this))
    }
    
    public Real : FsmState
    {
      get
      {
        statemap.Get(this)
      }
    }

    // copy constructor
    public this(st : FsmState)
    {
      name = st.name;
      analyser = st.analyser;
      do_activity = st.do_activity;
      internal_tran = st.internal_tran;
      entry = st.entry;
      exit = st.exit;
      history =  st.history.Map(_.ChangeState(this));
      transitions = st.transitions;
      initial = st.initial;
      super_state = st.super_state;
      sub_states = st.sub_states.Map(_.ChangeSuperState(this));
      pseudo_states = st.pseudo_states;
      Num = st.Num;
    }

    public HistoryPaths : IEnumerable[string * HistoryPath] // paths from outer history
    {
      get
      {
        //def reg = this is ConcurrentRegion;
        //when (Lived || reg) DefineHistoryPath(st, nodes);
        //when (!reg) sub_states.Iter(x  => x.DefineHistoryPathRecurse(st, nodes))
        def shist = SuperStates.Where(x => x.ParticipateInHistory.Exists(x => x.type == HistoryType.Shallow));
        def spaths = shist.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.HistoryPaths));
        def paths = ParticipateInHistory.Select(x => (x.state.name, HistoryPath(x.state, this, x).CreatePath(analyser)));
        paths.Concat(spaths)
      }
    }

    public PathFromOut : StateTransition
    {
      get
      {
        def path = StateTransition.Initial(analyser.TopState, this);
        path.TraversePath(analyser);
      }
    }

    ///// <summary>
    ///// Indicates what fsm lived in this state and it not only composite for others
    ///// </summary>
    //public Lived : bool 
    //{
    //  get
    //  {
    //    lived || clones.Exists(_.Lived)
    //  }
    //}

    public UsedInGenerate : bool
    {
      get
      {
        Lived || !AllLivedSubStates.IsEmpty()
      }
    }

    /// <summary>
    /// Hierarchy position
    /// </summary>
    public hierarchy_pos : int
    {
      get
      {
        SuperStates.Count()
      }
    }

    public source_pos : int
    {
      get
      {
        state.pos
      }
    }

    public IsTopState : bool
    {
      get
      {
        Name == TopStateName
      }
    }

    CopyName : string
    {
      get
      {
        if (copy_num == 0) "" else $"$copy_num"
      }
    }

    public Name : string
    {
      get
      {
        match (this)
        {
          | Final                               => $"$(Super)Final$CopyName"
          | State
          | ConcurrentRegion
          | ConcurrentSubRegion                 => NativeName
          | SubMachine(name = n)                => $"SubMachine$n$CopyName"
          | InlinedSubMachine(name = n)         => $"InlinedSubMachine$n$CopyName"
          | InlinedSubMachineInstance(name = n) => $"InlinedSubMachineInstance$n$CopyName"
        }
      }
    }

    public OriginalName : string
    {
      get
      {
        match (this)
        {
          | ConcurrentSubRegion(index = idx, contained_in = r) => $"$(r)SubRegion$idx"
          | _                                                  => if (name != null) name else AstName
        }
      }
    }

    public NativeName : string
    {
      get
      {
        $"$OriginalName$CopyName"
      }
    }

    public join_completion_transitions : list[StateTransition]
    {
      get
      {
        completion_transitions.Filter(x => x.To is TransitionTarget.PseudoState(Join()))
      }
    }

    public AstName : string
    {
      get
      {
        state.name
      }
    }

    /// <summary>
    /// Events for which reacts state
    /// </summary>
    public events : IEnumerable[StateEvent]
    {
      get
      {
        work_transitions.Select(_.Trigger).Distinct();
        //evts.RemoveDuplicatesSort(_.CompareTo(_))
      }
    }

    /// <summary>
    /// Events for which reacts state or nested states
    /// </summary>
    public events_nested : IEnumerable[StateEvent]
    {
      get
      {
        def evts = AllLivedSubStates.FoldLeft(Enumerable.Empty(), (x, a) => a.Concat(x.events));
        evts.Distinct()
        //def evts = events + ( |>< events);
        //evts.RemoveDuplicatesSort(_.CompareTo(_));
      }
    }

    public SuperStatesInclude : IEnumerable[FsmState]
    {
      get
      {
        SuperStates.AddBefore(this)
      }
    }

    public PartOfStateMachine : option[InlinedSubMachine]
    {
      get
      {
        SuperStatesInclude.FindType()
      }
    }

    public AllHistory : list[StateHistory]
    {
      get
      {
        AllSubStates.FoldLeft([], (x, a) => a.HeadAppend(x.history.Value))
      }
    }

    public PartOfSubRegion : option[ConcurrentSubRegion]
    {
      get
      {
        SuperStatesInclude.FindType()
      }
    }

    public PartOfSubRegions : IEnumerable[ConcurrentSubRegion]
    {
      get
      {
        SuperStatesInclude.FilterType()
      }
    }

    public PartOfTopRegion : option[ConcurrentRegion]
    {
      get
      {
        match (PartOfRegions)
        {
          | [] => None()
          | lst => Some(lst.Last())
        }
      }
    }

    public PartOfRegion : option[ConcurrentRegion]
    {
      get
      {
        SuperStatesInclude.FindType()
      }
    }

    public PartOfRegions : IEnumerable[ConcurrentRegion]
    {
      get
      {
        SuperStatesInclude.FilterType()
      }
    }

    //public GetPathFrom(st : FsmState) : IEnumerable[FsmState]
    //{
    //  def super = SuperStatesInclude.FirstElems(x => x.Name == st.Name);
    //  st :: super.Rev()
    //}

    //public PathName : list[FsmState]
    //{
    //  get
    //  {
    //    (this :: SuperStates.SplitLast()[1]).Rev()
    //  }
    //}

    public static NameComparer : FsmState * FsmState -> int = (x, y) => string.Compare(x.Name, y.Name);

    public PartOfRegionsOf(st : FsmState) : list[ConcurrentRegion]
    {
      SuperStatesInclude.NToList().FirstElems(_ == st).FilterType();
    }

    //public FoldThis(
    //            state   : IEnumerable[FsmState] * State -> FsmState,
    //            final   : Final            -> FsmState,
    //            sub_reg : IEnumerable[FsmState] * ConcurrentSubRegion -> FsmState,
    //            region  : IEnumerable[FsmState] * ConcurrentRegion -> FsmState,
    //            inlined_subm_inst : IEnumerable[FsmState] * InlinedSubMachineInstance -> FsmState,
    //            sub_mach : SubMachine -> FsmState,
    //            inlined_fsm : IEnumerable[FsmState] * InlinedSubMachine -> FsmState
    //          ) : FsmState
    //{

    //  def xnode(n, sub : IEnumerable[FsmState], ot)
    //  {
    //    match (n)
    //    {
    //      | null when (sub != null) => ot.ChangeSubStates(sub)
    //      | t    => t
    //    }
    //  }

    //  def stack = SCG.Stack();

    //  def pop(sub)
    //  {
    //    stack.PopRev(sub)
    //  }

    //  def loop(st, _)
    //  {
    //    match (st)
    //    {
    //      | State(sub_states = sub) as t                        => def sub_acc = pop(sub); 
    //          def acc = if (state != null) xnode(state(sub_acc, t), sub_acc, t) else t.ChangeSubStates(sub_acc);
    //          stack.Push(acc);
    //          acc
    //      | Final as t                                          => def acc = if (final != null) xnode(final(t), null, t) else t;
    //          stack.Push(acc);
    //          acc

    //      | ConcurrentSubRegion(sub_states = sub) as t          => def sub_acc = pop(sub); 
    //          def acc = if (sub_reg != null) xnode(sub_reg(sub_acc, t), sub_acc, t) else t.ChangeSubStates(sub_acc);
    //          stack.Push(acc);
    //          acc

    //      | ConcurrentRegion(sub_regions = reg)  as t           => def regacc = pop(reg |> _ : FsmState);
    //          def acc = if (regacc != null) xnode(region(regacc, t), regacc, t) else t.ChangeSubStates(regacc);
    //          stack.Push(acc);
    //          acc
    //      | InlinedSubMachineInstance(sub_states = sub) as t    => def sub_acc = pop(sub); 
    //          def acc = if (inlined_subm_inst != null) xnode(inlined_subm_inst(sub_acc, t), sub_acc, t) else t.ChangeSubStates(sub_acc);
    //          stack.Push(acc);
    //          acc 
    //      | SubMachine as t                                     => if (sub_mach != null) sub_mach(t) else t;
    //      | InlinedSubMachine(sub_states = sub) as t            => def sub_acc = pop(sub); 
    //          def acc = if (inlined_fsm != null) xnode(inlined_fsm(sub_acc, t), sub_acc, t) else t.ChangeSubStates(sub_acc);
    //          stack.Push(acc);
    //          acc
    //    }
    //  }

    //  Iterator().FoldLeft(null, loop)
    //}

    //public FoldThis[T](an : T,
    //            state   : State * IEnumerable[FsmState] * T -> FsmState * T,
    //            final   : Final * T-> FsmState * T,
    //            sub_reg : ConcurrentSubRegion * IEnumerable[FsmState] * T -> FsmState * T,
    //            region  : ConcurrentRegion * IEnumerable[FsmState] * T -> FsmState * T,
    //            inlined_subm_inst : InlinedSubMachineInstance * IEnumerable[FsmState] * T -> FsmState * T,
    //            sub_mach : SubMachine * T -> FsmState * T,
    //            inlined_fsm : InlinedSubMachine * IEnumerable[FsmState] * T -> FsmState * T
    //          ) : FsmState * T
    //{
    //  def loop(st, sub, an)
    //  {
    //    match (st)
    //    {
    //      | State as t                        => if (state != null) state(t, sub, an) else (null, an);
    //      | Final as t                        => if (final != null) final(t, an) else (null, an);
    //      | ConcurrentSubRegion as t          => if (sub_reg != null) sub_reg(t, sub, an) else (null, an);
    //      | ConcurrentRegion  as t            => if (region != null) region(t, sub, an) else (null, an);
    //      | InlinedSubMachineInstance as t    => if (inlined_subm_inst != null) inlined_subm_inst(t, sub, an) else (null, an);
    //      | SubMachine as t                   => if (sub_mach != null) sub_mach(t, an) else (null, an);
    //      | InlinedSubMachine as t            => if (inlined_fsm != null) inlined_fsm(t, sub, an) else (null, an);
    //    }
    //  }

    //  //def an = Iterator().FoldLeft(an, loop);
    //  FoldThis(an, loop)
    //}

    //public FoldThis(state   : IEnumerable[FsmState] * FsmState -> FsmState) : FsmState
    //{

    //  def xnode(n, ot)
    //  {
    //    match (n)
    //    {
    //      | null => ot
    //      | t    => t
    //    }
    //  }

    //  def stack = SCG.Stack();

    //  def pop(sub)
    //  {
    //    stack.PopRev(sub)
    //  }

    //  def loop(st, _)
    //  {
    //    match (st)
    //    {
    //      | FsmState where (sub_states = sub) as t => def sub_acc = pop(sub); 
    //          def acc = xnode(state(sub_acc, t), t);
    //          stack.Push(acc);
    //          acc
    //    }
    //  }

    //  FoldThis()
    //  //Iterator().FoldLeft(null, loop)
    //}

    //public FoldThis[T](an : T, state   : FsmState * IEnumerable[FsmState] * T -> FsmState * T) : FsmState * T
    //{

    //  //def an = Iterator().FoldLeft(an, loop);
    //  FoldThis(an, state)
    //}

    //public Fold[T](
    //              init : T,
    //              state   : T * State -> T,
    //              final   : T * Final -> T,
    //              sub_reg : T * ConcurrentSubRegion -> T,
    //              region  : T * ConcurrentRegion -> T,
    //              inlined_subm_inst : T * InlinedSubMachineInstance -> T,
    //              sub_mach : T * SubMachine -> T,
    //              inlined_fsm : T * InlinedSubMachine -> T
    //              ) : T
    //{
    //  def loop(st, acc)
    //  {
    //    match (st)
    //    {
    //      | State as t                        => state(acc, t)
    //      | Final as t                        => final(acc, t)
    //      | ConcurrentSubRegion as t          => sub_reg(acc, t)
    //      | ConcurrentRegion  as t            => region(acc, t)
    //      | InlinedSubMachineInstance as t    => inlined_subm_inst(acc, t)
    //      | SubMachine as t                   => sub_mach(acc, t)
    //      | InlinedSubMachine as t            => inlined_fsm(acc, t)
    //    }
    //  }

    //  Iterator().FoldLeft(init, loop)
    //}




    //public Visit[T](ctx : ISingleIteratorContext[FsmState], acc : T) : T
    //{
    //  def ctx = ctx :> FsmStateSingleIteratorContext[T];
    //  match (this)
    //  {
    //      | State as t                        => ctx.state(t, acc)
    //      | Final as t                        => ctx.final(t, acc)
    //      | ConcurrentSubRegion as t          => ctx.sub_reg(t, acc)
    //      | ConcurrentRegion  as t            => ctx.region(t, acc)
    //      | InlinedSubMachineInstance as t    => ctx.inlined_subm_inst(t, acc)
    //      | SubMachine as t                   => ctx.sub_mach(t, acc)
    //      | InlinedSubMachine as t            => ctx.inlined_fsm(t, acc)
    //  }
    //}

    public GetChild() : IEnumerable[FsmState]
    {
      sub_states
    }

    public Rebuild(child : IEnumerable[FsmState]) : FsmState
    {
      ChangeSubStates(child)
    }
    //public UpdateFromTarget(target : TransitionTarget) : FsmState
    //{
    //  def update_pseudo(op, p)
    //  {
    //    | (Choice(name = on), Choice(name = n))
    //    | (Junction(name = on), Junction(name = n))
    //    | (Join(name = on), Join(name = n)) 
    //    | (Merge(name = on), Merge(name = n)) when (on == n)                     => p
    //    | (Terminate(state = on), Terminate(state = n)) when (on.Name == n.Name) => p
    //    | _                                                                      => op
    //  }

    //  match (target)
    //  {
    //    | History(h)       => ChangeHistory(history.Map(x => if (x == h) h else x))
    //    | Final(f)         => ChangeSubStates(sub_states.Map(x => if (f.Name == x.Name) f else x))
    //    | PseudoState(p)   => ChangePseudoStates(pseudo_states.Map(update_pseudo(_, p)))
    //    | _                => this
    //  }
    //}

    public UpdateHistory(hist : StateHistory) : FsmState
    {
      def hist = history.Map(x => if (x.type == hist.type) hist else x);
      ChangeHistory(hist)
    }
  }
}
