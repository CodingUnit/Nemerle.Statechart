using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PseudoStateNode;


  /// <summary>
  /// Description of FsmStateImpl.
  /// </summary>
  [Traversable]
  public partial variant FsmState : IdObject
  {
    public override ToString() : string { Name }


    //public FormatName() : void
    //{
    //  def name = name.SplitToList('.');
    //  this.name = name.Last();
    //}

    public DefineInitial(st : FsmState) : FsmState
    {
      def init = match (this)
                  {
                    | ConcurrentSubRegion(contained_in = r) => Initial(r, st).Create()
                    | _                                     => Initial(this, st).Create()
                  }
      ChangeInitial([init])
    }

    public AddSubState(st : FsmState) : FsmState
    {
      //st.analyser = Analyser;
      if (sub_states.Exists(x => x.Num == st.Num)) this else ChangeSubStates(sub_states.Append(st).NToList())//sub_states = sub_states + [st];
    }

    public DefineTransitions(tr : IEnumerable[StateTransition]) : FsmState
    {
      def (tran : IEnumerable[StateTransition.Transition], other)   = tr.PartitionType();
      def (intern : IEnumerable[StateTransition.Internal], other)   = other.PartitionType();
      def (init : IEnumerable[StateTransition.Initial], _)          = other.PartitionType();
      def intern = internal_tran.Concat(intern.Select(_ : StateTransition));
      def init = initial.Concat(init.Select(_ : StateTransition));
      def tran = transitions.Concat(tran.Select(_ : StateTransition));
      ChangeInternalTranInitialTransitions(intern.NToList(), init.NToList(), tran.NToList())
    }

    public Updated : FsmState
    {
      get
      {
        statemap.Get(this)
        //if (Num == -1) this else statemap[Num]
      }
    }
    
    public DeleteTransitions(tr : IEnumerable[StateTransition]) : FsmState
    {
      def (tran, other)     = tr.PartitionType();
      def (int_tran, other) = other.PartitionType();
      def (init, _)         = other.PartitionType();
      def initial           = initial.Exclude(init, (x, y : StateTransition.Initial) => x.Num == y.Num);
      def internal_tran     = internal_tran.Exclude(int_tran, (x, y : StateTransition.Internal) => x.Num == y.Num);
      def transitions       = transitions.Exclude(tran, (x, y : StateTransition.Transition) => x.Num == y.Num);
      ChangeInternalTranInitialTransitions(internal_tran.NToList(), initial.NToList(), transitions.NToList())
    }

    public UpdateTransitions(tr : IEnumerable[StateTransition]) : FsmState
    {
      def (tran     : IEnumerable[StateTransition.Transition], other) = tr.PartitionType();
      def (int_tran : IEnumerable[StateTransition.Internal], other)   = other.PartitionType();
      def (init     : IEnumerable[StateTransition.Initial], _)        = other.PartitionType();

      def find(tr, trans)
      {
        match (trans.Find(x => x.Num == tr.Num))
        {
          | Some(tr) => tr
          | _        => tr
        }
      }

      def init = initial.Map(find(_, init.Select(_ : StateTransition)));
      def tran = transitions.Map(find(_, tran.Select(_ : StateTransition)));
      def int_tran = int_tran.Map(find(_, int_tran.Select(_ : StateTransition)));
      ChangeInternalTranInitialTransitions(int_tran, init, tran)
    }

    public TraverseTargets(func : TransitionTarget * StateTransition -> TransitionTarget, manual_rebuild : bool = false) : FsmState
    {
      def init = initial.Map(_.TargetTraverse(func, manual_rebuild));
      def tran = transitions.Map(_.TargetTraverse(func, manual_rebuild));
      def int_tran = internal_tran.Map(_.TargetTraverse(func, manual_rebuild));
      ChangeInternalTranInitialTransitions(int_tran, init, tran)
    }
    
    public TraverseTransitions() : FsmState
    {
      def paths = TransitionPaths(this);
      def (trans, paths) = paths.TraverseTransitions(true);
      UpdateTransitions(trans).ChangePaths(paths)
    }

    public this(an : FsmAnalyser)
    {
      analyser = an;
    }

    public this(name : string, analyser : FsmAnalyser)
    {
      //super : FsmState, 
      this(analyser);
      this.name = name;
      //this.super_state = super;
      //this.reference = reference;
      //Num = statemap.GetNewStateId(this)
    }

    public this(st : StateNode.State, sub : IEnumerable[FsmState], analyser : FsmAnalyser)
    {
      this(analyser);
      state = st;
      name = st.name;
      //this.reference = reference || state.reference;
      
      //when (!reference)
      //{
        do_activity = st.do_activity |> StateAction.Do(_.action.actions, _.flags);
        internal_tran = Internal.Create(this, st.internal_tran).NToList();
        entry = st.entry |> StateAction.Entry(_.action.actions, _.attrib);
        exit = st.exit |> StateAction.Exit(_.action.actions, _.attrib);
        history = StateHistory.Create(this, st.history);
        transitions = Transition.Create(this, st.transitions).NToList();
        initial = st.initial.Map(Initial.Create(this, _));
        //def (regs, subst) = st.sub_states.Partition(x => x.regions.HasValue);
        //def regs = regs |> ConcurrentRegion(this, _, _.regions.Value); // TODO: сделать с помощью st_from_node
        //super_state = super;
        //def subst = (subst |> st_from_node(_)) + regs;
        //sub_states = subst.Sort((x, y) => x.source_pos - y.source_pos);
        sub_states = sub.NToList();//.Map(_.ChangeSuperState(this));
        pseudo_states = st.pseudo_states |> PseudoStateNode.Create(this, _.node, analyser.statemap.GetNextGlobalNum())
      //}
      //Num = statemap.GetNewStateId(this)
    }

    public NestedObjects : IEnumerable[IdObject]
    {
      get
      {
        def trans = all_transitions_with_init;
        def obj = trans.Concat(pseudo_states.Select(_ : IdObject));
        def obj = obj.Concat(trans.SelectMany(_.TargetIdObjects));
        def obj = obj.Concat(history.Value);
        def default = history.Value.FoldLeft([], (x, a) => if (x.default is Some(t)) t :: a else a);
        obj.Concat(default)
      }
    }

    public ChildObjects : IEnumerable[IdObject]
    {
      get
      {
        def trans = all_transitions_with_init;
        def obj = trans.Concat(pseudo_states.Select(_ : IdObject));
        def obj = obj.Concat(history.Value);
        def default = history.Value.FoldLeft([], (x, a) => if (x.default is Some(t)) t :: a else a);
        obj.Concat(default)
      }
    }
    
    public ChildNodes : IEnumerable[int]
    {
      get
      {
        ChildObjects.Select(_.Num)
      }
    }
    
    public SetNextStateNum() : FsmState
    {
      SetNum(statemap.GetNextStateNum())
    }

    public SetNum(num : int) : FsmState
    {
      def st = ChangeNum(num);
      statemap.UpdateRefsToParent(st, ChildNodes);
      st
    }
    
    public SetNewId() : FsmState
    {
      SetNum(statemap.GetNextStateNum())
    }
    
    //// copy constructor
    //public this(st : FsmState)
    //{
    //  name = st.name;
    //  analyser = st.analyser;
    //  do_activity = st.do_activity;
    //  internal_tran = st.internal_tran;
    //  entry = st.entry;
    //  exit = st.exit;
    //  //history =  st.history.Map(_.ChangeState(this));
    //  transitions = st.transitions;
    //  initial = st.initial;
    //  //super_state = st.super_state;
    //  sub_states = st.sub_states;//.Map(_.ChangeSuperState(this));
    //  pseudo_states = st.pseudo_states;
    //  Num = st.Num;
    //}

    [NeedChange]
    public HistoryPaths : IEnumerable[string * HistoryPath]; // paths from outer history

    //[NeedChange]
    //public PathFromOut : StateTransition;
    ///// <summary>
    ///// Indicates what fsm lived in this state and it not only composite for others
    ///// </summary>
    //public Lived : bool 
    //{
    //  get
    //  {
    //    lived || clones.Exists(_.Lived)
    //  }
    //}

    public UsedInGenerate : bool
    {
      get
      {
        Lived || !AllLivedSubStates.IsEmpty()
      }
    }

    
    public hierarchy_pos : int
    {
      get
      {
        if (calc_hierarchy_pos != -1) calc_hierarchy_pos else SuperStates.Count()
      }
    }

    public source_pos : int
    {
      get
      {
        state.pos
      }
    }

    public IsTopState : bool
    {
      get
      {
        Num == statemap.TopNum
      }
    }

    CopyName : string
    {
      get
      {
        if (copy_num == 0) "" else $"$copy_num"
      }
    }

    public Name : string
    {
      get
      {
        match (this)
        {
          | Final
          | State
          | ConcurrentRegion
          | ConcurrentSubRegion                 => NativeName
          | SubMachine(name = n)                => $"SubMachine$n$CopyName"
          | InlinedSubMachine(name = n)         => $"InlinedSubMachine$n$CopyName"
          | InlinedSubMachineInstance(name = n) => $"InlinedSubMachineInstance$n$CopyName"
        }
      }
    }

    public OriginalName : string
    {
      get
      {
        match (this)
        {
          | Final                                              => $"$(Super)Final"
          | ConcurrentSubRegion(index = idx, contained_in = r) => $"$(r)SubRegion$idx"
          | _                                                  => if (name != null) name else AstName
        }
      }
    }

    public NativeName : string
    {
      get
      {
        $"$OriginalName$CopyName"
      }
    }

    public join_completion_transitions : IEnumerable[StateTransition]
    {
      get
      {
        completion_transitions.Where(x => x.To is TransitionTarget.PseudoState(Join()))
      }
    }

    public AstName : string
    {
      get
      {
        state.name
      }
    }

    /// <summary>
    /// Events for which reacts state
    /// </summary>
    public events : IEnumerable[StateEvent]
    {
      get
      {
        work_transitions.Select(_.Trigger).Distinct();
      }
    }

    /// <summary>
    /// Events for which reacts state or nested states
    /// </summary>
    public events_nested : IEnumerable[StateEvent]
    {
      get
      {
        def evts = AllLivedSubStates.SelectMany(_.events);
        evts.Distinct()
      }
    }

    public SuperStatesInclude : IEnumerable[FsmState]
    {
      get
      {
        SuperStates.AddBefore(this)
      }
    }

    public PartOfStateMachine : option[InlinedSubMachine]
    {
      get
      {
        SuperStatesInclude.FindType()
      }
    }

    public AllHistory : IEnumerable[StateHistory]
    {
      get
      {
        AllSubStates.SelectMany(x => x.history.Value)
      }
    }

    public PartOfSubRegion : option[ConcurrentSubRegion]
    {
      get
      {
        SuperStatesInclude.FindType()
      }
    }

    public PartOfSubRegions : IEnumerable[ConcurrentSubRegion]
    {
      get
      {
        SuperStatesInclude.FilterType()
      }
    }

    public PartOfTopRegion : option[ConcurrentRegion]
    {
      get
      {
        match (PartOfRegions)
        {
          | []  => None()
          | lst => Some(lst.Last())
        }
      }
    }

    public PartOfRegion : option[ConcurrentRegion]
    {
      get
      {
        SuperStatesInclude.FindType()
      }
    }

    public PartOfRegions : IEnumerable[ConcurrentRegion]
    {
      get
      {
        SuperStatesInclude.FilterType()
      }
    }

    public static NameComparer : FsmState * FsmState -> int = (x, y) => string.Compare(x.Name, y.Name);

    public PartOfRegionsOf(st : FsmState) : list[ConcurrentRegion]
    {
      SuperStatesInclude.NToList().FirstElems(_ == st).FilterType();
    }


    public GetChild() : IEnumerable[FsmState]
    {
      match (this)
      {
        | ConcurrentRegion(sub_regions = r) => r.Select(_ : FsmState)
        | _                                 => sub_states
      }
    }

    public Rebuild(child : IEnumerable[FsmState]) : FsmState
    {
      match (this)
      {
        | ConcurrentRegion as r => r.ChangeSubRegions(child.Map(_ :> FsmState.ConcurrentSubRegion))
        | _                     => ChangeSubStates(child.NToList())
      }
    }

    public UpdateHistory(hist : StateHistory) : FsmState
    {
      def hist = history.Map(x => if (x.type == hist.type) hist else x);
      ChangeHistory(hist)
    }
  }
}
