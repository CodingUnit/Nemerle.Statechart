// fsmstateimpl.n
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PseudoStateNode;
  using ListUtils;

  /// <summary>
  /// Description of FsmStateImpl.
  /// </summary>
  //[RefNode]
  public partial class FsmState : IGeneralTree[FsmState]
  {
    public override ToString() : string { if (name != null) name else AstName }

    public type : StateType;    
    
    public ChildNodes : IEnumerable[FsmState]
    {
      get
      {
        sub_states
      }
    }
    
    public Parent : FsmState
    {
      get
      {
        Super
      }
    }
    
    public Current : FsmState
    {
      get
      {
        this
      }
    }
    
    public static GetCopy(this node : FsmState, _copy : int) : FsmState
    {
      node
      
      /*def get_copy(st, ch)
      {
        def nst = GeneralTree(st.Data);
        nst.AddRange(ch);
        def std = nst.Data;
        //def num = statemap.GetNextGlobalNum();
        //def int_tran = st.InternalTransitions.Iter(x => x.Update .SetNewId());
        //def hist = st.history.Map(_.ChangeNumCopy(statemap.GetNextGlobalNum(), copy));
        //def trans = st.transitions.Map(_.SetNewId());
        //def init  = st.initial.Map(_.SetNewId());
        def an = std.analyser;
        def pseudo = st.PseudoStates().Map(x => x.Clone(x => x.Clone()));
        def tran   = st.AllTransitions().Map(x => x.Clone(x => x.Clone()));
        pseudo.Iter(x => x.Update(x => x.ChangeCopy(copy)));
        an.PseudoStates.Add(nst, pseudo);
        an.statemap.Transitions.Add(nst, tran);
        nst.Update(x => x.ChangeCopyNum(copy));
        an.Clones[st] = if (an.Clones.ContainsKey(st)) nst :: an.Clones[st] else  nst :: [];
        nst
        //st.ChangeNumHistoryPseudoStatesCloneForInitialInternalTranTransitionsCopyNum(num, hist, pseudo, st, init, int_tran, trans, copy)
      }

      //def node = node.Clone();
      def st = node.Reduce(get_copy);

      def old_pseudo  = node.AllPseudo();
      def new_pseudo  = st.AllPseudo();

      def pseudo_map = Map(old_pseudo.ZipLazy(new_pseudo));
      //def pseudo_id_map = old_pseudo.MakeArrayMap(new_pseudo, statemap.GlobalId, _.Num);
      //def states_id_map = node.AllStates().MakeArrayMap(st.AllStates(), statemap.GlobalId, _.Num);
      //states_id_map[Num] = to;
      
      def update_junction(j)
      {
        | Junction(tree = t) as j => t.GetBreadthFirstEnumerable().Iter(x => x.Update(x => x.ChangeJunc(pseudo_map.Get(x.junc)))); 
                                     j
        | _                       => j                             
      }
      
      def retarget_transitions(s)
      {
        def check_target(tar)
        {
          | TransitionTarget.State(st) as t               => t.ChangeState(st.Analyser().Clones[st].Head)
              //| Qualified(_, State(state = st) as t)                  => t.ChangeStateNum(find_state(st))
              //| Final(st) as t                         => t.ChangeStateNum(find_state(st))          
          | PseudoState(NodeValue(Value = Junction) as n) as t => def j = pseudo_map.Get(n);
                                                                  j.Update(update_junction);
                                                                  t//t.ChangeNode(p => p.ChangeNumCopy(statemap.GetNextGlobalNum(), copy))
          | PseudoState(node) as t                        => def pseudo = pseudo_map.Get(node);
                                                             def t = t.ChangeNode(pseudo);//t.node.Fix(pseudo_id_map[node.Num].Num)) 
                                                             t
                                                                        //t
          | _                                             => null
        }

        //def check_tran(tr)
        //{
        //  tr.TargetTraverse((x, _) => check_target(x))
        //}

        //def s        = s.AllTransitions().Iter(x : StateTransition => x.Update(y => check_target(y.To)));
        //def hist     = s.history.Map(_.ChangeDefault(check_tran));
        //s.ChangeHistory(hist)
        //s.Data
        s.AllTransitions().Iter(x => x.Update(x => x.TargetTraverse(check_target)))
      }

      st.AllStates().Iter(retarget_transitions); // retarget transitions to new place state
      st*/
    }
    
    public this(an : FsmAnalyser, type : StateType)
    {
      analyser = an;
      this.type = type;
      statemap.Bind(this);
    }

    public this(name : string, an : FsmAnalyser, type : StateType)
    {
      analyser  = an;
      this.type = type;
      this.name = name;
      statemap.Bind(this);
    }

    public this(st : StateNode.State, sb : IEnumerable[FsmState], an : FsmAnalyser)
    {
      analyser       = an;
      this.type      = st.type;
      this.name      = st.name;
      state          = st;
      sub_states     = sb.NToList();
      def tran       = st.transitions;
      transitions    = StateTransition.Create(this, tran).NToList();
      pseudo_states  = st.pseudo_states.Map(x => PseudoStateNode.Create(this, x.node));
      do_activity    = st.do_activity.Map(x => StateAction.Do(x.action.actions, this, x.flags, false));
      entry          = st.entry.Map(x => StateAction.Entry(x.action.actions, this, x.attrib));
      exit           = st.exit.Map(x => StateAction.Exit(x.action.actions, this, x.attrib));
      sub_states.Iter(x => x.Super = this); // set superstate to this
      statemap.Bind(this);
    }
   
    public source_pos : int
    {
      get
      {
        state.pos
      }
    }
   
    public CopyName : string
    {
      get
      {
        if (copy_num == 0) "" else $"$copy_num"
      }
    }
    

    public AstName : string
    {
      get
      {
        state.name
      }
    }

    public static NameComparer(x : FsmState, y : FsmState) : int { string.Compare(x.Name, y.Name) }

    
  }
}
