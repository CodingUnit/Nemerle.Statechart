using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PseudoStateNode;
  using ListUtils;

  /// <summary>
  /// Description of FsmStateImpl.
  /// </summary>
  //[RefNode]
  public partial variant FsmState
  {
    public override ToString() : string { Name }

    public static GetCopy(this node : SimpleTreeNode[FsmState], to : FsmState, copy : int) : FsmState
    {
      def statemap = node.Value.statemap;
      
      def get_copy(st)
      {
        def st = st.Value;
        def num = statemap.GetNextGlobalNum();
        def int_tran = st.internal_tran.Map(_.SetNewId());
        def hist = st.history.Map(_.ChangeNumCopy(statemap.GetNextGlobalNum(), copy));
        def trans = st.transitions.Map(_.SetNewId());
        def init  = st.initial.Map(_.SetNewId());
        def pseudo = st.pseudo_states.Map(_.ChangeNumCopy(statemap.GetNextGlobalNum(), copy));
        st.ChangeNumHistoryPseudoStatesCloneForInitialInternalTranTransitionsCopyNum(num, hist, pseudo, st, init, int_tran, trans, copy)
      }

      def node = node.Clone();
      node.Reduce(get_copy);

      def old_pseudo  = node.Value.AllPseudo;
      def new_pseudo  = st.AllPseudo;

      def pseudo_id_map = old_pseudo.MakeArrayMap(new_pseudo, statemap.GlobalId, _.Num);
      def states_id_map = AllStates.MakeArrayMap(st.AllStates, statemap.GlobalId, _.Num);
      states_id_map[Num] = to;
      
      def retarget_transitions(s, _)
      {
        def check_target(tar)
        {
          | TransitionTarget.State(st) as t               => t.ChangeValue(t.value.Fix(states_id_map[st.Id].Num))
              //| Qualified(_, State(state = st) as t)                  => t.ChangeStateNum(find_state(st))
              //| Final(st) as t                         => t.ChangeStateNum(find_state(st))          
          // TODO: copy unnamed junctions to states
          //| PseudoState(ReferenceNode(Value = Junction(IsUnnamed = true))) as t => t.ChangeNode(p => p.ChangeNumCopy(statemap.GetNextGlobalNum(), copy))
          | PseudoState(ReferenceNode(Value = node)) as t => t.ChangeNode(TransitionTarget.CreatePseudoRef(states_id_map[node.state.Num], pseudo_id_map[node.Num]))//t.node.Fix(pseudo_id_map[node.Num].Num)) 
                                                                        //t
          | _                                             => null
        }

        def check_tran(tr)
        {
          tr.TargetTraverse((x, _) => check_target(x))
        }

        def s        = s.TraverseTargets((x, _) => check_target(x));
        def hist     = s.history.Map(_.ChangeDefault(check_tran));
        s.ChangeHistory(hist)
      }

      st.ReduceSingle(retarget_transitions); // retarget transitions to new place state
    }

    //public FormatName() : void
    //{
    //  def name = name.SplitToList('.');
    //  this.name = name.Last();
    //}


   
    //public UpdateTransition(tr : StateTransition) : FsmState
    //{
    //  def find(t)
    //  {
    //    if (t.Num == tr.Num) tr else t
    //  }

    //  TransitionMap(find)
    //}
   
    //public UpdateTransitions(tr : IEnumerable[StateTransition]) : FsmState
    //{
    //  def find(tr, trans)
    //  {
    //    match (trans.Find(x => x.Num == tr.Num))
    //    {
    //      | Some(tr) => tr
    //      | _        => tr
    //    }
    //  }

    //  TransitionMap(find(_, tr))
    //}

    public TraverseTargets(func : TransitionTarget * StateTransition -> TransitionTarget, manual_rebuild : bool = false) : FsmState
    {
      TransitionMap(_.TargetTraverse(func, manual_rebuild))
    }

    public TraverseTransitions() : FsmState
    {
      def paths = TransitionPaths(this);
      def (trans, paths) = paths.TraverseTransitions(true);
      UpdateTransitions(trans).ChangePaths(paths)
    }

    public TransitionMap(tran_func : StateTransition -> StateTransition) : FsmState
    {
      def init = initial.Map(tran_func);
      def tran = transitions.Map(tran_func);
      def int_tran = internal_tran.Map(tran_func);
      ChangeTransitionsInitialInternalTran(tran, init, int_tran)
    }
    
    public this(an : FsmAnalyser)
    {
      analyser = an;
    }

    public this(name : string, analyser : FsmAnalyser)
    {
      //super : FsmState, 
      this(analyser);
      this.name = name;
      //this.super_state = super;
      //this.reference = reference;
      //Num = statemap.GetNewStateId(this)
    }

    public this(st : StateNode.State, sub : IEnumerable[FsmState], analyser : FsmAnalyser)
    {
      this(analyser);
      state = st;
      name = st.name;
      //this.reference = reference || state.reference;

      //when (!reference)
      //{
      do_activity = st.do_activity |> StateAction.Do(_.action.actions, _.flags);
      //internal_tran = Internal.Create(this, st.internal_tran).NToList();
      entry = st.entry |> StateAction.Entry(_.action.actions, _.attrib);
      exit = st.exit |> StateAction.Exit(_.action.actions, _.attrib);
      //history = PseudoStateNode.History.Create(this, st.history);
      //transitions = Transition.Create(this, st.transitions).NToList();
      //initial = st.initial.Map(Initial.Create(this, _));
        //def (regs, subst) = st.sub_states.Partition(x => x.regions.HasValue);
        //def regs = regs |> ConcurrentRegion(this, _, _.regions.Value); // TODO: сделать с помощью st_from_node
        //super_state = super;
        //def subst = (subst |> st_from_node(_)) + regs;
        //sub_states = subst.Sort((x, y) => x.source_pos - y.source_pos);
      //sub_states = sub.NToList();//.Map(_.ChangeSuperState(this));
      //pseudo_states = st.pseudo_states |> PseudoStateNode.Create(this, _.node, analyser.statemap.GetNextGlobalNum())
      //}
      //Num = statemap.GetNewStateId(this)
    }

    //public NestedObjects : IEnumerable[IdObject]
    //{
    //  get
    //  {
    //    def obj = all_transitions_with_init.SelectMany(_.TargetIdObjects);
    //    all_transitions_with_init + ChildPseudo + DefaultTransitions + obj
    //  }
    //}

    //public GetPseudo(num : int) : PseudoStateNode
    //{
    // ChildPseudo.Find(x => x.Num == num).WithDefault(null)
    //}
    
    //public ChangePseudo(num : int, func : PseudoStateNode -> PseudoStateNode) : FsmState
    //{
    //  PseudoMap(x => if (x.Num == num) func(x) else x)
    //}
    
    //public PseudoMap(func : PseudoStateNode -> PseudoStateNode) : FsmState
    //{
    //  def st = HistoryMap(x => func(x) :> PseudoStateNode.History);
    //  ChangePseudoStates(st.pseudo_states.Map(func))
    //  //def pseudo = ChildPseudo.Select(func);
    //}
    
    
    //public AddPseudo(node : PseudoStateNode) : FsmState
    //{
    //  ChangePseudoStates(pseudo_states.Append(node).NToList())
    //}
    
    //public ChildPseudo : IEnumerable[PseudoStateNode]
    //{
    //  get
    //  {
    //    history.Value + pseudo_states
    //  }
    //}

    //public ChildObjects : IEnumerable[IdObject]
    //{
    //  get
    //  {
    //    all_transitions_with_init + ChildPseudo + DefaultTransitions
    //  }
    //}

    public DefaultTransitions : IEnumerable[StateTransition]
    {
      get
      {
        history.Value.FoldLeft([], (x, a) => if (x.default is Some(t)) t :: a else a);
      }
    }

    public AllChilds : IEnumerable[int]
    {
      get
      {
        sub_states.Select(_.Num) + ChildNodes
      }
    }
    
    public ChildNodes : IEnumerable[int]
    {
      get
      {
        ChildObjects.Select(_.Num)
      }
    }

    //public SetNum(num : int) : FsmState
    //{
    //  def st = ChangeNum(num);
    //  statemap.UpdateRefsToParent(st);
    //  st
    //}

    public SetNewId() : FsmState
    {
      ChangeNum(statemap.GetNextGlobalNum())
    }

    public ChangeHistory(h : PseudoStateNode.History) : FsmState
    {
      def check_hist(hist)
      {
        if (hist.Num == h.Num)
        {
          h
        } else hist
      }
      
      HistoryMap(check_hist)
    }

    public ChangeHistory(num : int, h : PseudoStateNode -> PseudoStateNode) : FsmState
    {
      def check_hist(hist)
      {
        if (hist.Num == num)
        {
          h(hist) :> PseudoStateNode.History
        } else hist
      }
      
      HistoryMap(check_hist)
    }
    
    public HistoryMap(hist : PseudoStateNode.History -> PseudoStateNode.History) : FsmState
    {
      ChangeHistory(history.Map(hist))
    }
    //// copy constructor
    //public this(st : FsmState)
    //{
    //  name = st.name;
    //  analyser = st.analyser;
    //  do_activity = st.do_activity;
    //  internal_tran = st.internal_tran;
    //  entry = st.entry;
    //  exit = st.exit;
    //  //history =  st.history.Map(_.ChangeState(this));
    //  transitions = st.transitions;
    //  initial = st.initial;
    //  //super_state = st.super_state;
    //  sub_states = st.sub_states;//.Map(_.ChangeSuperState(this));
    //  pseudo_states = st.pseudo_states;
    //  Num = st.Num;
    //}



    //[NeedChange]
    //public PathFromOut : StateTransition;
    ///// <summary>
    ///// Indicates what fsm lived in this state and it not only composite for others
    ///// </summary>
    //public Lived : bool 
    //{
    //  get
    //  {
    //    lived || clones.Exists(_.Lived)
    //  }
    //}

    public UsedInGenerate : bool
    {
      get
      {
        Lived || !AllLivedSubStates.IsEmpty()
      }
    }


    public hierarchy_pos : int
    {
      get
      {
        if (calc_hierarchy_pos != -1) calc_hierarchy_pos else SuperStates.Count()
      }
    }

    public source_pos : int
    {
      get
      {
        state.pos
      }
    }

    public IsTopState : bool
    {
      get
      {
        Num == statemap.TopNum
      }
    }

    CopyName : string
    {
      get
      {
        if (copy_num == 0) "" else $"$copy_num"
      }
    }

    public Name : string
    {
      get
      {
        match (this)
        {
          | Final
          | State
          | ConcurrentRegion
          | ConcurrentSubRegion                 => NativeName
          | SubMachine(name = n)                => $"SubMachine$n$CopyName"
          | InlinedSubMachine(name = n)         => $"InlinedSubMachine$n$CopyName"
          | InlinedSubMachineInstance(name = n) => $"InlinedSubMachineInstance$n$CopyName"
        }
      }
    }

    public OriginalName : string
    {
      get
      {
        match (this)
        {
          | Final                                              => $"$(Super)Final"
          | ConcurrentSubRegion(index = idx, contained_in = r) => $"$(r)SubRegion$idx"
          | _                                                  => if (name != null) name else AstName
        }
      }
    }

    public NativeName : string
    {
      get
      {
        $"$OriginalName$CopyName"
      }
    }

    public join_completion_transitions : IEnumerable[StateTransition]
    {
      get
      {
        completion_transitions.Where(x => x.To is TransitionTarget.PseudoState(ReferenceNode(Value = Join)))
      }
    }

    public AstName : string
    {
      get
      {
        state.name
      }
    }

    /// <summary>
    /// Events for which reacts state
    /// </summary>
    public events : IEnumerable[StateEvent]
    {
      get
      {
        work_transitions.Select(_.Trigger).Distinct();
      }
    }



    public static NameComparer : FsmState * FsmState -> int = (x, y) => string.Compare(x.Name, y.Name);



    //public GetChild() : IEnumerable[FsmState]
    //{
    //  match (this)
    //  {
    //    | ConcurrentRegion(sub_regions = r) => r.Select(_ : FsmState)
    //    | _                                 => sub_states
    //  }
    //}

    //public Rebuild(child : IEnumerable[FsmState]) : FsmState
    //{
    //  match (this)
    //  {
    //    | ConcurrentRegion as r => r.ChangeSubRegions(child.Map(_ :> FsmState.ConcurrentSubRegion))
    //    | _                     => ChangeSubStates(child.NToList())
    //  }
    //}

    public UpdateHistory(hist : PseudoStateNode.History) : FsmState
    {
      def hist = history.Map(x => if (x.type == hist.type) hist else x);
      ChangeHistory(hist)
    }
  }
}
