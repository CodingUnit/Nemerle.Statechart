using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PseudoStateNode;
  using ListUtils;

  /// <summary>
  /// Description of FsmStateImpl.
  /// </summary>
  [RefNode]
  [Traversable]
  public partial variant FsmState : IdObject
  {
    public override ToString() : string { Name }

    public GetCopy(copy : int) : FsmState
    {
      def get_copy(st, _)
      {
        def num = statemap.GetNextGlobalNum();
        def int_tran = st.internal_tran.Map(_.SetNewId());
        def hist = st.history.Map(_.ChangeNumCopy(statemap.GetNextGlobalNum(), copy));
        def trans = st.transitions.Map(_.SetNewId());
        def init  = st.initial.Map(_.SetNewId());
        def pseudo = st.pseudo_states.Map(_.ChangeNumCopy(statemap.GetNextGlobalNum(), copy));
        st.ChangeNumHistoryPseudoStatesCloneForInitialInternalTranTransitionsCopyNum(num, hist, pseudo, st, init, int_tran, trans, copy)
      }

      def st = ReduceSingle(get_copy);

      def old_pseudo  = AllPseudo;
      def new_pseudo  = st.AllPseudo;

      def pseudo_id_map = old_pseudo.MakeArrayMap(new_pseudo, statemap.GlobalId, _.Num);
      def states_id_map = AllStates.MakeArrayMap(st.AllStates, statemap.GlobalId, _.Num);

      def retarget_transitions(s, _)
      {
        def check_target(tar)
        {
          | TransitionTarget.State(st) as t              => t.ChangeState(states_id_map[st.Num])
              //| Qualified(_, State(state = st) as t)                  => t.ChangeStateNum(find_state(st))
              //| Final(st) as t                         => t.ChangeStateNum(find_state(st))          
          | PseudoState(Junction(IsUnnamed = true)) as t => t.ChangeNode(p => p.ChangeNumCopy(statemap.GetNextGlobalNum(), copy))
          | PseudoState(node) as t                       => t.ChangeNode(pseudo_id_map[node.Num]); 
                                                                        //t
          | _                                            => null
        }

        def check_tran(tr)
        {
          tr.TargetTraverse((x, _) => check_target(x))
        }

        def s        = s.TraverseTargets((x, _) => check_target(x));
        def hist     = s.history.Map(_.ChangeDefault(check_tran));
        s.ChangeHistory(hist)
      }

      st.ReduceSingle(retarget_transitions); // retarget transitions to new place state
    }

    //public FormatName() : void
    //{
    //  def name = name.SplitToList('.');
    //  this.name = name.Last();
    //}

    public DefineInitial(st : FsmState) : FsmState
    {
      def init = match (this)
                  {
                    | ConcurrentSubRegion(contained_in = r) => Initial(r, st).Create()
                    | _                                     => Initial(this, st).Create()
                  }
      ChangeInitial([init])
    }

    public AddSubState(st : FsmState) : FsmState
    {
      //st.analyser = Analyser;
      if (sub_states.Exists(x => x.Num == st.Num)) this else ChangeSubStates(sub_states.Append(st).NToList())//sub_states = sub_states + [st];
    }

    public DefineTransitions(tr : IEnumerable[StateTransition]) : FsmState
    {
      def (tran : IEnumerable[StateTransition.Transition], other)   = tr.PartitionType();
      def (intern : IEnumerable[StateTransition.Internal], other)   = other.PartitionType();
      def (init : IEnumerable[StateTransition.Initial], _)          = other.PartitionType();
      def intern = internal_tran + intern.Select(_ : StateTransition);
      def init = initial + init.Select(_ : StateTransition);
      def tran = transitions + tran.Select(_ : StateTransition);
      ChangeTransitionsInitialInternalTran(tran.NToList(), init.NToList(), intern.NToList())
    }

    public Updated : FsmState
    {
      get
      {
        statemap.Get(this)
        //if (Num == -1) this else statemap[Num]
      }
    }

    public DeleteTransitions(tr : IEnumerable[StateTransition]) : FsmState
    {
      def (tran, other)     = tr.PartitionType();
      def (int_tran, other) = other.PartitionType();
      def (init, _)         = other.PartitionType();
      def initial           = initial.Exclude(init, (x, y : StateTransition.Initial) => x.Num == y.Num);
      def internal_tran     = internal_tran.Exclude(int_tran, (x, y : StateTransition.Internal) => x.Num == y.Num);
      def transitions       = transitions.Exclude(tran, (x, y : StateTransition.Transition) => x.Num == y.Num);
      ChangeTransitionsInitialInternalTran(transitions.NToList(), initial.NToList(), internal_tran.NToList())
    }

    public UpdateTransitions(tr : IEnumerable[StateTransition]) : FsmState
    {
      def (tran     : IEnumerable[StateTransition.Transition], other) = tr.PartitionType();
      def (int_tran : IEnumerable[StateTransition.Internal], other)   = other.PartitionType();
      def (init     : IEnumerable[StateTransition.Initial], _)        = other.PartitionType();

      def find(tr, trans)
      {
        match (trans.Find(x => x.Num == tr.Num))
        {
          | Some(tr) => tr
          | _        => tr
        }
      }

      def init = initial.Map(find(_, init.Select(_ : StateTransition)));
      def tran = transitions.Map(find(_, tran.Select(_ : StateTransition)));
      def int_tran = int_tran.Map(find(_, int_tran.Select(_ : StateTransition)));
      ChangeTransitionsInitialInternalTran(tran, init, int_tran)
    }

    public TraverseTargets(func : TransitionTarget * StateTransition -> TransitionTarget, manual_rebuild : bool = false) : FsmState
    {
      TransitionMap(_.TargetTraverse(func, manual_rebuild))
    }

    public TraverseTransitions() : FsmState
    {
      def paths = TransitionPaths(this);
      def (trans, paths) = paths.TraverseTransitions(true);
      UpdateTransitions(trans).ChangePaths(paths)
    }

    public TransitionMap(tran_func : StateTransition -> StateTransition) : FsmState
    {
      def init = initial.Map(tran_func);
      def tran = transitions.Map(tran_func);
      def int_tran = internal_tran.Map(tran_func);
      ChangeTransitionsInitialInternalTran(tran, init, int_tran)
    }
    
    public this(an : FsmAnalyser)
    {
      analyser = an;
    }

    public this(name : string, analyser : FsmAnalyser)
    {
      //super : FsmState, 
      this(analyser);
      this.name = name;
      //this.super_state = super;
      //this.reference = reference;
      //Num = statemap.GetNewStateId(this)
    }

    public this(st : StateNode.State, sub : IEnumerable[FsmState], analyser : FsmAnalyser)
    {
      this(analyser);
      state = st;
      name = st.name;
      //this.reference = reference || state.reference;

      //when (!reference)
      //{
      do_activity = st.do_activity |> StateAction.Do(_.action.actions, _.flags);
      internal_tran = Internal.Create(this, st.internal_tran).NToList();
      entry = st.entry |> StateAction.Entry(_.action.actions, _.attrib);
      exit = st.exit |> StateAction.Exit(_.action.actions, _.attrib);
      history = PseudoStateNode.History.Create(this, st.history);
      transitions = Transition.Create(this, st.transitions).NToList();
      initial = st.initial.Map(Initial.Create(this, _));
        //def (regs, subst) = st.sub_states.Partition(x => x.regions.HasValue);
        //def regs = regs |> ConcurrentRegion(this, _, _.regions.Value); // TODO: сделать с помощью st_from_node
        //super_state = super;
        //def subst = (subst |> st_from_node(_)) + regs;
        //sub_states = subst.Sort((x, y) => x.source_pos - y.source_pos);
      sub_states = sub.NToList();//.Map(_.ChangeSuperState(this));
      pseudo_states = st.pseudo_states |> PseudoStateNode.Create(this, _.node, analyser.statemap.GetNextGlobalNum())
      //}
      //Num = statemap.GetNewStateId(this)
    }

    public NestedObjects : IEnumerable[IdObject]
    {
      get
      {
        def obj = all_transitions_with_init.SelectMany(_.TargetIdObjects);
        all_transitions_with_init + ChildPseudo + DefaultTransitions + obj
      }
    }

    public ChildPseudo : IEnumerable[PseudoStateNode]
    {
      get
      {
        history.Value + pseudo_states
      }
    }

    public ChildObjects : IEnumerable[IdObject]
    {
      get
      {
        all_transitions_with_init + ChildPseudo + DefaultTransitions
      }
    }

    public DefaultTransitions : IEnumerable[StateTransition]
    {
      get
      {
        history.Value.FoldLeft([], (x, a) => if (x.default is Some(t)) t :: a else a);
      }
    }

    public ChildNodes : IEnumerable[int]
    {
      get
      {
        ChildObjects.Select(_.Num)
      }
    }

    public SetNum(num : int) : FsmState
    {
      def st = ChangeNum(num);
      statemap.UpdateRefsToParent(st, ChildNodes);
      st
    }

    public SetNewId() : FsmState
    {
      SetNum(statemap.GetNextGlobalNum())
    }

    public ChangeHistory(h : PseudoStateNode.History) : FsmState
    {
      def check_hist(hist)
      {
        if (hist.Num == h.Num)
        {
          h
        } else hist
      }
      
      HistoryMap(check_hist)
    }
    
    public HistoryMap(hist : PseudoStateNode.History -> PseudoStateNode.History) : FsmState
    {
      ChangeHistory(history.Map(hist))
    }
    //// copy constructor
    //public this(st : FsmState)
    //{
    //  name = st.name;
    //  analyser = st.analyser;
    //  do_activity = st.do_activity;
    //  internal_tran = st.internal_tran;
    //  entry = st.entry;
    //  exit = st.exit;
    //  //history =  st.history.Map(_.ChangeState(this));
    //  transitions = st.transitions;
    //  initial = st.initial;
    //  //super_state = st.super_state;
    //  sub_states = st.sub_states;//.Map(_.ChangeSuperState(this));
    //  pseudo_states = st.pseudo_states;
    //  Num = st.Num;
    //}

    [NeedChange]
    public HistoryPaths : IEnumerable[string * HistoryPath]; // paths from outer history

    //[NeedChange]
    //public PathFromOut : StateTransition;
    ///// <summary>
    ///// Indicates what fsm lived in this state and it not only composite for others
    ///// </summary>
    //public Lived : bool 
    //{
    //  get
    //  {
    //    lived || clones.Exists(_.Lived)
    //  }
    //}

    public UsedInGenerate : bool
    {
      get
      {
        Lived || !AllLivedSubStates.IsEmpty()
      }
    }


    public hierarchy_pos : int
    {
      get
      {
        if (calc_hierarchy_pos != -1) calc_hierarchy_pos else SuperStates.Count()
      }
    }

    public source_pos : int
    {
      get
      {
        state.pos
      }
    }

    public IsTopState : bool
    {
      get
      {
        Num == statemap.TopNum
      }
    }

    CopyName : string
    {
      get
      {
        if (copy_num == 0) "" else $"$copy_num"
      }
    }

    public Name : string
    {
      get
      {
        match (this)
        {
          | Final
          | State
          | ConcurrentRegion
          | ConcurrentSubRegion                 => NativeName
          | SubMachine(name = n)                => $"SubMachine$n$CopyName"
          | InlinedSubMachine(name = n)         => $"InlinedSubMachine$n$CopyName"
          | InlinedSubMachineInstance(name = n) => $"InlinedSubMachineInstance$n$CopyName"
        }
      }
    }

    public OriginalName : string
    {
      get
      {
        match (this)
        {
          | Final                                              => $"$(Super)Final"
          | ConcurrentSubRegion(index = idx, contained_in = r) => $"$(r)SubRegion$idx"
          | _                                                  => if (name != null) name else AstName
        }
      }
    }

    public NativeName : string
    {
      get
      {
        $"$OriginalName$CopyName"
      }
    }

    public join_completion_transitions : IEnumerable[StateTransition]
    {
      get
      {
        completion_transitions.Where(x => x.To is TransitionTarget.PseudoState(Join()))
      }
    }

    public AstName : string
    {
      get
      {
        state.name
      }
    }

    /// <summary>
    /// Events for which reacts state
    /// </summary>
    public events : IEnumerable[StateEvent]
    {
      get
      {
        work_transitions.Select(_.Trigger).Distinct();
      }
    }

    /// <summary>
    /// Events for which reacts state or nested states
    /// </summary>
    public events_nested : IEnumerable[StateEvent]
    {
      get
      {
        def evts = AllLivedSubStates.SelectMany(_.events);
        evts.Distinct()
      }
    }

    public SuperStatesInclude : IEnumerable[FsmState]
    {
      get
      {
        SuperStates.AddBefore(this)
      }
    }

    public PartOfStateMachine : option[InlinedSubMachine]
    {
      get
      {
        SuperStatesInclude.FindType()
      }
    }

    public AllPseudo  : IEnumerable[PseudoStateNode]
    {
      get
      {
        AllStates.SelectMany(_.ChildPseudo)
      }
    }

    public AllHistory : IEnumerable[PseudoStateNode.History]
    {
      get
      {
        AllSubStates.SelectMany(x => x.history.Value)
      }
    }

    public PartOfSubRegion : option[ConcurrentSubRegion]
    {
      get
      {
        SuperStatesInclude.FindType()
      }
    }

    public PartOfSubRegions : IEnumerable[ConcurrentSubRegion]
    {
      get
      {
        SuperStatesInclude.FilterType()
      }
    }

    public PartOfTopRegion : option[ConcurrentRegion]
    {
      get
      {
        match (PartOfRegions)
        {
          | []  => None()
          | lst => Some(lst.Last())
        }
      }
    }

    public PartOfRegion : option[ConcurrentRegion]
    {
      get
      {
        SuperStatesInclude.FindType()
      }
    }

    public PartOfRegions : IEnumerable[ConcurrentRegion]
    {
      get
      {
        SuperStatesInclude.FilterType()
      }
    }

    public static NameComparer : FsmState * FsmState -> int = (x, y) => string.Compare(x.Name, y.Name);

    public PartOfRegionsOf(st : FsmState) : list[ConcurrentRegion]
    {
      SuperStatesInclude.NToList().FirstElems(_ == st).FilterType();
    }


    public GetChild() : IEnumerable[FsmState]
    {
      match (this)
      {
        | ConcurrentRegion(sub_regions = r) => r.Select(_ : FsmState)
        | _                                 => sub_states
      }
    }

    public Rebuild(child : IEnumerable[FsmState]) : FsmState
    {
      match (this)
      {
        | ConcurrentRegion as r => r.ChangeSubRegions(child.Map(_ :> FsmState.ConcurrentSubRegion))
        | _                     => ChangeSubStates(child.NToList())
      }
    }

    public UpdateHistory(hist : PseudoStateNode.History) : FsmState
    {
      def hist = history.Map(x => if (x.type == hist.type) hist else x);
      ChangeHistory(hist)
    }
  }
}
