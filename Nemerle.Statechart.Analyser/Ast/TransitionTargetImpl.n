using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  using PseudoStateModelNode;
  using FsmState;
  using PseudoStateNode;
  using ListUtils;

  /// <summary>
  /// Description of TransitionTargetImpl.
  /// </summary>
  public partial variant TransitionTarget
  {
    
    public static Create(tran : StateTransition, st : FsmState, target : TargetType) : TransitionTarget
    {
      //def an = st.analyser;
      match (target)
      {
        | PseudoState as t                  => PseudoState(tran, st, t)
        | Final                             => TransitionTarget.Final(null)
        //| State       as t                  => State(an, t)
        | Named       as t                  => Named(st, t)
        //| SubMachine(_m, s)                 => SubMachine(null, s)//SubMachine(m, null), s)
        | Qualified(parent = p, target = t) => Qualified(p, Create(tran, st, t))
        | Self                              => TransitionTarget.State(st)
        | NoTarget                          => TransitionTarget.Nowhere()
        //| JunctionNode(g, a, t, n)          => JunctionNode(an, g, a, Create(st, t), n.Map(x => Create(st, x) :> JunctionNode), null, JunctionType.Junction)
      }
    }

    public CompareTo(target : TransitionTarget) : int
    {
      CompareTo(this, target)
    }

    public static CompareTo(t1 : TransitionTarget, target : TransitionTarget) : int
    {
      | (PseudoState(node = n1), PseudoState(node = n2))                    => if (n1 : object == n2) 0 else -1
      | (Final(state = n1), Final(state = n2))                              
      | (State(state = n1), State(state = n2))                              => if (n1 : object == n2) 0 else -1
      //| (SubMachine(machine = m, state = s), SubMachine(machine = m2, state = s2)) when (m.Value == m2.Value) => s.CompareTo(s2)
      //| (Qualified(p, t), Qualified(p2, t2)) when (p == p2)   => t.CompareTo(t2)
      | _                                                                   => -1
    }

    public PartOfSubRegion : option[FsmState]
    {
      get
      {
        def st = ToState;
        match (st)
        {
          | null                              => None()
          | FsmState(type = StateType.Region) => Some(st)
          | _                                 => st.PartOfSubRegion
        }
      }
    }

    public ToState : FsmState
    {
      get
      {
        match (this)
        {
          | PseudoState(PseudoStateNode(state = st))
          //| History(PseudoStateNode.History(state = st))
          | Final(st)
          //| SubMachine(machine = st)
          | State(st)  => st
          | Qualified(_, t)    => t.ToState
          | _                  => null
        }
      }
    }

    //public transition : StateTransition;

    //public SetCopy(ncopy : int) : TransitionTarget
    //{
    //  Reduce(pseudo_state = t => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
    //         merge = (t, _) => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
    //         junction = (t, _) => t.ChangeNode(t.node.ChangeCopy(ncopy)))
    //}

    public Guards : IEnumerable[GuardNode]
    {
      get
      {
        match (this)
        {
          //| TransitionTarget.PseudoState(NodeValue(Value = Junction as j)) => j.Guards
          | _                                                              => Enumerable.Empty()
        }
        //JunctionNodeParts.Select(_.guard)
      }
    }

    //public Traverse(func : TransitionTarget -> TransitionTarget) : TransitionTarget
    //{
        
        
    //    def to = func(this);
    //    def to = to ?? this;
    //    match (to)
    //    {
    //      | null                                                                                        => ()
    //      //| TransitionTarget.PseudoState(NodeValue(Value = PseudoStateNode.Junction(tree = t)))         => t.GetBreadthFirstEnumerable().Iter(traverse);
    //      | TransitionTarget.PseudoState(PseudoStateNode.Fork(target = t) as j)  => n.Update(_ => j.ChangeTarget(t.Map(func)));
    //      | TransitionTarget.PseudoState(PseudoStateNode.Join(target = t) as j)  => n.Update(_ => j.ChangeTarget(func(t)));
    //      | _                                                                                           => ()
    //    }
    //    to
    //}
    //public Rebuild(child : IEnumerable[TransitionTarget]) : TransitionTarget
    //{
    //  match (this)
    //  {
    //    | PseudoState(raw_value = Junction) as t => t.node.SetValue(j => (j :> PseudoStateNode.Junction).ChangeTo(child.First() :> JunctionNode));
    //                                                this// t.ChangeNode(p.ChangeTo(child.First() :> JunctionNode))
    //    | JunctionNode(next = Some as nt) as t  => def (f, s) = child.TakeTwo();
    //                                               t.ChangeNextTo(nt.ChangeValue(s :> JunctionNode), f)
    //    | JunctionNode as t                     => def f = child.First();
    //                                               t.ChangeTo(f);
    //    | _                                     => this
    //  }
    //}

    //public GetChild() : IEnumerable[TransitionTarget]
    //{
    //  match (this)
    //  {
    //    | JunctionNode(to = to, next = Some(n)) => TraverseUtils.DoubleElement(to, n)
    //    | PseudoState(value = Junction(to = n))
    //    | JunctionNode(to =  n)                 => TraverseUtils.SingleElement(n)
    //    | _                                     => Enumerable.Empty()
    //  }
    //}

    //public Clone() : TransitionTarget
    //{
    //  match (this)
    //  {
    //    | PseudoState(node = n) as j => def n = n.Clone();
    //                                    n.Update(x => x.Clone());
    //                                    j.ChangeNode(n)
    //    | State(state = n) as j      => j.ChangeState(n.Clone())
    //    | _                          => this
    //  }
    //}
    
    //public StateMap : StateMap
    //{
    //  get
    //  {
    //    analyser.statemap
    //  }
    //}

    //public analyser : FsmAnalyser;

  }
}
