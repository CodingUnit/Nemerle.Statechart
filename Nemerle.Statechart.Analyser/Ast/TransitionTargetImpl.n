using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using PseudoStateAstNode;
  using FsmState;
  using PseudoStateNode;
  using ListUtils;

  /// <summary>
  /// Description of TransitionTargetImpl.
  /// </summary>
  public partial variant TransitionTarget
  {
    
    public IdObjects : IEnumerable[IdObject]
    {
      get
      {
        PseudoStateParts.Select(_.node)
        //Fold([], pseudo_state = (p, a) => p.node :: a)
      }
    }

    public static Create(st : FsmState, target : TargetType) : TransitionTarget
    {
      def an = st.analyser;
      match (target)
      {
        | PseudoState as t                  => PseudoState(st, t)
        //| History     as t                  => History(st, t)
        | Final                             => TransitionTarget.Final(an, null)
        | State       as t                  => State(an, t)
        | Named       as t                  => Named(st, t)
        | SubMachine(m, s)                  => SubMachine(an, SubMachine(m, null), s)
        | Qualified(parent = p, target = t) => Qualified(an, p, Create(st, t))
        | JunctionNode(g, a, t, n)          => JunctionNode(an, g, a, Create(st, t), n.Map(x => Create(st, x) :> JunctionNode), null, JunctionType.Junction)
      }
    }

    public CompareTo(target : TransitionTarget) : int
    {
      CompareTo(this, target)
    }

    public static CompareTo(t1 : TransitionTarget, target : TransitionTarget) : int
    {
      //| (History(h1), History(h2))                            => h1.Name.CompareTo(h2.Name)
      | (Final(st1), Final(st2))                              => st1.Name.CompareTo(st2.Name)
      | (PseudoState(n1), PseudoState(n2))                    => n1.ToString().CompareTo(n2.ToString())
      | (State(st1), State(st2))                              => st1.Name.CompareTo(st2.Name)
      | (SubMachine(machine = m, state = s), SubMachine(machine = m2, state = s2)) when (m == m2) => s.CompareTo(s2)
      | (Qualified(p, t), Qualified(p2, t2)) when (p == p2)   => t.CompareTo(t2)
      | _                                                     => -1
    }

    public static @==(a : TransitionTarget, b : TransitionTarget) : bool
    {
      //| (History(h1), History(h2))             => h1 == h2
      | (State(st1), State(st2))
      | (Final(st1), Final(st2))               => st1 == st2
      | (PseudoState(n1), PseudoState(n2))     => n1 == n2
      | (Named(st, n), Named(st2, n2))         => st == st2 && n == n2
      | (Qualified(p, t), Qualified(p2, t2))   => p == p2 && t == t2
      | (SubMachine(machine = m, state = s), SubMachine(machine = m2, state = s2)) => m == m2 && s == s2
      | _                                      => false
    }

    public PartOfSubRegion : option[ConcurrentSubRegion]
    {
      get
      {
        match (ToState)
        {
          | null => None()
          | ConcurrentSubRegion as st => Some(st)
          | st => st.PartOfSubRegion
        }
      }
    }

    public ToState : FsmState
    {
      get
      {
        match (this)
        {
          | PseudoState(PseudoStateNode(state = st))
          //| History(PseudoStateNode.History(state = st))
          | Final(state = st)
          | SubMachine(machine = st)
          | State(state = st)  => st
          | Qualified(_, t)    => t.ToState
          | _                  => null
        }
      }
    }

    //public transition : StateTransition;

    //public SetCopy(ncopy : int) : TransitionTarget
    //{
    //  Reduce(pseudo_state = t => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
    //         merge = (t, _) => t.ChangeNode(t.node.ChangeCopy(ncopy)), 
    //         junction = (t, _) => t.ChangeNode(t.node.ChangeCopy(ncopy)))
    //}

    public Guards : IEnumerable[GuardNode]
    {
      get
      {
        JunctionNodeParts.Select(_.guard)
      }
    }

    public Rebuild(child : IEnumerable[TransitionTarget]) : TransitionTarget
    {
      match (this)
      {
        | PseudoState(Merge as p) as t          => t.ChangeNode(p.ChangeTo(child.First() :> JunctionNode))
        | PseudoState(Junction as p) as t       => t.ChangeNode(p.ChangeTo(child.First() :> JunctionNode))
        | JunctionNode(next = Some as nt) as t  => def (f, s) = child.TakeTwo();
                                                   t.ChangeNextTo(nt.ChangeValue(s :> JunctionNode), f)
        | JunctionNode as t                     => def f = child.First();
                                                   t.ChangeTo(f);
        | _                                     => this
      }
    }

    public GetChild() : IEnumerable[TransitionTarget]
    {
      match (this)
      {
        | JunctionNode(to = to, next = Some(n)) => TraverseUtils.DoubleElement(to, n)
        | PseudoState(Merge(to = n))
        | PseudoState(Junction(to = n))
        | JunctionNode(to =  n)                 => TraverseUtils.SingleElement(n)
        | _                                     => Enumerable.Empty()
      }
    }

    public StateMap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }

    public analyser : FsmAnalyser;

  }
}
