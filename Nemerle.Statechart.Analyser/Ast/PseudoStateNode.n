using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  using FsmState;
  using ListUtils;


  [Record]
  public variant PseudoStateNode
  {
    | Initial 
      { 
        this(st : FsmState, tran : StateNode.Transition)
        {
          base(st);
          this.tran = StateTransition(this, None(), tran)
        }

        this(st : FsmState, tostate : FsmState)
        {
          base(st);
          this.tran = StateTransition(this, tostate, TransitionKind.Local)
        }

        tran : StateTransition;
      }
    | History 
      {
        public this(st : FsmState, hist : PseudoStateModelNode.History)
        {
          base(st);
          type = hist.type;
          default = hist.default.Map(x => StateTransition(st, None(), x))
        }

        public SubStatesParticipateIn : IEnumerable[FsmState]
        {
          get
          {
            match (type)
            {
              | HistoryType.Deep     => state.AllLivedSubStates
              | HistoryType.Shallow  => state.LivedSubStatesNested
              | _                    => Enumerable.Empty()
            }
          }
        }        

        public SimpleName : string
        {
          get
          {
            $"$(state)History"
          }
        }        

        public default : option[StateTransition] {get;set;}

        public type : HistoryType;
      }
    | Junction
      {
        name : string;
        tree : FsmJunctionNode;// TransitionTarget.JunctionNode;
        //[TraverseIgnore] parent : Junction;
        type : JunctionType;

        decision_tree : DecisionNode {get;set;}
        IsUnnamed : bool;
        //ChangeDecisionTree(tree : DecisionNode) : Junction
        //{
        //  ChangeTo(to.ChangeDecisionTree(tree))
        //}

        //this(n : string, nodes : list[FsmJunctionNode], type : JunctionType, is_unnamed : bool)
        //{
        //  base(0);
        //  name = n;
        //  IsUnnamed = is_unnamed;
        //  this.nodes = nodes;
        //  this.type = type;
        //}
        
        public static GetUnnamedName(this an : FsmAnalyser, type : JunctionType) : string
        {
          match (type) 
          {
            | JunctionType.Choice   => def num = an.NextChoiceNum();
                                     $"UnnamedChoice$num"
            | JunctionType.Junction => def num = an.NextJunctionNum();
                                       $"UnnamedJunction$num"
            | _                     => throw NotImplementedException()
          }
        }
        
        this(st : FsmState, node : PseudoStateModelNode.Junction)
        {
          base(st);
          def an = st.analyser;
          name = match (node) 
          {
            | PseudoStateModelNode.Junction(name = null, type = t) => IsUnnamed = true;
                                                                      GetUnnamedName(an, t);
            | Junction(name = n)                                   => n
          }
          
          tree = FsmJunctionNode.Create(this, node.nodes);
          type = node.type;
          //Junction(st, name, tree, node.type, unnamed)
        }
        //Nodes : IEnumerable[TransitionTarget.JunctionNode]
        //{
        //  get
        //  {
        //    def loop(t)
        //    {
        //      yield t;
        //      match (t.next)
        //      {
        //        | Some(t) => loop(t)
        //        | _       => ()
        //      }
        //    }

        //    loop(to)

        //  }
        //} 

        TypeName : string
        {
          get
          {
            match (type)
            {
              | Junction => "Junction"
              | Choice   => "Choice"
              | Merge    => "Merge"
            }
          }
        }

        //Name : string
        //{
        //  get
        //  {
        //    $"$name$TypeName" // $copy_name
        //  }
        //}

        //Guards : IEnumerable[GuardNode]
        //{
        //  get
        //  {
        //    def data = tree.GetBreadthFirstEnumerable().FoldLeft([], (x, a) => x.Data.guard :: a);
        //    data.Exclude(_ is GuardNode.Else)
        //  }
        //}


        override ToString() : string
        {
          Name
        }

      }
      
    | Fork 
      {
        target    : list[TransitionTarget];
        fork_tran : list[StateTransition]  {get;set;default []}
      }
    | Join 
      {
        name : string;
        target : TransitionTarget {get;set;}
        region : FsmState {get;set;}

        joined_tran : list[StateTransition] {get;set;default []}
        transition : StateTransition {get;set;}

        trigger : StateEvent
        {
          get
          {
            match (joined_tran.NToList())
            {
              | []                                => null
              | t :: _ => t.Trigger
            }
          }
        }

      }
    | EntryPoint { name : string; tran : StateTransition;}
    | ExitPoint { name : string; tran : option[StateTransition] {get;set;default None()} }
    | Terminate { override ToString() : string {"Terminate"} }

    public static Create(st : FsmState, pseudo : PseudoStateModelNode) : PseudoStateNode
    {
      match (pseudo)
      {
        | Initial(tr)                                => Initial(st, tr)
        | History as hist                            => History(st, hist)
        | Junction as j                              => Junction(st, j)
        //| Fork(target = lst)                         => Fork(0, lst.Map(TransitionTarget.Create(st, _)), [])
        //| Join(name = n, target = t)                 =>  Join(0, n, TransitionTarget.Create(st, t), null, null, null))
        | EntryPoint(n, tr)                          => EntryPoint(st, n, StateTransition.Create(st, tr).First())
        | ExitPoint(n, tr)                           => ExitPoint(st, n, tr.Map(x => StateTransition.Create(st, x).First()))
        | Terminate                                  => Terminate(st)
        | _                                          => throw NotImplementedException("this TransitionTarget not implemented")
      }
    }

    //copy_name : string
    //{
    //  get
    //  {
    //    if (copy == 0) "" else $"$copy"
    //  }
    //}

    public state : FsmState {get;set;}

    public NativeName : option[string]
    {
      get
      {
        match (this)
        {
          | Join(name = n)
          | Junction(name = n, IsUnnamed = false) 
          | EntryPoint(name = n)
          | ExitPoint(name = n) => Some(n)
          | _                   => None()
        }
      }
    }

    public Name : string
    {
      get
      {
        match (this)
        {
          | PseudoStateNode.History(type = t) => 

              def type = match (t)
                          {
                            | HistoryType.Deep     => "Deep"
                            | Shallow              => "Shallow"
                            | None                 => ""
                          }

              if (state != null)
              {
                if (state.history.IsOne) $"$(state)History" else $"$(state)$(type)History"
              } else "History";
          | Join(name = n )           => $"Join$n"//$copy_name
          | PseudoStateNode.Terminate => $"$(state)Terminate"
          | Fork(target = t)          => $<#Fork$(state)To..$(t;"_")#>
          | Initial                   => $"$(state)Initial"
          | Junction(name = n)        => $"$state$n"
          | EntryPoint(name = n)      => $"EntryPoint$n"
          | ExitPoint(name = n)       => $"ExitPoint$n"
          //| n                         => n.ToString()
          //| FsmNode.State(st)                                => st.Value.Name
          //| FsmNode.PseudoState(n)                           => n.ToString()
        }
      }
    }

    public override ToString() : string
    {
      Name
    }

    analyser : FsmAnalyser
    {
      get
      {
        state.analyser
      }
    }

    public Used : bool
    {
      get
      {
        analyser.Used[this]
      }
      set
      {
        analyser.Used[this] = value
      }
    }

  }


}
