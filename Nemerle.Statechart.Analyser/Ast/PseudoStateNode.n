using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using FsmState;
  using ListUtils;

//  [RefNode]
  [Record]
  public variant PseudoStateNode : IdObject
  {
    | History 
      {
        public this(st : FsmState, num : int, hist : StateNode.History)
        {
          base(0, num, st.analyser);
      //history = hist;
      //state = if (hist.state != null) FsmState.State(hist.state, null, analyser, true); else st;
          type = hist.type;
          default = hist.default |> StateTransition.Default(st, this, _).Create();
        }

        
    //public history : StateNode.History;

    //public state : FsmState
    //{
    //  get
    //  {
    //    statemap.ParentFor(Num)
    //  }
    //}

        [NeedChange]
        public default : option[StateTransition];

        public ChangeDefault(tran : StateTransition -> StateTransition) : History
        {
          ChangeDefault(default.Map(tran))
        }
    //[NeedChange]
    //[Accessor]
    //public num : int;

    //[NeedChange(default)]
    //[NeedChange] public state : FsmState;
        public type : HistoryType;
    //[NeedChange] public reference : bool;

        [NeedChange] public Used : bool;

    //public this(an : FsmAnalyser) { analyser = an }
    //public this(hist : PseudoStateNode.History, clone : bool = false, ncopy : int = 0)
    //{
    //  history = hist.history;
    //  default = if (clone) hist.default.Map(x => x.Clone(ncopy) :> StateTransition.Default) else hist.default;
    //  state = hist.state;
    //  type = hist.type;
    //  reference = hist.reference;
    //  Used = hist.Used;
    //}

        public static Create(st : FsmState, hist : TwoOption[StateNode.History]) : TwoOption[History]
        {
          hist.Map(Create(st, st.statemap.GetNextGlobalNum(), _))
        }

        public static Create(st : FsmState, num : int, hist : StateNode.History) : History
        {
          History(st, num, hist)
        }

    //[Accessor] clone_for : PseudoStateNode.History;

    //public static @==(a : PseudoStateNode.History, b : PseudoStateNode.History) : bool
    //{
    //  a.Num == b.Num//a.Name == b.Name && a.type == b.type && a.state == b.state
    //}

    //public static @!=(a : PseudoStateNode.History, b : PseudoStateNode.History) : bool
    //{
    //   !(@==(a, b))
    //}


        public BothHistories(st : FsmState) : bool
        {
          st.BothHistories
        }

        public Name : string
        {
          get
          {
            def type = match (type)
                        {
                          | HistoryType.Deep     => "Deep"
                          | Shallow              => "Shallow"
                          | None                 => ""
                        }

            if (state.history.IsOne) $"$(state)History" else $"$(state)$(type)History"
          }
        }

        public SimpleName : string
        {
          get
          {
            $"$(state)History"
          }
        }

        public override ToString() : string
        {
          Name
        }

        public SubStatesParticipateInHistory : IEnumerable[FsmState]
        {
          get
          {
            state.SubStatesParticipateIn(this)
          }
        }

    //public ChangeState(st : FsmState) : void
    //{
    //  analyser.statemap.ParentFor(Num, st)
    //}
    //public SubStatesParticipateInHistoryIndirect : IEnumerable[FsmState]
    //{
    //    st.Updated.SubStatesParticipateIn(this)
    //}

        public Updated : PseudoStateNode.History
        {
          get
          {
            state.GetHistory(this)
          }
        }

        //public ChangeDefault(tran : StateTransition -> StateTransition) : History
        //{
        //  ChangeHistory(history.ChangeDefault(history.default.Map(tran)))
        //}

        //this(st : FsmState, type : TargetType.History)
        //{
        //  base(st.analyser);
        //  history = PseudoStateNode.History.Create(st, -1, type.history)
        //}
      }

    | Junction
      {
        [NeedChange] native_name : string;
        [NeedChange] to : TransitionTarget.JunctionNode;
        //[TraverseIgnore] parent : Junction;
        type : JunctionType;

        ChangeDecisionTree(tree : DecisionNode) : Junction
        {
          ChangeTo(to.ChangeDecisionTree(tree))
        }
        
        IsUnnamed : bool
        {
          get
          {
            native_name == null
          }
        }
        
        name : string
        {
          get
          {
            if (native_name != null) native_name else "Unnamed"
          }
        }
        
        this(st : FsmState, num : int, n : string, node : TargetType.JunctionNode, type : JunctionType)
        {
          def an =st.analyser;
          base(0, num, an);
          this.to = TransitionTarget.JunctionNode.Create(st, node);//lst |> JunctionNode(st, tran, _, this);
          native_name = n;
          this.type = type;
        }

        Nodes : IEnumerable[TransitionTarget.JunctionNode]
        {
          get
          {
            def loop(t)
            {
              yield t;
              match (t.next)
              {
                | Some(t) => loop(t)
                | _       => ()
              }
            }

            loop(to)

          }
        } 

        TypeName : string
        {
          get
          {
            match (type)
            {
              | Junction => "Junction"
              | Choice   => "Choice"
              | Merge    => "Merge"
            }
          }
        }
        
        Name : string
        {
          get
          {
            $"$name$TypeName$copy_name"
          }
        }

        //IsTop : bool 
        //{
        //  get
        //  {
        //    parent == null
        //  }
        //}

        Actions : IEnumerable[PathNode]
        {
          get
          {
            to.Actions
          }
        }

        Guards : IEnumerable[GuardNode]
        {
          get
          {
            def g = Nodes.Select(_.guard);//FoldLeft([], (x, a) => a + x.Guards).Rev();
            g.Exclude(_ is GuardNode.Else)
          }
        }

        //override UpdateReference() : PseudoStateNode
        //{
        //  def st = ChangeTo(to.UpdateReference() :> TransitionTarget.JunctionNode);
        //  st.UpdateReference()
        //}

        override ToString() : string
        {
          Name
        }

      }

    | Fork 
      {
        [NeedChange] target    : list[TransitionTarget] = [];
        [NeedChange] fork_tran : list[StateTransition]  = [];

        //override UpdateReference() : PseudoStateNode
        //{ 
        //  // TODO: сделать через Lazy создание нового списк только в случае если есть новые элементы
        //  def st = base.UpdateReference();
        //  match (st)
        //  {
        //    | Fork as j => def target = target.Map(_.UpdateReference());
        //                   j.ChangeTarget(target)//(Fork(st, copy, target, fork_tran), an)
        //    | _         => this
        //  }
        //}

        Name : string
        {
          get
          {
            $<#Fork$(state)To..$(target;"_")#>
          }
        }

        override ToString() : string
        {
          Name
        }
      }
    | Join 
      {
        name : string;
        [NeedChange] target : TransitionTarget;
        [NeedChange(joined_tran, transition)] region : ConcurrentRegion;

        joined_tran : IEnumerable[StateTransition] = Enumerable.Empty();
        transition : StateTransition;

        trigger : StateEvent
        {
          get
          {
            match (joined_tran)
            {
              | []                                => null
              | StateTransition(Trigger = t) :: _ => t
            }
          }
        }

        Name : string
        {
          get
          {
            $"Join$name$copy_name"
          }
        }

        override ToString() : string
        {
          Name
        }

        //override UpdateReference() : PseudoStateNode
        //{
        //  def tar = target?.UpdateReference();
        //  def st = base.UpdateReference();
        //  match (st)
        //  {
        //    | Join as j => j.ChangeTarget(tar)//Join(state, copy, name, tar, region, joined_tran, transition)
        //    | _         => this
        //  }
        //}

      }
    | EntryPoint
    | ExitPoint
    | Terminate
      {
        Name : string
        {
          get
          {
            $"$(state)Terminate"
          }
        }

        public static Create(st : FsmState, an : FsmAnalyser) : Terminate
        {
          def node = Terminate(0, an.statemap.GetNextGlobalNum(), an);
          an.statemap.ParentFor(node.Num, st);
          node
        }

        override ToString() : string
        {
          Name
        }
      }

    public static Create(st : FsmState,  pseudo : PseudoStateAstNode, num : int = -1) : PseudoStateNode
    {
      def an = st.analyser;
      match (pseudo)
      {
        | History(n)                                  => History.Create(st, num, n)
        | Junction(null, node, t) => def num = if (num == -1) an.NextGlobalNum(); else num;
                                     Junction(st, num, null, node, t)
        | Junction(name = n, node = nn, type = tp)   => Junction(st, num, n, nn, tp)
        | Fork(target = lst)                         => Fork(0, num, an, lst |> TransitionTarget.Create(st, _), [])
        | Join(name = n, target = t)                 => Join(0, num, an, n, TransitionTarget.Create(st, t), null, null, null)
        | EntryPoint                                 => EntryPoint(0, num, an)
        | ExitPoint                                  => ExitPoint(0, num, an)
        | Terminate                                  => Terminate(0, num, an)
      }
    }

    copy_name : string
    {
      get
      {
        if (copy == 0) "" else $"$copy"
      }
    }

    //[NeedChange]
    public state : FsmState
    {
      get
      {
        StateMap.ParentFor(Num)
      }
    }

    //public ChangeState(st : FsmState) : void
    //{
    //  StateMap.ParentFor(Num, st)
    //}
    //[RecordIgnore] [Accessor] cloneFor : PseudoStateNode;
    [NeedChange]
    public copy : int;

    [NeedChange(copy)]
    [NeedChange]
    [Accessor]
    public num : int;

    public NativeName : option[string]
    {
      get
      {
        match (this)
        {
          | Join(name = n) 
          | Junction(name = n) => Some(n)
          | _                  => None()
        }
      }
    }

    public static @==(a : PseudoStateNode, b : PseudoStateNode) : bool
    {
      | (null, null) => true
      | (null, _)    
      | (_, null)    => false
      | _            => a.Num == b.Num
    }

    public analyser : FsmAnalyser;

    public StateMap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }

  }


}
