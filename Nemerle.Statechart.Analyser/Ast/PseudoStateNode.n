using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using FsmState;
  using ListUtils;

  [Record]
  public variant PseudoStateNode
  {
    | Junction
      {
        [NeedChange] name : string;
        [NeedChange] to : TransitionTarget.JunctionNode;
        [TraverseIgnore] parent : Junction;
        type : JunctionType;

        this(an : FsmAnalyser, st : FsmState, n : string, node : TargetType.JunctionNode, type : JunctionType)
        {
          base(st, 0, an);
          this.to = TransitionTarget.JunctionNode.Create(an, node);//lst |> JunctionNode(st, tran, _, this);
          name = n;
          this.type = type;
        }

        Nodes : IEnumerable[TransitionTarget.JunctionNode]
        {
          get
          {
            def loop(t)
            {
              yield t;
              match (t.next)
              {
                | Some(t) => loop(t)
                | _       => ()
              }
            }

            loop(to)

          }
        } 

        Name : string
        {
          get
          {
            match (type)
            {
              | Junction => $"Junction$name$copy_name"
              | Choice   => $"Choice$name$copy_name"
            }
          }
        }

        IsTop : bool 
        {
          get
          {
            parent == null
          }
        }

        Actions : IEnumerable[PathNode]
        {
          get
          {
            to.Actions
          }
        }

        Guards : IEnumerable[GuardNode]
        {
          get
          {
            def g = Nodes.Select(_.guard);//FoldLeft([], (x, a) => a + x.Guards).Rev();
            g.Exclude(_ is GuardNode.Else)
          }
        }

        override UpdateReference() : PseudoStateNode
        {
          def st = ChangeTo(to.UpdateReference() :> TransitionTarget.JunctionNode);
          st.UpdateReference()
        }

        override ToString() : string
        {
          Name
        }

      }

    | Merge
      {
        name : string;
        [NeedChange] to : TransitionTarget.JunctionNode;

        this(an : FsmAnalyser, st : FsmState, n : string, node : TargetType.JunctionNode)
        {
          base(st, 0, an);
          this.to = TransitionTarget.JunctionNode.Create(an, node);//lst |> JunctionNode(st, tran, _, this);
          name = n;
        }

        public override UpdateReference() : PseudoStateNode
        {
          def nnode = to.UpdateReference();
          def st = base.UpdateReference();

          match (st, nnode)
          {
            | (Merge as j, TransitionTarget.JunctionNode as to) => j.ChangeTo(to)//Merge(x.state, copy, name, nnode :> TransitionTarget.JunctionNode)
            | (_, _)                                            => this
          }
        }

        Name : string
        {
          get
          {
            $"Merge$name$copy_name"
          }
        }

        override ToString() : string
        {
          Name
        }
      }
    | Fork 
      {
        [NeedChange] target : list[TransitionTarget] = [];
        [NeedChange] fork_tran : list[StateTransition] = [];

        override UpdateReference() : PseudoStateNode
        { 
          // TODO: сделать через Lazy создание нового списк только в случае если есть новые элементы
          def st = base.UpdateReference();
          match (st)
          {
            | Fork as j => def target = target.Map(_.UpdateReference());
                          j.ChangeTarget(target)//(Fork(st, copy, target, fork_tran), an)
            | _         => this
          }
        }

        Name : string
        {
          get
          {
            $<#Fork$(state)To..$(target;"_")#>
          }
        }

        override ToString() : string
        {
          Name
        }
      }
    | Join 
      {
        name : string;
        [NeedChange] target : TransitionTarget;
        [NeedChange(joined_tran, transition)] region : ConcurrentRegion;

        joined_tran : IEnumerable[StateTransition] = Enumerable.Empty();
        transition : StateTransition;

        trigger : StateEvent
        {
          get
          {
            match (joined_tran)
            {
              | [] => null
              | StateTransition where (Trigger = t) :: _ => t
            }
          }
        }

        Name : string
        {
          get
          {
            $"Join$name$copy_name"
          }
        }

        override ToString() : string
        {
          Name
        }

        override UpdateReference() : PseudoStateNode
        {
          def tar = target?.UpdateReference();
          def st = base.UpdateReference();
          match (st)
          {
            | Join as j => j.ChangeTarget(tar)//Join(state, copy, name, tar, region, joined_tran, transition)
            | _         => this
          }
        }

      }
    | EntryPoint
    | ExitPoint
    | Terminate
      {
        Name : string
        {
          get
          {
            $"$(state)Terminate"
          }
        }


        override ToString() : string
        {
          Name
        }
      }


    public static Create(an : FsmAnalyser, st : PseudoStateAstNode, state : FsmState) : PseudoStateNode
    {
      def analyser = an;
      match (st)
      {
        | Junction(null, node, JunctionType.Junction) => 
            def num = analyser.NextJunctionNum();
            def name = $"Unnamed$num";
            Junction(an, state, name, node, JunctionType.Junction)

        | Junction(null, node, JunctionType.Choice) => 
            def num = analyser.NextChoiceNum();
            def name = $"Unnamed$num";
            //j.ChangeName(name)
            Junction(an, state, name, node, JunctionType.Choice)

        | Junction(name = n, node = nn, type = tp)   => Junction(an, state, n, nn, tp)
        | Merge(name = n, node = node)    => Merge(an, state, n, node)
        | Fork(target = lst)              => Fork(0, an, lst |> TransitionTarget.Create(an, _))
        | Join(name = n, target = t)      => Join(0, an, n, TransitionTarget.Create(an, t), null, null, null)
        | EntryPoint                      => EntryPoint(0, an)
        | ExitPoint                       => ExitPoint(0, an)
        | Terminate                       => Terminate(0, an)
      }

    }

    copy_name : string
    {
      get
      {
        if (copy == 0) "" else $"$copy"
      }
    }

    //[NeedChange]
    //public state : FsmState;

    //[RecordIgnore] [Accessor] cloneFor : PseudoStateNode;
    [NeedChange]
    public copy : int;

    [NeedChange]
    public Num : int;
    
    public NativeName : option[string]
    {
      get
      {
        match (this)
        {
          | Join(name = n) 
          | Merge(name = n)
          | Junction(name = n) => Some(n)
          | _                  => None()
        }
      }
    }

    public static @==(a : PseudoStateNode, b : PseudoStateNode) : bool
    {
      | (PseudoStateNode(Num = num), PseudoStateNode(Num = num2)) => num == num2
    }

    public analyser : FsmAnalyser;

    public StateMap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }
  }


}
