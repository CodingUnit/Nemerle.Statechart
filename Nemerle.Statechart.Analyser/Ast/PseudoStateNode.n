using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using FsmState;
  using ListUtils;

  public enum JunctionType
  {
    | Junction
    | Choice
  }

  [Record]
  public variant PseudoStateNode
  {
    | Junction
      {
        name : string;
        [NeedChange] to : TransitionTarget.JunctionNode;
        parent : Junction;
        type : JunctionType;

        this(st : FsmState, n : string, node : JunctionAstNode, tran : StateTransition)
        {
          base(st, 0);
          this.node = JunctionNode.Create(st, tran, node, this);//lst |> JunctionNode(st, tran, _, this);
          name = n;
        }

        Nodes : IEnumerable[TransitionTarget.JunctionNode]
        {
          get
          {
            def loop(t)
            {                
              yield t;
              match (t.next)
              {
                | Some(t) => loop(t)
                | _       => ()
              }
            }

            loop(to)

          }
        } 

        Name : string
        {
          get
          {
            match (type)
            {
              | Junction => $"Junction$name$copy_name"
              | Choice   => $"Choice$name$copy_name"
            }
          }
        }

        [NeedChange] decisionTree : DecisionNode;

        IsTop : bool 
        {
          get
          {
            parent == null
          }
        }

        Actions : PathNode
        {
          get
          {
            decisionTree.Actions
          }
        }

        Guards : list[GuardNode]
        {
          get
          {
            def g = node.FoldLeft([], (x, a) => a + x.Guards).Rev();
            g.Exclude(_ is GuardNode.Else)
          }
        }

        override UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
        {
          def (st, an) = base.UpdateReference(an);
          match (st)
          {
            | Junction(n, nodes, p, t) as j => def st = j.state;
                def (nodes, an) = node.MapThrough(an, _.UpdateRef(_));
                (Junction(st, copy, n, nodes, p, t), an)
            | _ => (this, an)
          }
        }

        override ToString() : string
        {
          Name
        }

      }

    | Merge
      {
        name : string;
        [NeedChange] to : TransitionTarget.JunctionNode;

        this(st : FsmState, n : string, node : JunctionAstNode)
        {
          base(st, 0);
          this.node = JunctionNode(st, null, node,  this);
          name = n;
        }

        public override UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
        {
          def (nnode, an) = to.UpdateReference(an);
          def (st, an) = base.UpdateReference(an);
          def st = match (st)
                    {
                      | x when (x : object != this || to : object != nnode) => Merge(x.state, copy, name, nnode :> TransitionTarget.JunctionNode)
                      | _                           => this
                    }
          (st, an)
        }

        Name : string
        {
          get
          {
            $"Merge$name$copy_name"
          }
        }

        override ToString() : string
        {
          Name
        }
      }
    | Fork 
      {
        [NeedChange] target : list[TransitionTarget];
        [NeedChange] fork_tran : list[StateTransition] = [];

        override UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
        { 
          // TODO: сделать через Lazy создание нового списк только в случае если есть новые элементы
          def (st, an) = base.UpdateReference(an);
          match (st)
          {
            | Fork(state = st) => def (target, an) = target.MapThrough(an, _.UpdateReference(_));
                (Fork(st, copy, target, fork_tran), an)
            | _                => (this, an)
          }
        }

        Name : string
        {
          get
          {
            $<#Fork$(state)To..$(target;"_")#>
          }
        }

        override ToString() : string
        {
          Name
        }
      }
    | Join 
      {
        name : string;
        [NeedChange] target : TransitionTarget;
        [NeedChange(joined_tran, transition)] region : ConcurrentRegion;

        joined_tran : list[StateTransition] = [];
        transition : StateTransition;

        trigger : StateEvent
        {
          get
          {
            match (joined_tran)
            {
              | [] => null
              | StateTransition where (Trigger = t) :: _ => t
            }
          }
        }

        Name : string
        {
          get
          {
            $"Join$name$copy_name"
          }
        }

        override ToString() : string
        {
          Name
        }

        override UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
        {
          def (tar, an) = target?.UpdateReference(an);
          def (st, an) = base.UpdateReference(an);
          def st = match (st)
                    {
                      | Join as j when (tar : object != target || j : object != this) => Join(state, copy, name, tar, region, joined_tran, transition)
                      | _                                                             => this
                    }
          (st, an)
        }

      }
    | EntryPoint
    | ExitPoint
    | Terminate
      {
        Name : string
        {
          get
          {
            $"$(state)Terminate"
          }
        }


        override ToString() : string
        {
          Name
        }
      }


    public static Create(st : PseudoStateAstNode, state : FsmState, tran : StateTransition) : PseudoStateNode
    {
      def analyser = state.analyser;
      match (st)
      {
        | PseudoStateAstNode.Choice(null, lst) =>

            def num = analyser.NextChoiceNum();
            def name = $"Unnamed$num";
            Choice(state, name, lst, tran)

        | PseudoStateAstNode.Choice(n, lst) => Choice(state, n, lst, tran)  

        | Junction(null, lst) => 
            def num = analyser.NextJunctionNum();
            def name = $"Unnamed$num";
            Junction(state, name, lst, tran)

        | Junction(name = n, node = nn)   => Junction(state, n, nn, tran)
        | Merge(name = n, node = node)    => Merge(state, n, node)
        | Fork(target = lst)              => Fork(state, 0, lst |> TransitionTarget.Create(state, tran, _), null)
        | Join(name = n, target = t)      => Join(state, 0, n, TransitionTarget.Create(state, tran, t), null, null, null)
        | EntryPoint                      => EntryPoint(state, 0)
        | ExitPoint                       => ExitPoint(state, 0)
        | Terminate                       => Terminate(state, 0)
      }

    }

    public SetCopy(ncopy : int) : PseudoStateNode
    {

      FoldThis((_, _, _, _, x) => x.SetCopy(ncopy), 
               (_, _, _, _, x) => x.SetCopy(ncopy), 
               (_, _, x) => x.SetCopy(ncopy), 
               (_, _, x) => x.SetCopy(ncopy),
               (_, _, _, _, _, x) => x.SetCopy(ncopy), 
               x => x.SetCopy(ncopy), 
               x => x.SetCopy(ncopy),
               x => x.SetCopy(ncopy), 
               (_, _, _, _, x) => x.SetCopy(ncopy))
      //match (this)
      //{
      //  | Junction(state = st, name = n, nodes = lst, parent = p, decisionTree = t) => 
      //      def lst = lst.Map(x => x.SetCopy(ncopy) :> JunctionNode);
      //      def t = t?.SetCopy(ncopy);
      //      Junction(st, ncopy, n, lst, p, t)
      //  | Choice(state = st, name = n, nodes = lst, parent = p, decisionTree = t) => 
      //      def lst = lst.Map(x => x.SetCopy(ncopy) :>  JunctionNode);
      //      def t = t?.SetCopy(ncopy);
      //      Choice(st, ncopy, n, lst, p, t)
      //  | Merge(state = st, name = n, node = node) => 
      //      def node = node.SetCopy(ncopy) :> JunctionNode;
      //      Merge(st, ncopy, n, node)
      //  | JunctionNode(state = st, guard = g, action = a, to = t, parent = p) => 
      //      def t = t.SetCopy(ncopy);
      //      JunctionNode(st, ncopy, g, a, t, p)
      //  | _ => this
      //}
    }

    copy_name : string
    {
      get
      {
        if (copy == 0) "" else $"$copy"
      }
    }

    [NeedChange]
    public state : FsmState;

    //[RecordIgnore] [Accessor] cloneFor : PseudoStateNode;
    public copy : int;

    public NativeName : option[string]
    {
      get
      {
        match (this)
        {
          | Join(name = n) 
          | Choice(name = n)
          | Merge(name = n)
          | Junction(name = n) => Some(n)
          | _ => None()
        }
      }
    }

    public static @==(a : PseudoStateNode, b : PseudoStateNode) : bool
    {
      | (Join(state = st, name = null, target = t), Join(state = st2, name = null, target = t2)) => st == st2 && t == t2
      | (Junction(name = n), Junction(name = n2))
      | (Choice(name = n), Choice(name = n2))
      | (Join(name = n), Join(name = n2))
      | (Merge(name = n), Merge(name = n2)) => n == n2
      | (Fork(target = lst, state = st), Fork(target = lst2, state = st2)) => st == st2 && lst.Equals(lst2, _ == _)
      | (EntryPoint(state = st), EntryPoint(state = st2))
      | (ExitPoint(state = st), ExitPoint(state = st2))
      | (Terminate(state = st), Terminate(state = st2)) => st == st2
      | _ => false
    }

    public virtual UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
    {
      if (state !=null && state.reference) 
      {
        def (st, an) = an.statemap.Get(state.Name, an);
        def st = if (st != null) ChangeState(st) else this;
        (st, an)
      } else (this, an)
    }

    public FoldThis(choice : string * list[PseudoStateNode] * Choice * DecisionNode * Choice -> PseudoStateNode,
                    junction : string * list[PseudoStateNode] * Junction * DecisionNode * Junction -> PseudoStateNode, 
                    merge : string * PseudoStateNode * Merge -> PseudoStateNode, 
                    fork : list[TransitionTarget] * list[StateTransition] * Fork -> PseudoStateNode,
                    join : string * TransitionTarget * ConcurrentRegion * list[StateTransition] * StateTransition * Join -> PseudoStateNode,
                    entry_point : EntryPoint -> PseudoStateNode,
                    exit_point : ExitPoint -> PseudoStateNode,
                    terminate : Terminate -> PseudoStateNode,
                    junc_node : option[GuardNode] * option[Actions] * TransitionTarget * PseudoStateNode * JunctionNode -> PseudoStateNode
                    ) : PseudoStateNode
    {
      def xnode(n, ot)
      {
        match (n)
        {
          | null 
          | x when (x : object == ot) => ot
          | x                         => x
        }
      }

      def loop(e, cont)
      {
        match (e)
        {
          | Choice(n, nn, p, dn)      as t => cont(xnode(choice(n, nn.MapCont((x, c) => c(loop(x, cont)), x => x), p, dn, t), t))//cont(xnode(choice(n, nn.Map(x => loop(x, cont)), p, dn, t), t)) // f x (fun x' -> loop (x'::acc) xs cont)
          | Junction(n, nn, p, dn)    as t => cont(xnode(junction(n, nn.Map(x => loop(x, cont)), p, dn, t), t))
          | Merge(n, nn)              as t => loop(nn, nnacc => cont(xnode(merge(n, nnacc, t), t)))
          | Fork(tt, ft)              as t => cont(xnode(fork(tt, ft, t), t))
          | Join(n, tt, r, tr, d)     as t => cont(xnode(join(n, tt, r, tr, d, t), t))
          | EntryPoint                as t => cont(xnode(entry_point(t), t))
          | ExitPoint                 as t => cont(xnode(exit_point(t), t))
          | Terminate                 as t => cont(xnode(terminate(t), t))
          | JunctionNode(g, a, tt, p) as t => cont(xnode(junc_node(g, a, tt, p, t), t))
        }
      }

      loop(this, x => x)
    }

    public Fold[T](choice : string * list[T] * Choice * DecisionNode * Choice -> T,
                  junction : string * list[T] * Junction * DecisionNode * Junction -> T, 
                  merge : string * T * Merge -> T, 
                  fork : list[TransitionTarget] * list[StateTransition] * Fork -> T,
                  join : string * TransitionTarget * ConcurrentRegion * list[StateTransition] * StateTransition * Join -> T,
                  entry_point : EntryPoint -> T,
                  exit_point : ExitPoint -> T,
                  terminate : Terminate -> T,
                  junc_node : option[GuardNode] * option[Actions] * TransitionTarget * PseudoStateNode * JunctionNode -> T
                  ) : T
    {            
      def loop(e, cont)
      {
        match (e)
        {
          | Choice(n, nn, p, dn)      as t => cont(choice(n, nn.Map(x => loop(x, cont)), p, dn, t))
          | Junction(n, nn, p, dn)    as t => cont(junction(n, nn.Map(x => loop(x, cont)), p, dn, t))
          | Merge(n, nn)              as t => loop(nn, nnacc => cont(merge(n, nnacc, t)))
          | Fork(tt, ft)              as t => cont(fork(tt, ft, t))
          | Join(n, tt, r, tr, d)     as t => cont(join(n, tt, r, tr, d, t))
          | EntryPoint                as t => cont(entry_point(t))
          | ExitPoint                 as t => cont(exit_point(t))
          | Terminate                 as t => cont(terminate(t))
          | JunctionNode(g, a, tt, p, n) as t => cont(junc_node(g, a, tt, p, t))
        }
      }

      loop(this, x => x)
    }


  }


}
