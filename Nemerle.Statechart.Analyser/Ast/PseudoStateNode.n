using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using FsmState;
  using ListUtils;

  [Record]
  public class FsmJunctionNode 
  {
    public pos : int;
    public guard : GuardNode;
    public action : option[Actions];
    public to : TransitionTarget;
  }

//  [RefNode]
  [Record]
  public variant PseudoStateNode
  {
    | History 
      {
        public this(st : FsmState, hist : PseudoStateAstNode.History)
        {
          base(st);
      //history = hist;
      //state = if (hist.state != null) FsmState.State(hist.state, null, analyser, true); else st;
          type = hist.type;
          default = hist.default.Map(x => StateTransition.Default(st, x, this))
        }

public SimpleName : string
        {
          get
          {
          def state = state.Super;
          $"$(state)History"
        }
        }        
    //public history : StateNode.History;

    //public state : FsmState
    //{
    //  get
    //  {
    //    statemap.ParentFor(Num)
    //  }
    //}

        public default : option[StateTransition] {get;set;}

        //public ChangeDefault(tran : StateTransition -> StateTransition) : History
        //{
        //  ChangeDefault(default.Map(tran))
        //}
    //[NeedChange]
    //[Accessor]
    //public num : int;

    //[NeedChange(default)]
    //[NeedChange] public state : FsmState;
        public type : HistoryType;
    //[NeedChange] public reference : bool;

        //[NeedChange] public Used : bool;

    //public this(an : FsmAnalyser) { analyser = an }
    //public this(hist : PseudoStateNode.History, clone : bool = false, ncopy : int = 0)
    //{
    //  history = hist.history;
    //  default = if (clone) hist.default.Map(x => x.Clone(ncopy) :> StateTransition.Default) else hist.default;
    //  state = hist.state;
    //  type = hist.type;
    //  reference = hist.reference;
    //  Used = hist.Used;
    //}

    //[Accessor] clone_for : PseudoStateNode.History;

    //public static @==(a : PseudoStateNode.History, b : PseudoStateNode.History) : bool
    //{
    //  a.Num == b.Num//a.Name == b.Name && a.type == b.type && a.state == b.state
    //}

    //public static @!=(a : PseudoStateNode.History, b : PseudoStateNode.History) : bool
    //{
    //   !(@==(a, b))
    //}


        //public BothHistories(st : FsmState) : bool
        //{
        //  st.BothHistories
        //}



        //public override ToString() : string
        //{
        //  Name
        //}

        //public SubStatesParticipateInHistory : IEnumerable[FsmState]
        //{
        //  get
        //  {
        //    state.SubStatesParticipateIn(this)
        //  }
        //}

    //public ChangeState(st : FsmState) : void
    //{
    //  analyser.statemap.ParentFor(Num, st)
    //}
    //public SubStatesParticipateInHistoryIndirect : IEnumerable[FsmState]
    //{
    //    st.Updated.SubStatesParticipateIn(this)
    //}

        //public Updated : PseudoStateNode.History
        //{
        //  get
        //  {
        //    state.GetHistory(this)
        //  }
        //}

        //public ChangeDefault(tran : StateTransition -> StateTransition) : History
        //{
        //  ChangeHistory(history.ChangeDefault(history.default.Map(tran)))
        //}

        //this(st : FsmState, type : TargetType.History)
        //{
        //  base(st.analyser);
        //  history = PseudoStateNode.History.Create(st, -1, type.history)
        //}
      }
#if 0
    | Junction
      {
        [NeedChange] name : string;
        [NeedChange] tree : BinaryTree[TreeJunctionNode];// TransitionTarget.JunctionNode;
        [NeedChange] nodes : list[FsmJunctionNode];
        //[TraverseIgnore] parent : Junction;
        type : JunctionType;
        //[NeedChange] decisionTree : DecisionNode;

        IsUnnamed : bool;
        //ChangeDecisionTree(tree : DecisionNode) : Junction
        //{
        //  ChangeTo(to.ChangeDecisionTree(tree))
        //}

        this(n : string, nodes : list[FsmJunctionNode], type : JunctionType, is_unnamed : bool)
        {
          base(0);
          name = n;
          IsUnnamed = is_unnamed;
          this.nodes = nodes;
          this.type = type;
        }

        static CreateTree(node : PseudoStateNode) : void
        {
          def tree = TreeJunctionNode.Create(node);//lst |> JunctionNode(st, tran, _, this);
          node.Update(x => (x :> Junction).ChangeTree(tree))
        }

        Create(an : FsmAnalyser, st : FsmState, node : PseudoStateAstNode.Junction) : PseudoStateNode
        {
          def (name, unnamed) =  match (node) 
          {
            | PseudoStateAstNode.Junction(name = null, type = JunctionType.Choice) => def num = an.NextChoiceNum();
                                                                                      ($"UnnamedChoice$num", true)
            | Junction(name = null, type = JunctionType.Junction)                  => def num = an.NextJunctionNum();
                                                                                      ($"UnnamedJunction$num", true)
            | Junction(name = n)                                                   => (n, false)
          }
          def create_node(x)
          {
            | JunctionNode(p, g, a, t) => FsmJunctionNode(p, g, a, TransitionTarget.Create(st, t))
          }
          //def tree = TreeJunctionNode.Create(node);//lst |> JunctionNode(st, tran, _, this);
          def nodes = node.node.Map(create_node);
          def junc = Junction(name, nodes, node.type, unnamed);
          NodeValue(st, junc);
        }
        //Nodes : IEnumerable[TransitionTarget.JunctionNode]
        //{
        //  get
        //  {
        //    def loop(t)
        //    {
        //      yield t;
        //      match (t.next)
        //      {
        //        | Some(t) => loop(t)
        //        | _       => ()
        //      }
        //    }

        //    loop(to)

        //  }
        //} 

        TypeName : string
        {
          get
          {
            match (type)
            {
              | Junction => "Junction"
              | Choice   => "Choice"
              | Merge    => "Merge"
            }
          }
        }

        Name : string
        {
          get
          {
            $"$name$TypeName$copy_name"
          }
        }

        //IsTop : bool 
        //{
        //  get
        //  {
        //    parent == null
        //  }
        //}

        //Actions : IEnumerable[PathNode]
        //{
        //  get
        //  {
        //    tree.Fold((x, a) => a.Concat(x.action))
        //  }
        //}

        Guards : IEnumerable[GuardNode]
        {
          get
          {
            def data = tree.GetBreadthFirstEnumerable().FoldLeft([], (x, a) => x.Data.guard :: a);
            data.Exclude(_ is GuardNode.Else)
            //def g = Nodes.Select(_.guard);//FoldLeft([], (x, a) => a + x.Guards).Rev();
            //g.Exclude(_ is GuardNode.Else)
          }
        }

        //override UpdateReference() : PseudoStateNode
        //{
        //  def st = ChangeTo(to.UpdateReference() :> TransitionTarget.JunctionNode);
        //  st.UpdateReference()
        //}

        override ToString() : string
        {
          Name
        }

      }
#endif
    | Fork 
      {
        target    : list[TransitionTarget];
        fork_tran : list[StateTransition]  {get;set;default []}

        //override UpdateReference() : PseudoStateNode
        //{ 
        //  // TODO: сделать через Lazy создание нового списк только в случае если есть новые элементы
        //  def st = base.UpdateReference();
        //  match (st)
        //  {
        //    | Fork as j => def target = target.Map(_.UpdateReference());
        //                   j.ChangeTarget(target)//(Fork(st, copy, target, fork_tran), an)
        //    | _         => this
        //  }
        //}

        //override ToString() : string
        //{
        //  "FO"
        //}
      }
    | Join 
      {
        name : string;
        target : TransitionTarget {get;set;}
        region : FsmState {get;set;}


        joined_tran : list[StateTransition] {get;set;default []}
        transition : StateTransition {get;set;}

        trigger : StateEvent
        {
          get
          {
            match (joined_tran.NToList())
            {
              | []                                => null
              | t :: _ => t.Trigger
            }
          }
        }



        //override UpdateReference() : PseudoStateNode
        //{
        //  def tar = target?.UpdateReference();
        //  def st = base.UpdateReference();
        //  match (st)
        //  {
        //    | Join as j => j.ChangeTarget(tar)//Join(state, copy, name, tar, region, joined_tran, transition)
        //    | _         => this
        //  }
        //}

      }
    | EntryPoint
    | ExitPoint
    | Terminate { override ToString() : string {"Terminate"} }

    public static Create(st : FsmState, pseudo : PseudoStateAstNode) : PseudoStateNode
    {
      match (pseudo)
      {
        | History as hist     => History(st, hist)
        //| Junction as j                              => Junction.Create(st, j)
        //| Fork(target = lst)                         => Fork(0, lst.Map(TransitionTarget.Create(st, _)), [])
        //| Join(name = n, target = t)                 =>  Join(0, n, TransitionTarget.Create(st, t), null, null, null))
        | EntryPoint                                 //EntryPoint(0, num, an))
        | ExitPoint                                  => null//ExitPoint(0, num, an)
        | Terminate                                  => Terminate(st)
        | _                                          => throw NotImplementedException("this TransitionTarget not implemented")
      }
    }

    //copy_name : string
    //{
    //  get
    //  {
    //    if (copy == 0) "" else $"$copy"
    //  }
    //}

    public state : FsmState {get;set;}
    ////[NeedChange]
    //public state : FsmState
    //{
    //  get
    //  {
    //    StateMap.ParentFor(Num)
    //  }
    //}

    //public ChangeState(st : FsmState) : void
    //{
    //  StateMap.ParentFor(Num, st)
    //}
    //[RecordIgnore] [Accessor] cloneFor : PseudoStateNode;
    //[NeedChange]
    //public copy : int;


    public NativeName : option[string]
    {
      get
      {
        match (this)
        {
          | Join(name = n) => Some(n)
          //| Junction(name = n) 
          | _                  => None()
        }
      }
    }

    
        
    public Name : string
        {
          get
          {
          //def state_val = state;
          match (this)
          {
            | PseudoStateNode.History(type = t) => 
            
              def type = match (t)
                          {
                            | HistoryType.Deep     => "Deep"
                            | Shallow              => "Shallow"
                            | None                 => ""
                          }

              
              if (state.history.IsOne) $"$(state)History" else $"$(state)$(type)History"
           | Join(name = n )           => $"Join$n"//$copy_name
           | PseudoStateNode.Terminate => $"$(state)Terminate"
           | Fork(target = t)          => $<#Fork$(state)To..$(t;"_")#>
           | n                         => n.ToString()
           //| FsmNode.State(st)                                => st.Value.Name
           //| FsmNode.PseudoState(n)                           => n.ToString()
          }
        }
        }
        
        public override ToString() : string
        {
          Name
        }
        
    analyser : FsmAnalyser
    {
      get
      {
        state.analyser
      }
    }
    
    public Used : bool
    {
      get
      {
        analyser.Used[this]
      }
      set
      {
        analyser.Used[this] = value
      }
    }

    //public Clone() : PseudoStateNode
    //{
    //  match (this)
    //  {
    //    //| Junction(tree = t) as n => n.ChangeTree(t.Clone())
    //    | n                       => n
    //  }
    //}
    //public static @==(a : PseudoStateNode, b : PseudoStateNode) : bool
    //{
    //  | (null, null) => true
    //  | (null, _)    
    //  | (_, null)    => false
    //  | _            => a.Num == b.Num
    //}

    //public analyser : FsmAnalyser;

    //public StateMap : StateMap
    //{
    //  get
    //  {
    //    analyser.statemap
    //  }
    //}

  }


}
