using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using FsmState;
  using ListUtils;

  [Record]
  public variant PseudoStateNode
  {
    | Junction
      {
        [NeedChange] name : string;
        [NeedChange] to : TransitionTarget.JunctionNode;
        [TraverseIgnore] parent : Junction;
        type : JunctionType;

        this(st : FsmState, n : string, node : TargetType.JunctionNode, tran : StateTransition, type : JunctionType)
        {
          base(st, 0);
          this.to = TransitionTarget.JunctionNode.Create(st, this, node, tran);//lst |> JunctionNode(st, tran, _, this);
          name = n;
          this.type = type;
        }

        Nodes : IEnumerable[TransitionTarget.JunctionNode]
        {
          get
          {
            def loop(t)
            {                
              yield t;
              match (t.next)
              {
                | Some(t) => loop(t)
                | _       => ()
              }
            }

            loop(to)

          }
        } 

        Name : string
        {
          get
          {
            match (type)
            {
              | Junction => $"Junction$name$copy_name"
              | Choice   => $"Choice$name$copy_name"
            }
          }
        }

        [NeedChange] decisionTree : DecisionNode;

        IsTop : bool 
        {
          get
          {
            parent == null
          }
        }

        Actions : PathNode
        {
          get
          {
            decisionTree.ActionNode
          }
        }

        Guards : IEnumerable[GuardNode]
        {
          get
          {
            def g = Nodes.Select(_.guard);//FoldLeft([], (x, a) => a + x.Guards).Rev();
            g.Exclude(_ is GuardNode.Else)
          }
        }

        override UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
        {
          def (st, an) = base.UpdateReference(an);
          match (st)
          {
            | Junction(to = to) as j => 
                match (to.UpdateReference(an))
                {
                 | (TransitionTarget.JunctionNode as nt, an) => (j.ChangeTo(nt), an)
                 | (_, an) => (j, an)
                }
            | _ => (this, an)
          }
        }

        override ToString() : string
        {
          Name
        }

      }

    | Merge
      {
        name : string;
        [NeedChange] to : TransitionTarget.JunctionNode;

        this(st : FsmState, n : string, node : TargetType.JunctionNode, tran : StateTransition)
        {
          base(st, 0);
          this.to = TransitionTarget.JunctionNode.Create(st, this, node, tran);//lst |> JunctionNode(st, tran, _, this);
          name = n;
        }

        public override UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
        {
          def (nnode, an) = to.UpdateReference(an);
          def (st, an) = base.UpdateReference(an);
          
          def st = match (st, nnode)
                    {
                      | (Merge as j, TransitionTarget.JunctionNode as to) => j.ChangeTo(to)//Merge(x.state, copy, name, nnode :> TransitionTarget.JunctionNode)
                      | (_, _)                                            => this
                    }
          (st, an)
        }

        Name : string
        {
          get
          {
            $"Merge$name$copy_name"
          }
        }

        override ToString() : string
        {
          Name
        }
      }
    | Fork 
      {
        [NeedChange] target : list[TransitionTarget];
        [NeedChange] fork_tran : list[StateTransition] = [];

        override UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
        { 
          // TODO: сделать через Lazy создание нового списк только в случае если есть новые элементы
          def (st, an) = base.UpdateReference(an);
          match (st)
          {
            | Fork as j => def (target, an) = target.MapThrough(an, _.UpdateReference(_));
                           (j.ChangeTarget(target), an)//(Fork(st, copy, target, fork_tran), an)
            | _         => (this, an)
          }
        }

        Name : string
        {
          get
          {
            $<#Fork$(state)To..$(target;"_")#>
          }
        }

        override ToString() : string
        {
          Name
        }
      }
    | Join 
      {
        name : string;
        [NeedChange] target : TransitionTarget;
        [NeedChange(joined_tran, transition)] region : ConcurrentRegion;

        joined_tran : list[StateTransition] = [];
        transition : StateTransition;

        trigger : StateEvent
        {
          get
          {
            match (joined_tran)
            {
              | [] => null
              | StateTransition where (Trigger = t) :: _ => t
            }
          }
        }

        Name : string
        {
          get
          {
            $"Join$name$copy_name"
          }
        }

        override ToString() : string
        {
          Name
        }

        override UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
        {
          def (tar, an) = target?.UpdateReference(an);
          def (st, an) = base.UpdateReference(an);
          def st = match (st)
                    {
                      | Join as j => j.ChangeTarget(tar)//Join(state, copy, name, tar, region, joined_tran, transition)
                      | _         => this
                    }
          (st, an)
        }

      }
    | EntryPoint
    | ExitPoint
    | Terminate
      {
        Name : string
        {
          get
          {
            $"$(state)Terminate"
          }
        }


        override ToString() : string
        {
          Name
        }
      }


    public static Create(st : PseudoStateAstNode, state : FsmState, tran : StateTransition) : PseudoStateNode
    {
      def analyser = state.analyser;
      match (st)
      {
        | Junction(null, node, JunctionType.Junction) => 
            def num = analyser.NextJunctionNum();
            def name = $"Unnamed$num";
            Junction(state, name, node, tran, JunctionType.Junction)
            
        | Junction(null, node, JunctionType.Choice) => 
            def num = analyser.NextChoiceNum();
            def name = $"Unnamed$num";
            //j.ChangeName(name)
            Junction(state, name, node, tran, JunctionType.Choice)

        | Junction(name = n, node = nn, type = tp)   => Junction(state, n, nn, tran, tp)
        | Merge(name = n, node = node)    => Merge(state, n, node, tran)
        | Fork(target = lst)              => Fork(state, 0, lst |> TransitionTarget.Create(state, tran, _), null)
        | Join(name = n, target = t)      => Join(state, 0, n, TransitionTarget.Create(state, tran, t), null, null, null)
        | EntryPoint                      => EntryPoint(state, 0)
        | ExitPoint                       => ExitPoint(state, 0)
        | Terminate                       => Terminate(state, 0)
      }

    }

    copy_name : string
    {
      get
      {
        if (copy == 0) "" else $"$copy"
      }
    }

    [NeedChange]
    public state : FsmState;

    //[RecordIgnore] [Accessor] cloneFor : PseudoStateNode;
    [NeedChange]
    public copy : int;

    public NativeName : option[string]
    {
      get
      {
        match (this)
        {
          | Join(name = n) 
          | Merge(name = n)
          | Junction(name = n) => Some(n)
          | _ => None()
        }
      }
    }

    public static @==(a : PseudoStateNode, b : PseudoStateNode) : bool
    {
      | (Join(state = st, name = null, target = t), Join(state = st2, name = null, target = t2)) => st == st2 && t == t2
      | (Junction(name = n), Junction(name = n2))
      | (Join(name = n), Join(name = n2))
      | (Merge(name = n), Merge(name = n2)) => n == n2
      | (Fork(target = lst, state = st), Fork(target = lst2, state = st2)) => st == st2 && lst.Equals(lst2, _ == _)
      | (EntryPoint(state = st), EntryPoint(state = st2))
      | (ExitPoint(state = st), ExitPoint(state = st2))
      | (Terminate(state = st), Terminate(state = st2)) => st == st2
      | _ => false
    }

    public virtual UpdateReference(an : FsmAnalyser) : PseudoStateNode * FsmAnalyser
    {
      if (state !=null) 
      {
        def (st, an) = an.statemap.Get(state.Name, an);
        def st = if (st != null) ChangeState(st) else this;
        (st, an)
      } else (this, an)
    }

  }


}
