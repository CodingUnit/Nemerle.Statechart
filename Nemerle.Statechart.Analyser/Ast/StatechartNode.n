using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

  using FsmState;

  [Record]  
  public class StateEvent
  {
    [Accessor] evt : TransitionNode.Event;
    //public InternalOnly : bool {get;set;}

    public Name : string
    {
      get
      {
        if (evt.name != null) evt.name else "Completion"
      }
    }

    public CompareTo(b : StateEvent) : int
    {
      Name.CompareTo(b.Name)
    }

    public static  @== (a : StateEvent, b : StateEvent) : bool
    {
      a.Name == b.Name
    }

    public IsCompletion : bool
    {
      get
      {
        evt.name == null
      }
    }

    public override ToString() : string
    {
      $"Event$Name"
    }
  }

  [Record]
  public class StateHistory
  {
    
    public this(an : FsmAnalyser, hist : StateNode.History, reference : bool = false)
    {
      this(an);
      history = hist;
      //state = if (hist.state != null) FsmState.State(hist.state, null, analyser, true); else st;
      type = hist.type;
      this.reference = reference;
      default = history.default |> StateTransition.Default(this, _).Create();
    }

    public history : StateNode.History;
    
    public state : FsmState
    {
      get
      {
        StateMap.ParentFor(Num)
      }
    }
    
    [NeedChange]
    public default : option[StateTransition];
    
    [NeedChange]
    public Num : int;
    
    //[NeedChange(default)]
    //[NeedChange] public state : FsmState;
    public type : HistoryType;
    [NeedChange] public reference : bool;

    [NeedChange] public Used : bool;

    public analyser : FsmAnalyser;
    
    public StateMap : StateMap
    {
      get
      {
        analyser.statemap
      }
    }
    
    public this(an : FsmAnalyser) { analyser = an }
    //public this(hist : StateHistory, clone : bool = false, ncopy : int = 0)
    //{
    //  history = hist.history;
    //  default = if (clone) hist.default.Map(x => x.Clone(ncopy) :> StateTransition.Default) else hist.default;
    //  state = hist.state;
    //  type = hist.type;
    //  reference = hist.reference;
    //  Used = hist.Used;
    //}

    public static Create(hist : TwoOption[StateNode.History], href : bool = false) : TwoOption[StateHistory]
    {      
      hist.Map(Create(_, href))
    }

    public static Create(an : FsmAnalyser, hist : StateNode.History, href : bool = false) : StateHistory
    {
      match (hist)
      {
        | StateNode.History(type = HistoryType.Deep)    => StateHistory(an, hist, href)
        | StateNode.History(type = HistoryType.Shallow) => StateHistory(an, hist, href)
        | _                                             => throw InvalidOperationException("Unknown history node")
      }
    }

    //[Accessor] clone_for : StateHistory;

    public static  @==(a : StateHistory, b : StateHistory) : bool
    {
      | (null, null)  => true
      | (a, null)     => a : object  ==  null
      | (null, b)     => b : object  ==  null
      | (_, _)        => a.Num == b.Num//a.Name == b.Name && a.type == b.type && a.state == b.state
    }

    public static @!=(a : StateHistory, b : StateHistory) : bool
    {
       !(@==(a, b))
    }

    
    public BothHistories(st : FsmState) : bool
    {
        st.BothHistories
    }

    public Name(st : FsmState) : string
    {
        def type = match (type)
                    {
                      | HistoryType.Deep     => "Deep"
                      | Shallow              => "Shallow"
                      | None                 => ""
                    }

        if (st.Updated.history.IsOne) $"$(st)History" else $"$(st)$(type)History"
    }

    public SimpleName(st : FsmState) : string
    {
        $"$(st)History"
    }

    public override ToString() : string
    {
      Name
    }

    public SubStatesParticipateInHistory(st : FsmState) : IEnumerable[FsmState]
    {
        st.Updated.SubStatesParticipateIn(this)
    }

    public SubStatesParticipateInHistoryIndirect(st : FsmState) : IEnumerable[FsmState]
    {
        st.Updated.SubStatesParticipateIn(this)
    }

    //public Updated : StateHistory
    //{
    //  get
    //  {
    //    state.Updated.GetHistory(this)
    //  }
    //}
    
    public UpdateReference() : StateHistory
    {
      def st = StateMap.Get(state);
      def hist = if (history.reference)
                  {
                    state.GetHistory(this);
                  } else this;

      def default = default.Map(_.UpdateReference());
      hist.ChangeStateDefault(st, default)
    }

  }

  [Record]    
  [DebuggerDisplay("Actions  =  {actions}")]
  public variant StateAction : Actions
  {
    | Entry
      {

        GetName(state : FsmState) : string
        {
            $"$(state)Entry"
        }

        flags : ActionFlags;

        override ToString() : string
        {
          $"Entry $(base.ToString())"
        }

      }
    | Exit
      {

        GetName(state : FsmState) : string
        {
          $"$(state)Exit"
        }

        flags : ActionFlags;

        override ToString() : string
        {
          $"Exit $(base.ToString())"
        }
      }

    | Do 
      {
        [FlagAccessor (Concurrently,  NoWaitCancel, NotLong)]
        [NeedChange] public flags : ActivityFlag; // shows that we must run each action concurrently with others

        GetName(state : FsmState) : string
        {
          $"DoActivity$(state)"
        }

        override ToString() : string
        {
          $"DoActivity $(base.ToString())"
        }
      }       


    //[NeedChange] public state : FsmState;
  }

}
