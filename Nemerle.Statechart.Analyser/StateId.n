using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{

  using FsmState;
  using BitUtils;

  [Record]
  public class IdType
  {
    public val : BitArray;

    public Count : int
    {
      get
      {
        val.Count
      }
    }

    public Length : int 
    {
      get
      {
        MathUtils.UpperDiv(Count, 32)
      }
    }

    public Or(id : IdType) : IdType
    {
      def id = val | id.val;
      IdType(id)
    }

    public static @|(id : IdType, id2 : IdType) : IdType
    {
      id.Or(id2)
    }

    public UInt : uint
    {
      get
      {
        Result[0] :> uint
      }
    }

    public ULong : ulong
    {
      get
      {
        unchecked 
        {
          def r1 = Result[0] :> uint;
          def r2 = Result[1] :> uint;
          BitUtils.MakeLong(r1, r2)
        }
      }
    }

    public Result : array[int]
    {
      get
      {
        def res = array(Length);
        val.CopyTo(res, 0);
        res
      }
    }

  }

  /// <summary>
  /// State identifier
  /// </summary>
  [Record]
  public class StateId
  {
    analyser : FsmAnalyser;

    public IsSimple : bool
    {
      get
      {
        Length <= 2
      }
    }

    public IsStruct : bool
    {
      get
      {
        def len = Length;
        len > 2 && len <= 4
      }
    }

    public Length : int 
    {
      get
      {
        MathUtils.UpperDiv(Count, 32)
      }
    }

    Count : int
    {
      get
      {
        analyser.statemap.States.Count()
      }
    }

    public CreateMasks() : void
    {
      def st = analyser.States.NToList();
      def idx = st.MapIndex((x, i) => (x, i));
      def map = Hashtable(idx);
      
      def create_id(t)
      {
        def id = BitArray(Count);
        def num = map[t];
        id[num] = true;
        IdType(id)
      }

      def create_num_id(s)
      {
        def id = create_id(s);
        def id = if (s.Parent != null) id | s.Parent.Data.Id else id;
        s.Update(x => x.ChangeId(id))
      }


      def mark_inlined_inst(t : GeneralTree[FsmState])
      {
        match (t.PartOfStateMachine())
        {
        //| FsmState          => null//(CloneFor = null) => null
        | Some(m) => 
              def id = t.Data.Id;
              def clone_id = analyser.Clones.Find(x => x.Value.Exists(x => x == t : object)).Value.Key.Data.Id;
              def inlined_super_id = m.Super().Data.Id;
               // CloneFor = FsmState(Id = clone_id, PartOfStateMachine = Some(FsmState(Super = FsmState(Id = inlined_super_id)))
              def clone_id = clone_id.val & ~inlined_super_id.val; // get clone id but without it super state environment
              def id = (id.val | clone_id); // merge current id and from it is cloned
              def id = IdType(id);
              t.Update(x => x.ChangeId(id))

        | _ => ()
        }
      }

      // first pass
      st.Iter(create_num_id);
      //analyser.UpdateStateMap(st);
      // second pass
      st.Iter(mark_inlined_inst);
      //analyser.UpdateStateMap(st)
    }

  }
}
