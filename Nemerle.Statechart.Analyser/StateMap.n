using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

using NC = Nemerle.Collections;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using FsmState;

  //[Record]
  public partial class StateMap
  {
    public Analyser : FsmAnalyser;

    [Accessor]
    state_tree : FsmState;
    
    [Accessor]
    mutable pseudo_states : NC.Hashtable[FsmState, list[PseudoStateNode]];// = NC.Hashtable();
    //[Accessor]
    //transitions   : ValueMap[FsmState, StateTransition] = ValueMap();
    [Accessor]
    mutable all_pseudo : IEnumerable[PseudoStateNode];
    [Accessor]
    mutable states : array[FsmState];
    
    // if changed tree added new states or pseudo create new cached tree iterator
    Rebuild() : void
    {
      states = state_tree.GetBreadthFirstEnumerable().ToArray();
      pseudo_states = NC.Hashtable();
      states.Iter(x => pseudo_states.Add(x, x.pseudo_states));
      all_pseudo = pseudo_states.SelectMany(x => x.Value)
    }
    
    public this(an : FsmAnalyser, stree : FsmState) 
    { 
      state_tree = stree;
      Analyser = an; 
      Rebuild()
      ///tr.GetBreadthFirstEnumerable().Iter(x => when (x.Value is FsmNode.State(n)) map[n] = x)
    }

    public Get(state : list[string]) : FsmState
    {
      def merge_name(n)
      {
        $<#..$(n;".")#>
      }

      def get_loop(st : list[_], lst, path)
      {
        | (st, head :: tail, p) => 
              def path = head :: p;
              match (get_all_state(st, head), tail)
              {
                | ([], _)    => Analyser.AddError(FsmError.StateNotFound(FsmState(merge_name(path.Rev()), Analyser))); null
                | ([st], []) => st
                | ([st], _)  => get_loop(st.sub_states, tail, path)
                | (lst, _)   => Analyser.AddError(FsmError.SeveralState(lst.Map(x => FsmState(merge_name((x.NativeName() :: p).Rev()), Analyser))));
                                null
              }
        | _                => null
      }

      get_loop(states.NToList(), state, [])
    }

    get_all_state(map : IEnumerable[FsmState], state : string) : list[FsmState]
    {
      def name = state ?? FsmState.TopStateName;
      def (name, sub_name) = if (name != FsmState.TopStateName) 
                              {
                                def sub =  name.GetSub('[', ']');
                                if (sub != null) (name.GetSub('['), sub) else (name, null)
                              } else (name, null);
      def name = if (sub_name != null) $"$(name)SubRegion$sub_name" else name;
      map.Filter(x => x.NativeName() == name)
    }


    public Get(state : string) : FsmState
    {
      def st = state.SplitToList('.');
      Get(st)
    }

    public Add(parent : FsmState, st : FsmState) : void
    {
      parent.Add(st);
      Rebuild()
      //transitions.Add(st, []);
    }
    
    public static Create(an : FsmAnalyser, state : StateNode.State) : void
    {
      def top = TreeUtils.FoldTree(state, null, _.sub_states, FsmState(_, _, an));
      def map = StateMap(an, top);
      an.statemap = map;
      map.UpdateReferences();
    }

  }
}
