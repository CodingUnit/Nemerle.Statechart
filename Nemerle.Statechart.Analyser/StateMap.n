using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

using NC = Nemerle.Collections;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using FsmState;

  //[Record]
  public partial class StateMap
  {
    public Analyser : FsmAnalyser;

    [Accessor]
    state_tree : GeneralTree[FsmState];
    
    [Accessor]
    pseudo_states : ValueMap[FsmState, PseudoStateNode] = ValueMap();
    [Accessor]
    transitions   : ValueMap[FsmState, StateTransition] = ValueMap();

    public States : IEnumerable[GeneralTree[FsmState]]
    {
      get
      {
        state_tree.AllStates()
      }
    }

    public this(an : FsmAnalyser, stree : GeneralTree[FsmState], pseudo : ValueMap[FsmState, PseudoStateNode], tr : ValueMap[FsmState, StateTransition]) 
    { 
      state_tree = stree;
      Analyser = an; 
      pseudo_states = pseudo;
      transitions = tr;
      ///tr.GetBreadthFirstEnumerable().Iter(x => when (x.Value is FsmNode.State(n)) map[n] = x)
    }

    public Get(state : list[string]) : GeneralTree[FsmState]
    {
      def merge_name(n)
      {
        $<#..$(n;".")#>
      }

      def get_loop(st : list[GeneralTree[_]], lst, path)
      {
        | (st, head :: tail, p) => 
              def path = head :: p;
              match (get_all_state(st, head), tail)
              {
                | ([], _)    => Analyser.AddError(FsmError.StateNotFound(State(merge_name(path.Rev()), Analyser))); null
                | ([st], []) => st
                | ([st], _)  => get_loop(st.SubStates().NToList(), tail, path)
                | (lst, _)   => Analyser.AddError(FsmError.SeveralState(lst.Map(x => State(merge_name((x.NativeName() :: p).Rev()), Analyser))));
                                null
              }
        | _                => null
      }

      get_loop(States.NToList(), state, [])
    }

    get_all_state(map : IEnumerable[GeneralTree[FsmState]], state : string) : list[GeneralTree[FsmState]]
    {
      def name = state ?? FsmState.TopStateName;
      def (name, sub_name) = if (name != FsmState.TopStateName) 
                              {
                                def sub =  name.GetSub('[', ']');
                                if (sub != null) (name.GetSub('['), sub) else (name, null)
                              } else (name, null);
      def name = if (sub_name != null) $"$(name)SubRegion$sub_name" else name;
      map.Filter(x => x.NativeName() == name)
    }


    public Get(state : string) : GeneralTree[FsmState]
    {
      def st = state.SplitToList('.');
      Get(st)
    }

    public Add(parent : GeneralTree[FsmState], st : GeneralTree[FsmState]) : void
    {
      parent.Add(st);
      pseudo_states.Add(st, []);
      transitions.Add(st, []);
    }
    
    public static Create(an : FsmAnalyser, state : StateNode.State) : void
    {
      def create_node(s, sb : IEnumerable[_] = null) : GeneralTree[_]
      {
        def node = GeneralTree(s);
        when (sb != null) node.AddRange(sb);
        node 
      }

      def top = state.Fold(null, 
                           (s, sb) => create_node(FsmState.CreateState(s, an), sb),
                           (s, sr) => create_node(FsmState.ConcurrentRegion(s, an), sr));

      def pseudo_map = ValueMap();
      def tran_map   = ValueMap();

      def create_tree(n)
      {
        //def node = GeneralTree(FsmNode.State(n));

        //when (sb != null) node.AddRange(sb);
		def st = n.Data.state;
        def pseudo = st.pseudo_states.Select(x => PseudoStateNode.Create(n, x.node));				        
		
        def tran   = StateTransition.Create(n, n.Data.state.transitions);
		def tran   = StateTransition.Create(n, n.Data.state.initial).Concat(tran);
		def tran   = StateTransition.Create(n, n.Data.state.internal_tran).Concat(tran);
        def tran   = tran.Map(NodeValue(n, _));
        pseudo_map.Add(n, pseudo);
        tran_map.Add(n, tran);
        //pseudo_states.
        //node.Children.AddRange(pseudo);
        //node
      }

      top.GetBreadthFirstEnumerable().Iter(create_tree);


      def map = StateMap(an, top, pseudo_map, tran_map);
      an.statemap = map;
      map.UpdateReferences();
    }

    //public Update(top : FsmState) : void
    //{
    //  BeginUpdate();
    //  UpdateInternal(top);
    //  EndUpdate();
    //}

    //public Update(force : bool = false) : void
    //{
    //  when (force || Updating == 0)
    //  {
    //    BeginUpdate();
    //    def st = ChangeMan.CheckChange();
    //    if (st.IsEmpty()) () else UpdateInternal(st);
    //    EndUpdate();
    //  }	  
    //}

    //mutable Updating : int;

    //BeginUpdate() : void
    //{
    //  Updating++;
    //}

    //EndUpdate() : void
    //{
    //  Updating--;
    //}

    //UpdateInternal(top : FsmState) : void
    //{

    //  // if top is not top state, but some child
    //  if (Top != null && Top.Num != -1 && top.Num != Top.Num)
    //  {
    //    UpdateInternal(TraverseUtils.SingleElement(top))
    //  } else
    //    when (top : object != Top)
    //    {
    //      if (TopNum == -1) // if not set number
    //      {
    //        def st = top.LevelOrderMap(x => x.ChangeNum(GetNextGlobalNum())).ToArray();
    //        TopNum = st.First().Num;
    //        UpdateInternal(st, top)
    //      } else
    //      {
    //        def st = top.AllStates;
    //        def len = states.Length;
    //        states = st.MakeArrayMap(st, global_id, _.Num);//OrderBy(_.Num).ToArray();
    //        ChangeMan.StateMapChanged();
    //        Update(true);
    //        def new_states = len != states.Length; // 
    //        // update super state map
    //        // if new map
    //        when (super_map.Length < global_id)
    //        {
    //          // create new super state map
    //          def supers = States.SelectMany(x => x.AllChilds.Select(y => (y, x.Num))).AddBefore((TopNum, -1));
    //          super_map = supers.MakeArrayMap(global_id);
    //        }
    //        when (new_states || NewReferences)
    //        {
    //          def st = top.ReduceSingle((x, _) => UpdateStateReference(x)); // update references in tree
    //          NewReferences = false;
    //          UpdateInternal(st)
    //        }
    //      }
    //    }
    //}

    //public Super(st : FsmState) : FsmState
    //{
    //  def num = st.Num;
    //  if (num != -1) ParentFor(num) else null
    //}

    //public Count : int
    //{
    //  get
    //  {
    //    states.Length
    //  }
    //}

    //public TopNum : int {get; private set;}

    public Top : GeneralTree[FsmState]
    {
      get
      {
        state_tree
      }
    }
  }
}
