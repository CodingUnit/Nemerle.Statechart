using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

using NC = Nemerle.Collections;

namespace Nemerle.Statechart
{
  using FsmState;

  [Record]
  public class StateMap
  {
    mutable states : array[FsmState] = array[];

    public Analyser : FsmAnalyser;

    public namemap : Hashtable[string, int] = Nemerle.Collections.Hashtable();
    public tranmap : Hashtable[string, int] = Nemerle.Collections.Hashtable();

    public GetNewStateId(state : FsmState) : int
    {
      match (namemap.Get(state.Name))
      {
        | Some(num) => num
        | _         => def num = GetNextStateNum();
                      namemap[state.Name] = num;
                      num
      }
    }

    public GetNewTransitionId(tran : StateTransition) : int
    {
      match (tranmap.Get(tran.Name))
      {
        | Some(num) => num
        | _         => def num = GetNextTransitionNum();
                       tranmap[tran.Name] = num;
                       num
      }
    }

    [Accessor]
    mutable state_num      : int;

    [Accessor]
    mutable transition_num : int;

    GetNextStateNum() : int
    {
      def num = state_num;
      state_num++;
      num
    }

    GetNextTransitionNum() : int
    {
      def num = transition_num;
      transition_num++;
      num
    }

    public States : IEnumerable[FsmState]
    {
      get
      {
        states
      }
    }

    public this(an : FsmAnalyser) { Analyser = an; TopNum = -1 }

    public Contains(state : FsmState) : bool
    {
      states.Length - 1 >= state.Num
    }

    public static GetFullName(st : list[FsmState]) : string
    {
      string.Join(".", st |> NativeName)
    }

    public Get(state : FsmState) : FsmState
    {
      Get(state.Num)
    }

    public Get(state : list[string]) : FsmState
    {
      def merge_name(n)
      {
        string.Join(".", n)
      }

      def get_loop(st, lst, path, err)
      {
        match (st, lst, path)
        {
          | (st, head :: tail, p) => 
              def path = head :: p;
              match (get_all_state(st, head), tail)
              {
                | (x, _)   when x.IsEmpty()     => (null, FsmError.StateNotFound(State(merge_name(path.Rev()))) :: err)
                | (st, []) when st.IsSingle()   => (st.First(), err)
                | (st, _)  when st.IsSingle()   => get_loop(st.First().sub_states, tail, path, err)
                | (lst, _)                      => (null, FsmError.SeveralState(lst |> State(merge_name((_.NativeName :: p).Rev()))) :: err)
              }
          | _                                   => (null, err)
        }
      }

      def (st, err) = get_loop(states, state, [], []);
      Analyser.AddErrors(err);
      st
    }

    get_all_state(map : IEnumerable[FsmState], state : string) : IEnumerable[FsmState]
    {
      def name = state ?? FsmState.TopStateName;
      def (name, sub_name) = if (name != FsmState.TopStateName) 
                              {
                                def sub =  name.GetSub('[', ']');
                                if (sub != null) (name.GetSub('['), sub) else (name, null)
                              } else (name, null);
      def name = if (sub_name != null) $"$(name)SubRegion$sub_name" else name;
      map.Where(x => x.NativeName == name)
    }


    public Get(state : string) : FsmState
    {
      def st = state.SplitToList('.');
      Get(st)
    }

    public Get(num : int) : FsmState
    {
      states[num]
    }

    public Item[index : int] : FsmState
    {
      get
      {
        Get(index)
      }
    }

    public Update(st : IEnumerable[FsmState], manual_rebuild : bool = false) : void
    {
      def check_name(n, _)
      {
        match (st.Find(x => x.Num == n.Num))
        {
          | Some(n) => n
              // if no new state use old
          | _       => null
        }
      }

      def top = Top.ReduceSingle(manual_rebuild, check_name); // replace old states with new ones
      Update(top)
    }

    public Update(top : FsmState) : void
    {
      // if top is not top state, but some child
      if (TopNum != -1 && top.Num != Top.Num)
      {
        Update(TraverseUtils.SingleElement(top))
      } else
        when (top != Top)
        {
          when (TopNum == -1)
          {
            TopNum = top.Num
          }
          def st = top.AllStates;
          states = st.OrderBy(_.Num).ToArray();
        }
    }

    public Count : int
    {
      get
      {
        states.Length
      }
    }

    public TopNum : int {get; private set;}

    public Top : FsmState
    {
      get
      {
        if (TopNum != -1) states[TopNum] else null
      }
    }
  }
}
