using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

namespace Nemerle.Statechart
{
  using FsmState;
  
  [Record]
  public class StateMap
  {
    [NeedChange]
    public states : list[FsmState] = [];
        
    //[Accessor]
    //errors : list[FsmError] = [];

    [Accessor] analyser : FsmAnalyser;
    
    //public HaveErrors : bool
    //{
    //  get
    //  {
    //     !errors.IsEmpty()
    //  }
    //}

    public Count : int
    {
      get
      {
        states.Length
      }
    }

    public Contains(state : string) : bool
    {
      states.Exists(x => x.Name == state)
    }

    public static GetFullName(st : list[FsmState]) : string
    {
      string.Join(".", st |> NativeName)
    }
    
    public Get(state : list[string]) : FsmState
    {
      def merge_name(n)
      {
        string.Join(".", n)
      }
      
      def get_loop(st, lst, path)
      {
        | (st, head :: tail, p) => 
           def path = head :: p;
           match (get_all_state(st, head), tail)
           {
             | ([], _) => analyser.AddError(FsmError.StateNotFound(State(merge_name(path.Rev()))));null
             | ([st], []) => st
             | ([st], _) => get_loop(st.sub_states, tail, path)
             | (lst, _) => analyser.AddError(FsmError.SeveralState(lst |> State(merge_name((_.NativeName :: p).Rev()))));null
           }
        | _ => null   
      }
      
      get_loop(states, state, [])
    }

    get_all_state(map : list[FsmState], state : string) : list[FsmState]
    {
      def name = state ?? FsmState.TopStateName;
      def (name, sub_name) = if (name != FsmState.TopStateName) 
                             {
                               def sub =  name.GetSub('[', ']');
                               if (sub != null) (name.GetSub('['), sub) else (name, null)
                             } else (name, null);
      def name = if (sub_name != null) $"$(name)SubRegion$sub_name" else name;
      map.FindAll(x => x.NativeName == name)
    }
    
    public Get(state : string) : FsmState
    {
      def st = state.SplitToList('.');
      Get(st)
    }

    public Get(num : int) : FsmState
    {
      states.ElementAt(num)
    }
    
    public CheckNew(st : FsmState) : StateMap
    {
      if (states.Contains(st)) this else Add(st)
    }
    
    public Add(st : FsmState) : StateMap
    {
      def states = st :: states;
      ChangeStates(states)
      //st.FormatName();
    }
    
    public Rem(st : FsmState) : StateMap
    {
      def st = get_all_state(states, st.NativeName);
      def st = states.Exclude(x => st.Contains(x));
      ChangeStates(st)
    }
    
    public IndexOf(st : FsmState) : int
    {
      states.FindIndex(_ == st : object)
    }
    
    public Item[index : string] : FsmState
    {
      get
      {
        Get(index)
      }
    }

    public Item[index : int] : FsmState
    {
      get
      {
        Get(index)
      }
    }
    
    public this(analyser : FsmAnalyser)
    {
      this.analyser = analyser;
    }    
    
    public Init(topstate : FsmState) : StateMap
    {
      ChangeStates(topstate :: topstate.AllSubStates)
    }

    public Names : list[string]
    {
      get
      {
        states |> Name
      }
    }

  }
}
