using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

using NC = Nemerle.Collections;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using FsmState;

  //[Record]
  public partial class StateMap
  {
    public Analyser : FsmAnalyser;

    [Accessor]
    state_tree : FsmState;
    
    [Accessor]
    mutable pseudo_states : array[PseudoStateNode];// = NC.Hashtable();
    [Accessor]
    mutable transitions   : array[StateTransition];    
    [Accessor]
    mutable states : array[FsmState];
    
    // if changed tree added new states or pseudo create new cached tree iterator and structures
    Rebuild() : void
    {
      states = state_tree.GetBreadthFirstEnumerable().ToArray();      
      pseudo_states = states.SelectMany(_.pseudo_states).ToArray();
      transitions = states.SelectMany(_.transitions).ToArray();
    }
    
    public this(an : FsmAnalyser, stree : FsmState) 
    { 
      state_tree = stree;
      Analyser = an; 
      Rebuild()
      ///tr.GetBreadthFirstEnumerable().Iter(x => when (x.Value is FsmNode.State(n)) map[n] = x)
    }    

    public Add(parent : FsmState, st : FsmState) : void
    {
      parent.Add(st);
      Rebuild()
      //transitions.Add(st, []);
    }
    
    public static Create(an : FsmAnalyser, state : StateNode.State) : void
    {
      def top = TreeUtils.FoldTree(state, null, _.sub_states, FsmState(_, _, an));
      def map = StateMap(an, top);
      an.statemap = map;
      map.UpdateReferences();
    }

  }
}
