using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

namespace Nemerle.Statechart
{
  using FsmState;

  [Record]
  public class StateMap
  {
    [NeedChange]
    public states : array[FsmState];

    public this() {}

    public Count : int
    {
      get
      {
        states.Length
      }
    }

    public Contains(state : string) : bool
    {
      states.Exists(x => x.Name == state)
    }

    public static GetFullName(st : list[FsmState]) : string
    {
      string.Join(".", st |> NativeName)
    }

    public Get(state : list[string], an : FsmAnalyser) : FsmState * FsmAnalyser
    {
      def merge_name(n)
      {
        string.Join(".", n)
      }

      def get_loop(st, lst, path, err)
      {
        match (st, lst, path)
        {
          | (st, head :: tail, p) => 
              def path = head :: p;
              match (get_all_state(st, head), tail)
              {
                | (x, _) when x.IsEmpty()   => (null, FsmError.StateNotFound(State(merge_name(path.Rev()))) :: err)
                | (st, []) when (st.IsSingle()) => (st.First(), err)
                | (st, _) when (st.IsSingle()) => get_loop(st.First().sub_states, tail, path, err)
                | (lst, _)   => (null, FsmError.SeveralState(lst |> State(merge_name((_.NativeName :: p).Rev()))) :: err)
              }
          | _ => (null, err)
        }
      }

      def (st, err) = get_loop(states, state, [], []);
      def an = an.AddErrors(err);
      (st, an)
    }

    get_all_state(map : IEnumerable[FsmState], state : string) : IEnumerable[FsmState]
    {
      def name = state ?? FsmState.TopStateName;
      def (name, sub_name) = if (name != FsmState.TopStateName) 
                              {
                                def sub =  name.GetSub('[', ']');
                                if (sub != null) (name.GetSub('['), sub) else (name, null)
                              } else (name, null);
      def name = if (sub_name != null) $"$(name)SubRegion$sub_name" else name;
      map.Where(x => x.NativeName == name)
    }

    public Get(state : string, an : FsmAnalyser) : FsmState * FsmAnalyser
    {
      def st = state.SplitToList('.');
      Get(st, an)
    }

    public Get(num : int) : FsmState
    {
      states[num]
    }

    //public CheckNew(st : FsmState) : StateMap
    //{
    //  if (states.Contains(st)) this else Add(st)
    //}

    public CheckNew(st : IEnumerable[FsmState]) : StateMap
    {
      // replace state if we have new copy
      def check_name(n, s)
      {
        match (st.Find(x => x.Name == n.Name))
        {
          | Some(n) => n.ChangeSubStates(s)
          // if no new state use old
          | _       => null
        }
      }

      def top = Top.ReduceSingle(check_name);
      Update(top)
      //if (states.Exists(x => st.Exists(y => x : object != y))) this else Add(st)
    }

    //public InitAdd(st : FsmState) : FsmState * StateMap
    //{
    //  def st = st.ChangeNum(CurrentNum);
    //  def map = Add(st);
    //  (st, map)
    //}

    //public InitAdd(st : list[FsmState]) : list[FsmState] * StateMap
    //{
    //  def st = st.MapIndex((x, i) => x.ChangeNum(CurrentNum + i));
    //  def nst = states.Append(RList.FromList(st));
    //  def map = ChangeStates(nst);
    //  (st, map)
    //}

    //public Add(st : FsmState) : StateMap
    //{
    //  def states = states.Filter(x => x.Num != st.Num);
    //  def states = states + [st];
    //  def states = states.Sort((x, y) => x.Num - y.Num);
    //  ChangeStates(states.ToArray())
    //  //st.FormatName();
    //}

    //public Add(st : list[FsmState]) : StateMap
    //{
    //  def states = states.Exclude(st, (x, y) => x.Num == y.Num);
    //  def states = states.Append(st.ToArray());
    //  def states = states.Sort(_.Num);
    //  ChangeStates(states)
    //  //st.FormatName();
    //}

    public Get(st : list[FsmState]) : list[FsmState]
    {
      if (states.Exists(x => st.Exists(y => x : object != y)))
        st.Map(x => Get(x.Num)) else st
    }

    //public Rem(st : FsmState) : StateMap
    //{
    //  def st = get_all_state(states.NToList(), st.NativeName);
    //  def st = states.Filter(x => st.Exists(y => y.Num == x.Num));
    //  def st = st.Sort((x, y) => x.Num - y.Num);
    //  ChangeStates(st.ToArray())
    //}

    //public IndexOf(st : FsmState) : int
    //{
    //  states.FindIndex(_ == st : object)
    //}

    public Item[index : int] : FsmState
    {
      get
      {
        Get(index)
      }
    }

    public CurrentNum : int
    {
      get
      {
        states.Length
      }
    }

    //public this(analyser : FsmAnalyser)
    //{
    //  this.analyser = analyser;
    //}

    public Init(top : FsmState) : StateMap
    {
      def states = top.AllStates;
      def states = states.MapIndex((x, i) => x.ChangeNum(i));
      ChangeStates(states.ToArray())
    }

    public Update(top : FsmState) : StateMap
    {
      if (top != Top)
      {
        def states = top.AllStates;
        ChangeStates(states.ToArray())
      } else this
    }

    public Names : array[string]
    {
      get
      {
        states |> Name
      }
    }

    public Top : FsmState
    {
      get
      {
        states[0]
      }
    }
  }
}
