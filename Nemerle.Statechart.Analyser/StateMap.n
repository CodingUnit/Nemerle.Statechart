using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

using NC = Nemerle.Collections;

namespace Nemerle.Statechart
{
  using FsmState;

  [Record]
  public partial class StateMap
  {
    mutable states : array[FsmState] = array[];

    public Analyser : FsmAnalyser;

    mutable super_map : array[int] = array[];
    
    mutable parents_map : Hashtable[int, int] = Nemerle.Collections.Hashtable();
    
    public ParentFor(num : int) : FsmState
    {
      if (parents_map.ContainsKey(num)) states[parents_map[num]] else null
    }
    
    public ParentFor(num : int, st : FsmState) : void
    {
      parents_map[num] = st.Num
    }
    

    [Accessor]
    mutable global_id : int;

    public UpdateRefsToParent(parent : FsmState, nodes : IEnumerable[int]) : void
    {
      nodes.Iter(x => parents_map[x] = parent.Num)
    }
    
    public GetNumOfNode(parent : FsmState) : int
    {
      def num = GetNextGlobalNum();
      parents_map[parent.Num] = num;
      num
    }
    
    public GetNextGlobalNum() : int
    {
      def num = global_id;
      global_id++;
      num
    }

    public States : array[FsmState]
    {
      get
      {
        Update();
        states.FilterToArray(_ != null)
      }
    }

    public this(an : FsmAnalyser) { Analyser = an; TopNum = -1; ChangeMan = ChangeManager(an) }

    public Contains(state : FsmState) : bool
    {
      states.Length - 1 >= state.Num
    }

    public static GetFullName(st : list[FsmState]) : string
    {
      string.Join(".", st |> NativeName)
    }

    public Get(state : FsmState) : FsmState
    {
      if (state == null) null else
      {
        def num = state.Num;
        def st = if (num == -1) Get(state.NativeName) else Get(num);
        match (st)
        {
          | null => state//throw InvalidOperationException($"state is not correctly mapped $state")
          | st   => st
        }
      }
    }

    public Get(state : list[string]) : FsmState
    {
      def merge_name(n)
      {
        string.Join(".", n)
      }

      def get_loop(st, lst, path)
      {
        | (st, head :: tail, p) => 
              def path = head :: p;
              match (get_all_state(st, head), tail)
              {
                | ([], _)    => Analyser.AddError(FsmError.StateNotFound(State(merge_name(path.Rev()), Analyser))); null
                | ([st], []) => st
                | ([st], _)  => get_loop(st.sub_states, tail, path)
                | (lst, _)   => Analyser.AddError(FsmError.SeveralState(lst |> State(merge_name((_.NativeName :: p).Rev()), Analyser)));
                                null
              }
        | _                => null
      }

      get_loop(States.NToList(), state, [])
    }

    get_all_state(map : IEnumerable[FsmState], state : string) : list[FsmState]
    {
      def name = state ?? FsmState.TopStateName;
      def (name, sub_name) = if (name != FsmState.TopStateName) 
                              {
                                def sub =  name.GetSub('[', ']');
                                if (sub != null) (name.GetSub('['), sub) else (name, null)
                              } else (name, null);
      def name = if (sub_name != null) $"$(name)SubRegion$sub_name" else name;
      map.Filter(x => x.NativeName == name)
    }


    public Get(state : string) : FsmState
    {
      Update();
      def st = state.SplitToList('.');
      Get(st)
    }

    public Get(num : int) : FsmState
    {
      Update();
      if (num != -1) states[num] else null
    }

    public Item[index : int] : FsmState
    {
      get
      {
        Get(index)
      }
    }

    public ChangeMan : ChangeManager;
    
    public Update(st : IEnumerable[FsmState], top : FsmState = null) : void
    {
	  BeginUpdate();
      UpdateInternal(st, top);
      Update();
	  EndUpdate();
    }
    
    UpdateInternal(st : IEnumerable[FsmState], top : FsmState = null) : void
    {
      
      def check_name(n, _)
      {
        match (st.Find(_.StateEquals(n)))
        {
          | Some(n) => n
            // if no new state use old
          | _       => null
        }
      }

      def top = Top ?? top;
      def top = top.ReduceSingle(check_name); // replace old states with new ones
      UpdateInternal(top)
    }

    //public DefineState(st : FsmState, super : FsmState) : void
    //{
    //  super_map[st.Num] = super.Num
    //}
    
    public Update(top : FsmState) : void
    {
	  BeginUpdate();
      UpdateInternal(top);
      Update();
	  EndUpdate();
    }
    
    public Update() : void
    {
      def st = ChangeMan.CheckChange();
      UpdateInternal(st)  
    }
    
	mutable Updating : bool;

	BeginUpdate() : void
	{
		Updating = true;
	}

	EndUpdate() : void
	{
		Updating = false;
	}

    UpdateInternal(top : FsmState) : void
    {
      
      // if top is not top state, but some child
      if (Top != null && Top.Num != -1 && top.Num != Top.Num)
      {
        UpdateInternal(TraverseUtils.SingleElement(top))
      } else
        when (top : object != Top)
        {
          if (TopNum == -1) // if not set number
          {
            def st = top.LevelOrderMap(x => x.ChangeNum(GetNextGlobalNum())).ToArray();
            TopNum = st.First().Num;
            UpdateInternal(st, top)
          } else
          {
            def st = top.AllStates;
            states = st.MakeArrayMap(st, global_id, _.Num);//OrderBy(_.Num).ToArray();
            ChangeMan.StateMapChanged();
            def new_st = super_map.Length != states.Length;
            // update super state map
            // if new map
            when (new_st)
            {
              // create new super state map
              def supers = States.SelectMany(x => x.sub_states.Select(y => (y.Num, x.Num))).AddBefore((0, -1));
              super_map = supers.MakeArrayMap(global_id);//OrderBy((s, _) => s.Num).Select((_, s) => s.Num);
              //super_map = supers.AddBefore(-1).ToArray();
            }
            when (new_st || ChangeMan.NewReferences)
            {
              def top = top.ReduceSingle((x, _) => UpdateStateReference(x)); // update references in tree
              UpdateInternal(top)
            }
            
          }
        }
        
      //when (States.Length != namemap.Count()) // if name and statemap not equal
      //{
      //  def map_st = States.MapToList(_.Name);
      //  def name_st = namemap.Map(_.Key);
      //  def map = map_st.Exclude(name_st);//.Exists(_ == x));
      //  def name = name_st.Exclude(map_st);
      //  throw InvalidOperationException($"Statemap and names map not equal. New states in statemap ..$map. New states in namemap ..$name)");
      //}
    }

    public Super(st : FsmState) : FsmState
    {
      def num = st.Num;
      if (num != -1) Get(super_map[num]) else null
    }
    
    public Count : int
    {
      get
      {
        states.Length
      }
    }

    public TopNum : int {get; private set;}

    public Top : FsmState
    {
      get
      {
        if (Count == 0) null else states[TopNum]
      }
    }
  }
}
