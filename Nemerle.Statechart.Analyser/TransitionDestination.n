using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NGenerics.DataStructures.Trees;

namespace Nemerle.Statechart
{
  using FsmState;  
  /// <summary>
  /// Description of TransitionDestination.
  /// </summary>
  [Record]
  public variant TransitionDestination
  {
    | Unknown
    | History {state : NodeValue[FsmState, PseudoStateNode];}
    | State {state : GeneralTree[FsmState];}
    | NoStateChange
    | Choice 
      {
        state      : GeneralTree[FsmState];
        choice     : list[NodeValue[FsmState, StateTransition]];
        else_state : option[GeneralTree[FsmState]] = None();
      }
    | Terminate {node : NodeValue[FsmState, PseudoStateNode];}
    | Region {reg : GeneralTree[FsmState];}
    | SubRegion {reg : GeneralTree[FsmState];state : TransitionDestination;from : GeneralTree[FsmState];}
    | Fork {reg : GeneralTree[FsmState];sub_tran : list[NodeValue[FsmState, StateTransition]];}
    | Join {join : NodeValue[FsmState, PseudoStateNode];}
    | Final {state : GeneralTree[FsmState];sub_region : GeneralTree[FsmState];region : GeneralTree[FsmState];completion : list[NodeValue[FsmState, StateTransition]];}
    | ForceStateChange {nested : TransitionDestination;}
    | HistoryRestore {history : NodeValue[FsmState, PseudoStateNode];}
    | EventSend {st : GeneralTree[FsmState];evt : StateEvent;}
    | CheckAfter {check : CheckNode;before : TransitionDestination;nested : TransitionDestination;}
    | JoinedTransition {join : NodeValue[FsmState, PseudoStateNode];transition : NodeValue[FsmState, StateTransition];}
    | SubMachine {machine : GeneralTree[FsmState];state : string;}
    //| JunctionNode {node : DecisionNode;}
    //| ChoiceNode {node : BinaryTree[TreeJunctionNode];}
    | TransitionExecute {tran : NodeValue[FsmState, StateTransition];}

    public override ToString() : string
    {
      match (this)
      {
        | Unknown                   => "Unknown"
        | History(st)               => $"History$st"
        | State(st)                 => $"State$st"
        | NoStateChange             => "NoStateChange"
        | Choice(st, ch, els)       => $"Choice $st trans:..$ch else: $els"
        | Terminate(n)              => $"Terminate$n"
        | Region(r)                 => $"Region$r"
        | SubRegion(r, st, fr)      => $"SubRegion: $r state:$st from:$fr"
        | Fork(r, sub)              => $"Fork: $r to ..$sub"
        | Join(j)                   => $"Join$j"
        | Final(st, sub, r, comp)   => $"Final$st sub_reg:$sub reg:$r comp: ..$comp"
        | ForceStateChange(nest)    => $"ForceStateChange$nest"
        | HistoryRestore(rest)      => $"HistoryRestore$rest"
        | EventSend(st, evt)        => $"EventSend$st evt: $evt"
        | CheckAfter(ch, bef, nest) => $"CheckAfter$ch before:$bef nest:$nest"
        | JoinedTransition(j, tran) => $"JoinedTransition: $j tran:$tran"
        | SubMachine(m, st)         => $"SubMachine$m state:$st"
        //| JunctionNode(n)           => $"Junction$n"
        //| ChoiceNode(n)             => $"Choice$n"
        | TransitionExecute(tr)     => $"TransitionExecute:$tr"
      }
    }
    /// <summary>
    /// Concrete State for where transition ends known at compile time
    /// </summary>
    public ConcreteTo : GeneralTree[FsmState]
    {
      get
      {
        def check_dest(d)
        {
          | null                  => null
          | TransitionDestination.State(st)
          | Fork(st, _)
          | Region(st)
          | Final(state = st)     => st
          | Join(j)
          | Terminate(j)          => j.Parent
          | ForceStateChange(st)
          | SubRegion(state = st) => check_dest(st)
          | _                     => null
        }

        check_dest(this)
      }
    }

    //public Transition : IEnumerable[StateTransition]
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | ForceStateChange(n)
    //      | SubRegion(_, n, _)     => n.Transition
    //      | Choice(_, tr, _)       => tr
    //      | Fork(_, tr)           
    //      | Final(_, _, _, tr)     => tr
    //      | CheckAfter(_, b, n)    => b.Transition.Concat(n.Transition)
    //      | JoinedTransition(_, t) => TraverseUtils.SingleElement(t)
    //      | _                      => Enumerable.Empty()
    //    }
    //  }
    //}

    public ToState : GeneralTree[FsmState]
    {
      get
      {
        match (this)
        {
          | State(st)
          | Region(st)
          | SubRegion(reg = st)
          | Fork(reg = st)
          | Final(state = st)
          | Choice(st, _, _)        => st
          | History(st)
          | Terminate(st)
          | Join(st) => st.Parent
          | TransitionExecute(tran) => tran.Value.ToState
          | ForceStateChange(nest)  => nest.ToState
          | _                       => null
        }
      }
    }

    public this() {}

    public this(post : TransitionPostConditions) 
    {
      post_conditions = post
    }

    public Nested : TransitionDestination
    {
      get
      {
        match (this)
        {
          | SubRegion(_, st, _)
          | CheckAfter(_, _, st)
          | ForceStateChange(st) => st
          | _ => this
        }
      }
    }

    [RecordIgnore] 
    [Accessor]
    post_conditions : TransitionPostConditions;
  }

  public variant TransitionPostConditions
  {
    | None
    | RegionCompletion {reg : GeneralTree[FsmState]; tran : IEnumerable[NodeValue[FsmState, StateTransition]];}
  }
}
