using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  using FsmState;  
  /// <summary>
  /// Description of TransitionDestination.
  /// </summary>
  [Record]
  public variant TransitionDestination
  {
    | Unknown
    | History {state : PseudoStateNode;}
    | State {state : FsmState;}
    | NoStateChange
    | Choice 
      {
        state      : FsmState;
        choice     : list[StateTransition];
        else_state : option[FsmState] = None();
      }
    | Terminate {node : PseudoStateNode.Terminate;}
    //| Region {reg : FsmState;}
    //| SubRegion {reg : FsmState;state : TransitionDestination;from : FsmState;}
    //| Fork {reg : FsmState;sub_tran : list[StateTransition];}
    //| Join {join : PseudoStateNode;}
    //| Final {state : FsmState;sub_region : FsmState;region : FsmState;completion : list[StateTransition];}
    //| ForceStateChange {nested : TransitionDestination;}
    //| HistoryRestore {history : PseudoStateNode.History;}
    //| EventSend {st : FsmState;evt : StateEvent;}
    //| CheckAfter {check : CheckNode;before : TransitionDestination;nested : TransitionDestination;}
    //| JoinedTransition {join : PseudoStateNode;transition : StateTransition;}
    //| SubMachine {machine : FsmState;state : string;}
    | Junction {node : DecisionNode;}
    //| ExitPoint {point : PseudoStateNode.ExitPoint; }
    //| ChoiceNode {node : BinaryTree[TreeJunctionNode];}
    | TransitionExecute {tran : StateTransition;}

    public override ToString() : string
    {
      match (this)
      {
        | Unknown                   => "Unknown"
        | History(st)               => $"History$(st)"
        | State(st)                 => $"State$(st)"
        | NoStateChange             => "NoStateChange"
        | Choice(st, ch, els)       => $"Choice $(st) trans:..$ch else: $els"
        | Terminate(n)              => $"Terminate$n"
        //| Region(r)                 => $"Region$(r)"
        //| SubRegion(r, st, fr)      => $"SubRegion: $(r) state:$st from:$(fr)"
        //| Fork(r, sub)              => $"Fork: $(r) to ..$sub"
        //| Join(j)                   => $"Join$j"
        //| Final(st, sub, r, comp)   => $"Final$(st) sub_reg:$(sub) reg:$(r) comp: ..$comp"
        //| ForceStateChange(nest)    => $"ForceStateChange$nest"
        //| HistoryRestore(rest)      => $"HistoryRestore$rest"
        //| EventSend(st, evt)        => $"EventSend$(st) evt: $evt"
        //| CheckAfter(ch, bef, nest) => $"CheckAfter$ch before:$bef nest:$nest"
        //| JoinedTransition(j, tran) => $"JoinedTransition: $j tran:$tran"
        //| SubMachine(m, st)         => $"SubMachine$m state:$st"
        | Junction(n)               => $"Junction$n"
        //| ChoiceNode(n)             => $"Choice$n"
        | TransitionExecute(tr)     => $"TransitionExecute:$tr"
        //| ExitPoint(p)              => $"$p"
      }
    }
    /// <summary>
    /// Concrete State for where transition ends known at compile time
    /// </summary>
    public ConcreteTo : FsmState
    {
      get
      {
        def check_dest(d)
        {
          | null                  => null
          | TransitionDestination.State(st) => st
          //| Fork(st, _)
          //| Region(st)
          //| Final(state = st)     => st
          //| Join(j)
          | Terminate(j)          => j.state
          //| ForceStateChange(st)
          //| SubRegion(state = st) => check_dest(st)
          | _                     => null
        }

        check_dest(this)
      }
    }

    //public Transition : IEnumerable[StateTransition]
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | ForceStateChange(n)
    //      | SubRegion(_, n, _)     => n.Transition
    //      | Choice(_, tr, _)       => tr
    //      | Fork(_, tr)           
    //      | Final(_, _, _, tr)     => tr
    //      | CheckAfter(_, b, n)    => b.Transition.Concat(n.Transition)
    //      | JoinedTransition(_, t) => TraverseUtils.SingleElement(t)
    //      | _                      => Enumerable.Empty()
    //    }
    //  }
    //}

    public ToState : FsmState
    {
      get
      {
        match (this)
        {
          | State(st)
          //| Region(st)
          //| SubRegion(reg = st)
          //| Fork(reg = st)
          //| Final(state = st)
          | Choice(st, _, _)        => st
          | History(st)
          | Terminate(st) => st.state
          //| Join(st) => st.state
          | TransitionExecute(tran) => tran.ToState
          //| ForceStateChange(nest)  => nest.ToState
          | _                       => null
        }
      }
    }

    public this() {}

    //public this(post : TransitionPostConditions) 
    //{
    //  post_conditions = post
    //}

    //public Nested : TransitionDestination
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | SubRegion(_, st, _)
    //      | CheckAfter(_, _, st)
    //      | ForceStateChange(st) => st
    //      | _ => this
    //    }
    //  }
    //}

    //[RecordIgnore] 
    //[Accessor]
    //post_conditions : TransitionPostConditions;
  }

  //public variant TransitionPostConditions
  //{
  //  | None
  //  | RegionCompletion {reg : FsmState; tran : IEnumerable[StateTransition];}
  //}
}
