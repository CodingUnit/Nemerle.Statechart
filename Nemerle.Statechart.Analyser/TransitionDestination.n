using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using FsmState;  
  /// <summary>
  /// Description of TransitionDestination.
  /// </summary>
  [Record]
  public variant TransitionDestination
  {
    | Unknown
    | History {state : PseudoStateNode.History;}
    | State {state : FsmState;}
    | NoStateChange
    | Choice 
      {
        state      : FsmState;
        choice     : IEnumerable[StateTransition];
        else_state : option[FsmState] = None();
      }
    | Terminate {node : PseudoStateNode.Terminate;}
    | Region {reg : ConcurrentRegion;}
    | SubRegion {reg : ConcurrentSubRegion;state : TransitionDestination;from : FsmState;}
    | Fork {reg : ConcurrentRegion;sub_tran : list[StateTransition];}
    | Join {join : PseudoStateNode.Join;}
    | Final {state : FsmState;sub_region : ConcurrentSubRegion;region : ConcurrentRegion;completion : IEnumerable[StateTransition];}
    | ForceStateChange {nested : TransitionDestination;}
    | HistoryRestore {history : PseudoStateNode.History;}
    | EventSend {st : FsmState;evt : StateEvent;}
    | CheckAfter {check : CheckNode;before : TransitionDestination;nested : TransitionDestination;}
    | JoinedTransition {join : PseudoStateNode.Join;transition : StateTransition;}
    | SubMachine {machine : FsmState.SubMachine;state : string;}
    | JunctionNode {node : DecisionNode;}
    | ChoiceNode {node : DecisionNode;}
    | TransitionExecute {tran : StateTransition;}

    public override ToString() : string
    {
      match (this)
      {
        | Unknown                   => "Unknown"
        | History(st)               => $"History$st"
        | State(st)                 => $"State$st"
        | NoStateChange             => "NoStateChange"
        | Choice(st, ch, els)       => $"Choice $st trans:..$ch else: $els"
        | Terminate(n)              => $"Terminate$n"
        | Region(r)                 => $"Region$r"
        | SubRegion(r, st, fr)      => $"SubRegion: $r state:$st from:$fr"
        | Fork(r, sub)              => $"Fork: $r to ..$sub"
        | Join(j)                   => $"Join$j"
        | Final(st, sub, r, comp)   => $"Final$st sub_reg:$sub reg:$r comp: ..$comp"
        | ForceStateChange(nest)    => $"ForceStateChange$nest"
        | HistoryRestore(rest)      => $"HistoryRestore$rest"
        | EventSend(st, evt)        => $"EventSend$st evt: $evt"
        | CheckAfter(ch, bef, nest) => $"CheckAfter$ch before:$bef nest:$nest"
        | JoinedTransition(j, tran) => $"JoinedTransition: $j tran:$tran"
        | SubMachine(m, st)         => $"SubMachine$m state:$st"
        | JunctionNode(n)           => $"Junction$n"
        | ChoiceNode(n)             => $"Choice$n"
        | TransitionExecute(tr)     => $"TransitionExecute:$tr"
      }
    }
    /// <summary>
    /// Concrete State for where transition ends known at compile time
    /// </summary>
    public ConcreteTo : FsmState
    {
      get
      {
        def check_dest(d)
        {
          | null => null
          | TransitionDestination.State(st)
          | Fork(st, _)
          | Region(ConcurrentRegion as st)
          | Join(Join(state = st))
          | Final(state = st)
          | Terminate(PseudoStateNode.Terminate(state = st)) => st
          | ForceStateChange(st)
          | SubRegion(state = st) => check_dest(st)
          | _ => null
        }

        check_dest(this)
      }
    }

    public Transition : IEnumerable[StateTransition]
    {
      get
      {
        match (this)
        {
          | ForceStateChange(n)
          | SubRegion(_, n, _)     => n.Transition
          | Choice(_, tr, _)       => tr
          | Fork(_, tr)           
          | Final(_, _, _, tr)     => tr
          | CheckAfter(_, b, n)    => b.Transition.Concat(n.Transition)
          | JoinedTransition(_, t) => TraverseUtils.SingleElement(t)
          | _                      => Enumerable.Empty()
        }
      }
    }

    public ToState : FsmState
    {
      get
      {
        match (this)
        {
          | State(st)
          | History(PseudoStateNode.History(state = st))
          | Terminate(PseudoStateNode(state = st))
          | Region(st)
          | SubRegion(reg = st)
          | Fork(reg = st)
          | Join(PseudoStateNode(state = st))
          | Final(state = st)
          | Choice(st, _, _)        => st
          | TransitionExecute(tran) => tran.ToState
          | ForceStateChange(nest)  => nest.ToState
          | _                       => null
        }
      }
    }

    public this() {}

    public this(post : TransitionPostConditions) 
    {
      post_conditions = post
    }

    public Nested : TransitionDestination
    {
      get
      {
        match (this)
        {
          | SubRegion(_, st, _)
          | CheckAfter(_, _, st)
          | ForceStateChange(st) => st
          | _ => this
        }
      }
    }

    [RecordIgnore] 
    [Accessor]
    post_conditions : TransitionPostConditions;
  }

  public variant TransitionPostConditions
  {
    | None
    | RegionCompletion {reg : ConcurrentRegion; tran : IEnumerable[StateTransition];}
  }
}
