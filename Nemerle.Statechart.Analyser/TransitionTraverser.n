using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of TransitionTraverser.
  /// </summary>
  public class TransitionTraverser
  {    
    defered    : List[StateTransition] = List();
    defered_st : List[FsmState]        = List();

    analyser : FsmAnalyser;

    public this(an : FsmAnalyser) { analyser = an }

    completed  : List[StateTransition] = List();

    completed_states : List[FsmState]  = List();

    public Completed : IEnumerable[StateTransition]
    {
      get
      {
        completed
      }
    }

    public CompletedStates : IEnumerable[FsmState]
    {
      get
      {
        completed_states
      }
    }

    public Add(tran : StateTransition) : void
    {
      defered.Add(tran)
    }

    public Add(tran : IEnumerable[StateTransition]) : void
    {
      defered.AddRange(tran)
    }

    public Add(st : FsmState) : void
    {
      defered_st.Add(st)
    }

    public Traverse() : void
    {
      def (fsm, st) = defered_st.PartitionLazy(x => x.PartOfStateMachine.HasValue);
      def state_queue = st.RemoveDuplicatesSort(_.Num).Concat(fsm);
      def tran_queue = defered.RemoveDuplicatesSort(_.Name);
      def state_queue = state_queue.Exclude(completed_states.Contains);
      defered_st.Clear();
      defered.Clear();
      def st_res = state_queue.Map(_.TraverseTransitions());
      completed_states.AddRange(st_res);
      def trans = tran_queue.Map(_.TraversePath());
      completed.AddRange(trans);
      // if empty queue
      when (!defered_st.IsEmpty() || !defered.IsEmpty()) Traverse() // else recursive call self and traverse again
    }
  }
}
