using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using System.Collections;
using System.IO;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of TransitionTraverser.
  /// </summary>
  public class TransitionTraverser
  {
    defered    : List[NodeValue[FsmState, StateTransition]] = List();
    defered_st : List[SimpleTreeNode[FsmState]]        = List();

    analyser : FsmAnalyser;

    public this(an : FsmAnalyser) 
    {
      analyser = an;
      completed_buf  = BitArray(an.statemap.GlobalId);
      when (analyser.FsmFlags.Debug) log_file = StreamWriter($"$(analyser.Name)path_log.log", false);
    }

    //completed        : List[StateTransition] = List();

    //completed_buf    : BitArray;
    
    //completed_states : List[FsmState]  = List();
    
    //public Completed : IEnumerable[StateTransition]
    //{
    //  get
    //  {
    //    completed
    //  }
    //}

    //public CompletedStates : IEnumerable[FsmState]
    //{
    //  get
    //  {
    //    completed_states
    //  }
    //}

    public Add(tran : NodeValue[FsmState, StateTransition]) : void
    {
      //def num = tran.Value.Num;
      //when (!completed_buf.Get(num)) 
      //{
        defered.Add(tran);
        //completed_buf.Set(num, true)
      //}
    }

    public Add(tran : IEnumerable[NodeValue[FsmState, StateTransition]]) : void
    {
      //def tran = tran.Where(x => !completed_buf.Get(x.Num));
      defered.AddRange(tran);
      //completed_buf.SetAll(tran, _.Num)
    }

    public Add(st : SimpleTreeNode[FsmState]) : void
    {
      //when (!completed_buf.Get(st.Value.Num))
      //{
        defered_st.Add(st);
        //completed_buf.Set(st.Value.Num, true)
      //}
      
    }

    public Log(str : string) : void
    {
      log_file?.WriteLine(str)
    }
    
    log_file : TextWriter;
    
    public Traverse() : void
    {
      def state_queue = defered_st.ToArray();
      def tran_queue  = defered.ToArray();
      defered_st.Clear();
      defered.Clear();
      state_queue.Iter(x => x.Update(x => x.TraverseTransitions()));
      tran_queue.Iter(x => x.Value = x.Value.TraversePath(true));
      // if empty queue
      if (!defered_st.IsEmpty() || !defered.IsEmpty()) Traverse() else
      {
        log_file?.Close()
      }// else recursive call self and traverse again
    }
  }
}
