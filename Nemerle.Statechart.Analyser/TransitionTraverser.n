using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using System.Collections;
using System.IO;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of TransitionTraverser.
  /// </summary>
  public class TransitionTraverser
  {
    defered    : List[StateTransition] = List();
    defered_st : List[FsmState]        = List();

    analyser : FsmAnalyser;

    public this(an : FsmAnalyser) 
    {
      analyser = an;
      completed_buf  = BitArray(an.statemap.GlobalId);
      when (analyser.FsmFlags.Debug) log_file = StreamWriter($"$(analyser.Name)path_log.log", false);
    }

    completed        : List[StateTransition] = List();

    completed_buf    : BitArray;
    
    completed_states : List[FsmState]  = List();
    
    public Completed : IEnumerable[StateTransition]
    {
      get
      {
        completed
      }
    }

    public CompletedStates : IEnumerable[FsmState]
    {
      get
      {
        completed_states
      }
    }

    public Add(tran : StateTransition) : void
    {
      def num = tran.Num;
      when (!completed_buf.Get(num)) 
      {
        defered.Add(tran);
        completed_buf.Set(num, true)
      }
    }

    public Add(tran : IEnumerable[StateTransition]) : void
    {
      def tran = tran.Where(x => !completed_buf.Get(x.Num));
      defered.AddRange(tran);
      completed_buf.SetAll(tran, _.Num)
    }

    public Add(st : FsmState) : void
    {
      when (!completed_buf.Get(st.Num)) 
      {
        defered_st.Add(st);
        completed_buf.Set(st.Num, true)
      }
      
    }

    public Log(str : string) : void
    {
      log_file?.WriteLine(str)
    }
    
    log_file : TextWriter;
    
    public Traverse() : void
    {
      def state_queue = defered_st.ToArray();
      def tran_queue  = defered.ToArray();
      defered_st.Clear();
      defered.Clear();
      def st_res = state_queue.Map(_.TraverseTransitions());
      completed_states.AddRange(st_res);
      def trans = tran_queue.Map(_.TraversePath(true));
      completed.AddRange(trans);
      // if empty queue
      if (!defered_st.IsEmpty() || !defered.IsEmpty()) Traverse() else
      {
        log_file?.Close()
      }// else recursive call self and traverse again
    }
  }
}
