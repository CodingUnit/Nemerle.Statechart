using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of TransitionTraverser.
  /// </summary>
  public class TransitionTraverser
  {    
    defered    : List[StateTransition] = List();
    defered_st : List[FsmState]        = List();

    analyser : FsmAnalyser;

    public this(an : FsmAnalyser) { analyser = an }

    completed  : List[StateTransition] = List();

    completed_states : List[FsmState]  = List();

    public Completed : IEnumerable[StateTransition]
    {
      get
      {
        completed
      }
    }

    public CompletedStates : IEnumerable[FsmState]
    {
      get
      {
        completed_states
      }
    }

    public Add(tran : StateTransition) : void
    {
      defered.Add(tran)
    }

    public Add(tran : IEnumerable[StateTransition]) : void
    {
      defered.AddRange(tran)
    }

    public Add(st : FsmState) : void
    {
      when (!completed_states.Contains(st))
      {
        when (completed_states.Exists(x => x.Num == st.Num)) Debugger.Break();
        when (!defered_st.Contains(st))
          if (!defered_st.Exists(x => x.Num == st.Num)) defered_st.Add(st) else Debugger.Break();
      }
    }

    public Traverse() : void
    {
      def state_queue = defered_st.ToArray();
      def tran_queue = defered.RemoveDuplicatesSort(_.Name);
      defered_st.Clear();
      defered.Clear();
      def st_res = state_queue.Map(_.TraverseTransitions());
      completed_states.AddRange(st_res);
      def trans = tran_queue.Map(_.TraversePath(true));
      completed.AddRange(trans);
      // if empty queue
      when (defered_st.Count != 0 || defered.Count != 0) Traverse() // else recursive call self and traverse again
    }
  }
}
