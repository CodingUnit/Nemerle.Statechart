using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of TransitionTraverser.
  /// </summary>
  public class TransitionTraverser
  {    
    mutable defered : IEnumerable[StateTransition] = Enumerable.Empty();
    mutable defered_st : IEnumerable[FsmState] = Enumerable.Empty();
    
    public Add(tran : StateTransition) : void
    {
      defered = defered.Concat(tran);
    }
    
    public Add(tran : IEnumerable[StateTransition]) : void
    {
      defered = defered.Concat(tran);
    }

    public Add(st : FsmState) : void
    {
      defered_st = defered_st.Concat(st);
    }    

    public Traverse(an : FsmAnalyser) : list[FsmState]
    {
      Traverse(an, List())
    }
    
    Traverse(an : FsmAnalyser, state_res : List[FsmState]) : list[FsmState]
    {
      def (fsm, st) = defered_st.Partition(x => x.PartOfStateMachine.HasValue);
      def state_queue = st.RemoveDuplicatesSort((x, y) => x.CompareTo(y)) + fsm;
      def tran_queue = defered.RemoveDuplicatesSort((x, y) => x.Name.CompareTo(y.Name));
      def state_queue = state_queue.Exclude(x => state_res.Exists(y => y.Num == x.Num));
      defered_st = [];
      defered = [];
      def st_res = state_queue.Map(x => x.TraverseTransitions(an));
      state_res.AddRange(st_res);
      tran_queue.Iter(x => x.TraversePath(an, true));
      match (defered, defered_st)
      {
        // empty queue
        | ([], []) => state_res.NToList() // finish traverse
        | (_, _) => Traverse(an, state_res) // else recursive call self and traverse again
      }
    }
  }
}
