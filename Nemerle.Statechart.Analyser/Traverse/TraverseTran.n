using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of TraverseTran.
  /// </summary>
  public partial class TransitionPath
  {

    TraverseOrdinaryTransition(tran : StateTransition) : TransitionDestination
    {
      TraverseTransitionPath(tran); // unwind path from Source up to transition begining (From) 
      tran.Used = true; //exec actions and enter to target configuration
      TraverseTargetReg(tran.To, tran)
    }

    TraverseInternalTransition(tran : StateTransition) : TransitionDestination
    {
      //DefPath(tran.Source, tran.From);
      CreatePath(tran.From, [], [], tran.action); // create empty path
      //TraverseDecisionTree(tran.DecisionTree, tran);
      tran.Used = true;
      TransitionDestination.NoStateChange()
    }
    
    TraverseTransition(tran : StateTransition) : TransitionDestination
    {
      match (tran.kind)
      {
        | Internal                              => TraverseInternalTransition(tran)
          // if not exit from region
        | External when tran.WithinRegion       => TraverseWithinRegionTransition(tran)
          // if go to join pseudo state
      //| Transition(To = TransitionTarget.PseudoState(node = Join as j)) => TraverseJoinTransition(j, tran)
    // | Transition(IsCompletion = true)         => tran.
          // if from state in orthogonal region, and transition begins in orthogonal regions boundary or upper
        | _ 
                                                  => 
            if (tran.Source.PartOfSubRegion is Some(r))
              TraverseTransitionFromRegion(r, tran) else TraverseOrdinaryTransition(tran)
                                                // else ordinary transition
      }
    }

    TraverseDecisionTree(tree : DecisionNode, tran : StateTransition) : DecisionNode
    {
      def tree = tree.Clone();
      foreach (j in tree.GetBreadthFirstEnumerable())
      {
        | DecisionNode.Target(target = tar) as t => 
            def p = TransitionPath(tran, recursive); // create path new path 
            p.path = this.path.Clone(); // copy from this
            def dest = tar.ToState; // if we know the target
            p.DefPath(t.state, dest, true, j.actions); // create nodes to
            def dest = p.TraverseTargetReg(tar, tran); // traversing target
            t.path = p.path; // set node path to calculated
            t.destination = dest; // destination set to dest
          
        | _ => 
        
            def src = j.state;
            j.path = path.Clone(); // foreach nodes path from parent to childs
            foreach (n in j.ChildNodes)
            {
              def dest = n.state;
              def path = GetPath(src, dest, true, j.actions);
              n.path = path;
            }
      }
      tree
    }
    
  }
}
