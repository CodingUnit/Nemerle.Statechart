using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PathNode;
  using TransitionDestination;
  using TransitionTarget;
  using FsmState;


  /// <summary>
  /// Transition Path
  /// </summary>
  public partial class TransitionPath
  {
    [Accessor]
    mutable path : PathSequence = PathSequence();
    public recursive : bool;
    public traverser : TransitionTraverser;

    [Accessor]
    mutable transition : StateTransition;
    public analyser : FsmAnalyser;


    TraverseDecisionTree(tree : DecisionNode, tran : StateTransition) : void
    {
      foreach (j in tree.GetBreadthFirstEnumerable())
      {
        | DecisionNode.Target(target = tar) as t => 
            def p = TransitionPath(tran, recursive); // create path new path 
            p.path = this.path.Clone(); // copy from this
            def dest = tar.ToState; // if we know the target
            when (dest != null) p.DefPath(t.state, dest, true, j.actions); // create nodes to
            def dest = p.TraverseTargetReg(tar, tran); // traversing target
            t.path = p.path; // set node path to calculated
            t.destination = dest; // destination set to dest
          
        | _ => 
        
            def src = j.state;
            j.path = path.Clone(); // foreach nodes path from parent to childs
            foreach (n in j.ChildNodes)
            {
              def dest = n.state;
              def path = GetPath(src, dest, true, j.actions);
              n.path = path;
            }
      }
    }
    
    TraverseJunction(j : PseudoStateNode.Junction, tran : StateTransition) : TransitionDestination
    {
      TraverseDecisionTree(j.decision_tree, tran);
      //j.decision_tree.Iter(traverse_node, traverse_target);
      TransitionDestination.Junction(j.decision_tree)
    }

    TraverseTransition(tran : StateTransition) : TransitionDestination
    {
      match (tran.type)
      {
        | Internal                                => TraverseInternalTransition(tran)
          // if not exit from region
        | Transition when tran.WithinRegion         => TraverseWithinRegionTransition(tran)
          // if go to join pseudo state
      //| Transition(To = TransitionTarget.PseudoState(node = Join as j)) => TraverseJoinTransition(j, tran)
    // | Transition(IsCompletion = true)         => tran.
          // if from state in orthogonal region, and transition begins in orthogonal regions boundary or upper
        | _ 
                                                  => 
            if (tran.Source.PartOfSubRegion is Some(r))
              TraverseTransitionFromRegion(r, tran) else TraverseOrdinaryTransition(tran)
                                                // else ordinary transition
      }
    }

    /// <summary>
    /// Traversing path
    /// </summary>
    //rec : bool = false
    public Traverse() : void
    {
      def check_actual_to(to)
      {
        | SubRegion(state = st)
        | ForceStateChange(st)                   => check_actual_to(st)
        | Choice(_, _, Some(st))
        | Final(state = st)
        | State(st)                              =>
                                                st.Lived = true;
                                                when (recursive) traverser?.Add(st);
                                                st
        | Terminate(node = PseudoStateNode(state = st))
        | Region(st)
        | Choice(st, _, _)                       => st
        | _                                      => null
      }


      //recursive = rec;
      traverser?.Log($"start traverse transition: $(transition)");
      def to = TraverseTransition(transition); // traversing transition
      traverser?.Log($"transition: $(transition) destination:$to");
      def actual = check_actual_to(to);

      
      transition.Destination = to;
      transition.ActualTo = actual;
      transition.InitSimpleDecisionTree(path);
      //transition.Path = this;
    }

    public this(tran : StateTransition, rec : bool = false)
    {
      recursive = rec;
      transition = tran;
      this.analyser = tran.analyser;
      traverser = analyser.Traverser;
    }

    public Actions : IEnumerable[FsmAction]
    {
      get
      {
        path.Path.PathActions()
      }
    }
  }

}
