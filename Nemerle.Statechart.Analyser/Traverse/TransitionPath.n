using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using StateTransition;
  using PathNode;
  using TransitionDestination;
  using TransitionTarget;
  using FsmState;

  public class PathSequence
  {
    //mutable path : List[PathNode] = List();

    [Memoized]
    public exit_states : list[FsmState]
    {
      get
      {
        exit_tran_path.Map(_.st)
      }
    }
    
    exit_path   : List[TranPath.Exit]   = List();
    act_path    : List[TranPath.Action] = List();
    entry_path  : List[TranPath.Entry]  = List();
    
    [Memoized]
    public exit_tran_path  : list[TranPath.Exit]
    {
      get
      {
        exit_path.NToList()
      }
    }
    
    [Memoized]
    public actions_path    : list[TranPath.Action]
    {
      get
      {
        act_path.NToList()
      }
    }
    
    [Memoized]
    public entry_tran_path : list[TranPath.Entry]
    {
      get
      {
        entry_path.NToList()
      }
    }
    
    [Memoized]
    public action_nodes : list[PathNode]
    {
      get
      {
        actions_path.SelectMany(_.nodes).NToList()
      }
    }
    
    public entry_states : list[FsmState]
    {
      get
      {
        entry_tran_path.Map(_.st)
      }
    }
    
    //public this() {}

    public AddEntry(node : PathNode) : void
    {
      | PathNode(state = st) =>
      
        match (entry_path.Find(x => x.st == st))
        {
          | null => entry_path.Add(TranPath.Entry([node], st))
          | ep   => ep.nodes = ep.nodes.Append(node).NToList();
        }
    }

    public AddEntry(st : FsmState, node : IEnumerable[PathNode]) : void
    {
        entry_path.Add(TranPath.Entry(node.NToList(), st))
    }

    public AddEntry(path : IEnumerable[TranPath.Entry]) : void
    {
        entry_path.AddRange(path)
    }
    
    public AddExit(st : FsmState, node : IEnumerable[PathNode]) : void
    {
        exit_path.Add(TranPath.Exit(node.NToList(), st))
    }
    
    public AddExit(path : IEnumerable[TranPath.Exit]) : void
    {
        exit_path.AddRange(path)
    }
    
    public AddAction(node : IEnumerable[PathNode]) : void
    {
        act_path.Add(TranPath.Action(node.NToList()))
    }
    
    public AddAction(node : IEnumerable[TranPath.Action]) : void
    {
        act_path.AddRange(node)
    }
    //public Add(nodes : IEnumerable[PathNode]) : void
    //{
    //  path.AddRange(nodes)
    //}

    [Memoized]
    public exit_nodes : list[PathNode]
    {
      get
      {
        exit_tran_path.SelectMany(_.nodes).NToList()
      }
    }
    
    [Memoized]
    public entry_nodes : list[PathNode]
    {
      get
      {
        entry_tran_path.SelectMany(_.nodes).NToList()
      }
    }
    
    [Memoized]
    public Path : IEnumerable[PathNode]
    {
      get
      {
        exit_nodes + action_nodes + entry_nodes
      }
    }
  }

  /// <summary>
  /// Transition Path
  /// </summary>
  public partial class TransitionPath
  {
    [Accessor]
    path : PathSequence = PathSequence();
    public recursive : bool;
    public traverser : TransitionTraverser;

    [Accessor]
    mutable transition : StateTransition;
    public analyser : FsmAnalyser;

    AddEntry(node : PathNode) : void
    {
      path.AddEntry(node)
    }

    //AddNode(node : IEnumerable[PathNode]) : void
    //{
    //  path.Add(node)
    //}

#if 0        
    TraverseChoice(j : PseudoStateNode, tran : StateTransition) : TransitionDestination
    {
      match (j.Value)
      {
      | PseudoStateNode.Junction(tree = t) =>
          def jst = j.Parent;  
          DefPath(tran.From.StateDecl, jst);
          def exit = ExitNodeCreate(TraverseUtils.SingleElement(jst));
          AddNode(exit);
          def init_path = path;
          //path = Empty();



          def create_targ_tree(t, pst)
          {
            match (t.Data)
            {
              | TreeJunctionNode.Node(junc = j) =>
                def st = j.Parent;
                def node_path = GetPath(pst, st, true, jst);
                t.Update(x => x.ChangeNodePathOutPath(node_path, Enumerable.Empty()));
                st

            | TreeJunctionNode.Target(target = tar, junc = j) as tt=>

                def st = j.Parent;
                path = init_path;
                def node_path = GetPath(pst, st, true, jst);
                DefPath(st, tar.ToState, true, jst);
                def dest = TraverseTargetReg(tar, tran);
                def out_path = path.Path;
                t.Data = tt.ChangeDestOutPathNodePath(dest, out_path, node_path); 
                st
              }

          }

          traverser?.Log($"\nTraversing choice node $j");
          _ = t.GetBreadthFirstEnumerable().Fold(jst, create_targ_tree);//Reduce(j.state, (t, _, _, a) => create_tree_node(t, a), create_targ_tree);
          path = init_path;
          ChoiceNode(t)

          | _ => ()
        }
    }

    TraverseJunction(j : PseudoStateNode.Junction, tran : StateTransition) : TransitionDestination
    {
      //| (PseudoStateNode.Junction(to = jn), _) =>
        //TraverseJunctionNode(j.to, tran, j)
        null
    }


    TraverseJunctionNode(j : TransitionTarget.JunctionNode, junc : PseudoStateNode.Junction) : TransitionDestination
    {
      | (JunctionNode(decisionTree = t), PseudoStateNode.Junction(state = jst)) =>

          def init_path = path;

          def create_targ_tree(t)
          {
            | DecisionNode.Target(target = tar, state = st) as t =>
                  path = init_path;
                  def node_path = init_path.Add(GetPath(jst, st, true, jst));
                  DefPath(st, tar.ToState, true, jst);
                  def dest = TraverseTargetReg(tar, transition);
                  def out_path = path.Path;
                  t.ChangeDestinationOutPathNodePath(dest, out_path, node_path.Path)
          }

          traverser?.Log($"\nTraversing junction node $j");
          def dest_tree = t.Reduce(target = create_targ_tree);
          JunctionNode(dest_tree)

    }

    TraverseJunctionNode(j : TransitionTarget.JunctionNode, tran : StateTransition, junc : PseudoStateNode.Junction) : TransitionDestination
    {
          def jst = junc.state;
          DefPath(tran.From, jst);
          def exit = ExitNodeCreate(TraverseUtils.SingleElement(jst));
          AddNode(exit);
          def path = TransitionPath(tran, analyser, recursive);
          path.TraverseJunctionNode(j, junc);
    }



    TraverseMerge(j : PseudoStateNode.Junction, tr : StateTransition) : TransitionDestination
    {
      null
      //| (PseudoStateNode.Junction(to = TransitionTarget.JunctionNode(guard = g, action = a, to = t)), _) =>

      //    match (g)
      //    {
      //      | GuardNode.Empty => ()
      //      | g               => transition = transition.AddCheck(CheckNode.Guard([g]));
      //    }
      //    match (a)
      //    {
      //      | Some(a) => AddNode(Action(a))
      //      | _       => ()
      //    }

      //    DefPath(j.state, t.ToState);
      //    TraverseTargetReg(t, tr)
    }
#endif


    TraverseTransition(tran : StateTransition) : TransitionDestination
    {

      | Internal                                => tran.Used = true;
                                                      NoStateChange()
      | Default                                 => TraverseDefaultTransition(tran)
      | Initial                                 => TraverseInitialTransition(tran)
      | History                                 => TraverseHistoryPath(tran)
          // if not exit from region
      | Transition(WithinRegion = true)         => TraverseWithinRegionTransition(tran)
          // if go to join pseudo state
      //| Transition(To = TransitionTarget.PseudoState(node = Join as j)) => TraverseJoinTransition(j, tran)
    // | Transition(IsCompletion = true)         => tran.
          // if from state in orthogonal region, and transition begins in orthogonal regions boundary or upper
      | _ 
                                                  => 
          if (tran.Source.PartOfSubRegion is Some(r))
            TraverseTransitionFromRegion(r, tran) else TraverseOrdinaryTransition(tran)
                                                // else ordinary transition
    }

    /// <summary>
    /// Traversing path
    /// </summary>
    //rec : bool = false
    public Traverse() : void
    {
      def check_actual_to(to)
      {
        | SubRegion(state = st)
        | ForceStateChange(st)                   => check_actual_to(st)
        | Choice(_, _, Some(st))
        | Final(state = st)
        | State(st)                              =>
                                                st.Lived = true;
                                                when (recursive) traverser?.Add(st);
                                                st
        | Terminate(node = PseudoStateNode(state = st))
        | Region(st)
        | Choice(st, _, _)                       => st
        | _                                      => null
      }


      //recursive = rec;
      traverser?.Log($"start traverse transition: $(transition)");
      def to = TraverseTransition(transition); // traversing transition
      traverser?.Log($"transition: $(transition) destination:$to");
      def actual = check_actual_to(to);

      transition.Destination = to;
      transition.ActualTo = actual;
      transition.Path = this;
    // Update(x => x.ChangeDestinationActualToPath(to, actual, this));
    }

    public this(tran : StateTransition, rec : bool = false)
    {
      recursive = rec;
      transition = tran;
      this.analyser = tran.analyser;
      traverser = analyser.Traverser;
    }

    public Actions : IEnumerable[FsmAction]
    {
      get
      {
        path.Path.PathActions()
      }
    }
  }

}
