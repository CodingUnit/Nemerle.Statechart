using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{

  using CheckNode;
  using StateTransition;
  using PathNode;
  using TransitionDestination;
  using FsmState;

  /// <summary>
  /// Description of TransitionPathOrthogonal.
  /// </summary>
  public partial class TransitionPath
  {

    //TraverseJoinTransition(join : PseudoStateNode.Join, tr : StateTransition) : TransitionDestination
    //{
    //  | (Join(state = st, joined_tran = jtran, transition = tran), StateTransition(Source = src)) =>

    //      tr.omit_guard = true;
    //      tr.Used = true;
    //      DefExitPath(src, st);
    //      traverser?.Add(tran);
    //      def (node, tran) = if (tr.FromRegion : object == jtran.Last().FromRegion)
    //      {
    //        tr.AddCheck(CheckNode.Join(join, tr));
    //        (JoinedTransition(join, tran), tr)
    //      } else
    //      if (tr.FromRegion: object == jtran.First().FromRegion)
    //      {
    //        tr.AddCheck(RegionStates(jtran.Map(x => x.From)));
    //        def has_guard = jtran.Exists(x => x.guard.HasValue);
    //        when (has_guard) tr.AddCheck(Guard(jtran.FilterValues(x => x.Guard).NToList()));
    //        (Join(join), tr)
    //      }
    //      else
    //      {
    //        tr.AddCheck(Join(join, tr));
    //        (Join(join), tr)
    //      }
    //      transition = tran;
    //      node

    //}

    TraverseFork(fork : PseudoStateNode.Fork, targets : list[TransitionTarget]) : TransitionDestination
    {
      | (Fork(fork_tran = ftran), t) => 

        def st = t.Map(x => x.ToState);
        def reg = st.Head.PartOfRegion.Value;
        traverser?.Add(ftran);
        null
        //Fork(reg, ftran)
    }

    TraverseOrthogonalRegion(reg : FsmState) : TransitionDestination
    {
      def initial = reg.sub_states.Map(x => x.initial_tran);
      when (!initial.All(x => x.HasValue)) throw FsmErrorException(FsmError.RegionMustContainInitial(reg, transition));
      def init = reg.sub_states.FilterValues(x => x.initial_tran);
      //def init = initial.Flatten();
      init.Iter(_.TraversePath());
      //def target = Region(reg);
      //if (transition.IsInitial) target else TraverseCompletionTransition(target, target)
      null
    }

    TraverseCompletionTransition(target : TransitionDestination) : TransitionDestination
    {
      match (target)
      {
        | State(s) => 

            def tr = s.join_completion_transitions;
            if (tr.IsEmpty()) target else
            {
              def (reg, joined) = match (tr.First().To)
              {
                | TransitionTarget.PseudoState(node = Join(joined_tran = tran, region = reg)) => (reg, tran)
                | _                                                                           => (null, null)
              }
              traverser?.Add(tr);
              //ForceStateChange(TransitionPostConditions.RegionCompletion(reg, joined), to)
              null
            }

        | _ => target// end state
      }
    }

    TraverseSubRegion(reg : FsmState, to : TransitionTarget, tran : StateTransition) : TransitionDestination
    {
      def region = reg.Super; // region of sub region
      def st = to.ToState;
      def omitted = region.RegionsExcept(st); // other omitted regions
      def initial = omitted.Map(x => x.initial_tran);
      def initial = initial.FilterValues(x => x);//.SelectMany(x.Value);

      def res = initial.Map(TransitionTraverser.Traverse);
      def res = res.Map(x => x.ToState);
          // TODO: initial not to state
      def target = TraverseTarget(to, tran);
      def combined_path = initial.SelectMany(x => x.Path); // path of other initial
      def target = target.ToState;
      combined_path.Iter(path.AddPath);
      def res = target :: res;
      //def target = reg.SequentialFromConcurrent(res);
      //TraverseCompletion(target)
      null
    }

    TraverseWithinRegionTransition(tran : StateTransition) : TransitionDestination
    {
      def to = TraverseOrdinaryTransition(tran);
      //TraverseCompletionTransition(to, to)
      null
    }

    TraverseTransitionFromRegion(_reg : FsmState, tran : StateTransition) : TransitionDestination
    {
      //| (ConcurrentSubRegion, StateTransition(Source = src, From = from)) =>
      TraverseTransitionPath(tran);
      tran.Used = true;
      null
      //ForceStateChange(TraverseTargetReg(tran.To, tran)) // traversing transition target
    }

  }
}
