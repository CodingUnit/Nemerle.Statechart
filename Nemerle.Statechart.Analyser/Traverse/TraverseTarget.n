using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;


namespace Nemerle.Statechart
{
  using TransitionDestination;

  /// <summary>
  /// Description of TraverseTarget.
  /// </summary>
  public partial class TransitionPath
  {
    
    
    TraverseJunction(j : PseudoStateNode.Junction, tran : StateTransition) : TransitionDestination
    {
      def tree =  TraverseDecisionTree(j.decision_tree, tran);
      //j.decision_tree.Iter(traverse_node, traverse_target);
      tran.DecisionTree = tree;
      TransitionDestination.Junction(tree)
    }
    
    TraverseExitPoint(pseudo : PseudoStateNode.ExitPoint, tr : StateTransition) : TransitionDestination
    {
      match (pseudo)
      {
        | ExitPoint(tran = Some(t)) => tr.Used = true;
                                       CheckExecuteTran(t)
        | _                         => TransitionDestination.Unknown()
      }
    }
    
    TraversePseudo(st : PseudoStateNode, tr : StateTransition) : TransitionDestination
    {
      match (st)
      {
        | History as p                                => TraverseHistory(p)
        | Terminate as p                              => tr.Used = true;
                                                         Terminate(p)
        | Fork(target = t) as p                       => null//TraverseFork(p, t)
        | Junction(type = JunctionType.Junction) as j => TraverseJunction(j, tr)
        | Junction(type = JunctionType.Merge) as j    => TraverseJunction(j, tr)
        | EntryPoint(tran = t)                        => tr.Used = true;CheckExecuteTran(t)
        | ExitPoint as p                              => TraverseExitPoint(p, tr)
        | Junction(type = JunctionType.Choice)      //TraverseChoice(j, tr)
        | _                                           => Unknown()
      }
    }
    /// <summary>
    /// Processing final state node
    /// </summary>
    TraverseFinal(st : FsmState) : TransitionDestination
    {
      match (st.PartOfRegion, st.PartOfSubRegion)
      {
        | (Some(r), Some(sr)) => 

            match (st.CompletionTransitions.NToList()) 
            {

              | []   => traverser?.Log($"\nEntering in final state $st of Region ($r:$sr) and live in it");
                        State(st)
              | tran =>
                  //st.Completion = tran;
                  traverser?.Log($"\nEntering in final state $st of Region ($r:$sr) transitions ..$tran may happen");
                  traverser?.Add(tran);
                  TransitionDestination.Unknown()//Final(st, sr, r, tran)
            }

        | _ => 
          match (st.ParticipateInHistory.NToList()) // create clear history node
          {
            | [] => ()
            | lst=> def node = PathNode.ClearHistory(st, lst);
                    AddEntry(node); // get nodes and add to path
          }
          traverser?.Log($"\nEntering in final state $st");
          match (st.CompletionTransitions.NToList(), st.ExternalTransitions)
          {
            // if we not have completion transition and transitions from this or upper states, final state must recognised as terminate node
            | ([], [])  => Terminate(PseudoStateNode.Terminate(0, st))
    //when (st.CompletionTransitions.IsEmpty() && st.Transitions.IsEmpty())
            | ([], _) => traverser?.Log($"\nEntering state $(st) and live in it");
                          st.Lived = true;
                          traverser?.Add(st);
                          State(st) // end state
            | (tran, _) =>
                st.Lived = true;
                match (tran)
                {
                  | [StateTransition(guard = Empty) as tran]  => 
                // if not defined transition path create it
                        traverser?.Log($"..and pass it by completion transition $tran");
                        CheckExecuteTran(tran) // if not defined transition path create it

                  | tran       => 
                      traverser?.Add(tran);
                      traverser?.Log($"..and pass it by completion transitions ..$tran");
                      Choice(st.Super, tran, Some(st)) // 
                }


          }
      }
    }

    TraverseCompletion(st : FsmState) : TransitionDestination
    {
      match (st.CompletionTransitions.Filter(x => x.From.IsSimple).NToList())
      {
        | [] => traverser?.Log($"\nEntering state $(st) and live in it");
                st.Lived = true;
                traverser?.Add(st);
                State(st) // end state
        | tran =>
            def dest = match (tran)
                        {
                          | [StateTransition(guard = Empty) as tran]  => 
                        // if not defined transition path create it
                                traverser?.Log($"..and pass it by completion transition $tran");
                                CheckExecuteTran(tran) // if not defined transition path create it

                          | tran       => 
                              traverser?.Add(tran);
                              traverser?.Log($"..and pass it by completion transitions ..$tran");
                              Choice(st, tran, Some(st))
                        }
            match (st.do_activity)
            {
              | []  => traverser?.Log($"\nNo internal activity run completion event");
                      st.Lived = true;
                      dest
              | act => act.Iter(x => x.need_completion = true);
                      st.Lived = true;
                      traverser?.Add(st);
                      traverser?.Log($"\nafter internal activity ..$act complete, run completion event, now stay in $st state");
                      State(st) // end state
            }
      }

    }

    TraverseHistory(hist : PseudoStateNode.History) : TransitionDestination
    {
      | PseudoStateNode.History(default = tran) =>
            tran.Iter(traverser?.Add);
            hist.Used = true;
            History(hist)
    }

    //TraverseSubMachine(fsm : FsmState.SubMachine, state : string) : TransitionDestination
    //{
    //  def fsm = fsm.ChangeLived(true);
    //  TransitionDestination.SubMachine(fsm, state)
    //}

    TraverseStateTarget(st : FsmState) : TransitionDestination
    {
      match (st.type)
      {
        // transition to region
        | Region      => TraverseOrthogonalRegion(st)
        | Final       => TraverseFinal(st)
        | State when st.IsSimple => TraverseCompletion(st)
        | _ => match (st.initial_tran)// with (initial = [Initial(guard = None) as init]) => 
            {
              // if simple state and no initial transition
              | None => 
                      traverser?.Log($"\nEntering state $(st) and live in it");
                      st.Lived = true;
                      traverser?.Add(st);
                      State(st) // end state
                // if state with one initial transition without Guard
              | Some(init) =>
        // check initial transition path, and traverse it if it null
                  traverser?.Log($"\nEntering state $(st) and pass through initial transition $(init)");
                  CheckExecuteTran(init)

              //| init => 
              //    def init = init.Map(_ : StateTransition);
              //    traverser?.Log($"\nEntering state $(st) and pass through several initial transitions ..$(init)");
              //    traverser?.Add(init);
              //    init.Iter(x => x.Used = true);
              //    Choice(st, init, None()); // creating dynamic choice node
            }
      }
    }

    TraverseTarget(to : TransitionTarget, tr : StateTransition) : TransitionDestination
    {
      match (to)
      {
        | State(state = st)        => TraverseStateTarget(st)
          // if target is orthogonal state
        | Final(state = st)        => TraverseFinal(st) // process final node
        | PseudoState(node = st)   => TraversePseudo(st, tr)
        | Nowhere                  => NoStateChange()
        //| SubMachine(m, s)  => TraverseSubMachine(m, s)
        | _                        => Unknown()
      }
    }

    TraverseTargetReg(to : TransitionTarget, tr : StateTransition) : TransitionDestination
    {
      match (to)
      {
        | TransitionTarget(PartOfSubRegion = Some(r)) when (!tr.WithinRegion) => TraverseSubRegion(r, to, tr)
        | _                                                                   => TraverseTarget(to, tr)
      }
    }
  }
}
