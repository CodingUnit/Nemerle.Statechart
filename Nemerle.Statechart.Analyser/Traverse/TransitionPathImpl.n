using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;


namespace Nemerle.Statechart
{

  using PathNode;
  using ListUtils;
  /// <summary>
  /// Description of TransitionPathImpl.
  /// </summary>
  public partial class TransitionPath
  {
    public static FindPath(src_st : FsmState,
                          dest_st : FsmState,
                          exit : IEnumerable[FsmState],
                          entry : IEnumerable[FsmState]) : list[FsmState] * list[FsmState]
    {
      def (ex, en) = FindPath(src_st, dest_st);
      (exit.Concat(ex).NToList(), en.Concat(entry).NToList())
    }

    public static FindPath(src_st : FsmState,
                           dest_st : FsmState) : list[FsmState] * list[FsmState]
    {
      def src = if (src_st != null) src_st.SuperStatesIncludeFromTop else [];
      def dest = if (dest_st != null) dest_st.SuperStatesIncludeFromTop else [];
      def (ex, en) = src.RemoveDupFirst(dest, (x, y) => x == y : object);
      (ex.Reverse(), en)
    }
    
    AddEntry(node : PathNode) : void
    {
      path.AddEntry(node)
    }

    static GetEntryNode(st : FsmState) : IEnumerable[PathNode]
    {
      | FsmState(do_activity = do_act, entry = en) => 
              def act = en.Map(_.action);
              def en = act.Map(Entry(st, _));
              def do_act = do_act.Select(RunDoActivity(st, _));
              en.Concat(do_act)
          //def act = Actions(st.entry.SelectMany(_.actions).NToList());
          //def inl = do_act.Map(x => (RunDoActivity(x, st), true));
          //if (!en.IsEmpty() || !inl.IsEmpty()) Entry(act, inl, st) :: a else a
    }

    static GetEntryPath(nodes : IEnumerable[FsmState]) : list[TranPath]
    {
      //nodes.SelectMany(EnterState).NToList()
      $[TranPath(st, GetEntryNode(st).NToList(), PathKind.Entry), st in nodes]
    }

    static GetActionPath(st : FsmState, act : list[FsmAction]) : list[TranPath]
    {
      $[TranPath(st, PathNode.Action(st, a) :: [], PathKind.Action), a in act]
      //nodes.Concat(act.Map(PathNode.Action(PathKind.Action(), st, _)))
    }

    static GetExitNode(st : FsmState) : IEnumerable[PathNode]
    {
      def do_act = st.do_activity.Map(StopDoActivity(st, _));
      def nodes = if (st.history.HasValue) SaveHistory(st, st.history.Value) :: do_act; else do_act;
      //def inline = inline.Map(x => (x, false));
      def act = st.exit.Map(_.action);
      def exit = act.Select(Exit(st, _));
      nodes.Concat(exit)
      //if (!st.exit.IsEmpty() || !inline.IsEmpty()) Exit(act, st) else Empty()
    }

    public static GetExitPath(nodes : IEnumerable[FsmState]) : list[TranPath]
    {
      $[TranPath(st, GetExitNode(st).NToList(), PathKind.Exit), st in nodes]
    }

    GetPath(st : FsmState, ex : IEnumerable[FsmState], en : IEnumerable[FsmState], act : list[FsmAction]) : PathSequence
    {
      def path = PathSequence();
      def exit = GetExitPath(ex); // create nodes for exit exit actions
      def act = GetActionPath(st, act); // add transition action
      def entry = GetEntryPath(en); // create nodes for entry exit actions
      path.AddExit(exit);
      path.AddAction(act);
      path.AddEntry(entry);
      path
    }

    CreatePath(st : FsmState, ex : IEnumerable[FsmState], en : IEnumerable[FsmState], act : list[FsmAction]) : void
    {
      def exit = GetExitPath(ex); // create nodes for exit exit actions
      def act = GetActionPath(st, act); // add transition action
      def entry = GetEntryPath(en); // create nodes for entry exit actions
      path.AddExit(exit);
      path.AddAction(act);
      path.AddEntry(entry);
    }
    
    TraverseTransitionPath(tran : StateTransition) : void
    {
      ExitToLca(tran);
      DefPath(tran.From, tran.AtLeastStaticTo, tran.Local, tran.action);
    }

    ExitToLca(tran : StateTransition) : void
    {
      def ex = FindPath(tran.Source, tran.From)[0];
      path.AddExit(GetExitPath(ex));
    }
    
    DefPath(src : FsmState, dest : FsmState, local : bool = true, act : list[FsmAction]) : void
    {
      def (ex, en) = if (local) FindPath(src, dest) else 
      {
        FindPath(src?.Super, dest?.Super, [src], [dest]);
      }
      CreatePath(src, ex, en, act)
    }

    GetPath(src : FsmState, dest : FsmState, local : bool = true, act : list[FsmAction]) : PathSequence
    {
      def (ex, en) = if (local) FindPath(src, dest) else FindPath(src?.Super, dest?.Super, [src], [dest]);
      GetPath(src, ex, en, act)
    }

    //DefPath(src : FsmState, dest : FsmState) : void
    //{
    //  def ex = FindPath(src, dest, [], [])[0];// else FindPath(src.Super, dest.Super, [src], [dest])[0];
    //  path.AddExit(GetExitPath(ex));
    //  //NodesCreate(ex, tr);
    //  //def node = if (ex_node != null) ex_node + node else node;
    //  //AddEntry(node)
    //}

  }
}
