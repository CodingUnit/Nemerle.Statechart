using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;


namespace Nemerle.Statechart
{

  using PathNode;
  using ListUtils;
  /// <summary>
  /// Description of TransitionPathImpl.
  /// </summary>
  public partial class TransitionPath
  {
    public static FindPath(src_st : FsmState,
                          dest_st : FsmState,
                          exit : IEnumerable[FsmState],
                          entry : IEnumerable[FsmState]) : IEnumerable[FsmState] * IEnumerable[FsmState]
    {
      def src = src_st.super_states;
      def dest = dest_st.super_states;
      def (ex, en) = src.RemoveDupFirst(dest, (x, y) => x == y : object);
      (exit.Concat(ex.Reverse()), en.Concat(entry))
    }

    //* 1. The source and target are the same (self-transition).
                //* -2. The target is a substate of the source. (local or external?)
                //* -3. The source is a substate of the target. (local or external?)
                //* 4. The source and target share the same superstate.
                //* 5. All other cases.
                //*     a. The source and target reside at the save level in the
                //*        hiearchy (but do not share the same superstate).
                //*     b. The source is lower in the hiearchy than the target.
                //*     c. The target is lower in the hierarchy than the source.
                //*
                //* Case 1: Immediately performs the transition.
                //*
                //* Case 2: Traverses the hierarchy from the source to the target,
                //*         entering each state along the way. No states are exited.
                //*
                //* Case 3: Traverses the hierarchy from the source to the target,
                //*         exiting each state along the way. The target is then
                //*         entered.
                //*
                //* Case 4: The source is exited and the target entered.
                //*
                //* Case 5: Traverses the hiearchy until a common superstate is met.


    //static FindLCA(st : FsmState, dest_st : FsmState) : FsmState//IEnumerable[FsmState] * IEnumerable[FsmState]
    //{
    //  //def super = dest_st.Super;
    //  //def dest = if (super != null) super else dest_st;
    //  //FindPath(st.Super, dest, TraverseUtils.SingleElement(st), TraverseUtils.SingleElement(dest_st))
    //  //FindPath(st.Super, dest, TraverseUtils.SingleElement(st), TraverseUtils.SingleElement(dest_st))

    //   def super1 = st.super_states;
    //   def super2 = dest_st.super_states;
    //   match (super1.ZipLazy(super2).Find((x, y) => x == y : object))
    //   {
    //     | Some((st, _)) => st
    //     | _             => null
    //   }
    //}

    //static FindPath(st : FsmState, dest_st : FsmState) : IEnumerable[FsmState] * IEnumerable[FsmState]
    //{
    //  //def super = dest_st.Super;
    //  //def dest = if (super != null) super else dest_st;
    //  //FindPath(st.Super, dest_st, TraverseUtils.SingleElement(st), TraverseUtils.SingleElement(dest_st))
    //  //FindPath(st.Super, dest, TraverseUtils.SingleElement(st), TraverseUtils.SingleElement(dest_st))
    //}

    

    static GetEntryNode(st : FsmState) : IEnumerable[PathNode]
    {
      | FsmState(do_activity = do_act, entry = en) => 
              def act = en.Map(_.action);
              def en = act.Map(Entry(st, _));
              def do_act = do_act.Select(RunDoActivity(st, _));
              en.Concat(do_act)
          //def act = Actions(st.entry.SelectMany(_.actions).NToList());
          //def inl = do_act.Map(x => (RunDoActivity(x, st), true));
          //if (!en.IsEmpty() || !inl.IsEmpty()) Entry(act, inl, st) :: a else a
    }

    static GetEntryPath(nodes : IEnumerable[FsmState]) : list[TranPath]
    {
      //nodes.SelectMany(EnterState).NToList()
      $[TranPath(st, GetEntryNode(st).NToList(), PathKind.Entry), st in nodes]
    }

    static GetActionPath(st : FsmState, act : list[FsmAction]) : list[TranPath]
    {
      $[TranPath(st, PathNode.Action(st, a) :: [], PathKind.Action), a in act]
      //nodes.Concat(act.Map(PathNode.Action(PathKind.Action(), st, _)))
    }
    
    static GetExitNode(st : FsmState) : IEnumerable[PathNode]
    {
      def do_act = st.do_activity.Map(StopDoActivity(st, _));
      def nodes = if (st.history.HasValue) SaveHistory(st, st.history.Value) :: do_act; else do_act;
      //def inline = inline.Map(x => (x, false));
      def act = st.exit.Map(_.action);
      def exit = act.Select(Exit(st, _));
      nodes.Concat(exit)
      //if (!st.exit.IsEmpty() || !inline.IsEmpty()) Exit(act, st) else Empty()
    }

    public static GetExitPath(nodes : IEnumerable[FsmState]) : list[TranPath]
    {
      //def exiting_state(st)
      //{

      //  | FsmState(type = StateType.Region, exit = e)  => 
      //      def regs = st.RegionsExcept(src);
      //      def node = RegionExit(regs, st);
      //      if (e.IsEmpty()) TraverseUtils.SingleElement(node) else TraverseUtils.DoubleElement(GetExitNode(st), node)

      //  | _ => TraverseUtils.SingleElement(GetExitNode(st))
      //}

      //nodes.SelectMany(exiting_state)
      //nodes.SelectMany(GetExitNode)
      //TranPath.Exit()
      $[TranPath(st, GetExitNode(st).NToList(), PathKind.Exit), st in nodes]
    }

    NodesCreate(ex : IEnumerable[FsmState], tran : StateTransition) : void
    {
      def (exit, en) = TraverseTransitionPath(tran);
      def ex = ex.Concat(exit);

      def exit = GetExitPath(ex); // create nodes for exit exit actions
      def act = GetActionPath(tran.From, tran.action); // add transition action
      def entry = GetEntryPath(en); // create nodes for entry exit actions
      path.AddExit(exit);
      path.AddAction(act);
      path.AddEntry(entry)
      //node.Concat(entry_nodes) // merge together
    }

    //NodesCreate(ex : IEnumerable[FsmState], en : IEnumerable[FsmState]) : IEnumerable[PathNode]
    //{
    //  def node        = ExitNodeCreate(ex); // create nodes for exit exit actions
    //  def entry_nodes = EntryNodeCreate(en); // create nodes for entry exit actions
    //  node.Concat(entry_nodes) // merge together
    //}

    TraverseTransitionPath(tran : StateTransition) : IEnumerable[FsmState] * IEnumerable[FsmState]
    {
      match (tran.type)
      {
        // initial и pseudo is local transitions by default
        //| Initial(AtLeastStaticTo = st, From = from)
        //| History(From = from, ToState = st)
        // fork transition
        | Local => def from = tran.From;
                   def st = tran.AtLeastStaticTo;
                   def (ex, en) = FindPath(from, st, [], []);
                   def en = en.ChopLast(); // remove entry in state
                   def en = en.Append(st); // add entry to target state
                   (ex, en)
                   
      // transition to pseudo state
        | Transition => def st = tran.AtLeastStaticTo;
                        def (ex, en) = FindPath(tran.From, st, [], []);
                        (ex, en.Append(st))
        | Internal  // no path for internal transition
        | _        => (Enumerable.Empty(), Enumerable.Empty())
      }
    }

    //DefExitPath(src : FsmState, dest : FsmState) : void
    //{
    //  def ex = FindPath(src, dest, Enumerable.Empty(), Enumerable.Empty())[0];
    //  AddNode(ExitNodeCreate(ex))
    //}

    //DefPath(src : FsmState, dest : FsmState, local : bool = true, skip : FsmState = null) : void
    //{
    //  def node = GetPath(src, dest, local, skip);
    //  AddNode(node)
    //}

    //GetPath(src : FsmState, dest : FsmState, local : bool = true, skip : FsmState = null) : IEnumerable[PathNode]
    //{
    //  if (src == null || dest == null) Enumerable.Empty() else
    //  {
    //    def (ex, en) = if (local) FindPath(src, dest, Enumerable.Empty(), Enumerable.Empty()) else FindLCA(src, dest);
    //    def ex = if (ex.IsEmpty()) ex else 
    //               if (skip != null && ex.First() == skip : object) ex.Skip(1) else ex;
    //    NodesCreate(ex, en)
    //  }
    //}

    DefPath(src : FsmState, dest : FsmState, tr : StateTransition) : void//, ex_node : IEnumerable[PathNode] = null) : void
    {
      def ex = if (tr.Local) FindPath(src, dest, [], [])[0]; else FindPath(src, dest, [src], [dest])[0];
      NodesCreate(ex, tr);
      //def node = if (ex_node != null) ex_node + node else node;
      //AddEntry(node)
    }

  }
}
