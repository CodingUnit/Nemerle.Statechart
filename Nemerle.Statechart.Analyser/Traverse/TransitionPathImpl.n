using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;


namespace Nemerle.Statechart
{

  using PathNode;
  using ListUtils;
  /// <summary>
  /// Description of TransitionPathImpl.
  /// </summary>
  public partial class TransitionPath
  {
    public static FindPath(src_st : FsmState,
                          dest_st : FsmState,
                          exit : IEnumerable[FsmState],
                          entry : IEnumerable[FsmState]) : IEnumerable[FsmState] * IEnumerable[FsmState]
    {
      def src = if (src_st != null) src_st.SuperStatesIncludeFromTop else [];
      def dest = if (dest_st != null) dest_st.SuperStatesIncludeFromTop else [];
      def (ex, en) = src.RemoveDupFirst(dest, (x, y) => x == y : object);
      (exit.Concat(ex.Reverse()), en.Concat(entry))
    }

    //* 1. The source and target are the same (self-transition).
                //* -2. The target is a substate of the source. (local or external?)
                //* -3. The source is a substate of the target. (local or external?)
                //* 4. The source and target share the same superstate.
                //* 5. All other cases.
                //*     a. The source and target reside at the save level in the
                //*        hiearchy (but do not share the same superstate).
                //*     b. The source is lower in the hiearchy than the target.
                //*     c. The target is lower in the hierarchy than the source.
                //*
                //* Case 1: Immediately performs the transition.
                //*
                //* Case 2: Traverses the hierarchy from the source to the target,
                //*         entering each state along the way. No states are exited.
                //*
                //* Case 3: Traverses the hierarchy from the source to the target,
                //*         exiting each state along the way. The target is then
                //*         entered.
                //*
                //* Case 4: The source is exited and the target entered.
                //*
                //* Case 5: Traverses the hiearchy until a common superstate is met.


    //static FindLCA(st : FsmState, dest_st : FsmState) : FsmState//IEnumerable[FsmState] * IEnumerable[FsmState]
    //{
    //  //def super = dest_st.Super;
    //  //def dest = if (super != null) super else dest_st;
    //  //FindPath(st.Super, dest, TraverseUtils.SingleElement(st), TraverseUtils.SingleElement(dest_st))
    //  //FindPath(st.Super, dest, TraverseUtils.SingleElement(st), TraverseUtils.SingleElement(dest_st))

    //   def super1 = st.super_states;
    //   def super2 = dest_st.super_states;
    //   match (super1.ZipLazy(super2).Find((x, y) => x == y : object))
    //   {
    //     | Some((st, _)) => st
    //     | _             => null
    //   }
    //}

    //static FindPath(st : FsmState, dest_st : FsmState) : IEnumerable[FsmState] * IEnumerable[FsmState]
    //{
    //  //def super = dest_st.Super;
    //  //def dest = if (super != null) super else dest_st;
    //  //FindPath(st.Super, dest_st, TraverseUtils.SingleElement(st), TraverseUtils.SingleElement(dest_st))
    //  //FindPath(st.Super, dest, TraverseUtils.SingleElement(st), TraverseUtils.SingleElement(dest_st))
    //}


    AddEntry(node : PathNode) : void
    {
      path.AddEntry(node)
    }

    static GetEntryNode(st : FsmState) : IEnumerable[PathNode]
    {
      | FsmState(do_activity = do_act, entry = en) => 
              def act = en.Map(_.action);
              def en = act.Map(Entry(st, _));
              def do_act = do_act.Select(RunDoActivity(st, _));
              en.Concat(do_act)
          //def act = Actions(st.entry.SelectMany(_.actions).NToList());
          //def inl = do_act.Map(x => (RunDoActivity(x, st), true));
          //if (!en.IsEmpty() || !inl.IsEmpty()) Entry(act, inl, st) :: a else a
    }

    static GetEntryPath(nodes : IEnumerable[FsmState]) : list[TranPath]
    {
      //nodes.SelectMany(EnterState).NToList()
      $[TranPath(st, GetEntryNode(st).NToList(), PathKind.Entry), st in nodes]
    }

    static GetActionPath(st : FsmState, act : list[FsmAction]) : list[TranPath]
    {
      $[TranPath(st, PathNode.Action(st, a) :: [], PathKind.Action), a in act]
      //nodes.Concat(act.Map(PathNode.Action(PathKind.Action(), st, _)))
    }

    static GetExitNode(st : FsmState) : IEnumerable[PathNode]
    {
      def do_act = st.do_activity.Map(StopDoActivity(st, _));
      def nodes = if (st.history.HasValue) SaveHistory(st, st.history.Value) :: do_act; else do_act;
      //def inline = inline.Map(x => (x, false));
      def act = st.exit.Map(_.action);
      def exit = act.Select(Exit(st, _));
      nodes.Concat(exit)
      //if (!st.exit.IsEmpty() || !inline.IsEmpty()) Exit(act, st) else Empty()
    }

    public static GetExitPath(nodes : IEnumerable[FsmState]) : list[TranPath]
    {
      //def exiting_state(st)
      //{

      //  | FsmState(type = StateType.Region, exit = e)  => 
      //      def regs = st.RegionsExcept(src);
      //      def node = RegionExit(regs, st);
      //      if (e.IsEmpty()) TraverseUtils.SingleElement(node) else TraverseUtils.DoubleElement(GetExitNode(st), node)

      //  | _ => TraverseUtils.SingleElement(GetExitNode(st))
      //}

      //nodes.SelectMany(exiting_state)
      //nodes.SelectMany(GetExitNode)
      //TranPath.Exit()
      $[TranPath(st, GetExitNode(st).NToList(), PathKind.Exit), st in nodes]
    }

    //AddNodes(st : FsmState, ex : IEnumerable[FsmState], en : IEnumerable[FsmState], act : list[FsmAction]) : void
    //{
    //  def exit = GetExitPath(ex); // create nodes for exit exit actions
    //  def act = GetActionPath(st, act); // add transition action
    //  def entry = GetEntryPath(en); // create nodes for entry exit actions
    //  path.AddExit(exit);
    //  path.AddAction(act);
    //  path.AddEntry(entry)
    //}

    GetPath(st : FsmState, ex : IEnumerable[FsmState], en : IEnumerable[FsmState], act : list[FsmAction]) : PathSequence
    {
      def path = PathSequence();
      def exit = GetExitPath(ex); // create nodes for exit exit actions
      def act = GetActionPath(st, act); // add transition action
      def entry = GetEntryPath(en); // create nodes for entry exit actions
      path.AddExit(exit);
      path.AddAction(act);
      path.AddEntry(entry);
      path
    }

    CreatePath(st : FsmState, ex : IEnumerable[FsmState], en : IEnumerable[FsmState], act : list[FsmAction]) : void
    {
      def exit = GetExitPath(ex); // create nodes for exit exit actions
      def act = GetActionPath(st, act); // add transition action
      def entry = GetEntryPath(en); // create nodes for entry exit actions
      path.AddExit(exit);
      path.AddAction(act);
      path.AddEntry(entry);
    }
    
    //NodesCreate(ex : IEnumerable[FsmState], tran : StateTransition) : void
    //{
    //  def (exit, en) = TraverseTransitionPath(tran);
    //  def ex = ex.Concat(exit);
    //  AddNodes(tran.From, ex, en, tran.action)
    //}

    //NodesCreate(ex : IEnumerable[FsmState], en : IEnumerable[FsmState]) : IEnumerable[PathNode]
    //{
    //  def node        = ExitNodeCreate(ex); // create nodes for exit exit actions
    //  def entry_nodes = EntryNodeCreate(en); // create nodes for entry exit actions
    //  node.Concat(entry_nodes) // merge together
    //}

    TraverseTransitionPath(tran : StateTransition) : void
    {
        // initial и pseudo is local transitions by default
        //| Initial(AtLeastStaticTo = st, From = from)
        //| History(From = from, ToState = st)
        // fork transition
      def from = tran.From;
      def to = tran.AtLeastStaticTo;
      
      def (ex, en) = if (to != null)
      {
        if (tran.Local) FindPath(from, to, [], []) else FindPath(from.Super, to.Super, [from], [to]);
      } else ([], []);
      CreatePath(tran.From, ex, en, tran.action)
      
    }

    //DefExitPath(src : FsmState, dest : FsmState) : void
    //{
    //  def ex = FindPath(src, dest, Enumerable.Empty(), Enumerable.Empty())[0];
    //  AddNode(ExitNodeCreate(ex))
    //}

    DefPath(src : FsmState, dest : FsmState, local : bool = true, act : list[FsmAction]) : void
    {
      def (ex, en) = if (local) FindPath(src, dest, [], []) else FindPath(src.Super, dest.Super, [src], [dest]);
      CreatePath(src, ex, en, act)
    }

    GetPath(src : FsmState, dest : FsmState, local : bool = true, act : list[FsmAction]) : PathSequence
    {
      def (ex, en) = if (local) FindPath(src, dest, [], []) else FindPath(src.Super, dest.Super, [src], [dest]);
      GetPath(src, ex, en, act)
    }

    DefPath(src : FsmState, dest : FsmState) : void//, ex_node : IEnumerable[PathNode] = null) : void
    {
      //def ex = if (tr.Local) 
      def ex = FindPath(src, dest, [], [])[0];// else FindPath(src.Super, dest.Super, [src], [dest])[0];
      path.AddExit(GetExitPath(ex));
      //NodesCreate(ex, tr);
      //def node = if (ex_node != null) ex_node + node else node;
      //AddEntry(node)
    }

  }
}
