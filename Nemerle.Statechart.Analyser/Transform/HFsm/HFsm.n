using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of HFsm.
  /// </summary>
  [Record]
  public class HFsm
  {
    public name : string;
    public states : list[HState];
    
    public init_state : option[HState];
    
    public accept_state : option[HState];
    
    public super : HState;
    
    [Memoized]
    public all_states : list[HState]
    {
      get
      {
        states.SelectMany(_.all_states).NToList()
      }
    }
  
    [Memoized]
    public all_simple_states : list[HState]
    {
      get
      {
        states.SelectMany(_.all_simple_states).NToList()
      }
    }
    
    [Memoized]
    public active_super : list[HState]
    {
      get
      {
        if (super != null) super.active_super + [super] else []
      }
    }
  }

  [Record]
  public class HState
  {
    public name : string;
    public transitions : list[HTransition] {get;set;default []}
    public hierarchy : list[HFsm] {get;set;default []}
    public automaton : HFsm {get;set;}
    
    public entry : list[StateAction.Entry] {get;set;default []}
    public exit  : list[StateAction.Exit]  {get;set;default []}

    public do_activity : list[StateAction.Do] {get;set;default []}
    public deferred_events : list[StateEvent] {get;set;default []}
    
    public super : HState {get;set;}
    public history : TwoOption[HPseudoState.History] {get;set; default TwoOption.None()}
    
    public override GetHashCode() : int
    {
      name.GetHashCode()
    }
    
    //public entry : list[];
    public IsSimple : bool
    {
      get
      {
        hierarchy.IsEmpty()
      }
    }
    
    public IsConcurrent : bool
    {
      get
      {
        hierarchy.Length >= 2
      }
    }
    
    public IsComposite : bool
    {
      get
      {
        hierarchy.Length == 1
      }
    }
    
    public IsFinal : bool;
    
    public IsTop : bool
    {
      get
      {
        super == null
      }
    }
    
    [Memoized]
    public all_simple_states : list[HState]
    {
      get
      {
        if (hierarchy.IsEmpty()) this :: [] else
          hierarchy.SelectMany(x => x.states.SelectMany(x => x.all_simple_states)).NToList()
      }
    }

    [Memoized]
    public all_states : list[HState]
    {
      get
      {
        this :: hierarchy.SelectMany(x => x.states.SelectMany(x => x.all_states)).NToList()
      }
    }
    
    [Memoized]
    public active_config : list[HState]
    {
      get
      {
        active_super + [this]
      }
    }
    
    [Memoized]
    public active_super : list[HState]
    {
      get
      {
        if (super == null) [] else super :: super.active_super
      }
    }
    
    [Memoized]
    public region_pos : int
    {
      get
      {
        if (automaton != null && automaton.states != null) automaton.states.IndexOf(this) else 0
      }
    }
    
    [Memoized]
    public hierarchy_pos : int
    {
      get
      {
        if (automaton == null || automaton.super == null) 0 else
          automaton.super.hierarchy_pos + 1
      }
    }
    
    public override ToString() : string { if (name != null && !name.IsEmpty()) name else "Top" }
  }

  [Record]
  public class HTransition
  {
    public Source  : HTarget;
    public Trigger : StateEvent;
    public Guard   : GuardNode;
    public Actions : list[FsmAction];
    public Target  : HTarget;
    public Local   : bool;
    
    public IsCompletion : bool
    {
      get
      {
        Trigger.IsCompletion
      }
    }
    
    public override ToString() : string
    {
      if (IsCompletion) $"CompletionTransition$(Source)To$(Target)" else $"Transition$(Source)To$(Target)By$Trigger"
    }
  }

  [Record]
  public variant HTarget
  {
    | Nowhere
    | PseudoState { node : HPseudoState; }
    | State { state : HState; }
    
    public override ToString() : string
    {
      match (this)
      {
        | Nowhere           => ""
        | PseudoState(node) => node.ToString()
        | State(st)         => st.ToString()
      }
    }
  }

  [Record]
  public variant HJunctionNode : IGeneralTree[HJunctionNode]
  {
    | Node { nodes : list[HJunctionNode] {get;set;default []} }
    | Target { target : HTarget; } 
    
    public guard : GuardNode {get;set;}
    public actions : list[FsmAction] {get;set;}
    
    public state : HState;
    
    public Current : HJunctionNode 
    {
      get
      {
        this
      }
    }
    
    public ChildNodes : IEnumerable[IGeneralTree[HJunctionNode]] 
    {
      get
      {
        match (this)
        {
          | Node(nodes = n) => n
          | Target          => Enumerable.Empty()
        }
      }
    }
  }
  
  [Record]
  public variant HPseudoState
  {
    | History
      {
        default : option[HTransition];
        type    : HistoryType;
        //paths   : list[Transition] {get;set;default []}
      }
    | Junction
      {
        name : string;
        tree : HJunctionNode;
        type : JunctionType;
        decision_tree : DecisionNode {get;set;}
      }
    | Fork
      {
        states : list[HState];
      }
    | Join
      {
        name : string;
        states : list[HState];
        target : HTarget;
      }
    | Terminate
    
    
    public state : HState;
    
    public override ToString() : string
    {
      Name
    }
    
     public Name : string
    {
      get
      {
        def name = match (this)
        {
          | History(type = t) => 

              def type = match (t)
                          {
                            | HistoryType.Deep     => "Deep"
                            | Shallow              => "Shallow"
                            | None                 => ""
                          }

              if (state != null)
              {
                if (state.history.IsOne) $"$(state)History" else $"$(state)$(type)History"
              } else "History";
          | Join(name = n)           => $"Join$n"//$copy_name
          | Terminate => $"$(state)Terminate"
          | Fork(states = t)          => $<#Fork$(state)To..$(t;"_")#>
          //| Initial                   => $"$(state)Initial"
          | Junction(name = n)        => $"$state$n"
          //| EntryPoint(name = n)      => $"EntryPoint$n"
          //| ExitPoint(name = n)       => $"ExitPoint$n"
        }
        name// + copy_name
      }
    }
  }

}
