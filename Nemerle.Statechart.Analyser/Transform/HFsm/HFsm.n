using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of HFsm.
  /// </summary>
  [Record]
  public class HFsm
  {
    public name : string;
    public states : list[HState];
    
    public init_state : option[HState];
    
    public accept_state : option[HState];
    
    public super : HState;
    
    [Memoized]
    public all_states : list[HState]
    {
      get
      {
        states.SelectMany(_.all_states).NToList()
      }
    }
  
    [Memoized]
    public all_simple_states : list[HState]
    {
      get
      {
        states.SelectMany(_.all_simple_states).NToList()
      }
    }
    
    [Memoized]
    public active_super : list[HState]
    {
      get
      {
        if (super != null) super.active_super + [super] else []
      }
    }
  }

  [Record]
  public class HState : IEquatable[HState]
  {
    public name : string;
    public transitions : list[HTransition] {get;set;default []}
    public hierarchy : list[HFsm] {get;set;default []}
    public automaton : HFsm {get;set;}
    
    public entry : list[StateAction.Entry] {get;set;default []}
    public exit  : list[StateAction.Exit]  {get;set;default []}

    public do_activity : list[StateAction.Do] {get;set;default []}
    public deferred_events : list[StateEvent] {get;set;default []}
    
    public super : HState {get;set;}
    public history : TwoOption[HPseudoState.History] {get;set; default TwoOption.None()}
    
    public override GetHashCode() : int
    {
      name.GetHashCode()
    }
    
    public Equals(b : HState) : bool
    {
      this : object == b
    }
    
    //public entry : list[];
    public IsSimple : bool
    {
      get
      {
        hierarchy.IsEmpty()
      }
    }
    
    public IsConcurrent : bool
    {
      get
      {
        hierarchy.Length >= 2
      }
    }
    
    public IsComposite : bool
    {
      get
      {
        hierarchy.Length == 1
      }
    }
    
    public IsFinal : bool;
    
    public IsTop : bool
    {
      get
      {
        super == null
      }
    }
    
    [Memoized]
    public all_simple_states : list[HState]
    {
      get
      {
        if (hierarchy.IsEmpty()) this :: [] else
          hierarchy.SelectMany(x => x.states.SelectMany(x => x.all_simple_states)).NToList()
      }
    }

    [Memoized]
    public all_sub_states : list[HState]
    {
      get
      {
        hierarchy.SelectMany(x => x.states.SelectMany(x => x.all_states)).NToList()
      }
    }
    
    [Memoized]
    public all_states : list[HState]
    {
      get
      {
        this :: all_sub_states
      }
    }
    
    [Memoized]
    public active_config : list[HState]
    {
      get
      {
        active_super + [this]
      }
    }
    
    [Memoized]
    public active_super : list[HState]
    {
      get
      {
        ListUtils.UnfoldRev(super, x => if (x != null) Some(x, x.super) else None())
      }
    }
    
    //[Memoized]
    //public region_pos : int
    //{
    //  get
    //  {
    //    match (region)
    //    {
    //      | Some(r) => def sreg = r.hierarchy.First(x => x.all_states.ContainsRef(this));
    //                   r.hierarchy.IndexOf(sreg)
    //      | _       => 0
    //    }
    //  }
    //}
    
    [Memoized]
    public hierarchy_pos : int
    {
      get
      {
        if (automaton == null || automaton.super == null) 0 else
          automaton.super.hierarchy_pos + 1
      }
    }
    
    [Memoized]
    public regions : list[HState]
    {
      get
      {
        active_super.Rev().Filter(_.IsConcurrent)
      }
    }
    
    public region_pos(r : HState) : int
    {
      def sreg = r.hierarchy.First(x => x.all_states.ContainsRef(this));
      r.hierarchy.IndexOf(sreg)
    }
    
    public SameRegion(st : HState) : bool
    {
      def have = GetSameRegion(st);
      have.All(x => region_pos(x) == st.region_pos(x))
    }
    
    public GetSameRegion(st : HState) : IEnumerable[HState]
    {
      regions.Intersect(st.regions)
    }
    
    public override ToString() : string { if (name != null && !name.IsEmpty()) name else "Top" }
  }

  [Record]
  public class HTransition : Located
  {
    public Source  : HTarget;
    public Trigger : StateEvent;
    public Guard   : GuardNode;
    public Actions : list[FsmAction];
    public Target  : HTarget;
    public Kind    : TransitionKind;
    
    public Local   : bool
    {
      get
      {
        match (Kind)
        {
          | TransitionKind.Local
          | TransitionKind.Initial => true
          | _                      => false
        }
      }
    }
    
    [Memoized]
    public SourceState : HState
    {
      get
      {
        if (Source is HTarget.State(st)) st else null
      }
    }
    
    [Memoized]
    public TargetState : HState
    {
      get
      {
        if (Target is HTarget.State(st)) st else null
      }
    }
    
    public IsCompletion : bool
    {
      get
      {
        Trigger.IsCompletion
      }
    }
    
    public override ToString() : string
    {
      if (IsCompletion) $"CompletionTransition$(Source)To$(Target)" else $"Transition$(Source)To$(Target)By$Trigger"
    }
  }

  [Record]
  public variant HTarget : IEquatable[HTarget]
  {
    | Nowhere
    | PseudoState { node : HPseudoState; }
    | State { state : HState; }
    
    public override ToString() : string
    {
      match (this)
      {
        | Nowhere           => ""
        | PseudoState(node) => node.ToString()
        | State(st)         => st.ToString()
      }
    }
    
    public override GetHashCode() : int
    {
      ToString().GetHashCode()
    }
    
    public Equals(b : HTarget) : bool
    {
      match (this, b)
      {
        | (Nowhere, Nowhere)                          => true
        | (PseudoState(n), PseudoState(n2))           => n : object == n2
        | (State(st), State(st2))                     => st : object == st2
        | _                                           => false
      }
    }
  }

  [Record]
  public variant HJunctionNode : IGeneralTree[HJunctionNode]
  {
    | Node { nodes : list[HJunctionNode] {get;set;default []} }
    | Target { target : HTarget; } 
    
    public guard : GuardNode {get;set;}
    public actions : list[FsmAction] {get;set;}
    
    public state : HState;
    
    public Current : HJunctionNode 
    {
      get
      {
        this
      }
    }
    
    public ChildNodes : IEnumerable[IGeneralTree[HJunctionNode]] 
    {
      get
      {
        match (this)
        {
          | Node(nodes = n) => n
          | Target          => Enumerable.Empty()
        }
      }
    }
  }
  
  [Record]
  public variant HPseudoState
  {
    | History
      {
        default : option[HTransition];
        type    : HistoryType;
        //paths   : list[Transition] {get;set;default []}
      }
    | Junction
      {
        name : string;
        tree : HJunctionNode;
        type : JunctionType;
        decision_tree : DecisionNode {get;set;}
      }
    | Fork
      {
        states : list[HState];
      }
    | Join
      {
        name : string;
        states : list[HState];
        target : HTarget;
      }
    | Terminate
    
    
    public state : HState;
    
    public override ToString() : string
    {
      Name
    }
    
     public Name : string
    {
      get
      {
        def name = match (this)
        {
          | History(type = t) => 

              def type = match (t)
                          {
                            | HistoryType.Deep     => "Deep"
                            | Shallow              => "Shallow"
                            | None                 => ""
                          }

              if (state != null)
              {
                if (state.history.IsOne) $"$(state)History" else $"$(state)$(type)History"
              } else "History";
          | Join(name = n)           => $"Join$n"//$copy_name
          | Terminate => $"$(state)Terminate"
          | Fork(states = t)          => $<#Fork$(state)To..$(t;"_")#>
          //| Initial                   => $"$(state)Initial"
          | Junction(name = n)        => $"$state$n"
          //| EntryPoint(name = n)      => $"EntryPoint$n"
          //| ExitPoint(name = n)       => $"ExitPoint$n"
        }
        name// + copy_name
      }
    }
  }

}
