using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  /// <summary>
  /// Description of ConfigTraverser.
  /// </summary>
  class ConfigTraverser
  {

    solver : ConfigSolver = ConfigSolver();

    public transitions : list[HTransition];
    active_configs : List[ActiveStateConfig] = List();

    res_trans : List[Transition] = List();

    //[Memoized]
    public InitialTransition(init : HTransition) : Transition
    {
      def source = (init.Source :> HTarget.State).state.active_config;
      def source = ActiveStateConfig(null, [], source, [], [], null);
      def target = InitialConfiguration((init.Target :> HTarget.State).state);
      CreateTransitionPath(init, source, target) // create nodes for entry exit actions
        //Transition(null, StateEvent.Completion, GuardNode.Empty(), path, TargetDeterminator.State(InitialConfig))
    }

    public this(tran : list[HTransition])
    {
      transitions = tran;
    }

    public Transitions : IEnumerable[Transition]
    {
      get
      {
        res_trans
      }
    }

    public ActiveConfigs : list[ActiveStateConfig]
    {
      get
      {
        active_configs.NToList()
      }
    }

    public CreateConfig(seq : list[Configuration]) : list[ActiveStateConfig]
    {
      seq.Map(x => CreateConfig(x.States))
    }

    public CreateConfig(seq : IEnumerable[HState]) : ActiveStateConfig
    {
      match (active_configs.Find(x => x.states.Equals(seq)))
      {
        | null => def nseq = seq.Where(_.IsSimple);
                  def name = $<#..$(nseq;"")#>;
                  //def trans = seq.SelectMany(x => x.transitions).NToList();
                  def conf = ActiveStateConfig(name, [], seq.NToList(), [], [], null);
                  active_configs.Add(conf);
                  conf
        | c  => c
      }

    }

    public static GetInitialConfiguration(st : HState) : list[HState]
    {
      def solver = ConfigSolver();
      solver.Init(Config.Unknown(st), x => x.init_state :: []);
      solver.Solve().Head.States;
    }




    //CreateTran(tr : HTransition, source : ActiveStateConfig, target : ActiveStateConfig) : void
    //{
    //  def tran = CreateTransitionPath(tr, source, if (target != null) TargetDeterminator.State(target) else TargetDeterminator.NoStateChange());
    //  res_trans.Add(tran);
    //}

    //CreateTran(tr : HTransition, source : IEnumerable[ActiveStateConfig], target : ActiveStateConfig) : void
    //{
    //  source.Iter(x => CreateTran(tr, x, target))
    //}

    //TraverseGroupTran(evt : StateEvent, conf : ActiveStateConfig) : Transition
    //{
    //  def states = conf.states;
    //  def source_states = states.Map(x => (x, x.transitions.First(x => x.Trigger == evt)));
    //  def (targets, _other) = source_states.Partition((_, t) => t.Target is HTarget.State);
    //  def targets = targets.Map((x, t) => (x, t, (t.Target :> HTarget.State).state));
    //  def target = targets.Map((_, _, x) => x);
    //  def target = InitialConfiguration(target);

    //  def paths = targets.Map((x, t, _) => GetPath(x.active_config, target.states, t.Local));
    //  def exit = paths.SelectMany((x, _) => x).Distinct();
    //  def entry = paths.SelectMany((_, x) => x).Distinct();
    //  def actions = targets.SelectMany((_, t, _) => t.Actions);
    //  def path = CreatePath(exit, actions, entry);

    //  // TODO: групповые переходы с гуардами
    //  def tran = Transition(conf, evt, GuardNode.Empty(), tran.Path, TargetDeterminator.State(target));
    //}

    AddTran(tr : Transition) : void
    {
      res_trans.Add(tr)
    }

    public TraverseTran(tr : HTransition) : list[Transition]
    {
      def path = TransitionPath(tr, solver, this);
      path.Traverse();
      //def src_conf = SourceConfigs(tr);
      //match (tr.Target)
      //{
      //  | HTarget.State(st)       => def target = InitialConfiguration(st);
      //                               src_conf.Map(CreateTransitionPath(tr, _, target))
      //  | HTarget.PseudoState(st) => src_conf.Map(TraversePseudo(tr, _, st))
      //  | HTarget.Nowhere         => src_conf.Map(CreateTransitionPath(tr, _, null))
      //}

    }

    Traverse(tr : HTransition) : void
    {
      def res = TraverseTran(tr);
      res_trans.AddRange(res)
    }

    public Start() : void
    {
      foreach (tr in transitions) Traverse(tr);
      def groups = res_trans.GroupBy(x => x.Source);
      foreach (gr in groups)
      {
        gr.Key.transitions = gr.NToList()
      }
    }
  }
}
