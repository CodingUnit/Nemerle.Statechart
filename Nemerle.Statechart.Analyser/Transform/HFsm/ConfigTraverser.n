using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{

  /// <summary>
  /// Description of ConfigTraverser.
  /// </summary>
  public class ConfigTraverser
  {

    solver : ConfigSolver = ConfigSolver();

    public transitions : list[HTransition];
    active_configs : List[ActiveStateConfig] = List();

    res_trans : List[Transition] = List();

    //[Memoized]
    public InitialTransition(init : HTransition) : Transition
    {
      def source = (init.Source :> HTarget.State).state.active_config;
      def source = ActiveStateConfig(null, [], source, [], [], null);
      def target = InitialConfiguration((init.Target :> HTarget.State).state);
      CreateTransitionPath(init, source, target) // create nodes for entry exit actions
        //Transition(null, StateEvent.Completion, GuardNode.Empty(), path, TargetDeterminator.State(InitialConfig))
    }

    public this(tran : list[HTransition])
    {
      transitions = tran;
    }

    public Transitions : IEnumerable[Transition]
    {
      get
      {
        res_trans
      }
    }

    public ActiveConfigs : list[ActiveStateConfig]
    {
      get
      {
        active_configs.NToList()
      }
    }

    Solve(conf : Config, selector : HFsm -> list[HState]) : list[ActiveStateConfig]
    {
      solver.Init(conf, selector);
      def conf = solver.Solve();
      CreateConfig(conf)
    }

    CreateConfig(seq : list[Configuration]) : list[ActiveStateConfig]
    {
      seq.Map(x => CreateConfig(x.States))
    }

    public CreateConfig(seq : IEnumerable[HState]) : ActiveStateConfig
    {
      match (active_configs.Find(x => x.states.Equals(seq)))
      {
        | null => def nseq = seq.Where(_.IsSimple);
                  def name = $<#..$(nseq;"")#>;
                  //def trans = seq.SelectMany(x => x.transitions).NToList();
                  def conf = ActiveStateConfig(name, [], seq.NToList(), [], [], null);
                  active_configs.Add(conf);
                  conf
        | c  => c
      }

    }

    public static GetInitialConfiguration(st : HState) : list[HState]
    {
      def solver = ConfigSolver();
      solver.Init(Config.Unknown(st), x => x.init_state :: []);
      solver.Solve().Head.States;
    }

    InitialConfiguration(st : HState) : ActiveStateConfig
    {
      def conf = Solve(Config.Unknown(st), x => x.init_state :: []);
      conf.Head
    }

    InitialConfiguration(st : list[HState]) : ActiveStateConfig
    {
      def conf = Solve(Config.Concurrent(st), x => x.init_state :: []);
      conf.Head
    }


    public static FindPath(src_st : list[HState],
                          dest_st : list[HState],
                          exit : list[HState] = null,
                          entry : list[HState] = null) : list[HState] * list[HState]
    {
      def src = src_st ?? [];
      def dest = dest_st ?? [];
      def (ex, en) = src.RemoveDupFirst(dest, (x, y) => x == y : object);
      def exit  = exit ?? [];
      def entry = entry ?? [];
      (exit.Rev() + ex, en + entry)
    }

    static GetEntryNode(st : HState) : IEnumerable[PathNode]
    {
      | HState(do_activity = do_act, entry = en) =>
              def act = en.Map(_.action);
              def en = act.Map(PathNode.Entry(st.name, _));
              def do_act = do_act.Select(PathNode.RunDoActivity(st.name, _));
              en.Concat(do_act)
    }

    static GetEntryPath(nodes : IEnumerable[HState]) : list[TranPath]
    {
      $[TranPath(st.name, GetEntryNode(st).NToList(), PathKind.Entry), st in nodes]
    }

    static GetActionPath(act : IEnumerable[FsmAction]) : list[TranPath]
    {
      $[TranPath(null, PathNode.Action(null, a) :: [], PathKind.Action), a in act]
    }

    static GetExitNode(st : HState) : IEnumerable[PathNode]
    {
      def do_act = st.do_activity.Map(x => PathNode.StopDoActivity(st.name, x));
      def nodes = if (st.history.HasValue) PathNode.SaveHistory(st.name, st.history.Value) :: do_act; else do_act;
      def act = st.exit.Map(_.action);
      def exit = act.Select(PathNode.Exit(st.name, _));
      nodes.Concat(exit)
    }

    public static GetExitPath(nodes : IEnumerable[HState]) : list[TranPath]
    {
      $[TranPath(st.name, GetExitNode(st).NToList(), PathKind.Exit), st in nodes]
    }

    CreatePath(tran : HTransition, source : HState, target : HState) : PathSequence
    {
      CreatePath(tran, source.active_config, target.active_config)
    }

    CreatePath(tran : HTransition, source : ActiveStateConfig, target : ActiveStateConfig) : PathSequence
    {
      if (target == null) CreatePath(tran, [], []) else CreatePath(tran, source.states, target.states)
    }

    CreatePath(exit : IEnumerable[HState], act : IEnumerable[FsmAction], entry : IEnumerable[HState]) : PathSequence
    {
      def exit = GetExitPath(exit); // create nodes for exit exit actions
      def act = GetActionPath(act); // add transition action
      def entry = GetEntryPath(entry); // create nodes for entry exit actions
      def path = PathSequence();
      path.AddExit(exit);
      path.AddAction(act);
      path.AddEntry(entry);
      path
    }

    GetPath(source : list[HState], target : list[HState], local : bool) : list[HState] * list[HState]
    {
      if (local) FindPath(source, target) else
      {
        def (source_last, source) = source.SplitLast();
        def (target_last, target) = target.SplitLast();
        FindPath(source, target, [source_last], [target_last])
      }
    }

    CreatePath(tran : HTransition, source : list[HState], target : list[HState]) : PathSequence
    {

      def (exit, entry) = if (source.IsEmpty() && target.IsEmpty()) ([], []) else 
                           {
                             def st = (tran.Source :> HTarget.State).state;
                             def targ = st.active_config;
                             def path = FindPath(source, targ)[0]; // exit to source transition vertex, but no include
                             def (exit, entry) = GetPath(targ, target, tran.Local); // exit according local or external transition rule from source and enter the target
                             (path + exit, entry) // exit to source vertex + source exit node and entry nodes to target
                           }
      CreatePath(exit, tran.Actions, entry) // create path for transition
    }

    CreateTransitionPath(tran : HTransition, src_conf : ActiveStateConfig, target : ActiveStateConfig) : Transition
    {
      def path = CreatePath(tran, src_conf, target);
      def target = if (target != null) CheckCompletion(target) else TargetDeterminator.NoStateChange();
      Transition(src_conf, tran.Trigger, tran.Guard, path, target)
    }

    CheckCompletion(act : ActiveStateConfig) : TargetDeterminator
    {
      def simple = act.simple_states;
      def w_completion = simple.Filter(x => x.transitions.Exists(_.IsCompletion));
      def w_do = w_completion.Filter(x => !x.do_activity.IsEmpty());
      foreach (st in w_do)
      {
        st.do_activity.Iter(x => x.need_completion = true);
      }
      if (w_completion.IsEmpty()) TargetDeterminator.State(act) else TargetDeterminator.Completion(act)
    }

    SourceConfigs(tr : HTransition, st : HState) : list[ActiveStateConfig]
    {
      match (st.hierarchy)
      {
              // simple state
        | []           => Solve(Config.Simple(st), _.states)
        | head :: []   => // sequential composite state
            if (!tr.Local && tr.Trigger.IsCompletion) // completion
            {
              def final = head.accept_state.Value;
              Solve(Config.Simple(final), _.states)
            } else
            {
              Solve(Config.Composite(st), _.states)
            }
        | _           => Solve(Config.Composite(st), _.states) // concurrent state
      }
    }

    SourceConfigs(tr : HTransition) : list[ActiveStateConfig]
    {
      match (tr.Source)
      {
        | HTarget.State(st) => SourceConfigs(tr, st)
        | HTarget.PseudoState(p) =>
            match (p)
            {
              | HPseudoState.Join => []
              | _                 => []
            }
        | _ => []
      }
    }

    CreateTran(tr : HTransition, source : ActiveStateConfig, target : ActiveStateConfig) : void
    {
      def tran = CreateTransitionPath(tr, source, target);
      res_trans.Add(tran);
    }

    CreateTran(tr : HTransition, source : IEnumerable[ActiveStateConfig], target : ActiveStateConfig) : void
    {
      source.Iter(x => CreateTran(tr, x, target))
    }

    //TraverseGroupTran(evt : StateEvent, conf : ActiveStateConfig) : Transition
    //{
    //  def states = conf.states;
    //  def source_states = states.Map(x => (x, x.transitions.First(x => x.Trigger == evt)));
    //  def (targets, _other) = source_states.Partition((_, t) => t.Target is HTarget.State);
    //  def targets = targets.Map((x, t) => (x, t, (t.Target :> HTarget.State).state));
    //  def target = targets.Map((_, _, x) => x);
    //  def target = InitialConfiguration(target);

    //  def paths = targets.Map((x, t, _) => GetPath(x.active_config, target.states, t.Local));
    //  def exit = paths.SelectMany((x, _) => x).Distinct();
    //  def entry = paths.SelectMany((_, x) => x).Distinct();
    //  def actions = targets.SelectMany((_, t, _) => t.Actions);
    //  def path = CreatePath(exit, actions, entry);

    //  // TODO: групповые переходы с гуардами
    //  def tran = Transition(conf, evt, GuardNode.Empty(), tran.Path, TargetDeterminator.State(target));
    //}

    AddTran(tr : Transition) : void
    {
      res_trans.Add(tr)
    }

    TraversePseudo(tran : HTransition, source : ActiveStateConfig, pseudo : HPseudoState) : Transition
    {
      match (pseudo)
      {
        | HPseudoState.History as h  => def st = pseudo.state;
                                        def path = CreatePath(tran, source.states, st.active_config);
                                        Transition(source, tran.Trigger, tran.Guard, path, TargetDeterminator.History(h))
                                        
        | _                          => null
      }
    }

    public TraverseTran(tr : HTransition) : list[Transition]
    {
      def src_conf = SourceConfigs(tr);
      //def (group, other) = src_conf.Partition(x => x.states.Count(x => x.transitions.Exists(x => x.Trigger == tr.Trigger)) >= 1);
      //group.Iter(x => AddTran(TraverseGroupTran(tr.Trigger, x)));
      match (tr.Target)
      {
        | HTarget.State(st)       => def target = InitialConfiguration(st);
                                     src_conf.Map(CreateTransitionPath(tr, _, target))
        | HTarget.PseudoState(st) => src_conf.Map(TraversePseudo(tr, _, st))
        | HTarget.Nowhere         => src_conf.Map(CreateTransitionPath(tr, _, null))
      }
        //def target = TargetDeterminator.State(dest_conf);

    }

    Traverse(tr : HTransition) : void
    {
      def res = TraverseTran(tr);
      res_trans.AddRange(res)
    }

    public Start() : void
    {
      foreach (tr in transitions) Traverse(tr);
      def groups = res_trans.GroupBy(x => x.Source);
      foreach (gr in groups)
      {
        gr.Key.transitions = gr.NToList()
      }
    }
  }
}
