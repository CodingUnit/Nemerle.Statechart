using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{


  /// <summary>
  /// Description of ActiveState.
  /// </summary>
  [Record]
  public class ActiveStateConfig : IEquatable[ActiveStateConfig]
  {
    [Memoized]
    public name : string
    {
      get
      {
        $<#..$(simple_states;"")#>
      }
    }
    
    public transitions : list[Transition] {get;set;default []}

    public states : list[HState]; // states in it resides
    //public state : FsmState {get;set;}

    [Memoized]
    public deffered_events : list[StateEvent]
    {
      get
      {
        states.SelectMany(_.deferred_events).NToList()
      }
    }

    public IsThis(st : IEnumerable[HState]) : bool
    {
      simple_states.All(st.Contains)
    }

    public HistoryPath : list[HistoryPath] {get;set;default []}

    public History : list[PseudoState.History] {get;set;default []}

    public Id : IdType {get;set;}

    [Memoized]
    public simple_states : list[HState]
    {
      get
      {
        states.Filter(_.IsSimple)
      }
    }

    public Equals(b : ActiveStateConfig) : bool
    {
      IsThis(b.simple_states)
    }
    
    
    public override GetHashCode() : int
    {
      name.GetHashCode()
    }
    
    public override ToString() : string { name }
  }

  [Record]
  public class Transition : IEquatable[Transition]
  {
    public Source  : ActiveStateConfig;
    
    /// <summary>
    /// source of transition arrow
    /// </summary>
    public OriginateFrom : HState;
    
    
    public Trigger : StateEvent;
    public Guard   : GuardNode;
    //public Actions : list[FsmAction];
    public Path    : PathSequence;
    public Target  : TargetDeterminator;

    public DecisionTree : DecisionNode;
    
    public Priority : int {get;set;default 0}
    
    [Memoized]
    public Name : string
    {
      get
      {
          //| (Internal, None)                         => $"InternalTransition$(From)By$FriendlyTriggerName"
          //| (Local, _) when (internal_kind == TransitionRunKind.History) => $"HistoryFrom$(From)To$ToState"
        def tar = Target.ToString();
        if (tar.IsEmpty()) $"Transition$(Source)By$Trigger" else $"Transition$(Source)To$(Target)By$Trigger"
          //| (_, Some(PseudoStateNode.Initial))       => $"InitialTransitionFrom$(From)To$To"
          //| (_, Some(PseudoStateNode.History as h))  => 
          //    match (Destination)
          //    {
          //      | History(state = st) => $"DefaultTransition$(h)To$st"
          //      | _                   => $"DefaultTransition$(h)To$ActualTo"
          //    }
          //| (_, Some(PseudoStateNode.ExitPoint as e))     
          //| (_, Some(PseudoStateNode.EntryPoint as e))    => $"TransitionFrom$(e)To$(To)"
          //| _                                                         => throw InvalidOperationException("invalid transition name")
      }
    }

    public Equals(b : Transition) : bool
    {
      Name == b.Name
    }
    
    public override GetHashCode() : int
    {
      Name.GetHashCode()
    }
    
    public override ToString() : string { Name }

  }

  [Record]
  public variant PseudoState
  {
    | History 
      {
        default : option[Transition];
        type    : HistoryType;
        state   : HState;

        [Memoized]
        Name : string
        {
          get
          {
            def type = match (type)
                        {
                          | HistoryType.Deep     => "Deep"
                          | Shallow              => "Shallow"
                          | None                 => ""
                        }

            if (state != null)
            {
              if (state.history.IsOne) $"$(state)History" else $"$(state)$(type)History"
            } else "History";
          }
        }

        public override ToString() : string
        {
          Name
        }
      }
  }

  public variant TargetDeterminator
  {
    | State { state : ActiveStateConfig }
    | History { state : HPseudoState.History; }
    | NoStateChange
    | Terminate// { node : HPseudoState.Terminate; }
    | Completion { state : ActiveStateConfig; }
    | Junction { node : DecisionNode; name : string;}

    public override ToString() : string
    {
      match (this)
      {
        | State(st)       => $"$st"
        | History(h)      => $"$h"
        | Terminate       => "Terminate"
        | Junction(_, n)  => $"$n"
        | Completion(st)  => $"$(st)Completion"
        | _               => ""
      }
    }
  }

  //[Record]
  //public class Transition
  //{
  //  public trigger : StateEvent;

  //  public guard : GuardNode;

  //  public path : PathSequence;

  //  public end : TransitionEnd;

  //}

  class ActiveConfigProcessor
  {
    
    active_configs : List[ActiveStateConfig] = List();

    public ActiveConfigs : IEnumerable[ActiveStateConfig]
    {
      get
      {
        active_configs
      }
    }
    
    public CreateConfig(seq : list[Configuration]) : list[ActiveStateConfig]
    {
      seq.Map(x => CreateConfig(x.States))
    }

    public CreateConfig(seq : IEnumerable[HState]) : ActiveStateConfig
    {
      match (active_configs.Find(x => x.IsThis(seq)))
      {
        | null => def conf = ActiveStateConfig([], seq.NToList(), [], [], null);
                  active_configs.Add(conf);
                  conf
        | c  => c
      }

    }

  }
}
