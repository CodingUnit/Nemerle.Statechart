using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  /// <summary>
  /// Description of Transform.
  /// </summary>
  public partial class FsmAnalyser
  {

    finite_automatas : list[HFsm] {get;set;default []}

    transitions : list[HTransition] {get;set;default []}

    convert_FsmStateToHState(st : FsmState) : HState
    {
      def tran = st.transitions.Filter(x => x.To.TargetStates.All(y => y.Super == x.From.Super));
      def tran = tran.Map(x => x.ToHTransition);
      def newst = st.ToHState;
      newst.history = st.history.Map(x => x.ToHPseudo :> HPseudoState.History);
      newst.transitions = tran;
      newst
    }

    mutable finite_number : int;
    
    CreateFiniteAutomata() : void
    {

      //def connected_transitions(gr, initial)
      //{
      //  def tr = gr.SelectMany(_.transitions).Append(initial); // transitions in group
      //  def to = tr.Select(x => x.To); // to target
      //  def targets = to.SelectMany(_.TargetStates); // target states
      //  gr//.Filter(targets.Contains) // only those states transition targets connects at this level
      //}

      def create_automata(st, a)
      {
        //st.ToHState.hierarchy = ;
        def sub = st.sub_states;
        def super = convert_FsmStateToHState(st);
        if (st.IsConcurrent) a else
        match (sub)
        {
          | []  => a
          | sub =>
                  def group = sub;//connected_transitions(sub, st.initial_tran);
                  def states = group.Map(convert_FsmStateToHState);
                  
                  def init = st.InitialState.Map(convert_FsmStateToHState);
                  def accept = sub.Find(_.IsFinal).Map(convert_FsmStateToHState);
                  def name = $"A$finite_number";
                  finite_number++;
                  def fsm = HFsm(name, states, init, accept, super);
                  foreach (st in states)
                  {
                    st.automaton = fsm;
                    //st.super = super;
                  }
                  fsm :: a
        }
      }

      def fsms = States.FoldBack([], create_automata);
      foreach (st in States)
      {
        if (st.IsComposite)
        {
          if (st.IsConcurrent)
          {
            def sreg = st.sub_states;
            def fsms = sreg.Map(x => x.sub_states.First(x => x.ToHState.automaton != null).ToHState.automaton);
            st.ToHState.hierarchy = fsms;
          } else
          {
            def fsm = st.sub_states.First(x => x.ToHState.automaton != null).ToHState.automaton;
            st.ToHState.hierarchy = [fsm];
          }
        } else
        {
          st.ToHState.hierarchy = [];
        }
      }
      finite_automatas = fsms;
      transitions = StateTransitions.MapToList(_.ToHTransition);
      CreateDecisionTree();
    }

    CreateDecisionTree() : void
    {
      foreach (tr in transitions)
      {
        match (tr.Target)
        {
          | HTarget.PseudoState(HPseudoState.Junction as j) => DecisionNode.create_decision_tree(j, tr)
          | _                                               => ()
        }
      }
    }
    
    TransformFsm() : void
    {
      CreateFiniteAutomata();
      CreateActiveConfigurations();
      ResolveConflicts();
    }
    
    ResolveConflicts() : void
    {
      def is_sub_state_of(x, y)
      {
        y.all_sub_states.ContainsRef(x)
      }
      
      def compare(x, y)
      {
        def x = x.OriginateFrom;
        def y = y.OriginateFrom;
        if (is_sub_state_of(x, y)) -1 else
          if (is_sub_state_of(y, x)) 1 else 0
      }
      
      def guard_compare(x, y)
      {
        match (x.Guard, y.Guard)
        {
          | (GuardNode.Empty, GuardNode.Empty) => 0
          | (GuardNode.Empty, _)               => -1
          | (_, GuardNode.Empty)               => 1
          | _                                  => 0
        }
      }
      
      def not_originate_from_other_configs(last, tr)
      {
        def source_configs = TransitionPath.GetSourceConfigs(tr, ActiveConfigProc);
        def last = last.Source;
        match (source_configs)
        {
          | [one] => one : object == last
          | _     => false
        }
      }
      
      foreach (conf in ActiveStates)
      {
        def by_trigger = conf.transitions.GroupBy(_.Trigger);
        foreach (ctrig when ctrig.IsMoreThanOne() in by_trigger)
        {
          //def sort_by_priority = ctrig.NToList().Sort(compare);
          def grouped_equal_prio = ctrig.NToList().Group(compare);
          grouped_equal_prio.IterI((i, x) => x.Iter(x => x.Priority = i));
          def (conflict, other) = grouped_equal_prio.Partition(x => x.IsMoreThanOne());
          
          foreach (conf in conflict)
          {
            def dups = conf.Duplicates((x, y) => x.Guard.CompareTo(y.Guard));
            when (!dups.IsEmpty()) AddError(FsmError.DuplicateTransition(dups.Map(_ : object)));
          }
          
          def conflict = conflict.Map(x => x.RemoveDuplicatesSort((x, y) => x.Guard.CompareTo(y.Guard)));
          def trans = conflict + other;
          def trans = trans.Map(x => x.Sort(guard_compare));
          def trans = trans.Flatten();
          def (last, other) = trans.SplitFind(x => x.Guard.IsEmpty);
          def last = last.Last();
          def not_used = other.Filter(x => not_originate_from_other_configs(last, x));
          not_used.Iter(x => AddWarning(FsmWarning.TransitionOverriden(x, last)));
          when (!other.IsEmpty()) conf.transitions = conf.transitions.Exclude(other);
        }
      }
    }
  }
}
