using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using CommonLib.Macros;

namespace Nemerle.Statechart
{
  using CommonLib.Macros.LensUtils;
  /// <summary>
  /// Description of Transform.
  /// </summary>
  partial class FsmAnalyser
  {

    finite_automatas : list[HFsm] {get;set;default []}

    transitions : list[HTransition] {get;set;default []}

    convert_FsmStateToHState(st : FsmState) : HState
    {
      def tran = st.transitions;//.Filter(x => x.To.TargetStates.All(y => y.Super == x.From.Super));
      def tran = tran.Map(x => x.ToHTransition);
      def newst = st.ToHState;
      newst.transitions = tran;
      newst
    }

    mutable finite_number : int;
    
    CreateFiniteAutomata() : void
    {
      def create_automata(st, a)
      {
        def sub = st.sub_states;
        match (st.type)
        {
          | StateType.Region    => a
          | StateType.SubRegion with super = convert_FsmStateToHState(st.Super)
          | _ with super = convert_FsmStateToHState(st) => 
            match (sub)
            {
              | []  => a
              | sub =>
                      def group = sub;
                      def states = group.Map(convert_FsmStateToHState);
                  
                      def init = st.InitialState.Map(convert_FsmStateToHState);
                      def history = st.history.Map(x => x.ToHPseudo :> HPseudoState.History);
                      def accept = sub.Find(_.IsFinal).Map(convert_FsmStateToHState);
                      def name = $"A$finite_number";
                      finite_number++;
                      def fsm = HFsm(name, states, init, accept, super, history);
                      foreach (st in states)
                      {
                        st.automaton = fsm;
                        st.super = super;
                      }
                      fsm :: a
                    }
            }
      }

      
      def fsms = States.FoldRightO([], create_automata);
      foreach (st in States)
      {
        match (st.type)
        {
          | StateType.Region      => def sreg = st.sub_states;
                                     def fsms = sreg.Map(x => x.sub_states.First(x => x.ToHState.automaton != null).ToHState.automaton);
                                     st.ToHState.hierarchy = fsms;
          | StateType.SubRegion   => ()
          | _ when st.IsComposite => 
                                     def fsm = st.sub_states.First(x => x.ToHState.automaton != null).ToHState.automaton;
                                     st.ToHState.hierarchy = [fsm];
          | _                     => st.ToHState.hierarchy = [];
        }
      }
      finite_automatas = fsms;
      def tran = StateTransitions.MapToList(_.ToHTransition);
      def other = fsms.SelectMany(x => x.states.SelectMany(x => x.transitions)).NToList();
      def tran = tran + other;
      transitions = tran.Distinct().NToList();
      
      
      def process(tr)
      {
        | HTransition(Source = HTarget.PseudoState(HPseudoState.Join))  =>
        
          def lens = HTransition.Source_lens >> HTarget.PseudoState.node_lens >> HPseudoState.Join.transition_lens;
          //if (x.Source is  (x, j) :: a
          def tr = lens.Set(tr, tr);
          def lens = HTransition.Source_lens >> HTarget.PseudoState.node_lens;
          def j = lens.Get(tr).Value :> HPseudoState.Join;
          //j.transition = tr;
          foreach (st in j.states)
          {
            st.join_transitions = j :: st.join_transitions;
          }
          tr
          
        | _ => tr
      }

      transitions = transitions.Map(process);
      
      CreateDecisionTree();
    }

    CreateDecisionTree() : void
    {
      def mapping(tr)
      {
          def lens = HTransition.Target_lens >> HTarget.PseudoState.node_lens;
          def tr = lens.DownCast().Update(tr, DecisionNode.create_decision_tree(_, tr));
                                                               
          def create(x)
          {
            def tree = HJunctionNode.Target.target_lens.ToBasePartial() >> HTarget.PseudoState.node_lens;
            tree.DownCast().Update(x, DecisionNode.create_decision_tree(_, tr));
          }
                                                               
          def tree = HTransition.Target_lens >> HTarget.PseudoState.node_lens >> HPseudoState.Junction.tree_lens;
          tree.Update(tr, _.Reduce(create))
                                                               //foreach (HJunctionNode.Target(HTarget.PseudoState(HPseudoState.Junction as j)) in j.tree.GetBreadthFirstEnumerable())
                                                               //{
                                                                 
                                                               //}
       }
        
       transitions = transitions.Map(mapping)
    }
    
    TransformFsm() : void
    {
      CreateFiniteAutomata();
      CreateActiveConfigurations();
    }
    
  }
}
