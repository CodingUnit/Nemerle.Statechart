using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  [Record]
  class TraversePath
  {
    public Source : ActiveStateConfig;
    public Target : ActiveStateConfig;
    public tran_path   : TransitionPath;
    
    public this(source : ActiveStateConfig, target : ActiveStateConfig, tran_path : TransitionPath)
    {
      Source = source;
      Target = target;
      this.tran_path = tran_path;
    }
    
    Local : bool
    {
      get
      {
        tran_path.transition.Local
      }
    }
    
    [Memoized]
    SourceConfig : list[HState]
    {
      get
      {
        match (tran_source)
        {
          | HTarget.PseudoState(p) => p.state.active_config
          | State                  => Source.states
          | _                      => []
        }
      }
    }

    [Memoized]
    TargetConfig : list[HState]
    {
      get
      {
        match (tran_target)
        {
          | HTarget.PseudoState(p) => p.state.active_config
          | State                  => Target.states
          | _                      => []
        }
      }
    }
    
    [Memoized]
    MainSource : HState
    {
      get
      {
        match (tran_source)
        {
          | HTarget.PseudoState(p) => p.state
          | State(st)              => st
          | _                      => null
        }
      }
    }
    
    [Memoized]
    MainTarget : HState
    {
      get
      {
        match (tran_target)
        {
          | HTarget.PseudoState(null) => null
          | HTarget.PseudoState(p)    => p.state
          | State(st)                 => st
          | _                         => null
        }
      }
    }
    
    path : PathSequence = PathSequence();
    
    IsInternal : bool
    {
      get
      {
        transition.Target is HTarget.Nowhere
      }
    }
    
    transition : HTransition
    {
      get
      {
        tran_path.transition
      }
    }
    
    tran_source : HTarget
    {
      get
      {
        transition.Source
      }
    }
    
    tran_target : HTarget
    {
      get
      {
        transition.Target
      }
    }
    
    [Memoized]
    LcaConfig : list[HState]
    {
      get
      {
        if (Lca != null) Lca.active_config else []
      }
    }
    
    [Memoized]
    Lca : HState
    {
      get
      {
        if (Local) MainSource.active_config.DupLast(MainTarget.active_config, (x, y) => x == y : object) else
          MainSource.active_super.DupLast(MainTarget.active_super, (x, y) => x == y : object)// TranTargetState
      }
    }
    
    public static FindPath(src : list[HState],
                           dest : list[HState]) : list[HState] * list[HState]
    {
      def (ex, en) = src.RemoveDupFirst(dest, (x, y) => x == y : object);
      (ex.Rev(), en)
    }

    static GetEntryNode(st : HState) : IEnumerable[PathNode]
    {
      | HState(do_activity = do_act, entry = en) =>
              def act = en.Map(_.action);
              def en = act.Map(PathNode.Entry(st, _));
              def do_act = do_act.Select(PathNode.RunDoActivity(st, _));
              en.Concat(do_act)
    }

    static GetEntryPath(nodes : IEnumerable[HState]) : list[TranPath]
    {
      $[TranPath(st, GetEntryNode(st).NToList(), PathKind.Entry), st in nodes]
    }

    static GetActionPath(act : IEnumerable[FsmAction]) : list[TranPath]
    {
      $[TranPath(null, PathNode.Action(null, a) :: [], PathKind.Action), a in act]
    }

    static GetExitNode(st : HState) : IEnumerable[PathNode]
    {
      def do_act = st.do_activity.Map(x => PathNode.StopDoActivity(st, x));
      def nodes = if (st.history.HasValue) PathNode.SaveHistory(st, st.history.Value) :: do_act; else do_act;
      def act = st.exit.Map(_.action);
      def exit = act.Select(PathNode.Exit(st, _));
      nodes.Concat(exit)
    }

    public static GetExitPath(nodes : IEnumerable[HState]) : list[TranPath]
    {
      $[TranPath(st, GetExitNode(st).NToList(), PathKind.Exit), st in nodes]
    }

    static GetPath(source : list[HState], target : list[HState]) : list[HState] * list[HState]
    {
      FindPath(source, target)
    }

    static GetPath(source : list[HState], target : list[HState], act : list[FsmAction]) : PathSequence
    {
      def (ex, en) = GetPath(source, target);
      def exit = GetExitPath(ex);
      def entry = GetEntryPath(en);
      def act = GetActionPath(act);
      def path = PathSequence();
      path.AddEntry(entry);
      path.AddExit(exit);
      path.AddAction(act);
      path
    }
    
    AddPath(source : list[HState], target : list[HState], act : list[FsmAction]) : void
    {
      def (ex, en) = GetPath(source, target);
      def exit = GetExitPath(ex);
      def entry = GetEntryPath(en);
      def act = GetActionPath(act);
      path.AddEntry(entry);
      path.AddExit(exit);
      path.AddAction(act);
    }
        
    CheckCompletion(act : ActiveStateConfig) : TargetDeterminator
    {
      def simple = act.simple_states;
      // TODO: final states in each region
      match (simple.Find(_.IsFinal))
      {
        | Some(final)  => match (final.active_super.SelectMany(x => x.transitions.Filter(x => x.IsCompletion)))
                          {
                            | []     => TargetDeterminator.State(act)
                            | _      => TargetDeterminator.Completion(act)
                          }
        | _            => def w_completion = simple.Filter(x => x.transitions.Exists(_.IsCompletion));
                          def w_do = w_completion.Filter(x => !x.do_activity.IsEmpty());
                          foreach (st in w_do)
                          {
                            st.do_activity.Iter(x => x.need_completion = true);
                          }
                          if (w_completion.IsEmpty()) TargetDeterminator.State(act) else TargetDeterminator.Completion(act)
      }
    }

    AddExitPath(src : list[HState]) : void
    {
      def nodes = GetExitPath(src);
      path.AddExit(nodes)
    }
    
    //AddExit(st : HState) : void
    //{
    //  def nodes = GetExitPath(st :: []);
    //  path.AddExit(nodes)
    //}
    
    //AddEntry(st : HState) : void
    //{
    //  def nodes = GetEntryPath(st :: []);
    //  path.AddEntry(nodes)
    //}
    
    AddEntryPath(src : list[HState]) : void
    {
      def nodes = GetEntryPath(src);
      path.AddEntry(nodes)
    }
    
    [Memoized]
    ExitPath : list[HState]
    {
      get
      {
        SourceConfig.LastElems(Lca).Reverse()
      }
    }
    
    [Memoized]
    EntryPath : list[HState]
    {
      get
      {
        TargetConfig.LastElems(Lca)
      }
    }
    
    ExitSource() : void
    {
      AddExitPath(ExitPath)
    }
    
    Action() : void
    {
      def tran_path = GetActionPath(transition.Actions);
      path.AddAction(tran_path);
    }
    
    EntryTarget() : void
    {
      AddEntryPath(EntryPath);
    }
    
    TraverseJunction(j : HPseudoState.Junction) : TargetDeterminator
    {
      def tree = j.decision_tree;
      def tree = TraverseDecisionTree(tree);
      j.decision_tree = tree;
      TargetDeterminator.Junction(tree, j.name)
    }
    
    TraverseDecisionTree(tree : DecisionNode) : DecisionNode
    {
      def tree = tree.Clone();
      foreach (j in tree.GetBreadthFirstEnumerable())
      {
        | DecisionNode.Target(target = tar) as t => 
             def target_conf = if (tar is HTarget.State(st)) tran_path.InitialConfiguration(st) else null;
             def p = TraversePath(Source, target_conf, tran_path);
             match (tar)
             {
               | HTarget.PseudoState(HPseudoState(state = st))
               | State(st)                                    => p.AddPath(t.state.active_config, st.active_config, j.actions)
               | _                                            => ()
             }
             t.path = p.path;
             def tar = p.ProcessTarget(tar);
             t.destination = tar;
        | _ => 
        
            def src = j.state;
            j.path = path.Clone(); // foreach nodes path from parent to childs
            foreach (n in j.ChildNodes)
            {
              def dest = n.state;
              def path = GetPath(src.active_config, dest.active_config, j.actions);
              n.path = path;
            }
      }
      tree
    }
    
    ProcessTarget(tar : HTarget) : TargetDeterminator
    {
      match (tar)
      {
        | HTarget.State                                   => CheckCompletion(Target)
        | HTarget.PseudoState(HPseudoState.Terminate)     => TargetDeterminator.Terminate()
        | HTarget.PseudoState(HPseudoState.History as h)  => TargetDeterminator.History(h)
        | HTarget.PseudoState(HPseudoState.Junction as j) => TraverseJunction(j)
        | _                                               => TargetDeterminator.NoStateChange()
      }
    }
    
    EmptyDecisionTarget(target : TargetDeterminator) : DecisionNode
    {
      DecisionNode.Target(transition.Actions, path, (transition.Source :> HTarget.State).state, transition.Target, target)
    }
    
    CreateDecisionTree(target : TargetDeterminator) : DecisionNode
    {
      | TargetDeterminator.Junction(tree, _)  => tree
      | _                                     => match (transition.Guard)
                                                {
                                                  | GuardNode.Empty      => EmptyDecisionTarget(target);
                                                  | GuardNode.Expr as g  => def target = EmptyDecisionTarget(target);
                                                                            DecisionNode.Condition(transition.Actions, path, (transition.Source :> HTarget.State).state, g, target, None())
                                                  | _                    => throw InvalidOperationException("GuardNode.Else is not permitted on this stage")
                                                }
    }

    public CreateEntryPath() : Transition
    {
      Action();
      when (!IsInternal) EntryTarget();
      def target = ProcessTarget(tran_target);
      def tree = CreateDecisionTree(target);
      Transition(Source, null, transition.Trigger, transition.Guard, path, target, tree, 0, transition.Kind, transition.pos)
    }
    
    public CreatePath() : Transition
    {
      if (IsInternal)
      {
        Action()
      } else
      {
        when (MainTarget != null)
        {
          ExitSource();
          Action();
          EntryTarget();
        }
      }
      def target = ProcessTarget(tran_target);
      def tree = CreateDecisionTree(target);
      def originate = if (tran_source is HTarget.State(st)) st else null;
      Transition(Source, originate, transition.Trigger, transition.Guard, path, target, tree, 0, transition.Kind, transition.pos)
    }
    
  }
}
