using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  
  using SCG = System.Collections.Generic;
  
  variant Config
  {
    | Concurrent { lst : list[HState] }
    | Simple { st : HState }
    | Composite { st : HState }
    | Unknown { st : HState }
  }

  [Record]
  variant Configuration
  {
    | Simple { st : HState }
    | Sequential { states : list[HState]; }

    public States : list[HState]
    {
      get
      {
        match (this)
        {
          | Simple(a)     => [a]
          | Sequential(a) => a
        }
      }
    }

    public static @+(a : Configuration, b : Configuration) : Configuration
    {
      | (Simple(a), Simple(b))         => Sequential([a, b])
      | (Simple(a), Sequential(b))     => Sequential([a] + b)
      | (Sequential(a), Simple(b))     => Sequential(a + [b])
      | (Sequential(a), Sequential(b)) => Sequential(a + b)
    }
    
    public override ToString() : string
    {
       States.ToString()
    }
    
  }

  class ConfigSolver
  {
    mutable known : Config;

    mutable sub_selector : HFsm -> list[HState];

    solved_unknown : Config
    {
      get
      {
        match (known)
        {
          | Unknown(st) => 
              match (st.hierarchy)
              {
                | []      => Config.Simple(st)
                | _       => Config.Composite(st)
              }
          | st  => st
        }
      }
    }

    known_state : HState
    {
      get
      {
        match (solved_unknown)
        {
          | Config.Simple(st) 
          | Config.Composite(st) => st
          | _                    => null
        }
      }
    }
    
    public this(known : Config, sel : HFsm -> list[HState])
    {
      this.known = known;
      sub_selector = sel;
    }

    mutable current : Configuration;
    
    mutable conf_states : list[HState];
    
    current_state : HState
    {
      get
      {
        conf_states.Head
      }
    }
    
    next_super : HState
    {
      get
      {
        current_state.super
      }
    }
    
    conf_queue : SCG.Queue[Configuration] = SCG.Queue();
    
    GetConcurrentConfigs(super : HState, lst : list[list[Configuration]]) : list[Configuration]
    {
      def combinations = NList.Product(lst).Rev();
      def merge = combinations.Map(x => x.Reduce((x, a) => a + x));
      def add_super = merge.Map(x => Configuration.Sequential(super :: x.States));
      add_super
    }
    
    result : List[Configuration] = List();
    
    ExpandToParents(cur : Configuration) : Configuration
    {
      
      def loop()
      {
        match (next_super)
        {
          | null         => Configuration.Sequential(conf_states)
          | st           => match (st.hierarchy)
                            {
                              | [] 
                              | [_]  => conf_states ::= st;loop()//loop(super :: st, super :: acc)
                              | regs => def sregs = RegionConstant(regs, conf_states, sub_selector); // list of list of sub states of each region
                                        def comb = NList.Product(sregs).Rev(); // calculate product of concurrent combination
                                        foreach (conf in comb)
                                        {
                                          def configs = conf.Map(x => if (x : object == current_state) current :: [] else GetStateConfigs(x));
                                          def configs = GetConcurrentConfigs(st, configs);
                                          current = configs.First(x => x.States.ContainsList(conf_states));
                                          conf_states = current.States;
                                          def add_super = configs.Except(current);
                                          conf_queue.Append(add_super)
                                        }
                                        loop()
                            }
        }
      }

      current = cur;
      conf_states = current.States;
      loop()
    }

    static RegionConstant(st : list[HFsm], constant : list[HState], sub : HFsm -> list[HState]) : list[list[HState]]
    {
      def map(st)
      {
        def states = st.states;
        match (states.Find(x => constant.ContainsRef(x)))
        {
          | Some(x) => [x]
          | _       => sub(st)
        }
      }

      st.Map(map)
    }

    GetStateConfigs(st : HState) : list[Configuration]
    {
      match (st.hierarchy)
      {
        | []     => Configuration.Simple(st) :: []
        | [reg]  => def sub = sub_selector(reg);
                    sub.SelectMany(x => GetStateConfigs(x)).NToList();
        | regs   => def sregs = regs.Map(x => x.states);
                    def comb = NList.Product(sregs).Rev();
                    def comb = comb.Map(x => x.Map(x => GetStateConfigs(x)));
                    def comb = comb.SelectMany(x => GetConcurrentConfigs(st, x)).NToList();
                    comb
      }
    }
    
    public Solve() : list[Configuration]
    {
      match (solved_unknown)
      {
        | Simple(st)
        | Composite(st)  => def confs = GetStateConfigs(st);
                            conf_queue.Append(confs);
        | _              => ()
      }
                
       def loop()
       {
         if (conf_queue.IsEmpty()) () else
         {
          def conf = conf_queue.Dequeue();
          def res = ExpandToParents(conf);
          result.Add(res);
          loop()
         }
       }
       
      loop();
      result.NToList()
    }

  }

}
