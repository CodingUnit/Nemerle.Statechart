using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  [Record]
  public variant StateBinaryOp
  {
    | Equal    // ==
    | NotEqual // !=
    | Above    // >
    | AboveEq  // >=
    | Below    // <
    | BelowEq  // <=
    | Or       // &&
    | And      // ||
    | Error

    public pos : int;

    public Precedence : int
    {
      get
      {
        match (this)
        {
          | Equal    => 165
          | NotEqual => 165
          | Above    => 210 
          | AboveEq  => 210
          | Below    => 210
          | BelowEq  => 210
          | Or       => 150
          | And      => 160
          | Error    => 0
        }
      }
    }

    public Name : string
    {
      get
      {
        match (this)
        {
          | Equal    => "Equal"
          | NotEqual => "NotEqual" 
          | Above    => "Above" 
          | AboveEq  => "AboveEqual"
          | Below    => "Below" 
          | BelowEq  => "BelowEqual"
          | Or       => "Or"
          | And      => "And"
          | Error    => "Error"
        }
      }
    }

    public override ToString() : string
    {
      match (this)
      {
        | Equal    => "=="  
        | NotEqual => "!=" 
        | Above    => ">" 
        | AboveEq  => ">="
        | Below    => "<" 
        | BelowEq  => "<="
        | Or       => "||"
        | And      => "&&"
        | Error    => "Error"
      }
    }
  }

  [Record]
  public variant StateUnaryOp
  {
    | Not // !
    | Error

    public pos : int;

    public Name : string
    {
      get
      {
        match (this)
        {
          | Not   => "Not"
          | Error => "Error"
        }
      }
    }
    
    public Precedence : int
    {
      get
      {
        match (this)
        {
          | Not   => 281
          | Error => 0
        }
      }
    }

    public override ToString() : string
    {
      match (this)
      {
        | Not         => "!"
        | Error       => "Error"
      }
    }
  }

  [Record]
  public variant StateLit
  { 
    | Integer { a : int    } // 1
    | Double  { a : double } // 1.0
    | String  { a : string } // "1"
    | Bool    { a : bool; }  // true

    public pos : int;


    public override ToString() : string
    {
      match (this)
      {
        | Integer(a)         => $"$a"
        | Double(a)          => $"$a"
        | String(a)          => $<#"$a"#>
        | Bool(a)            => if (a) "true" else "false"
      }
    }
  }
  /// <summary>
  /// Description of Guards.
  /// </summary>
  [Record]
  public variant StateExpr
  {
    | Literal { lit : StateLit; }
    | Var     { v : string; } // abc
    | Method  { m : FsmAction; } // abc()
    | Braces  { a : StateExpr; }
    | TwoOp   { a : StateExpr; op : StateBinaryOp; b : StateExpr;} // ==
    | UnaryOp { op: StateUnaryOp; a : StateExpr; } 
    | Error   

    public pos : int;

    public Name : string
    {
      get
      {
        match (this)
        {
          | Literal(l)     => $"$l"
          | Var(v)         => $"$v"
          | Method(m)      => $"$m"
          | Braces(a)      => $"($a)"
          | TwoOp(a, o, b) => $"($(a)_$(o.Name)_$b)"
          | UnaryOp(o, a)  => $"$(o.Name)$a"
          | Error          => "Error"
        }
      }
    }

    public override ToString() : string
    {
      match (this)
      {
        | Literal(l)     => $"$l"
        | Var(v)         => $"$v"
        | Method(m)      => $"$m"
        | Braces(a)      => $"($a)"
        | TwoOp(a, o, b) => $"($a $o $b)"
        | UnaryOp(o, a)  => $"$o$a"
        | Error          => "Error"
      }
    }
  }
}
