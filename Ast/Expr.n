using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  [Record]
  public variant StateBinaryOp
  {
    | Equal    // ==
    | NotEqual // !=
    | Above    // >
    | AboveEq  // >=
    | Below    // <
    | BelowEq  // <=
    | Or       // &&
    | And      // ||
    | Error

    public pos : int;

    public override ToString() : string
    {
      match (this)
      {
        | Equal    => "=="  
        | NotEqual => "!=" 
        | Above    => ">" 
        | AboveEq  => ">="
        | Below    => "<" 
        | BelowEq  => "<="
        | Or       => "||"
        | And      => "&&"
        | Error    => "Error"
      }
    }
  }

  [Record]
  public variant StateUnaryOp
  {
    | Not // !
    | Error

    public pos : int;

    public override ToString() : string
    {
      match (this)
      {
        | Not         => "!"
        | Error       => "Error"
      }
    }
  }

  [Record]
  public variant StateLit
  { 
    | Integer { a : int    } // 1
    | Double  { a : double } // 1.0
    | String  { a : string } // "1"

    public pos : int;

    public override ToString() : string
    {
      match (this)
      {
        | Integer(a)         => $"$a"
        | Double(a)          => $"$a"
        | String(a)          => $<#"$a"#>
      }
    }
  }
  /// <summary>
  /// Description of Guards.
  /// </summary>
  [Record]
  [Traversable]
  public variant StateExpr
  {
    | Literal { lit : StateLit; }
    | Var     { v : string; } // abc
    | Method  { m : string; } // abc()
    | Braces  { a : StateExpr; }
    | TwoOp   { a : StateExpr; op : StateBinaryOp; b : StateExpr;} // ==
    | UnaryOp { op: StateUnaryOp; a : StateExpr; } 

    public pos : int;

    //public Current : StateExpr
    //{
    //  get
    //  {
    //    this
    //  }
    //}

    //public ChildNodes : IEnumerable[IGeneralTree[StateExpr]]
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | Literal     
    //      | Var         
    //      | Method         => ()
    //      | Braces(a)      => yield a
    //      | TwoOp(a, _, b) => yield a; yield b;
    //      | UnaryOp(_, a)  => yield a
    //    }
    //  }
    //}

    public GetChild() : IEnumerable[StateExpr]
    {
      match (this)
      {
        | Literal     
        | Var         
        | Method         => ()
        | Braces(a)      => yield a;
        | TwoOp(a, _, b) => yield a; yield b;
        | UnaryOp(_, a)  => yield a
      }
    }

    public Rebuild(_ : IEnumerable[StateExpr]) : StateExpr
    {
      this
    }

    public override ToString() : string
    {
      match (this)
      {
        | Literal(l)     => $"$l"
        | Var(v)         => $"$v"
        | Method(m)      => $"$m"
        | Braces(a)      => $"($a)"
        | TwoOp(a, o, b) => $"$a $o $b"
        | UnaryOp(o, a)  => $"$o$a"
      }
    }
  }
}
