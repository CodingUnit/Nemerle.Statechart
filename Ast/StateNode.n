using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  public variant StateType
  {
    | State
    | SubMachine {type : string;}
    | InlinedSubMachine {type : string;}
    | SubRegion
    | Region
  }

    //[Record]
  public class Iterator[T] : IIterator[StateNode]
  {
    public state_machine : StateNode.StateMachine * T-> T;
    public region        : StateNode.State * IEnumerable[T] -> T;
    public state         : StateNode.State * IEnumerable[T] -> T;
    public final         : StateNode.Final * T -> T;

    public this(state_machine : StateNode.StateMachine * T -> T, region : StateNode.State * IEnumerable[T] -> T, state : StateNode.State * IEnumerable[T] -> T, final : StateNode.Final * T -> T) 
    {
      base(state_machine, region, state, final);
      this.state_machine = state_machine;
      this.region = region;
      this.state = state;
      this.final = final;
    }


  }

  public class AccIterator[T] : IAccIterator[StateNode]
  {
    public state_machine : StateNode.StateMachine * T-> T;
    public region        : StateNode.State * T -> T;
    public state         : StateNode.State * T -> T;
    public final         : StateNode.Final * T -> T;

    public this(state_machine : StateNode.StateMachine * T -> T, region : StateNode.State * T -> T, state : StateNode.State * T -> T, final : StateNode.Final * T -> T) 
    {
      base(state_machine, region, state, final);
      this.state_machine = state_machine;
      this.region = region;
      this.state = state;
      this.final = final;
    }


  }
  
  [CachedTraversable]
  [Record]
  public variant StateNode
  {
    | StateMachine 
      {
        flags : MachineFlags;
        state : State;

        this(fl : MachineFlags, st : State)
        {
          flags = fl;
          state = st;
          base(st.pos);
        }

        GetErrors() : IEnumerable[Error]
        {
          Fold(Enumerable.Empty(), null, null, (s, a) => a.Concat(s.errors), null)
        }
      }
    | Region 
      {
        regions : IEnumerable[State];
      }
    | Initial 
      {
        guard : option[GuardNode];
        action : option[Actions];
        [NeedChange] to : TargetType;

        this(pos : int, tran : Transition)
        {
          guard = tran.guard;
          action = tran.action;
          to = tran.to;
          base(pos);
        }

      }
    | Default
      {
        action : option[Actions];
        target : StateNode.State;
        [NeedChange(pos)] history : History;

        this(act : option[Actions], to : State)
        {
          action = act;
          target = to;
          base(0)
        }

      }
    | Final
      {
        state  : State;

        this(s : State) 
        {
          state = s;
          base(0);
        }

      }
    | State 
      {
        this (n : string) {name = n;reference = true;base(0);}
        this (n : string, pos : int, type : StateType) 
        {
          base(pos);
          name = n;
          this.type = type;
        }
        this (n : string, pos : int, type : StateType, tran : list[Transition]) 
        {
          base(pos);
          name = n;
          transitions = tran;
          this.type = type;
        }
        this (pos : int, type : StateType) 
        {
          base(pos);
          this.type = type;
        }
        name : string;
        initial : IEnumerable[Initial] = Enumerable.Empty();
        attributes : IEnumerable[StateAttribute] = Enumerable.Empty();
        entry : IEnumerable[Entry] = Enumerable.Empty();
        exit : IEnumerable[Exit] = Enumerable.Empty();
        internal_tran : IEnumerable[InternalTransition] = Enumerable.Empty();
        transitions : IEnumerable[Transition] = Enumerable.Empty();
        do_activity : IEnumerable[DoActivity] = Enumerable.Empty();
        history : TwoOption[History] = TwoOption.None();
        sub_states : IEnumerable[State] = Enumerable.Empty();
        regions : option[Region] = None();
        [RecordIgnore]
        reference : bool;
        pseudo_states : IEnumerable[PseudoState] = Enumerable.Empty();
        type : StateType;
        errors : IEnumerable[Error] = Enumerable.Empty();

      }

    | Entry 
      {
        this(pos : int) {action = Actions([]);base(pos);}
        this(lst : list[string]) {action = Actions(lst);base(0);}

        attrib : ActionFlags;
        action : Actions;
      }
    | Exit 
      {
        this(pos : int) {action = Actions([]);base(pos);}
        this(lst : list[string]) {action = Actions(lst);base(0);}

        attrib : ActionFlags;
        action : Actions;
      }
    | Error {node : StateNode;}
    | DoActivity {action : Actions;flags : ActivityFlag;}
    | InternalTransition
      {
        evt : list[TransitionNode.Event];
        guard : option[GuardNode];
        action : Actions;

        Actions : IEnumerable[string]
        {
          get
          {
            action.ActionList
          }
        }

      }
    | Transition 
      {
        evt : IEnumerable[TransitionNode.Event];
        guard : option[GuardNode];
        action : option[Actions];
        [NeedChange] to : TargetType;

        ToState : StateNode.State
        {
          get
          {
            match (to)
            {
              | TargetType.State(st)  => st
              | _  => null
            }
          }
        }

        this(guard : option[GuardNode], action : option[Actions], to : TargetType)
        {
          this.guard = guard;
          this.action = action;
          this.to = to;
          base(to.pos);
        }

        this(evt : List[TransitionNode.Event],  tran : Transition)
        {
          this.evt = evt.NToList();
          guard = tran.guard;
          action = tran.action;
          to = tran.to;
          base(evt.First().pos);
        }

      }

    | History
      { 
        type : HistoryType;
        [NeedChange] default : option[Default];
        [NeedChange] state : State;
        reference : bool;

        this(pos : int, state : State)
        {
          this.state = state;
          reference = true;
          default = option.None();
          base(pos);
        }

        this(pos : int, type : HistoryType, default : option[Default])
        {
          this.type = type;
          this.default = default;
          base(pos)
        }

      }
    | PseudoState
      {
        [NeedChange] node : PseudoStateAstNode;
      }

    public pos : int;

    public this(p : int) { pos = p }

    public Visit[T](ctx : IIterator[StateNode], acc : IEnumerable[T]) : T
    {
      def ctx = ctx :> Iterator[T];
      match (this)
      {
        | State(regions = Some) as t => ctx.region(t, acc)
        | State as t                 => ctx.state(t, acc)
        | StateMachine as t          => ctx.state_machine(t, acc.First())
        | Final as t                 => ctx.final(t, acc.First())
        | _                          => default(T)
      }
    }

    public Visit[T](ctx : IAccIterator[StateNode], acc : T) : T
    {
      def ctx = ctx :> AccIterator[T];
      match (this)
      {
        | State(regions = Some) as t => ctx.region(t, acc)
        | State as t                 => ctx.state(t, acc)
        | StateMachine as t          => ctx.state_machine(t, acc)
        | Final as t                 => ctx.final(t, acc)
        | _                          => default(T)
      }
    }
    
    public Fold[T](init          : T,
                  state_machine : StateMachine * T-> T,
                  region        : State * IEnumerable[T] -> T,
                  state         : State * IEnumerable[T] -> T,
                  final         : Final * T -> T) : T
    {
      //def loop(n, sub, acc)
      //{
      //  match (n)
      //  {
      //    | State(regions = Some) as t             => if (region != null) region(t, sub) else acc;
      //    | State as t                             => if (state != null) state(t, sub) else acc;
      //    | StateMachine as t                      => if (state_machine != null) state_machine(t, sub.First()) else acc;
      //    | Final as t                             => if (final != null) final(t, sub.First()) else acc;
      //    | _                                      => acc
      //  }
      //}

      Fold(init, Iterator(state_machine, region, state, final))
    }

    public Fold[T](init          : T,
                  state_machine : StateMachine * T -> T,
                  region        : State * T -> T,
                  state         : State * T -> T,
                  final         : Final * T -> T) : T
    {
      Fold(init, AccIterator(state_machine, region, state, final))
    }

    public GetCode() : int
    {
      match (this)
      {
        | StateMachine            => 0
        | State(regions = Some()) => 1
        | State                   => 2
        | Final                   => 3
        | _                       => -1
      }
    }

    public GetChild() : IEnumerable[StateNode.State]
    {
      match (this)
      {
        | State(regions = Some(Region(sr))) => sr
        | State(sub_states = sub)           => sub
        | StateMachine(state = st)          => TraverseUtils.SingleElement(st)
        | _                                 => Enumerable.Empty()
      }
    }

    public Rebuild(_ : IEnumerable[StateNode]) : StateNode
    {
      this
    }    
  }

}
