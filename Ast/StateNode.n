// statenode.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using SCG = System.Collections.Generic;

namespace Nemerle.Statechart
{
  public variant StateType
  {
    | State
    | Final
    | SubMachine        { type : string; }
    | InlinedSubMachine { type : string; }
    | SubRegion
    | Region
  }

  public enum TransitionType
  {
    | Internal
    | Default 
    | Initial
    | Transition
  }

  //[Traversable(State)]
  [Record]
  public variant StateNode
  {
    | StateMachine
      {
        flags : MachineFlags;
        state : State;

        //this(fl : MachineFlags, st : State)
        //{
        //  flags = fl;
        //  state = st;
        //  base(st.pos);
        //}

        GetErrors() : IEnumerable[Error]
        {
          TreeUtils.Fold(state, [], _.sub_states, (x, a) => a.Concat(x.errors));
          //StateParts.SelectMany(_.errors)
        }
      }
      
    | State
      {
        this (n : string, type : StateType) {base(-1);name = n;/*reference = true;*/ this.type = type;}
        this (n : string, pos : int, type : StateType)
        {
          base(pos);
          name = n;
          this.type = type;
        }
        this (n : string, pos : int, type : StateType, tran : list[Transition])
        {
          base(pos);
          name = n;
          transitions = tran;
          this.type = type;
        }
        this (pos : int, type : StateType)
        {
          base(pos);
          this.type = type;
        }
        //[NeedChange]
        name          : string;
        parent        : option[State];
        attributes    : list[StateAttribute] = [];
        entry         : list[Entry] = [];
        exit          : list[Exit] = [];
        transitions   : list[Transition] = [];
        do_activity   : list[DoActivity] = [];
        //history       : TwoOption[History] = TwoOption.None();
        sub_states    : list[State] = [];
        //[RecordIgnore]
        //reference     : bool;
        pseudo_states : list[PseudoState] = [];
        type : StateType;
        errors : list[Error] = [];

      }

    | Entry
      {
        //this(pos : int) {action = Actions([]);base(pos);}
        //this(lst : list[string]) {action = Actions(lst);base(0);}

        attrib : ActionFlags;
        action : Actions;
      }
    | Exit
      {
        //this(pos : int) {action = Actions([]);base(pos);}
        //this(lst : list[string]) {action = Actions(lst);base(0);}

        attrib : ActionFlags;
        action : Actions;
      }
    | Error {node : StateNode;}
    | DoActivity {action : Actions;flags : ActivityFlag;}
    | Transition
      {
        evt : IEnumerable[TransitionEvent] = Enumerable.Empty();
        guard : option[GuardNode];
        action : option[Actions]; 
        
        //[NeedChange] 
        to : TargetType;

               
        
        [NeedChange(pos)]
        [NeedChange]
        type : TransitionType;

        ToState : StateNode.State
        {
          get
          {
            match (to)
            {
              | TargetType.State(st)  => st
              | _                     => null
            }
          }
        }

        //this(guard : option[GuardNode], action : option[Actions], to : TargetType)
        //{
        //  base(to.pos);
        //  this.guard = guard;
        //  this.action = action;
        //  this.to = to;
        //}

        //this(pos : int,  tran : Transition, type : TransitionType)
        //{
        //  base(pos);
        //  guard = tran.guard;
        //  action = tran.action;
        //  to = tran.to;
        //  this.type = type
        //}

        //this(evt : IEnumerable[TransitionEvent],  tran : Transition, type : TransitionType)
        //{
        //  base(evt.First().pos);
        //  this.evt = evt;
        //  this.type = type;
        //  guard = tran.guard;
        //  action = tran.action;
        //  to = tran.to;
        //}

      }      
    | PseudoState
      {
        //[NeedChange] 
        node : PseudoStateAstNode;
      }

    //[NeedChange]
    public pos : int;

    //public GetCode() : int
    //{
    //  match (this)
    //  {
    //    | StateMachine            => 0
    //    | State(regions = Some()) => 1
    //    | State                   => 2
    //    | Final                   => 3
    //    | _                       => -1
    //  }
    //}

    //public GetChild() : IEnumerable[StateNode.State]
    //{
    //  match (this)
    //  {
    //    | State(sub_states = sub)           => sub
    //    | StateMachine(state = st)          => TraverseUtils.SingleElement(st)        
    //    | _                                 => Enumerable.Empty()
    //  }
    //}

    //public Rebuild(_ : IEnumerable[StateNode]) : StateNode
    //{
    //  this
    //}
  }

}
