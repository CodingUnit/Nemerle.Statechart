//ast.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;

namespace Nemerle.Statechart
{

//using StateNode;

  public enum HistoryType
  {    
    | None
    | Shallow
    | Deep
  }   

  [Record]
  public variant NameIdentifier
  {
    | Name 
    | QualifiedName 
      {
        parts : list[string];
      }

    public pos : int;
    public name : string;

    //public TargetName : string
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | NameIdentifier.Name(name = n)
    //      | QualifiedName(name = n)  => n
    //    }
    //  }
    //}

    //public ParentName : string
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | NameIdentifier.Name  => null
    //      | QualifiedName(parts = n)  => 
    //    }
    //  }
    //}

    public FullName : string
    {
      get
      {
        match (this)
        {
          | Name(name = n)                     => n
          | QualifiedName(parts = p, name = n) => $<#..$(p;".")$n#>
        }
      }
    }
    
    public GetState() : StateNode.State
    {
      def n = FullName;
      StateNode.State(n, StateType.State())
    }

    //public GetNode() : StateNode.State
    //{
    //  StateNode.State(TargetName, StateType.State())
    //}
  }

  [Record]
  public variant GuardNode
  {
    | Empty
    | Guard {condition : string;}
    | InState {state : string;}
    | Else

    public pos : int;
    public override ToString() : string {Name}

    public Name : string
    {
      get
      {
        match (this)
        {
          | Guard(c)   => $"GuardNode$c"
          | InState(c) => $"InState($c)" 
          | Else       => "Else"
          | Empty      => "Empty"
        }
      }
    }

    public CompareTo(b : GuardNode) : int
    {
      match (this, b)
      {
        | (Guard(a), Guard(b))
        | (InState(a), InState(b)) => a.CompareTo(b)
        | (_, _) => -1
      }
    }
  }

  [Record]
  public class TransitionEvent
  {      
    public name : string; 

    public override ToString() : string {name}

    public pos : int;
  }

  [Record]
  public variant StateAttribute
  {
    | None
    | Initial 
    | ManualCompletion
    | Unknown {name : string}

    [Accessor]
    pos : int
  }

  [Flags]
  public enum MachineFlag
  {
    | None                 
    | Debug                = 0b00000001 // enable debug point
    | AutoInitial          = 0b00000010 // automatic define initial transition in first defined sub state
    | LocalDefault         = 0b00000100 // local transitions by default rather than external
    | TransitionCompleted  = 0b00001000 // create TransitionCompleted events
    | CompletionStrict     = 0b00010000 // standart strict completion behaviour (run if no activity)
    | OnlyAnalyse          = 0b00100000 // only analyse don't generate anything
    | AutoEntryExitActions = 0b01000000 // auto create events for entry and exit actions for all states
    | TestingFeatures      = 0b10000000 // test functions for test features of fsm
  }

  [Record]
  public class MachineFlags
  {
    [FlagAccessor (AutoInitial, 
                   LocalDefault, 
                   Debug, 
                   CompletionStrict, 
                   TransitionCompleted, 
                   OnlyAnalyse, 
                   AutoEntryExitActions,
                   TestingFeatures
                   )]
    flags : MachineFlag;
    public errors : IEnumerable[string] = Enumerable.Empty();

  }

  [Flags]
  public enum ActionFlags
  {
    | None
  }

  [Flags]
  public enum ActivityFlag
  {
    | None
    | Concurrently = 0b0001 // run several activities concurrently in separate task
    | NoWaitCancel = 0b0010 // no wait of canceling activity
    | NotLong      = 0b0100 // this is not long activity (eg fast action), this implies that parallel task create with specific option, 
                            // prevents long activity in the planner see TaskCreationOptions.LongRunning (this is default for activities)
  }

  public enum JunctionType
  {
    | Junction
    | Choice
    | Merge
  }

  [Record]
  public variant PseudoStateAstNode
  {
    | History
      {
		    type : HistoryType;
        default : option[StateNode.Transition];
      }

    | Fork {target : list[TargetType];}
    | Join {name : string;target : TargetType;}
    //| Junction
    //  {
    //    name : string;
    //    target : list[TargetType];
    //    type : JunctionType;

    //    Name : string
    //    {
    //      get
    //      {
    //        def type = match (type)
    //                    {
    //                      | Junction => "Junction"
    //                      | Choice   => "Choice"
    //                      | Merge    => "Merge"
    //                    }
    //        if (name !=null) $"$type$name" else "Unnamed$type"
    //      }
    //    }

    //    override ToString() : string {Name}
    //  }
    | EntryPoint
    | ExitPoint
    | Terminate 

    public pos : int;
  }

  [Record]
  public variant TargetType
  {
    | PseudoState 
      {
        node : PseudoStateAstNode;
      }
    | State 
      {
        state : StateNode.State;
      }
    | Named 
     {
       //parent : StateNode.State; 
       name : string;
      }
    | SubMachine {machine : StateNode.State; state : string;}
    | Qualified {parent : string; target : TargetType;}



    public pos : int;
    
  }

}
