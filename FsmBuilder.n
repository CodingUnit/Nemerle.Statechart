using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using System.IO;
using CommonLib.Macros;

namespace Nemerle.Statechart
{
  class FsmBuilder
  {
    parser : Parser;
    ty : TypeBuilder;
    top : TopDeclaration;
    locator : Locator;
    typer : Typer;
    
    public this(ty : TypeBuilder, typer : Typer, top : TopDeclaration, fsm : StateNode.StateMachine)
    {
      this(ty, typer, top);
      this.fsm = fsm;
      parser = Parser(FsmAnalyser.Flags);
      locator = Locator(parser, loc);
    }

    public this(ty : TypeBuilder, typer : Typer, top : TopDeclaration)
    {
      this.ty = ty;
      this.top = top;
      this.typer = typer;
      parser = Parser(FsmAnalyser.Flags);
      locator = Locator(parser, loc);
    }

    public this(file : string)
    {
      this.file = file;
      //this.files = files ?? HashSet();
      parser = Parser(FsmAnalyser.Flags);
      locator = Locator(parser, loc)
    }
    
    [Accessor]
    mutable fsm : StateNode.StateMachine;

    AttributesAndMods : AttributesAndModifiers
    {
      get
      {        
        top?.ParsedAttributsAndModifiers
      }
    }

    [Memoized]
    attribute : option[PExpr]
    {
      get
      {
        def find_func(x)
        {
          | <[ statechart(..$x) ]> => match (x)
                                      {
                                        | x :: _ => Some(x)
                                        | _      => None()
                                      }
          | _                      => None()
        }
        
        if (AttributesAndMods != null)
        {
          AttributesAndMods.ParsedCustomAttributes.FindMap(find_func)
        }
        else None()
      }
    }

    loc : Location
    {
      [Memoize]
      get
      {
        if (file != null) 
        {
          def idx = Location.AddFile(file);
          Location(idx, TextPoint(0, 0))
        } else
        if (attribute is Some(a)) a.Location else top?.Location;
      }
    }
    
    public body : string
    {
      [Memoize]
      get
      {
        if (ty != null)
        match (attribute)
        {
          | Some(<[ $(str : string) ]>) => str
          | _                           => null
        } else File.ReadAllText(file)
      }
    }

    env : GlobalEnv
    {
      get
      {
        ty.GlobalEnv
      }
    }

    attr_loc : Location
    {
      get
      {
        top.ParsedAttributsAndModifiers.Location
      }
    }
    
    //files : HashSet[string];
    
    ParseFile(file : string) : StateNode.StateMachine
    {
      def parser = Parser(FsmAnalyser.Flags);
      try
      {
        def text = File.ReadAllText(file);
        def fsm = parser.Parse(file, text)[0];
        def locator = Locator(parser, Location.Default);
        locator.Locate(fsm);
        fsm
      }
      catch
      {
        | c => Message.Error($"Error opening file $file: $c");null
      }
      
    }
    
    ParseInternal(text : string) : StateNode.StateMachine
    {
      def (ast, err) = parser.Parse(File, text);
      if (ast == null)
      {
        foreach (err in err)
        {
          def nloc = Locator.ConvLocation(err.Location, loc);
          def line = nloc.Line;
          def col  = nloc.Column;
          Message.Error(nloc, $"Error in input at $(line):$(col): $(err.Text) of file: $File");
        }
        null
      } else 
      {
        when (fsm != null) locator.Locate(fsm);
        ast |> OpenIncludes(_, [File])
      }
    }
    
    Parse(text : string) : void
    {
      fsm = if (!text.IsEmpty()) 
             {
               //when (loc.File == "AlarmClockInternals.n") assert2(false);
               //assert2(false);
               ParseInternal(text)
             } else null;       
    }
    
    OpenIncludes(src : StateNode.StateMachine, parents : list[string]) : StateNode.StateMachine
    {
      def included = List();
      
      def open(s, ch : list[StateNode])
      {
        match (s)
        {
          | StateNode.State(include = (_ :: _) as i) as st => 
              
              def (already, other) = i.Partition(x => parents.Contains(x.file));
              foreach (a in already)
              {
                Message.Error(a.Location, $"Cycle include file detected at $(a.Location)");
              }
              
              def fsms = other.Map(x => (x.file, ParseFile(x.file)));
              def fsms = fsms.Filter((_, x) => x != null);
              def fsms = fsms.Map((f, x) => OpenIncludes(x, f :: parents));
              fsms |> included.AddRange;
              def st = st.ChangeSubStates(ch.Map(x => x :> StateNode.State));
              fsms.Fold(st, (x, a) => StateNode.Combine(a, x.state));
              // else st;
          | State as st => st.ChangeSubStates(ch.Map(x => x :> StateNode.State))
          | StateNode.StateMachine as st       => st.ChangeState(ch.First() :> StateNode.State)
          | _                                  => s
        }
      }
      
      if (src != null)
      {
        def res = src.Reduce(open) :> StateNode.StateMachine;
        included.Fold(res, (x, a) => a.AddTopDecls(x));
      } else null
    }
    
    public Parse() : void
    {
      //assert2(false);
      def text = if (ty != null)
      {
        CheckBody();
        def text = body ?? "";
        //def name = Path.GetFileNameWithoutExtension(loc.File);
        //when (!text.IsEmpty())
        //  File.WriteAllText($"$(name)_gen.nsch", text);
        text
      } else
      {
        //_ = files.Add(file);
        body
      }
      Parse(text);
    }

    public static GetParsedResult(ty : TypeBuilder) : FsmBuilder
    {
      def data = ty.Manager.UserData;
      if (data.Contains(key)) 
      {
        def data = data[key] :> data_type;
        if (data.Find((x, _) => x == ty.Name) is Some((_, d))) d else null
      } else null
    }

    public static key = "statechart";
    type data_type = list[string * FsmBuilder];

    static Memoize(ty : TypeBuilder, tree : FsmBuilder) : void
    {
      def storage = ty.Manager.UserData;
      def name = ty.Name;
      def data = if (storage.Contains(key))
                  {
                    storage[key] :> data_type;
                  } else [];
      def data = (name, tree) :: data;
      storage[key] = data
    }
    
    public CheckEventClasses(typer : Typer) : void
    {
      def base_type = typer.BindFixedType(<[ HsmEvent ]>);
      def evt = fsm.event_classes;
      foreach (StateNode.EventClassDecl(name = n) as e in evt)
      {
        def parts = n.Parts;
        match (ty.GlobalEnv.LookupType(parts))
        {
          | Some(ty) => unless (ty.IsDerivedFrom(base_type.TypeInfo)) Message.Error(e.Location, $<#Event class "$(ty.FullName)" must implement HsmEvent class#>);
          | _        => ()
        }
      }
    }
    
    
    file : string;
    
    File : string
    {
      [Memoize]
      get
      {
        if (file != null) file else loc.File
      }
    }
    
    Name : string
    {
      get
      {
        if (ty != null) ty.Name else Path.GetFileNameWithoutExtension(file)
      }
    }
    
    public GetEventClasses(evt : list[StateNode.EventClassDecl]) : list[EventClass]
    {
      def find(e)
      {
        def name = e.name;
        def evts = e.events;
        def parts = name.Parts;
        match (ty.GlobalEnv.LookupType(parts))
        {
          | Some(ty) => def nested = ty.GetNestedTypes();
                        
                        def nested = if (evts.IsEmpty()) nested else 
                        {
                          def evts = evts.Map(x => if (nested.Find(y => y.Name == x.ToUpperFirst()) is Some(y)) (x, y) else (x, null));
                          foreach ((ev, null) in evts)
                          {
                            Message.Error(e.Location, $<#Event "$ev" not found in event class "$(name.FullName)"#>);
                          }
                          evts.Map((_, x) => x)
                        }
                        nested.Map(x => EventClass.External(x.FullName.SplitToList('.'), x))
          | _        => Message.Error(e.Location, $<#Event class "$(name.FullName)" not found#>);
                        []
        }
      }
      
      evt.SelectMany(find).NToList()
    }
    
    public CheckBody() : void
    {
      when (attribute is Some() && body == null) Message.Error(attr_loc, "Body expression must be a string");
    }
    
    public BuildGraph(other : list[FsmBuilder]) : void
    {
      when (fsm.flags.Logging) Console.WriteLine($"Starting analyse fsm $(Name)...");
      when (fsm.flags.Debug) assert2(false);
      //def mach = ty.Manager.UserData[key] :> data_type;
      def evt_class = GetEventClasses(fsm.event_classes);
      def mach = other.Map(x => (x.fsm.name, x.fsm));
      def analyser = FsmAnalyser(fsm, Name, mach, evt_class);
      analyser.CreateGraph();
      def warn = analyser.WarningMessages;
      when (fsm.flags.Logging) Console.WriteLine($"Finish analyse with $(analyser.ErrorMessages.Count()) errors and $(warn.Count()) warnings");
      def warn_file = $"$(Name)Warnings.log";
      if (!warn.IsEmpty()) 
      {
        def text = warn.Map((_, x) => x);
        warn.Iter(Message.Warning);
        when (fsm.flags.Debug) File.WriteAllLines(warn_file, text);
      } else when (fsm.flags.Debug) File.Delete(warn_file);
      def err_file = $"$(Name)errors.log";
      if (analyser.Error)
      {
        def err = analyser.ErrorMessages;
        def text = err.Map((_, x) => x);
        when (fsm.flags.Debug) System.IO.File.WriteAllLines(err_file, text);
        err.Iter(Message.Error)
      } else
      {
        when (fsm.flags.Debug) File.Delete(err_file)
      }
    }
    
    public Build() : void
    {
      when (fsm.flags.Logging) Console.WriteLine($"Starting analyse fsm $(ty.Name)...");
      when (fsm.flags.Debug) assert2(false);
      def mach = ty.Manager.UserData[key] :> data_type;
      def evt_class = GetEventClasses(fsm.event_classes);
      def analyser = FsmAnalyser(fsm, ty.Name, mach.Map((x, y) => (x, y.fsm)), evt_class);
      analyser.Analyse();
      def warn = analyser.WarningMessages;
      when (fsm.flags.Logging) Console.WriteLine($"Finish analyse with $(analyser.ErrorMessages.Count()) errors and $(warn.Count()) warnings");
      def warn_file = $"$(ty.Name)Warnings.log";
      if (!warn.IsEmpty()) 
      {
        def text = warn.Map((_, x) => x);
        warn.Iter(Message.Warning);
        when (fsm.flags.Debug) File.WriteAllLines(warn_file, text);
      } else when (fsm.flags.Debug) File.Delete(warn_file);
      def err_file = $"$(ty.Name)errors.log";
      if (analyser.Error)
      {
        def err = analyser.ErrorMessages;
        def text = err.Map((_, x) => x);
        when (fsm.flags.Debug) System.IO.File.WriteAllLines(err_file, text);
        err.Iter(Message.Error)
      } else
      {
        when (fsm.flags.Debug) File.Delete(err_file);

        when (!fsm.flags.OnlyAnalyse) 
        {
          if (analyser.Complete)
          {
            when (fsm.flags.Logging) Console.WriteLine($"Starting generate fsm $(ty.Name)...");
            def active = analyser.ActiveStates.Where(_.Used).NToList();
            def gen = StaticGenerator(active, analyser.FsmFlags, analyser.InitialTransition, analyser.StatesId, analyser.LoadedMachines, ty);
            gen.Generate();
            when (fsm.flags.Logging) Console.WriteLine($"Finish generating $(ty.Name)");
            ty.UserData[FsmBuilder.key] = true;
          } else Message.Warning("No Statechart to generate")
        }
      }

    }

    
    
    public static ParseAll(ty : TypeBuilder, typer : Typer) : void
    {
      def types = ty.Manager.Hierarchy.TopTypeBuilders();
      foreach (ty in types)
      {
        def types = ty.AstParts;
        def builders = types.Map(x => FsmBuilder(ty, typer, x));
        builders.Iter(x => x.Parse());
        def parsed = builders.Filter(x => x.fsm != null);
        match (parsed)
        {
          | []  => ()
          | [p] => Memoize(ty, p)
          | lst => def fsm = MergePartial(lst.Map(_.Fsm));
                   Memoize(ty, FsmBuilder(ty, typer, lst.Head.top, fsm))
        }
      }
    }
      
    static MergePartial(fsm : list[StateNode.StateMachine]) : StateNode.StateMachine
    {
      fsm.Reduce(StateNode.Combine)
    }

  }

}
