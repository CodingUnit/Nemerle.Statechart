//actions.n
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;

namespace Nemerle.Statechart
{
  [Record]
  public variant FsmAction
  {
    | Normal 
      {
        name : string;
        parameters : list[string];
      }

    | Expr 
      { 
        expr : PExpr;
        
        public this(expr : PExpr) 
        {
          base(-1);
          this.expr = expr
        }
      }

    public pos : int;

    public CompareTo(act : FsmAction) : int
    {
      match (this, act)
      {
        | (Normal(n, p), Normal(n2, p2))                    => if (n == n2 && p == p2) 0 else -1
        | (Expr(<[ $(n2 : usesite)(..$p2)]>), Normal(n, p))
        | (Normal(n, p), Expr(<[ $(n2 : usesite)(..$p2)]>)) => if (n == n2 && p == p2.Map(x => x.ToString())) 0 else -1
        | (Expr(n), Expr(n2))                               => if (n.ToString() == n2.ToString()) 0 else -1
        | _ => -1
      }
    }
    
    public static Empty : FsmAction
    {
      get
      {
        FsmAction.Normal(-1, null, [])
      }
    }

    public override ToString() : string
    {
      match (this)
      {
        | Normal(n, p) => $"$n(..$p)"
        | Expr(e)      => $"$e"
      } 
    }
  }

  [Record]
  public class Actions 
  {
    public actions : list[FsmAction];

    public this(actions : list[FsmAction])
    {
      pos = 0;
      this.actions = actions;//.Filter(x => x.name != null);
    }

    public pos : int;

    public CompareTo(p : Actions) : int
    {
      if (actions.Zip(p.actions).All((x, y) => x.CompareTo(y) == 0)) 0 else -1
    }
    
    public static GetActions(this opt : option[Actions]) : list[FsmAction]
    {
      opt.MapDefault(_.actions, [])
    }

    public Empty : bool
    {
      get
      {
        actions.IsEmpty()
      }
    }

    public override ToString() : string
    {
      $"..$actions"
    }
  } 

}
