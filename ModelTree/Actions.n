//actions.n
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;
using Nemerle.Extensions;
using CommonLib.Macros;

namespace Nemerle.Statechart
{
  [Record]
  [StructuralEquality]
  public variant FsmAction : LocatedNode
  {
    | Normal 
      {
        name : string;
        parameters : list[string];
      }

    | TargetExpr { expr : PExpr;}
    | Expr 
      { 
      
        public ExecExpr : PExpr
        {
          [Memoize]
          get
          {
            MainParser.ParseExpr(Env, expr)
          }
        }
        
        expr : string;
        
        public this(str : string) 
        {
          base(-1);
          expr = str;
        }
      }

    public static Empty : FsmAction
    {
      get
      {
        FsmAction.Normal(-1, null, [])
      }
    }

    [RecordIgnore]
    public Env : GlobalEnv {get;set;}
    
    public override ToString() : string
    {
      def str = match (this)
      {
        | Normal(n, p) => $"$n(..$p)"
        | Expr(s)      => s
        | TargetExpr(e) => $"$e"
      } 
      str.Replace("\r\n", " ")
    }
  }

  [Record]
  [StructuralEquality]
  public class Actions : LocatedNode
  {
    public actions : list[FsmAction];

    public this(actions : list[FsmAction])
    {
      base(if (actions.IsEmpty()) -1 else actions.First().pos);
      this.actions = actions;//.Filter(x => x.name != null);
    }

    public static GetActions(this opt : option[Actions]) : list[FsmAction]
    {
      opt.MapDefault(_.actions, [])
    }

    public ActionsString : IEnumerable[string]
    {
      [Memoize]
      get
      {
        actions.Select(x => x.ToString());
      }
    }
    
    public Empty : bool
    {
      get
      {
        actions.IsEmpty()
      }
    }

    public override ToString() : string
    {
      ($<#..$(actions;",")#>).Replace("\r\n", " ")
    }
  } 

}
