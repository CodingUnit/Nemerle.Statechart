//ast.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using Nemerle.Macro;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using Nemerle.Compiler;
using CommonLib.Macros;

namespace Nemerle.Statechart
{

  using CommonLib.Macros.LensUtils;

  [Lens]
  [Record]
  public class LocatedNode : Located
  {
    public pos : int;

    //[NeedChange]
    public location : Nemerle.Compiler.Location;
    
    
    //public location_lens : Lens[LocatedNode, Location]
    //{
    //  [Memoize]
    //  get
    //  {
    //    Lens(x => x.location, (x, y) => x |> y.ChangeLocation)
    //  }
    //}
    
    public override Location : Nemerle.Compiler.Location
    {
      get
      {
        location
      }
      set {assert2(false);_ = value; throw InvalidOperationException("use ChangeLocation method instead of set method")}
    }
    
    public this(pos : int)
    {
      this.pos = pos;
      location = Nemerle.Compiler.Location.Default;
    }
  }

  public enum HistoryType
  {    
    | None
    | Shallow
    | Deep
  }   

  [Record]
  public variant NameIdentifier : LocatedNode
  {
    | Name 
    | QualifiedName 
      {
        parts : list[string];
      }

    public name : string;

    //public TargetName : string
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | NameIdentifier.Name(name = n)
    //      | QualifiedName(name = n)  => n
    //    }
    //  }
    //}

    //public ParentName : string
    //{
    //  get
    //  {
    //    match (this)
    //    {
    //      | NameIdentifier.Name  => null
    //      | QualifiedName(parts = n)  => 
    //    }
    //  }
    //}

    public Parts : list[string]
    {
      [Memoize]
      get
      {
        
        match (this)
        {
          | Name             => name :: []
          | QualifiedName(p) => p + [name]
        }
      }
    }

    public FullName : string
    {
      [Memoize]
      get
      {
        $<#..$(Parts;".")#>
      }
    }

    public Add(name : string) : NameIdentifier.QualifiedName
    {
      match (this)
      {
        | Name(name = n)                     => QualifiedName(pos, name, n :: [])
        | QualifiedName(name = n, parts = p) => QualifiedName(pos, name, p + [n])
      }
    }
    //public GetState() : string
    //{
    //  def n = FullName;
    //  StateNode.State(n, StateType.State())
    //}

    //public GetNode() : StateNode.State
    //{
    //  StateNode.State(TargetName, StateType.State())
    //}
  }

  [Record]
  public variant EventClass
  {
    | Internal
    | External
      {
        path : list[string];

        ty : TypeInfo;
        
        public base_class : list[string]
        {
          [Memoize]
          get
          {
            if (path.IsEmpty()) null else path.ChopLast().NToList()
          }
        }

        public Base : string
        {
          [Memoize]
          get
          {
            $<#..$(base_class; ".")#>
          }
        }
        
        public FullName : string
        {
          [Memoize]
          get
          {
            $<#..$(path; ".")#>
          }
        }

        public evt_name : string
        {
          [Memoize]
          get
          {
            if (path.IsEmpty()) null else path.Last()
          }
        }
      }
  }

  public variant TimedExpr
  {
    | Expr { expr : TimedExprType; }
    | Error { type : TimedErrorType; }

    public override ToString() : string
    {
      match (this)
      {
        | Expr(e)  => e.ToString()
        | Error(t) => $"Error$t"
      }
    }
  }

  [Record]
  public variant TimedErrorType
  {
    | UnknownUnit { name : string; }
    | Overflow
    | InvalidValue
    | DuplicateUnit { name : string; }
  }

  public variant TimedExprType
  {
    | After { time : TimeSpan;}
    | AfterSince { }
    | When { time : DateTime; }

    public override ToString() : string
    {
      match (this)
      {
        | After(t)   => $"after($t)"
        | AfterSince => "after(since)"
        | When(t)    => $"when($t)"
      }
    }

    public TargetName : string
    {
      [Memoize]
      get
      {
        ToString().ToUpperFirst()
      }
    }

  }

  [Record]
  public variant TransitionEvent : LocatedNode
  {
    | Normal { name : string; parms : list[string]; }
    | Completion
    | Timed { time_expr : TimedExpr; }

    public static None : TransitionEvent
    {
      [Memoize]
      get
      {
        Normal(-1, null, [])
      }
    }
    
    public override ToString() : string 
    { 
      match (this)
      {
        | Normal(name = null)          => ""
        | Normal(name = n, parms = []) => n
        | Normal(name = n, parms = p)  => $"$n(..$p)"
        | Completion                   => "Completion"
        | Timed(e)                     => $"$e"
      }
    }

    //public static Completion : TransitionEvent = TransitionEvent(-1, null, []);
  }


  [Record]
  public variant StateAttribute : LocatedNode
  {
    | None
    | Initial 
    //| ManualCompletion
    | Unknown {name : string}

  }

  [Flags]
  public enum MachineFlag
  {
    | None                 
    | Debug                             = 0b00000000001 // enable debug point
    | AutoInitial                       = 0b00000000010 // automatic define initial transition in first defined sub state
    | LocalDefault                      = 0b00000000100 // local transitions by default rather than external
    | PropertyStateChanged              = 0b00000001000 // create events of state property on each state change
    | OnlyAnalyse                       = 0b00000010000 // only analyse don't generate anything
    | AutoEntryExitActions              = 0b00000100000 // auto create events for entry and exit actions for all states
    | TestingFeatures                   = 0b00001000000 // test functions for test features of fsm
    | TransitionCompleted               = 0b00010000000 // transition on complete of transition
    | Logging                           = 0b00100000000 // logging information to output window
    | ForceFieldConcurrentStates        = 0b01000000000 // force field concurrent states pattern, removes states explosion in large number of concurrent states but a little slower
    | ForceConcurrentStateCombination   = 0b10000000000 // force concurrent state combination pattern for concurrent states, faster but generates more code with exponential number of states and transition, good for little concurrent states number
    | ParseDebug                        = 0b100000000000 // enable parse debugging
  }

  [Record]
  public class MachineFlags
  {
    [FlagAccessor (AutoInitial, 
                LocalDefault, 
                Debug, 
                //CompletionStrict, 
                PropertyStateChanged, 
                OnlyAnalyse, 
                AutoEntryExitActions,
                TestingFeatures,
                TransitionCompleted,
                Logging,
                ForceFieldConcurrentStates,
                ForceConcurrentStateCombination,
                ParseDebug
                )]
    [NeedChange]
    public flags : MachineFlag;
    public errors : list[string] = [];

  }

  [Flags]
  public enum ActionFlags
  {
    | None
  }

  [Flags]
  public enum ActivityFlag
  {
    | None
    | NoCancel = 0b0001
    //| Concurrently = 0b0001 // run several activities concurrently in separate task
    //| NoWaitCancel = 0b0010 // no wait of canceling activity
    //| NotLong      = 0b0100 // this is not long activity (eg fast action), this implies that parallel task create with specific option, 
                            // prevents long activity in the planner see TaskCreationOptions.LongRunning (this is default for activities)
  }

  public enum JunctionType
  {
    | Junction
    | Choice
    | Merge
  }


  [Lens]
  [Record]
  public class JunctionNode : LocatedNode, IGeneralTree[JunctionNode]
  {
    //[NeedChange(action, to)]
    public guard  : GuardNode;
    public action : option[Actions];
    public to     : TargetType;

    public ExecStr : string
    {
      [Memoize]
      get
      {
        def action = if (action is Some(a)) $" / $a" else "";
        def guard = if (guard.ToString().IsEmpty()) "" else $" $guard";
        $"$guard$action"
      }
    }
    
    public override ToString() : string
    {
      $"$ExecStr => $to"
    }
    
    public Current : JunctionNode
    {
      get
      {
        this
      }
    }

    public ChildNodes : EnumerableLens[JunctionNode, JunctionNode]
    {
      [Memoize]
      get
      {
        JunctionNode.to_lens >> TargetType.PseudoState.node_lens >> PseudoStateModelNode.Junction.nodes_lens
        //match (to)
        //{
        //  | TargetType.PseudoState(PseudoStateModelNode.Junction(nodes = n)) => n
        //  | _                                                                => Enumerable.Empty()
        //}
      }
    }
  }

  [Lens]
  [Record]
  public variant PseudoStateModelNode : LocatedNode
  {
    | Initial { tran : list[StateNode.Transition]; }
    | History
      {
        type : HistoryType;
        default : option[StateNode.Transition];
      }

    | Fork { target : list[TargetType];}
    | Join { name : string; sources : list[NameIdentifier]; tran : StateNode.Transition; }
    | Junction
      {
        name  : string;
        nodes : list[JunctionNode];
        type  : JunctionType;

        Name : string
        {
          get
          {
            def type = TypeName(type);
            if (name != null) $"$type$name" else $"Unnamed$type"
          }
        }

        public static TypeName(type : JunctionType) : string
        {
          | Junction => "Junction"
          | Choice   => "Choice"
          | Merge    => "Merge"
        }

        override ToString() : string {Name}
      }

    | EntryPoint { name : string; tran : StateNode.Transition; }
    | ExitPoint { name : string; tran : option[StateNode.Transition]; }
    | Terminate 

  }

  [Lens]
  [Record]
  public variant TargetType : LocatedNode
  {
    | PseudoState { node : PseudoStateModelNode; }
    | Final
    //| State 
    //  {
    //    state : StateNode.State;
    //  }
    | Named { name : string; }
    //| SubMachine {machine : StateNode.State; state : string;}
    | Qualified 
      {
        parent : string; 
        target : TargetType;
        
        public FinalPath : list[string] * TargetType
        {
          [Memoize]
          get
          {
            def loop(t, res)
            {
              match (t)
              {
                | TargetType.Qualified(p, t) => loop(t, p :: res)
                | t                          => match (t)
                                                {
                                                  | PseudoState(Join(name = n))
                                                  | PseudoState(Junction(name = n))
                                                  | PseudoState(EntryPoint(name = n))
                                                  | PseudoState(ExitPoint(name = n))
                                                  | Named(name = n)                   => ((n :: res).Rev(), null)
                                                  | _                                 => (res.Rev(), t)
                                                }
              }
            }
            
            loop(this, [])
          }
        }
        
        public PathName : string
        {
          [Memoize]
          get
          {
            def path = Path[0];
            $<#..$(path;".")#>
          }
        }
        
        public Path : list[string] * TargetType
        {
          [Memoize]
          get
          {
            def loop(t, res)
            {
              match (t)
              {
                | TargetType.Qualified(p, t) => loop(t, p :: res)
                | _                          => (res.Rev(), t)
              }
            }

            loop(this, [])
          }
        }
      }
    | Self
    | NoTarget

    str : string
    {
      [Memoize]
      get
      {
        match (this)
        {
          | Final          => "Final"
          | Named(n)       => n
          | Qualified as q => def (p, t) = q.Path; 
                              $<#..$(p;".").$t#>
          | Self           => "Self"
          | NoTarget       => "NoTarget"
          | PseudoState(p) => $"$p"
        }
      }
    }
    
    public override ToString() : string
    {
      str
    }
  }

}
