// statenode.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using SCG = System.Collections.Generic;
using Nemerle.Compiler;
using CommonLib.Macros;

namespace Nemerle.Statechart
{
  
  using CommonLib.Macros.LensUtils;
  
  [Record]
  public variant StateType
  {
    | State
    | Final
    | SubMachine { type : string; unresolved : bool }
    | SubRegion
    | Region
    
    public override ToString() : string
    {
      match (this)
      {
        | State            => "State"
        | Final            => "Final"
        | SubMachine(t, _) => $"SubMachine_$t"
        | SubRegion        => "SubRegion"
        | Region           => "Region"
      }
    }
  }

  public enum TransitionKind
  {
    | Internal
    | Local
    | External
    | Initial
    | History
  }

  [Lens]
  [Record]
  public variant StateNode : LocatedNode, IGeneralTree[StateNode]
  {
    | Flags { flags : MachineFlags; }
    | Name { name   : string; }
    | Using { from : string;}
    | EventClassDecl
      {
        name    : NameIdentifier;
        events  : list[string];
      }
    | EventDecl 
      { 
        name : string; 
        parms_type : list[string]; 
        
        public override ToString() : string
        {
          $"Event_$name(..$parms_type)"
        }
      }
    | Include {file : string;}
    | StateMachine
      {
        flags : MachineFlags;
        name  : string;
        [NeedChange(Id)]
        state : State;
        usings : list[Using] = [];
        event_decls : list[EventDecl] = [];
        event_classes : list[EventClassDecl] = [];
        errors : list[Error];
        
        //public static state_lens : Lens[StateNode.StateMachine, State] = Lens(_.state, _.ChangeState(_));
        
        public AddTopDecls(b : StateMachine) : StateMachine
        {
          def flags = MachineFlags(flags.flags | b.flags.flags, flags.errors + b.flags.errors);
          def name = if (name != null) name else b.name;
          StateNode.StateMachine(pos, location, Id, flags, name, state, usings + b.usings, event_decls + b.event_decls, event_classes + b.event_classes, errors + b.errors)
        }
        
        type t = StateNode.State;
        
        GetErrors() : IEnumerable[Error]
        {
          TreeUtils.Fold(state, [], _.sub_states, (x, a) => a.Concat(x.errors)).Concat(errors)
          //StateParts.SelectMany(_.errors)
        }
       
        public Rebuild(ch : list[StateNode]) : StateNode.StateMachine
        {
          def first = ch.First();
          if (state != first : object)
          {
            ChangeState(first :> StateNode.State)
          } else this
        }
      }

      
        
    | State
      {
        this(pos : int, n : string, type : StateType) { base(pos, Location.Default, -1);name = n; this.type = type; }
        
        //public static transitions_lens : Lens[StateNode.State, list[Transition]] = Lens(_.transitions, _.ChangeTransitions(_));
        //public static name_lens : Lens[StateNode.State, string] = Lens(_.name, _.ChangeName(_));
        //{
        //  [Memoize]
        //  get
        //  {
            
            
        //  }
        //}
        
        name          : string;        
        parent        : option[string] = None();
        attributes    : list[StateAttribute] = [];
        entry         : list[Entry] = [];
        exit          : list[Exit] = [];
        transitions   : list[Transition] = [];
        do_activity   : list[DoActivity] = [];
        defer         : list[Defer] = [];
        [NeedChange(Id, pseudo_states)]
        sub_states    : list[State] = [];
        pseudo_states : list[PseudoState] = [];
        type          : StateType;
        errors        : list[Error] = [];
        include       : list[Include] = [];
     
        public Rebuild(ch : list[StateNode]) : StateNode.State
        {
          //def lens = transitions_lens >> Transition.guard_lens >> GuardNode.ParseString.expr_lens;
          //def a = lens.Map(this, _ + "123");
          if (sub_states != ch : object)
          {
            ChangeSubStates(ch.Map(x => x :> StateNode.State));
          } else this
        }
        
        public Instantiate(submachine : State) : State
        {
          State(pos, location, Id, name, parent, attributes, 
                entry, 
                exit, 
                transitions + submachine.transitions, 
                do_activity, 
                defer + submachine.defer, 
                submachine.sub_states, 
                pseudo_states + submachine.pseudo_states, 
                submachine.type, 
                errors, include)
        }
        
        public override ToString() : string
        {
          $"StateNode.State $name"
        }
      }

    | Entry
      {
        attrib : ActionFlags;
        action : Actions;
      }
    | Exit
      {
        attrib : ActionFlags;
        action : Actions;
      }
    | Defer { [NeedChange] evt : list[TransitionEvent]; }
    | Error { node : StateNode; }
    | DoActivity {[NeedChange] action : Actions;flags : ActivityFlag;}
    | Transition
      {
        //public static guard_lens : Lens[StateNode.Transition, GuardNode] = Lens(_.guard, _.ChangeGuard(_));
        
        from   : TargetType;
        [NeedChange(from, guard, action, to)]
        evt    : list[TransitionEvent] = [];
        [NeedChange(action, to)]
        guard  : GuardNode;
        action : option[Actions];
        to     : TargetType;
        kind   : TransitionKind;
        
        public ExecStr(evt : TransitionEvent) : string
        {
          def evt = if (evt is TransitionEvent.Normal(name = null)) "" else evt.ToString();
          def action = if (action is Some(a)) $" / $a" else "";
          def guard = if (guard.ToString().IsEmpty()) "" else $" $guard";
          $"$evt$guard$action"
        }
        
        Str : string
        {
          [Memoize]
          get
          {
            def action = if (action is Some(a)) $" / $a" else "";
            def guard = if (guard.ToString().IsEmpty()) "" else $" $guard";
            def to = match (kind, to)
            {
              | (_, TargetType.NoTarget) 
              | (TransitionKind.Internal, _) => ""
              | _                            => $" => $to"
            }
            $<#..$(evt; ",")$guard$action$to#>
          }
        }
        
        public override ToString() : string { Str }
      }
    | PseudoState { node : PseudoStateModelNode; }
    | Region
    | Sequence { lst : list[StateNode]; }
    
    public ChildNodes : EnumerableLens[StateNode, StateNode]
    {
      [Memoize]
      get
      {
        def st1 = StateMachine.state_lens.ConvertEnum(x => ListUtils.SingleElement(x : StateNode), x => x.First() :> State).ToBase();
        def st2 = State.sub_states_lens.ConvertEnum(_ : IEnumerable[StateNode], _.Map(_ :> State)).ToBase();
        def st3 = Sequence.lst_lens.ConvertEnum(x => x, _.NToList()).ToBase();
        (st1 | st2 | st3).ToEnum()
      }//EnumerableLens(_.ChildNodes, _.Rebuild(_));
    }
    
    //public ChildNodes : IEnumerable[StateNode]
    //{
    //  [Memoize]
    //  get
    //  {
    //    match (this)
    //    {
    //      | StateNode.StateMachine as st => StateMachine.state_lens.Get(st) |> ListUtils.SingleElement
    //      | State as st                  => State.sub_states_lens.Get(st)
    //      | Sequence as st               => Sequence.lst_lens.Get(st)
    //      | _                                 => Enumerable.Empty()
    //    }
    //  }
    //}
    
    public static Combine(a : StateMachine, b : StateMachine) : StateMachine
    {
      def pos = if (a.location.File == b.location.File) Math.Min(a.pos, b.pos) else b.pos;
      def flags = MachineFlags(a.flags.flags | b.flags.flags, a.flags.errors + b.flags.errors);
      def aname = a.name ?? "";
      def bname = b.name ?? "";
      def name = if (aname.Length > bname.Length) aname else bname;
      def state = State.Combine(a.state, b.state);
      StateNode.StateMachine(pos, a.Id, flags, name, state, a.usings + b.usings, a.event_decls + b.event_decls, a.event_classes + b.event_classes, a.errors + b.errors);
    }

        
    public static Combine(a : State, b : State) : State
    {
      def entry = a.entry + b.entry;
      def exit = a.exit + b.exit;
      def tran = a.transitions + b.transitions;
      def doact = a.do_activity + b.do_activity;
      def err = a.errors + b.errors;
      def defer = a.defer + b.defer;
      def pseudo = a.pseudo_states + b.pseudo_states;
      def sub = a.sub_states + b.sub_states;
      def pos = if (a.location.File == b.location.File) Math.Min(a.pos, b.pos) else b.pos;
      def include = a.include + b.include;
      StateNode.State(pos, a.Id, null, None(), [], entry, exit, tran, doact, defer, sub, pseudo, StateType.State(), err, include)
    }    
    
    //[RecordIgnore]
    //[NeedChange]
    public Id : int;

    public override Equals(obj : object) : bool
    {
      this == obj
    }
    
    public override GetHashCode() : int
    {
      Id
    }
  }

}
