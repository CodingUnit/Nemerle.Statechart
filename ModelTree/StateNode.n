// statenode.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using SCG = System.Collections.Generic;
using Nemerle.Compiler;
using CommonLib.Macros;

namespace Nemerle.Statechart
{


  [Record]
  public variant StateType
  {
    | State
    | Final
    | SubMachine { type : string; unresolved : bool }
    | SubRegion
    | Region
    
    public override ToString() : string
    {
      match (this)
      {
        | State            => "State"
        | Final            => "Final"
        | SubMachine(t, _) => $"SubMachine_$t"
        | SubRegion        => "SubRegion"
        | Region           => "Region"
      }
    }
  }

  public enum TransitionKind
  {
    | Internal
    | Local
    | External
    | Initial
    | History
  }

  [Record]
  public variant StateNode : LocatedNode, IGeneralTree[StateNode]
  {
    | Flags
      {
        flags : MachineFlags;
      }

    | Name { name   : string; }
    | Using { from : string;}
    | EventClassDecl
      {
        name    : NameIdentifier;
        events  : list[string];
      }
    | EventDecl 
      { 
        name : string; 
        parms_type : list[string]; 
        
        public override ToString() : string
        {
          $"Event_$name(..$parms_type)"
        }
      }
    | StateMachine
      {
        flags : MachineFlags;
        [NeedChange]
        name  : string;
        state : State;
        usings : list[Using] = [];
        event_decls : list[EventDecl] = [];
        event_classes : list[EventClassDecl] = [];
        errors : list[Error];
        
        GetErrors() : IEnumerable[Error]
        {
          TreeUtils.Fold(state, [], _.sub_states, (x, a) => a.Concat(x.errors)).Concat(errors)
          //StateParts.SelectMany(_.errors)
        }
      }

    | State
      {
        this(pos : int, n : string, type : StateType) { base(pos);name = n; this.type = type; }
        
        name          : string;
        parent        : option[string] = None();
        attributes    : list[StateAttribute] = [];
        entry         : list[Entry] = [];
        exit          : list[Exit] = [];
        [NeedChange]
        transitions   : list[Transition] = [];
        do_activity   : list[DoActivity] = [];
        defer         : list[Defer] = [];
        [NeedChange]
        sub_states    : list[State] = [];
        pseudo_states : list[PseudoState] = [];
        type          : StateType;
        errors        : list[Error] = [];

        public Instantiate(submachine_instance : State) : State
        {
          State(pos, name, parent, attributes, 
                entry + submachine_instance.entry, 
                exit + submachine_instance.exit, 
                transitions + submachine_instance.transitions, 
                do_activity + submachine_instance.do_activity, 
                defer + submachine_instance.defer, 
                submachine_instance.sub_states, 
                pseudo_states + submachine_instance.pseudo_states, 
                submachine_instance.type, 
                errors + submachine_instance.errors)
        }
        
        public override ToString() : string
        {
          $"StateNode.State $name"
        }
      }

    | Entry
      {
        attrib : ActionFlags;
        action : Actions;
      }
    | Exit
      {
        attrib : ActionFlags;
        action : Actions;
      }
    | Defer
      {
        evt : list[TransitionEvent];
      }
    | Error { node : StateNode; }
    | DoActivity {action : Actions;flags : ActivityFlag;}
    | Transition
      {
        [NeedChange]
        from   : TargetType;
        evt    : list[TransitionEvent] = [];
        guard  : GuardNode;
        action : option[Actions];
        to     : TargetType;
        kind   : TransitionKind;
        
        public ExecStr(evt : TransitionEvent) : string
        {
          def evt = if (evt is TransitionEvent.Normal(name = null)) "" else evt.ToString();
          def action = if (action is Some(a)) $" / $a" else "";
          def guard = if (guard.ToString().IsEmpty()) "" else $" $guard";
          $"$evt$guard$action"
        }
        
        Str : string
        {
          [Memoize]
          get
          {
            def action = if (action is Some(a)) $" / $a" else "";
            def guard = if (guard.ToString().IsEmpty()) "" else $" $guard";
            def to = match (kind, to)
            {
              | (_, TargetType.NoTarget) 
              | (TransitionKind.Internal, _) => ""
              | _                            => $" => $to"
            }
            $<#..$(evt; ",")$guard$action$to#>
          }
        }
        
        public override ToString() : string
        {
          Str
        }
      }
    | PseudoState
      {
        node : PseudoStateModelNode;
      }

    | Region
    | Sequence { lst : list[StateNode]; }
    
    public ChildNodes : IEnumerable[StateNode]
    {
      [Memoize]
      get
      {
        match (this)
        {
          | StateNode.StateMachine(state = s) => [s]
          | State(sub_states = s)             => s
          | Sequence(s)                       => s.AsEnumerable()
          | _                                 => Enumerable.Empty()
        }
      }
    }
    
    [NeedChange]
    static mutable id : int;
    
    public static GetMaxId() : int {id}
    public Id : int
    {
      [Memoize]
      get
      {
        System.Threading.Interlocked.Increment(ref id)
      }
    }
    
    public override Equals(obj : object) : bool
    {
      this == obj
    }
    
    public override GetHashCode() : int
    {
      Id
    }
  }

}
