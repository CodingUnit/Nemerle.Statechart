// statenode.n
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Statechart;
using SCG = System.Collections.Generic;
using Nemerle.Compiler;
using CommonLib.Macros;

namespace Nemerle.Statechart
{


  [Record]
  public variant StateType
  {
    | State
    | Final
    | SubMachine { type : string; unresolved : bool }
    | SubRegion
    | Region
    
    public override ToString() : string
    {
      match (this)
      {
        | State            => "State"
        | Final            => "Final"
        | SubMachine(t, _) => $"SubMachine_$t"
        | SubRegion        => "SubRegion"
        | Region           => "Region"
      }
    }
  }

  public enum TransitionKind
  {
    | Internal
    | Local
    | External
    | Initial
    | History
  }

  [Record]
  public variant StateNode : LocatedNode, IGeneralTree[StateNode]
  {
    | Flags
      {
        flags : MachineFlags;
      }

    | Name { name   : string; }
    | Using { from : string;}
    | EventClassDecl
      {
        name    : NameIdentifier;
        events  : list[string];
      }
    | EventDecl 
      { 
        name : string; 
        parms_type : list[string]; 
        
        public override ToString() : string
        {
          $"Event_$name(..$parms_type)"
        }
      }
    | Include {file : string;}
    | StateMachine
      {
        flags : MachineFlags;
        [NeedChange]
        name  : string;
        [NeedChange(Id)]
        [NeedChange]
        state : State;
        usings : list[Using] = [];
        event_decls : list[EventDecl] = [];
        event_classes : list[EventClassDecl] = [];
        errors : list[Error];
        
        public AddTopDecls(b : StateMachine) : StateMachine
        {
          def flags = MachineFlags(flags.flags | b.flags.flags, flags.errors + b.flags.errors);
          def name = if (name != null) name else b.name;
          StateNode.StateMachine(pos, Location, flags, name, state, usings + b.usings, event_decls + b.event_decls, event_classes + b.event_classes, errors + b.errors)
        }
        
        GetErrors() : IEnumerable[Error]
        {
          TreeUtils.Fold(state, [], _.sub_states, (x, a) => a.Concat(x.errors)).Concat(errors)
          //StateParts.SelectMany(_.errors)
        }
       
        public Rebuild(ch : list[StateNode]) : StateNode.StateMachine
        {
          def first = ch.First();
          if (state != first : object)
          {
            ChangeState(first :> StateNode.State)
          } else this
        }
      }

      
        
    | State
      {
        this(pos : int, n : string, type : StateType) { base(pos);name = n; this.type = type; }
        
        [NeedChange]
        name          : string;
        parent        : option[string] = None();
        attributes    : list[StateAttribute] = [];
        [NeedChange]
        entry         : list[Entry] = [];
        [NeedChange]
        exit          : list[Exit] = [];
        [NeedChange]
        transitions   : list[Transition] = [];
        [NeedChange]
        do_activity   : list[DoActivity] = [];
        defer         : list[Defer] = [];
        [NeedChange(Id, pseudo_states)]
        [NeedChange]
        sub_states    : list[State] = [];
        [NeedChange]
        pseudo_states : list[PseudoState] = [];
        type          : StateType;
        errors        : list[Error] = [];
        [NeedChange]
        include       : list[Include] = [];
     
        public Rebuild(ch : list[StateNode]) : StateNode.State
        {
          if (sub_states != ch : object)
          {
            ChangeSubStates(ch.Map(x => x :> StateNode.State));
          } else this
        }
        
        public Instantiate(submachine : State) : State
        {
          State(pos, Location, name, parent, attributes, 
                entry, 
                exit, 
                transitions + submachine.transitions, 
                do_activity, 
                defer + submachine.defer, 
                submachine.sub_states, 
                pseudo_states + submachine.pseudo_states, 
                submachine.type, 
                errors, include)
        }
        
        public override ToString() : string
        {
          $"StateNode.State $name"
        }
      }

    | Entry
      {
        attrib : ActionFlags;
        [NeedChange]
        action : Actions;
      }
    | Exit
      {
        attrib : ActionFlags;
        [NeedChange]
        action : Actions;
      }
    | Defer
      {
        evt : list[TransitionEvent];
      }
    | Error { node : StateNode; }
    | DoActivity {[NeedChange] action : Actions;flags : ActivityFlag;}
    | Transition
      {
        [NeedChange]
        from   : TargetType;
        evt    : list[TransitionEvent] = [];
        [NeedChange(action, to)]
        [NeedChange]
        guard  : GuardNode;
        [NeedChange]
        action : option[Actions];
        [NeedChange]
        to     : TargetType;
        kind   : TransitionKind;
        
        public ExecStr(evt : TransitionEvent) : string
        {
          def evt = if (evt is TransitionEvent.Normal(name = null)) "" else evt.ToString();
          def action = if (action is Some(a)) $" / $a" else "";
          def guard = if (guard.ToString().IsEmpty()) "" else $" $guard";
          $"$evt$guard$action"
        }
        
        Str : string
        {
          [Memoize]
          get
          {
            def action = if (action is Some(a)) $" / $a" else "";
            def guard = if (guard.ToString().IsEmpty()) "" else $" $guard";
            def to = match (kind, to)
            {
              | (_, TargetType.NoTarget) 
              | (TransitionKind.Internal, _) => ""
              | _                            => $" => $to"
            }
            $<#..$(evt; ",")$guard$action$to#>
          }
        }
        
        public override ToString() : string
        {
          Str
        }
      }
    | PseudoState
      {
        [NeedChange]
        node : PseudoStateModelNode;
      }

    | Region
    | Sequence { lst : list[StateNode]; }
    
    public ChildNodes : IEnumerable[StateNode]
    {
      [Memoize]
      get
      {
        match (this)
        {
          | StateNode.StateMachine(state = s) => [s]
          | State(sub_states = s)             => s
          | Sequence(s)                       => s.AsEnumerable()
          | _                                 => Enumerable.Empty()
        }
      }
    }
    
    public static Combine(a : StateMachine, b : StateMachine) : StateMachine
    {
      def pos = if (a.Location.File == b.Location.File) Math.Min(a.pos, b.pos) else b.pos;
      def flags = MachineFlags(a.flags.flags | b.flags.flags, a.flags.errors + b.flags.errors);
      def aname = a.name ?? "";
      def bname = b.name ?? "";
      def name = if (aname.Length > bname.Length) aname else bname;
      def state = State.Combine(a.state, b.state);
      StateNode.StateMachine(pos, flags, name, state, a.usings + b.usings, a.event_decls + b.event_decls, a.event_classes + b.event_classes, a.errors + b.errors);
    }

        
    public static Combine(a : State, b : State) : State
    {
      def entry = a.entry + b.entry;
      def exit = a.exit + b.exit;
      def tran = a.transitions + b.transitions;
      def doact = a.do_activity + b.do_activity;
      def err = a.errors + b.errors;
      def defer = a.defer + b.defer;
      def pseudo = a.pseudo_states + b.pseudo_states;
      def sub = a.sub_states + b.sub_states;
      def pos = if (a.Location.File == b.Location.File) Math.Min(a.pos, b.pos) else b.pos;
      def include = a.include + b.include;
      StateNode.State(pos, null, None(), [], entry, exit, tran, doact, defer, sub, pseudo, StateType.State(), err, include)
    }    
    
    [RecordIgnore]
    [NeedChange]
    public Id : int;
    
    public override Equals(obj : object) : bool
    {
      this == obj
    }
    
    public override GetHashCode() : int
    {
      Id
    }
  }

}
