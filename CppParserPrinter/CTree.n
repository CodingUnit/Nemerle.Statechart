using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using CommonLib.Macros;

namespace CppParserPrinter
{
  // public:
  public variant CMod
  {
    | Private
    | Public
    | Protected
  }

  public variant CTree : IPrintable
  {
      | Compound {decls : list[CTree] }
      | NameSpace { name : string; decls : CTree.Compound}
      | Type { type : CComplexType;}
      | Func { ret_type : CType; name : string; parms : list[CType]; body : CStatement.Compound }
      | Decl { specifiers : list[CSpec]; type : CType; decls : list[CDecl] }
      
      public override Print(del : int) : string
      {
        Delim($"$this", del)
      }
      
      public override ToString() : string
      {
        match (this)
        {
          //| Decl(spec, type, decls)          => $""
          | Type(t)                          => $"$t"
          | Func(ret, name, parms, body)     => $<#$ret $name(..$(parms;", "))$body#>
          | Compound(decls)                  => $"..$decls"
          | NameSpace(name, Compound(decls)) => 
$<#namespace $name
{
  ..$(decls;"\n")
}#>
        }
      }
  }

  public variant CMethodQualifier : IPrintable
  {
    | None
    | Const
    | Volatile
    
    public override Print(del : int) : string
    {
      ""
    }
  }
  
  // class содержимое
  public variant CTypeDecl : IPrintable
  {
      | Type { type : CComplexType } // nested type
      | Method { specifier : CSpec; func : CTree.Func; qualifiers : list[CMethodQualifier]; } // method
      | Modifier { mod : CMod; } // public:
      | Decl { var : CTree.Decl }
      | Constructor {cl : CComplexType.Class;parms : list[CType]; body : CStatement}
      | Destructor {specifier : CSpec;cl : CComplexType.Class;body : CStatement}
      | CopyAssignmentOperator {cl : CComplexType.Class;qualifiers : list[CMethodQualifier];body : CStatement}
      
      public override Print(del : int) : string
      {
        $"$this" |> Delim(_, del)
      }
      
      public override ToString() : string
      {
        match (this)
        {
          | Type(t)                                            => $"$t"
          | Method(spec, (ret, name, parms, body), qual)       => $<#$spec $ret $name(..$(parms; ", ")) ..$(qual; " ")$body#>
          | Modifier(m)                                        => $"$m:"
          | Decl(v)                                            => $"$v"
          | Constructor(Class(name = Some(name)), parms, body) => $<#$name(..$(parms; ",")$body#>
          | Destructor(spec, Class(name = Some(name)), body)   => $<#$spec~$name()$body#>
        }
      }
  }

  // typedef, enum, union, storage class auto, register, static, extern
  // type qualif const, volatile, restrict
  // function qualif inline, noreturn

  // тип переменных и параметров функции
  public variant CType : IPrintable
  {
      | Void
      | ComplexTypeDecl { type : CComplexType; }
      | Class { name : string; }
      | Enum  { name : string; }
      | Short
      | Byte
      | Char
      | UShort
      | UByte
      | UChar
      | Int
      | UInt
      | Long
      | ULong
      | Float
      | Double
      | LongLong
      | ULongLong
      | Pointer { type : CType; rank : list[int] }
      | Reference { type : CType }
      | Array { type : CType; rank : list[int]}
      
      public override Print(del : int) : string
      {
        ""
      }
  }

  public class CEnumDecl : IPrintable
  {
      public name : string;
      public val  : option[CConstExpr];
  }

  public class CUnionDecl : IPrintable
  {
      public name : string;
      public val  : option[CConstExpr];
  }

  public abstract class IPrintable
  {
    public Del(del : int) : string
    {
      del |> string(' ', _)
    }
    
    public abstract Print(delim : int) : string
    {
      
    }
    
    public Print(printer : IEnumerable[IPrintable], del : int, func : string -> string) : list[string]
    {
        (x => Print(x, del) |> func) |> printer.Map;
    }
    
    public Print(printer : IEnumerable[IPrintable], del : int) : list[string]
    {
        Print(_, del) |> printer.Map;
    }
    
    //public PrintOpt[T](printer : option[T], del : int, func : string -> string) : string where T : IPrintable
    //{
    //    def func = if (func != null) func else x => x;
    //    (x => Print(x, del) |> func) |> printer.MapDefault(_, "");
    //}
    
    public Print(printer : IPrintable, del : int) : string
    {
       printer.Print(del)
    }
    
    public Delim(str : string, del : int) : string
    {
      Del(del) + str |> _.Replace("\n", Del(del))
    }
  }
 
  //class Printer
  //{
  //  public static Delim(del : int) : string {string(' ', del)}
    
  //  public static Print(printer : IPrintable, del : int) : string
  //  {
  //      printer.Print(del)
  //  }
  //}
   [Record]
  public variant CComplexType : IPrintable
  {
      | Class { base_class : list[CMod * Class]; decls : list[CTypeDecl]; }
      | Struct { decls : list[CTypeDecl]; }
      | Enum { decls : list[CEnumDecl]}
      | Union { decls : list[CUnionDecl] }

      public name : option[string];

      public Name : string
      {
        [Memoize]
        get
        {
          name.Value
        }
      }
      //public static PrintMod(mod : CMod) : string
      //{
      //  | CMod.mod_private   => "private"
      //  | CMod.mod_public    => "public"
      //  | CMod.mod_protected => "protected"
      //}
      
      public override Print(delim : int) : string
      {
        Delim($"$this", delim)
      }
 
      public override ToString() : string
      {
        match (this)
        {
          | Class(b, decls) => def base1 = match (b)
                                           {
                                             | [] => ""
                                             | _  => def b = b.Map((x, y) => $"$x $y");
                                                     $<# : ..$(b; ", ")#>
                                                 
                                           }
$<#class $Name$base1
{
  ..$(decls; "\n")
};#>
                           
          | Struct(decls)   => 
$<#struct $Name
{
  ..$(decls; "\n")
};#>
        }
      }
  }


  public variant CSpec : IPrintable
  {
      | None
      | Typedef
      | Auto
      | Register
      | Static
      | Extern
      | ThreadLocal
      | Const
      | Volatile
      | Restrict
      | Inline
      | Noreturn
      | Virtual
      
      public override Print(del : int) : string
      {
        ""
      }
  }

  public variant CDecl
  {
      | Id
      | Pointer
      | Array
      | Function

      name : string;
      init : option[ CConstExpr ]
  }

  public class COper
  {
  }

  public variant CUnaryOper : COper
  {
      | PostInc
      | PreInc
      | PostDec
      | PreDec
      | PointerDereference
      | AddresGet
      | Not
      | Invert
      | Plus
      | Minus
      | Sizeof

      expr : CExpr;
  }

  public variant CReadOnlyOper : COper
  {
      | Not { expr : CConstExpr }
      | Invert {expr : CConstExpr }
      | Plus { expr : CConstExpr }
      | Minus { expr : CConstExpr }
      | Sizeof { expr : CConstExpr }
      | Binary { bin : CBinaryOper }
  }

  public variant CBinaryOper : COper
  {
      | Mul
      | Div
      | Add
      | Sub
      | Mod
      | LogicAnd
      | LogicOr
      | Xor
      | And
      | Or
      | LShift
      | RShift
      | CondOper { cond : CExpr } // ? :
      | Assign
      | AddAssign
      | SubAssign
      | MulAssign
      | DivAssign
      | ModAssign
      | AndAssign
      | OrAssign
      | XorAssign
      | LShiftAssign
      | RShfiftAssign
      | Equal
      | NotEqual
      | Greater
      | Lower
      | GreaterEqual
      | LowerEqual
      | ArrayIndex
      | MemberPointerAccess
      | MemberAccess
      | SeqOp // ,
      | CallFunc // a(...)
      | TypeConv // (type)expr

      left : CExpr;
      right : CExpr;
      
      public override ToString() : string
      {
        match (this)
        {
          | Mul        => $"$left * $right"
          | Div        => $"$left / $right"
          | LogicAnd   => $"$left & $right"
          | LowerEqual => $"$left <= $right"
          | ArrayIndex => $"$left[$right]"
          | SeqOp      => $"$left, $right"
          | CallFunc   => $"$left$right"
          | TypeConv   => $"$(left)$right"
        }
      }
  }

  public variant CConstExpr
  {
      | Compound { expr : list[CConstExpr] }
      | Int { val : int }
      | Enum { val : string }
      | Oper { oper : CReadOnlyOper }
      | Char { val : Char }
      | Float { val : double }
      | Sizeof { expr : CExpr }
  }

  public variant CStatement : IPrintable
  {
      | Compound { body : list[CStatement]}
      | Empty
      | Null // ;
      | Decl { type: CTree.Decl; }
      | Expression { expr : CExpr }
      | Return {ret : option[CExpr]}
      | Break
      | Continue
      | Goto { label : string; }
      | Label { label : string; body : CStatement }
      | Switch { cond : CExpr; cases : list[CSwitchCase]}
      | If { cond : CExpr; body : CStatement; else_body : option[CStatement]}
      | While { cond : CExpr; body : CStatement }
      | DoWhile { body : CStatement; cond : CExpr }
      | For { init : option[CInitExpr]; cond : option[CExpr]; iter : option[CExpr]; body : CStatement }
      
      public override Print(del : int) : string
      {
        match (this)
        {
          | Compound(b) => def delim = string(' ', del);
                           def b = b.Map(x => x.Print(del + 1));
                           $<#$delim{..$(b;"\n")$delim}#>
        }
      }
      
  }

  public variant CSwitchCase
  {
      | Default { body : CStatement }
      | Case { expr : CConstExpr; body : CStatement }
  }

  public variant CInitExpr
  {
      | Decl { decl : CStatement.Decl }
      | Expr { expr : CExpr }
  }

  public variant CConstant
  {
      | Int { val : int}
      | Float { val : float }
      | String { str : string }
  }

  public variant CExpr
  {
      | Compound { expr : list[CExpr]} // (a,b,c)
      | Id { name : string }
      | Constant { lit : CConstant }
      | Operator { op : COper }

  }

  public variant PreprocessorExpr
  {
    | Include {file : string;}
    | Define {parms : list[string]; body : string;}
  }
}
