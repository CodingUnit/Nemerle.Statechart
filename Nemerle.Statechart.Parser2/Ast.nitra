using Nitra;
using Nitra.Declarations;
using Nemerle.Statechart;

namespace Nemerle.Statechart.Grammar
{
  declaration StateMachine : State
  {
    //state : State;
    flags : MachineFlag;
  }

  abstract ast Action
  {
    | Normal { name : string; params : list[string];}
    | Expr   { expr : string;}
  }

  abstract ast StateAction : Action
  {
    | Entry
    | Exit
    | Do {flag : ActivityFlag;}

    flags : ActionFlags;
  }

  ast Transition
  {
    from    : Target;
    trigger : Event;
    guard   : Guard?;
    action  : Action?;
    target  : Target;
    kind    : TransitionKind;
  }

  abstract ast Guard
  {
    | Expr {str : string;}
    | Else
  }

  abstract ast Target
  {
    | PseudoState
    | Final
    | Qualified {path : list[string];target : Target;}
    | Self
  }

  abstract ast Event
  {
    | Normal { name : string; parms : list[string];}
    | Completion 
    | Timed {expr : TimedExprType; }
  }

  ast Defer
  {
    trigger : Event;
  }

  abstract declaration State
  {
    attributes    : list[StateAttribute];
    parent        : option[string];
    entry         : StateAction*;
    exit          : StateAction*;
    do            : StateAction*;
    transitions   : Transition*;
    defer         : Defer*;
    sub_states    : State*;
    pseudo_states : PseudoState*;
  }

  abstract ast PseudoState
  {
    | Initial {tran : Transition+;}
    | History {type : HistoryType; default : Transition?;}
    | Junction {name : string; nodes : JuncNode+;}
    | Choice   {name : string; nodes : JuncNode+;}
    | Join    {name : string; sources : list[NameIdentifier]; tran : Transition; }
    | Fork    { target : Target;}
    | EntryPoint {name : string; tran : Transition;} 
    | ExitPoint {name : string; tran : Transition?;} 
    | Terminate
  }

  ast JuncNode
  {
    guard  : Guard;
    action : Action?;
    to     : Target;
  }
}
