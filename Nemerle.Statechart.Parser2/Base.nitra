namespace Nemerle.Statechart.Grammar
{
  syntax module Base
  {
    using Nitra.Core;
    using Nitra;
    using Nitra.CStyleComments;

	token String
	{
		Value() : string;

		| Single = '\'' Str=(!'\'' Any)* '\'' {override Value = GetText(Str); }
		| Double = '"' Str=(!'"' Any)* '"' {override Value = GetText(Str); }
	}

	regex Integer  = ['0'..'9']+;
	alias Numeric = Integer;

  [SpanClass(Number)]
  regex FloatingNumber = "-"? Integer Fraction? Exponent?
  {
    regex Fraction = "." Integer;
    regex Exponent = ("E" | "e") ("-" | "+")? Integer;
  }

  regex KeywordToken =   EventNotKeywords | "state"    | "else"     | "flags"      | "name"    | "region"
                          | "and"          | "history"  | "defer"    | "terminate"  | "X"       | "x"      
                          | "join"         | "junction" | "choice"   | "merge"      | "class" 
                          | "event"        | "using"    | "submachine" | "state_conc";

  regex EventNotKeywords =   "(X)"       | "(x)"        | "entry:"   | "exit:" | "entry"
                          | "exit"       | "0"          | "initial"  | "do"    | "(H*)"
                          | "(H)"        | "deferred"   | "$>"       | "$<"
                          | "completion" | "_";

  regex PseudoKeywords = "exit:"  | "(X)" | "(x)" | "history";

  token QualifiedIdentifier = !TargetKeyword IdentifierBody
  {
    regex TargetTokens = PseudoKeywords | "self" | "$0" | "final" | "H" | "h" | "H*" | "h*" | "X" | "x";
    token TargetKeyword = TargetTokens !IdentifierPartCharacters;
  }

  regex IdentifierBody = IdentifierStartCharacter IdentifierPartCharacters*;

  regex IdentifierStartCharacter  = LetterCharacter | "_";
  regex IdentifierPartCharacters  = LetterCharacter 
                                    | DecimalDigitCharacter
                                    | ConnectingCharacter 
                                    | CombiningCharacter
                                    | FormattingCharacter
                                    | '-';

  token EventIdentifier = !Keyword IdentifierBody
  {
    token Keyword = EventNotKeywords !IdentifierPartCharacters;
  }

	token Identifier = !Keyword !'=' IdentifierBody
  {
    token Keyword = KeywordToken !IdentifierPartCharacters;
  }
    
  token AnyIdentifier = IdentifierBody;

  token NameIdentifier 
  {
	| AnyIdentifier 
	| String
  }

  syntax FullyQualified = (QualifiedIdentifier; '.')+;
  syntax FullyQualifiedAny = (AnyIdentifier; '.')+;

  syntax Attributes = '[' (Identifier; ',')+ ']';

  }
}
