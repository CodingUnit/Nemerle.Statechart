namespace Nemerle.Statechart.Grammar
{
  syntax module Base
  {
    using Nitra.Core;
    
    using PrettyPrint;
    using Outline;
    using TokenNames;
    using StandardSpanClasses;
    using Whitespaces;
    using CStyleComments;
    
/*
    extend token IgnoreToken
    {
      | [SpanClass(Comment)] SingleLineComment = SingleLineComment;
      | [SpanClass(Comment)] MultiLineComment;
    }*/

    regex Whitespace = [Zs] | '\t' | '\v' | '\f';
    regex Spaces     = Whitespace*;

	  regex Integer  = '0' | ['1'..'9'] ['0'..'9']*;
	  alias Numeric = Integer;

    [SpanClass(Number)]
    regex FloatingNumber = "-"? Integer Fraction? Exponent?
    {
      regex Digits   = ['0'..'9']+;
      regex Fraction = "." Digits;
      regex Exponent = ("E" | "e") ("-" | "+")? Digits;
    }

    regex KeywordToken =   EventNotKeywords | "state"    | "else"     | "flags"      | "name"    | "region"
                           | "and"          | "history"  | "defer"    | "terminate"  | "X"       | "x"      
                           | "join"         | "junction" | "choice"   | "merge"      | "event" Spaces "class" 
                           | "event"        | "using"    | "submachine";

    regex EventNotKeywords =   "(X)"       | "(x)"        | "entry:"   | "exit:" | "entry"
                            | "exit"       | "0"          | "initial"  | "do"    | "(H*)"
                            | "(H)"        | "deferred"   | "$>"       | "$<"
                            | "completion" | "_";

    regex PseudoKeywords = "exit:"  | "(X)" | "(x)" | "history";

    token QualifiedIdentifier = !TargetKeyword IdentifierBody
    {
      regex TargetTokens = PseudoKeywords | "self" | "$0" | "final" | "H" | "h" | "H*" | "h*" | "X" | "x";
      token TargetKeyword = TargetTokens !IdentifierPartCharacters;
    }

    regex IdentifierBody = IdentifierStartCharacter IdentifierPartCharacters*;

    regex LetterCharacter           = [Lu, Ll, Lt, Lm, Lo, Nl];
    regex CombiningCharacter        = [Mn, Mc];
    regex DecimalDigitCharacter     = [Nd];
    regex ConnectingCharacter       = [Pc];
    regex FormattingCharacter       = [Cf];

    regex IdentifierStartCharacter  = LetterCharacter | "_";
    regex IdentifierPartCharacters  = LetterCharacter 
                                      | DecimalDigitCharacter
                                      | ConnectingCharacter 
                                      | CombiningCharacter
                                      | FormattingCharacter
                                      | '-';

    token EventIdentifier = !Keyword IdentifierBody
    {
      token Keyword = EventNotKeywords !IdentifierPartCharacters;
    }

	  token Identifier = !Keyword !'=' IdentifierBody
    {
      token Keyword = KeywordToken !IdentifierPartCharacters;
    }
    
    token AnyIdentifier = IdentifierBody;

    syntax FullyQualified = (QualifiedIdentifier; '.')+;
    syntax FullyQualifiedAny = (AnyIdentifier; '.')+;

    syntax Attributes = '[' (Identifier; ',')+ ']';

  }
}
