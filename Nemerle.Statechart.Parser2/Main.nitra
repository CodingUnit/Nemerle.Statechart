language NemerleStatechart
{
  syntax module Nemerle.Statechart.Grammar.Main start rule StateMachine;
  //syntax module Nemerle.Statechart.Grammar.Actions;
  //syntax module Nemerle.Statechart.Grammar.Base;
  //syntax module Nemerle.Statechart.Grammar.Events;
  //syntax module Nemerle.Statechart.Grammar.PseudoStates;
  //syntax module Nemerle.Statechart.Grammar.Regions;
  //syntax module Nemerle.Statechart.Grammar.Targets;
  //syntax module Nemerle.Statechart.Grammar.Transitions;
}

namespace Nemerle.Statechart.Grammar
{
  syntax module Main
  {
    using Nitra.Core;
    using PseudoStates;
    using Transitions;
    using Actions;
    using Regions;
    using Events;
    using Base;

    syntax Parent = ':' ParentIdentifier
    {
      syntax ParentIdentifier 
      {
          | RegionReference 
          | FullyQualified
      }
    }


    syntax StateDecl
    {
      | State = Attributes?  "state" sm AnyIdentifier Parent? '{' RegionSequence '}'
      | Entry
      | Exit
      | SubMachine = Attributes? "submachine" AnyIdentifier TypeDecl? Parent? '{' RegionSequence '}'
      {
        syntax TypeDecl = '[' AnyIdentifier ']';
      }
      | DoActivity = Attributes? "do" ActList
      | DeferrableEvent
      | PseudoState
      | Transition
      | Regions
			| StateConcurrent
    }
    
    syntax StateMachine = StateMachineDecl*
    {
      regex SyntaxDelim = '=';// ':'

      syntax StateMachineDecl
      {
				| Flags = "flags" SyntaxDelim? (AnyIdentifier; FlagsDelim)+ ';'
				{
					token FlagsDelim
					{
						| Comma = ','
						| Spaces = s
					}
				}
				| Name  = "name" SyntaxDelim? NameIdentifier ';'
					{
						token NameIdentifier 
						{
							| AnyIdentifier 
							| CommaIdentifier = "\"" (!'\"' Any)+ "\""
						}
					}
				| Using = "using" FullyQualifiedAny ';'
				| EventClass
				| EventDecl
				| StateDecl
      }
    }

  }
}
