using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nitra;
using Nemerle.Compiler;
using Nemerle.Statechart.Grammar;

namespace Nemerle.Statechart
{
  using Nemerle.Statechart.Grammar.MainAst;
  using Nemerle.Statechart.Grammar.BaseAst;
  using Nemerle.Statechart.Grammar.MainAst.StateMachine.StateMachineDecl;
  using Nemerle.Statechart.Grammar.ActionsAst.ActionList.Action;
  /// <summary>
  /// Description of Parser.
  /// </summary>
  public class Parser
  {
    public flags_map : Hashtable[string, MachineFlag];
    public env : GlobalEnv;
    
    public this(flags : list[string * MachineFlag], env : GlobalEnv)
    {
      this.env = env;
      flags_map = Hashtable(flags);
    }
    
    public Parse(loc : Nemerle.Compiler.Location, text : string) : StateNode.StateMachine * list[Error]
    {
      def parserHost = ParserHost();
      if (string.IsNullOrWhiteSpace(text)) (null, []) else
      {
        def source = SourceSnapshot(text, loc.FileIndex, loc.File);
        def result = Main.StateMachine(source, parserHost);
        def ast = MainAstWalkers.StateMachine(result);
        
        if (result.IsSuccess) 
        {
          match (ast)
          {
            | MainAst.StateMachine.Ast as a => def res = ConvertTree(a);
                                               (res, [])
            | _                             => (null, [])
          }
          
        } else (null, result.GetErrors().NToList())
        //    def (line, col) = error.Location.StartLineColumn;
        //    WriteLine($<#$line:$col: $(error.Message)#>);
      }

    }
    
    GetFlags(str : list[string]) : MachineFlags
    {
      def err = List();
      def proc_tok(str, a)
      {
        def flag= if (flags_map.ContainsKey(str)) flags_map[str] else 
                    {
                      err.Add(str);
                      MachineFlag.None
                    }
        flag | a
      }
      
      def flags = str.FoldLeft(MachineFlag.None, proc_tok);
      MachineFlags(flags, err.NToList());
    }
    
    GetNameIdentifier(fully : FullyQualified.Ast) : NameIdentifier
    {
      def id = fully.Identifiers[0];
      def pos = fully.Location.StartPos;
      match (id)
      {
        | Identifier.Ast(i) :: []   => NameIdentifier.Name(pos, fully.GetText(i))
        | lst                       => def lst = GetIdentifierText(lst);
                                       def (last, lst) = lst.SplitLast();
                                       NameIdentifier.QualifiedName(pos, last, lst)
      }

    }
    
    GetIdentifierText(id : list[Identifier]) : list[string]
    {
      id.FoldRight([], (x, a) => if (x is Identifier.Ast) x.GetText() :: a else a);
    }
    
    parse_action(pos : int, text : string) : Actions
    {
      def expr = MainParser.ParseExpr(env, text);
      def act = FsmAction.Expr(pos, expr);
      Actions(pos, act :: [])
    }
    
    GetActions(lst : ActionsAst.ActionList.Action) : Actions
    {
      | SimpleActionList(ActionsAst.SimpleActionList.Ast((a, _))) => 
          def act = a.FoldLeft([], ((x, _), a) => if (x is Identifier.Ast as x) FsmAction.Normal(x.Location.StartPos, x.GetText(), []) :: a else a);
          Actions(lst.Location.StartPos, act)
      | Expr(ActionsAst.ActionList.Action.Expr.Nested.Expr.SimpleExpr as e) => 
          def text = e.GetText();
          parse_action(e.Location.StartPos, text);
      | Expr(ActionsAst.ActionList.Action.Expr.Nested.Expr.LongExprAction(_, e, _)) => 
          def text = e.GetText();
          parse_action(e.Location.StartPos, text);
      | _ => Actions(lst.Location.StartPos, [])
    }
    
    CreateState(pos : int, name : string, decls : list[MainAst.StateDecl], type : StateType, parent : option[NameIdentifier]) : StateNode.State
    {
      mutable defer = [];
      mutable do_act = [];
      foreach (d in decls)
      {
        | StateDecl.DeferrableEvent(EventsAst.DeferrableEvent.Deferrable(Events = EventsAst.SimpleEventList.Ast((e, _)))) => 
            def lst = e.FoldLeft([], (x, a) => if (x is Identifier.Ast as x) TransitionEvent.Normal(x.Location.StartPos, x.GetText(), []) :: a else a);
            defer ::= StateNode.Defer(d.Location.StartPos, lst)
        | StateDecl.DoActivity(ActionsAst.DoActivity.Ast(ActionList = ActionsAst.ActionList.Ast(_, a)))                   => 
            def act = GetActions(a);
            do_act ::= StateNode.DoActivity(d.Location.StartPos, act, ActivityFlag.None);
      }
      null
    }
    
    ConvertTree(ast : MainAst.StateMachine.Ast) : StateNode.StateMachine
    {
      mutable flags = MachineFlag.None;
      mutable event_class = [];
      mutable event_decls = [];
      mutable names = [];
      mutable usings = [];
      mutable st_decl = [];
      mutable err = [];
      def decls = ast.StateMachineDecls;
      foreach (d in decls)
      {
        | Flags(Flags = (a, _))                                                                        => def data = GetIdentifierText(a);
                                                                                                          def fl = GetFlags(data);
                                                                                                          unless (fl.errors.IsEmpty()) err ::= StateNode.Flags(d.Location.StartPos, fl);
                                                                                                          flags |= fl.flags;
        | EventClass(EventsAst.EventClass.Ast(_, _, FullyQualified.Ast as f, o, _))                    => 
                                                                                                          def n = GetNameIdentifier(f);
                                                                                                          def evt = match (o)
                                                                                                                    {
                                                                                                                      | Some(EventsAst.EventClass.EventList.Ast(_, (e, _), _)) => GetIdentifierText(e)
                                                                                                                      | _                                                      => []
                                                                                                                    }
                                                                                                          event_class ::= StateNode.EventClassDecl(d.Location.StartPos, n, evt)
        | EventDecl(EventsAst.EventDecl.Ast(Name = Identifier.Ast as a, Types = (t, _)))               => 
                                                                                                          def name = a.GetText();
                                                                                                          def lst = GetIdentifierText(t);
                                                                                                          event_decls ::= StateNode.EventDecl(d.Location.StartPos, name, lst);
        | Name(Name = n)                                                                               => match (n)
                                                                                                          {
                                                                                                            | Name.Nested.NameIdentifier.CommaIdentifier(Body = i)       => def name = d.GetText(i);
                                                                                                                                                                            names ::= StateNode.Name(d.Location.StartPos, name);
                                                                                                            | Name.Nested.NameIdentifier.Identifier(Identifier.Ast as i) => def name = i.GetText();
                                                                                                                                                                            names ::= StateNode.Name(d.Location.StartPos, name);
                                                                                                            | _                                                          => ();
                                                                                                          }
        | Using(Type = FullyQualified.Ast as f)                                                        => def data = GetNameIdentifier(f);
                                                                                                          usings ::= StateNode.Using(d.Location.StartPos, data.FullName)
        | StateDecl as d                                                                               => st_decl ::= d.StateDecl;
        | _                                                                                            => ()
      }
     def st = CreateState(ast.Location.StartPos, null, st_decl, StateType.State(), None());
     def (name, error) = (names.Head, names.Tail);
     def error = error.Map(_ : StateNode) + err;
     def error = error.Map(x => StateNode.Error(x.pos, x));
     StateNode.StateMachine(ast.Location.StartPos, MachineFlags(flags, []), name.name, st, usings, event_decls, event_class, error)
    }
  }
}
