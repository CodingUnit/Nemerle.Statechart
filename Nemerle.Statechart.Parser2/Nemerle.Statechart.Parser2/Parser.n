using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nitra;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Statechart.Grammar;
using CommonLib.Macros;

namespace Nemerle.Statechart
{
  using Nemerle.Statechart.Grammar.MainParseTree;
  using Nemerle.Statechart.Grammar.BaseParseTree;
  using Nemerle.Statechart.Grammar.PseudoStatesParseTree;
  using Nemerle.Statechart.Grammar.TransitionsParseTree;
  using Nemerle.Statechart.Grammar.TargetsParseTree;
  using Nemerle.Statechart.Grammar.TransitionsParseTree.Guard;
  using Nemerle.Statechart.Grammar.MainParseTree.StateMachine.Nested.StateMachineDecl;
  using Nemerle.Statechart.Grammar.ActionsParseTree.ActionList.Nested.Action;
  using Nemerle.Statechart.Grammar.ActionsParseTree;
  /// <summary>
  /// Description of Parser.
  /// </summary>
  partial public class Parser
  {

    parse_action(pos : int, text : string) : Actions
    {
      Actions(pos, FsmAction.Expr(pos, parse_expr(text), text) :: [])
    }

    GetActions(lst : ActionsParseTree.ActionList) : Actions
    {
      match (lst.Action)
      {
        | SimpleAction(SimpleAction = a) => 
        
            def conv_simple(x, a)
            {
              match (x)
              {
                | ActionsParseTree.SimpleAction.AmbiguousOrMissingNode    => a
                | ActionsParseTree.SimpleAction.Nested.Action.Empty       => FsmAction.Empty :: a
                | ActionsParseTree.SimpleAction.Nested.Action.Simple(AnyIdentifier = n) as f with p = [] 
                | ActionsParseTree.SimpleAction.Nested.Action.Full(AnyIdentifier = n, AnyIdentifiersData = (p, _)) as f => 
                    FsmAction.Normal(f.Location.StartPos, n.IdentifierBodyData, p.Map(_.IdentifierBodyData)) :: a
                | _ => a
              }
            }
            def act = a.ActionsData[0].FoldRightO([], conv_simple);
            Actions(lst.Location.StartPos, act)
                
        | SimpleExpr(SimpleExpr = ActionsParseTree.SimpleExpr(Expr = e))            
        | BraceExpr(BraceExpr = ActionsParseTree.BraceExpr(Exprs = e)) =>
            def text = e.GetText();
            parse_action(e.Location.StartPos, text);
            
              
        | _ => Actions(lst.Location.StartPos, [])
      }
      //| _ => Actions(lst.Location.StartPos, [])
    }
    
    GetActions(lst : ActionsParseTree.ActList) : Actions
    {
      | Simple(ActionList = a) => GetActions(a)
      | BraceAction(BraceExpr = ActionsParseTree.BraceExpr(Exprs = e)) =>
          def text = e.GetText();
          parse_action(e.Location.StartPos, text);
      | _ => Actions(lst.Location.StartPos, [])
    }
    
    CreatePseudo(p : PseudoStatesParseTree.PseudoState) : option[StateNode.PseudoState]
    {
      def pos = p.Location.StartPos;
      def pseudo = match (p)
      {
        | PseudoState.Choice(AnyIdentifier = n, JunctionBody = b) => 
            def nodes = GetNodes(b);
            def name = n.GetText();
            PseudoStateModelNode.Junction(p.Location.StartPos, name, nodes, JunctionType.Choice)
            
        | PseudoState.EntryPoint(EntryPoint = PseudoStatesParseTree.EntryPoint(EntryPointHead = n, EntryPointTransition = tr)) => 
            match (GetEntryPointTran(tr))
            {
              | Some(tr) => 
                  match (n)
                  {
                    | PseudoStatesParseTree.EntryPoint.Nested.EntryPointHead.Ver1(AnyIdentifier = n)
                    | PseudoStatesParseTree.EntryPoint.Nested.EntryPointHead.Ver2(AnyIdentifier = n)
                    | PseudoStatesParseTree.EntryPoint.Nested.EntryPointHead.Ver3(AnyIdentifier = n) => 
                        def name = n.GetText();
                        PseudoStateModelNode.EntryPoint(pos, name, tr)
                    | _ => null
                  }
              | _ => null
                                
            }
        | PseudoState.ExitPoint(ExitPoint = PseudoStatesParseTree.ExitPoint(ExitPointDecl = PseudoStatesParseTree.ExitPointDecl(AnyIdentifier = n), ExitPointEnd = e)) => 
            def name = n.GetText();
            def tran = match (e)
            {
              | PseudoStatesParseTree.ExitPoint.Nested.ExitPointEnd.Tran(ExitPointTransition = tr) => GetEntryPointTran(tr)
              | _                                                                                  => None()
            }
            PseudoStateModelNode.ExitPoint(pos, name, tran)
            
        | PseudoState.History(History = PseudoStatesParseTree.History.HistoryDeep(HistoryEndOptData = t))    with type = HistoryType.Deep
        | PseudoState.History(History = PseudoStatesParseTree.History.HistoryShallow(HistoryEndOptData = t)) with type = HistoryType.Shallow => 
            def tran = match (t)
                       {
                         | Some(PseudoStatesParseTree.HistoryEnd.Tran(DefaultTransition = t)) => GetDefaultTran(t)
                         | _                                                                  => None()
                       }
            PseudoStateModelNode.History(pos, type, tran)
            
        | PseudoState.History(History = PseudoStatesParseTree.History.HistoryLong(Type = type, DefaultTransitionOptData = t)) => 
            match (type)
            {
              | PseudoStatesParseTree.History.HistoryLong.Nested.Type.Deep    with type = HistoryType.Deep
              | PseudoStatesParseTree.History.HistoryLong.Nested.Type.Shallow with type = HistoryType.Shallow =>
                 def tran = match (t)
                      {
                        | Some(t) => GetDefaultTran(t)
                        | _       => None()
                      }
                 PseudoStateModelNode.History(pos, type, tran)
              | _                                                       => null
            }
            
        | PseudoState.Initial(GuardOptData = g, ActionListOptData = a, InitialTarget = t) => 
            def act = a.Map(GetActions);
            def guard = g.MapDefault(GetGuard, GuardNode.Empty(-1));
            def tar = match (t)
            {
              | PseudoState.Initial.Nested.InitialTarget.Simple(SimpleTarget = t)                                       => 
                 match (GetSimpleTarget(t))
                 {
                   | Some(t) => StateNode.Transition(pos, TargetType.NoTarget(-1), [], guard, act, t, TransitionKind.Local) :: []
                   | _       => []
                 }
               
               
              | PseudoState.Initial.Nested.InitialTarget.JunctionTarget(JunctionTarget = t) => 
                 match (GetJunctionTarget(t, JunctionType.Junction))
                 {
                   | Some(TargetType.PseudoState(PseudoStateModelNode.Junction as j)) => 
                       j.nodes.Map(x => StateNode.Transition(x.pos, TargetType.NoTarget(-1), [], x.guard, x.action, x.to, TransitionKind.Local))
                   | _ => []
                 }
              | _ => []
            }
          
            match (tar)
            {
              | []  => null
              | lst => PseudoStateModelNode.Initial(pos, lst)
            }
        | PseudoState.Join(AnyIdentifier = n, TransitionPart = TransitionsParseTree.TransitionPart(GuardOptData = g, ActionListOptData = a, TransitionTarget = t)) => 
           def name = n.GetText();
           match (GetTran(p, None(), g, a, t, TransitionKind.External))
           {
             | Some(t) => PseudoStateModelNode.Join(pos, name, [], t)
             | _       => null
           }
           
        | PseudoState.Junction(AnyIdentifier = n, JunctionBody = b) => 
           def name = n.GetText();
           def nodes = GetNodes(b);
           PseudoStateModelNode.Junction(pos, name, nodes, JunctionType.Junction)
           
        | PseudoState.Merge(AnyIdentifier = n, TransitionPart = TransitionsParseTree.TransitionPart(GuardOptData = g, ActionListOptData = a, TransitionTarget = t)) =>
           def name = n.GetText();
           match (GetTran(p, None(), g, a, t, TransitionKind.External))
           {
             | Some(t) => def node = JunctionNode(pos, t.guard, t.action, t.to);
                          PseudoStateModelNode.Junction(pos, name, node :: [], JunctionType.Merge)
             | _       => null
           }
           
        | PseudoState.Terminate => PseudoStateModelNode.Terminate(pos)
        | _ => null
      }
      if (pseudo != null) Some(StateNode.PseudoState(pos, pseudo)) else None()
    }

    GetParent(par : MainParseTree.Parent) : option[string]
    {
      | MainParseTree.Parent(ParentIdentifier = MainParseTree.Parent.Nested.ParentIdentifier.RegionReference(RegionReference = r)) =>
          def parent = r.GetText();
          Some(parent)
      | MainParseTree.Parent(ParentIdentifier = MainParseTree.Parent.Nested.ParentIdentifier.FullyQualified(FullyQualified = FullyQualified(QualifiedIdentifiersData = (id, _)))) => Some($<#..$(id; ".")#>)
      | _ => None()
    }
    
    GetAttribute(attr : BaseParseTree.Attributes) : list[StateAttribute]
    {
      | BaseParseTree.Attributes.AmbiguousOrMissingNode => []
      | BaseParseTree.Attributes(IdentifiersData = (a, _)) => 
      
        def pos = attr.Location.StartPos;
        def check_attr(x)
        {
          if (x is BaseParseTree.Identifier.AmbiguousOrMissingNode) StateAttribute.Unknown(pos, null) else
            match (x.GetText())
            {
              | "Initial" => StateAttribute.Initial(pos)
              | str       => StateAttribute.Unknown(pos, str)
            }
        }
        
        a.Map(check_attr)
    }
    
    CreateState(st : StateDecl.State, type : StateType) : StateNode.State
    {
      //if (decls != null)
      //{
      //  CreateState(st, st.AnyIdentifier, st.ParentOptData, st.AttributesOptData, decls, type)
      //} else
      {
        //def regions = st.RegionSequence.StateDeclsesData[0];
        //def st_regions = regions.Map(x => CreateState(st, null, None(), None(), x, StateType.SubRegion())); // concurrent and regions
        CreateState(st, st.AnyIdentifier, st.ParentOptData, st.AttributesOptData, st.RegionSequence.StateDeclsesData[0], type)
        //CreateRegionFromSequence(st, regions)
      }
      //match (st)
      //{
      //  | StateDecl.State(a, _, n, p, _, d, _) as t => 
      //}
    }

    //CreateState(ast : Nitra.ParseTree, name : BaseParseTree.AnyIdentifier, parent : option[MainParseTree.Parent], attr : option[BaseParseTree.Attributes], decls : list[StateDecl], type : StateType, err : list[StateNode.Error] = null) : StateNode.State
    //{
    //  def name = name.GetText();
    //  def parent = if (parent is Some(p)) GetParent(p) else None();
    //  def attr = attr.MapDefault(GetAttribute, []);
    //  CreateState(ast.Location.StartPos, attr, name, decls, type, parent, err);
    //}
   
    
    CreateState(ast : Nitra.ParseTree, name : BaseParseTree.AnyIdentifier, parent : option[MainParseTree.Parent], attr : option[BaseParseTree.Attributes], decls : list[list[MainParseTree.StateDecl]], type : StateType, err : list[StateNode.Error] = null) : StateNode.State
    {
      def name = name?.GetText();
      def parent = if (parent is Some(p)) GetParent(p) else None();
      def attr = attr.MapDefault(GetAttribute, []);
      
      match (decls)
      {
        | [] with decls = []
        | [decls] => CreateState(ast.Location.StartPos, attr, name, decls, type, parent) 
        | r       => def regs = r.Map(x => CreateState(ast.Location.StartPos, [], null, x, StateType.SubRegion(), None()));
                     StateNode.State(ast.Location.StartPos, name, parent, attr, [], [], [], [], [], regs, [], StateType.Region(), err ?? []);
      }
      //
    }
    
    GetConcurrentDecls(decls : list[list[RegionsParseTree.StateConcDecl]]) : list[list[MainParseTree.StateDecl]] * list[StateNode.Error]
    {
      def decls = decls.Map(x => x.Partition(x => x is RegionsParseTree.StateConcDecl.DelimiterErr));
      def reg_err = decls.Map(x => x[0]).Flatten();
      def decls = decls.Map(x => x[1].Map(x => (x :> RegionsParseTree.StateConcDecl.StateDecl).StateDecl));
      def reg_err = reg_err.Map(x => StateNode.Error(x.Location.StartPos, StateNode.Region(x.Location.StartPos)));
      (decls, reg_err)
    }
    
    
                                                               
    CreateState(pos : int, attr : list[StateAttribute], name : string, decls : list[MainParseTree.StateDecl], type : StateType, parent : option[string], errors : list[StateNode.Error] = null) : StateNode.State
    {
      def defer  = List();
      def do_act = List();
      def entry  = List();
      def exit   = List();
      def pseudo = List();
      def states = List();
      def tran   = List();
      def err    = if (errors != null) List(errors) else List();
      //def decls = decls.FoldRightO([], (x, a) => if (x is MainParseTree.StateDecl.Sequence(h, t)) (h :: t) + a else x :: a);
      foreach (d in decls)
        {
          | MainParseTree.StateDecl.AmbiguousOrMissingNode => ()
          | StateDecl.DeferrableEvent(DeferrableEvent = EventsParseTree.DeferrableEvent.Deferrable(SimpleEventList = e))
          | StateDecl.DeferrableEvent(DeferrableEvent = EventsParseTree.DeferrableEvent.Deferred(SimpleEventList = e)) =>
              def lst = e.EventIdentifiersData[0].Map(x => TransitionEvent.Normal(x.Location.StartPos, x.GetText(), []));
              StateNode.Defer(d.Location.StartPos, lst) |> defer.Add
          | StateDecl.DoActivity as d => 
              def act = GetActions(d.ActList);
              StateNode.DoActivity(d.Location.StartPos, act, ActivityFlag.None) |> do_act.Add
          | StateDecl.Entry as e => 
              def act = GetActions(e.Entry.ActList);
              StateNode.Entry(d.Location.StartPos, ActionFlags.None, act) |> entry.Add
          | StateDecl.Exit as e => 
              def act = GetActions(e.Exit.ActList);
              StateNode.Exit(d.Location.StartPos, ActionFlags.None, act) |> exit.Add
          | StateDecl.PseudoState as p => match (CreatePseudo(p.PseudoState))
                                        {
                                          | Some(p) => pseudo.Add(p)
                                          | _       => ()
                                        }
          | StateDecl.Regions as r => def (st, e) = CreateRegion(r.Regions);
                                      err.AddRange(e);
                                      states.AddRange(st)
          
          | StateDecl.State as t => def state = CreateState(t, StateType.State()); 
                                    states.Add(state);
              
          | StateDecl.SubMachine as st => //(a, _, n, t, p, _, d, _) as st
             def type = st.TypeDeclOptData.MapDefault(x => x.AnyIdentifier.GetText(), null);
             def state = CreateState(st, st.AnyIdentifier, st.ParentOptData, st.AttributesOptData, st.RegionSequence.StateDeclsesData[0], StateType.SubMachine(type, true));
             states.Add(state);
             
          | StateDecl.Transition(Transition = TransitionsParseTree.Transition.NormalTransition as t) => 
             match (CreateTransition(t.NormalTransition))
             {
               | Some(t) => tran.Add(t)
               | _       => ()
             }
          | StateDecl.Transition(Transition = TransitionsParseTree.Transition.RelocateTransition as t) => 
             match (CreateRelocateTran(t))
             {
               | Some(t) => match (t)
                            {
                              | StateNode.Sequence(tr)     => def tr = tr.Map(x => x :> StateNode.Transition);
                                                              tran.AddRange(tr);
                              | StateNode.Transition as tr => tran.Add(tr)
                              | _                          => () // others not supported yet
                            }
               | _       => ()
             }
          | StateDecl.StateConcurrent(StateConcurrent = st) => def (decls, reg_err) = GetConcurrentDecls(st.StateConcDeclsData :: st.AndSubRegionsData.Map(x => x.StateConcDeclsData));
                                                               err.AddRange(reg_err);
                                                               def st = CreateState(st, st.AnyIdentifier, st.ParentOptData, st.AttributesOptData, decls, StateType.Region());
                                                               states.Add(st)
          | _ => ()
        }
      StateNode.State(pos, name, parent, attr, entry.NToList(), exit.NToList(), tran.NToList(), do_act.NToList(), defer.NToList(), states.NToList(), pseudo.NToList(), type, err.NToList())
    }

    CreateRegion(reg : RegionsParseTree.Regions) : list[StateNode.State] * list[StateNode.Error]
    {
      match (reg)
      {
        | RegionsParseTree.Regions.AmbiguousOrMissingNode => ([], [])
        | _ => 
            def decls = reg.StateConcDeclsData :: reg.AndSubRegionsData.Map(x => x.StateConcDeclsData);
            def (decls, err) = GetConcurrentDecls(decls);
            def state = decls.Map(x => CreateState(reg, null, None(), reg.AttributesOptData, [x], StateType.SubRegion()));
            (state, err)
         }
    }
    
    
    
  }
}
