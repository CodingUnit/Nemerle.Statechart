using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nitra;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Statechart.Grammar;

namespace Nemerle.Statechart
{
  using Nemerle.Statechart.Grammar.MainAst;
  using Nemerle.Statechart.Grammar.BaseAst;
  using Nemerle.Statechart.Grammar.PseudoStatesAst;
  using Nemerle.Statechart.Grammar.TransitionsAst;
  using Nemerle.Statechart.Grammar.TargetsAst;
  using Nemerle.Statechart.Grammar.TransitionsAst.Guard;
  using Nemerle.Statechart.Grammar.MainAst.StateMachine.StateMachineDecl;
  using Nemerle.Statechart.Grammar.ActionsAst.ActionList.Action;
  /// <summary>
  /// Description of Parser.
  /// </summary>
  partial public class Parser
  {

    parse_action(pos : int, text : string) : Actions
    {
      def expr = parse_expr(text);
      def act = FsmAction.Expr(pos, expr);
      Actions(pos, act :: [])
    }

    GetActions(lst : ActionsAst.ActionList) : Actions
    {
      | ActionsAst.ActionList.Ast(_, a) => 
          match (a)
          {
            | SimpleActionList(ActionsAst.SimpleActionList.Ast(ActionsAst.SimpleAction.Empty)) => Actions(a.Location.StartPos, [])
            | SimpleActionList(ActionsAst.SimpleActionList.Ast(ActionsAst.SimpleAction.List((a, _)))) => 
                def act = a.FoldBack([], ((x, _), a) => if (x is AnyIdentifier.Ast as x) FsmAction.Normal(x.Location.StartPos, x.GetText(), []) :: a else a);
                Actions(lst.Location.StartPos, act)
                
            | Expr(ActionsAst.ActionList.Action.Expr.Nested.Expr.SimpleExpr(e))
            | Expr(ActionsAst.ActionList.Action.Expr.Nested.Expr.LongExprAction(ActionsAst.LongExprAction.Ast( _, e, _)))
            | Expr(ActionsAst.ActionList.Action.Expr.Nested.Expr.BraceExpr(ActionsAst.BraceExpr.Ast(_, e, _))) => 
                def text = e.GetText();
                parse_action(e.Location.StartPos, text);
              
            | _ => Actions(lst.Location.StartPos, [])
          }
      | _ => Actions(lst.Location.StartPos, [])
    }
    
    GetActions(lst : ActionsAst.ActList) : Actions
    {
      | ActionsAst.ActList.Ast(_, a) => 
          match (a)
          {
            | SimpleActionList(ActionsAst.SimpleActionList.Ast(ActionsAst.SimpleAction.Empty), _) => Actions(a.Location.StartPos, [])
            | SimpleActionList(ActionsAst.SimpleActionList.Ast(ActionsAst.SimpleAction.List((a, _))), _) => 
                def act = a.FoldBack([], ((x, _), a) => if (x is AnyIdentifier.Ast as x) FsmAction.Normal(x.Location.StartPos, x.GetText(), []) :: a else a);
                Actions(lst.Location.StartPos, act)
            | Expr(ActionsAst.ActList.Action.Expr.Nested.Expr.SimpleExpr(ActionsAst.SimpleExpr.Ast(e), _))
            | Expr(ActionsAst.ActList.Action.Expr.Nested.Expr.LongExprAction(ActionsAst.LongExprAction.Ast( _, e, _)))
            | Expr(ActionsAst.ActList.Action.Expr.Nested.Expr.BraceExpr(ActionsAst.BraceExpr.Ast(_, e, _))) => 
                def text = e.GetText();
                parse_action(e.Location.StartPos, text);
              
            | _ => Actions(lst.Location.StartPos, [])
          }
      | _ => Actions(lst.Location.StartPos, [])
    }
    
    CreatePseudo(p : PseudoStatesAst.PseudoState) : option[StateNode.PseudoState]
    {
      def pos = p.Location.StartPos;
      def pseudo = match (p)
      {
        | PseudoState.Choice(_, AnyIdentifier.Ast as n, _, JunctionBody.Ast as b) => 
            def nodes = GetNodes(b);
            def name = n.GetText();
            PseudoStateModelNode.Junction(p.Location.StartPos, name, nodes, JunctionType.Choice)
            
        | PseudoState.EntryPoint(PseudoStatesAst.EntryPoint.Ast(n, TransitionsAst.EntryPointTransition.Ast as tr)) => 
            match (GetEntryPointTran(tr))
            {
              | Some(tr) => 
                  match (n)
                  {
                    | PseudoStatesAst.EntryPoint.EntryPointHead.Ver1(_, BaseAst.AnyIdentifier.Ast as n)
                    | PseudoStatesAst.EntryPoint.EntryPointHead.Ver2(BaseAst.AnyIdentifier.Ast as n, _)
                    | PseudoStatesAst.EntryPoint.EntryPointHead.Ver3(_, BaseAst.AnyIdentifier.Ast as n, _) => 
                        def name = n.GetText();
                        PseudoStateModelNode.EntryPoint(pos, name, tr)
                    | _ => null
                  }
              | _ => null
                                
            }
        | PseudoState.ExitPoint(PseudoStatesAst.ExitPoint.Ast(PseudoStatesAst.ExitPointDecl.Ast(_, BaseAst.AnyIdentifier.Ast as n), e)) => 
            def name = n.GetText();
            def tran = match (e)
            {
              | PseudoStatesAst.ExitPoint.ExitPointEnd.Tran(TransitionsAst.EntryPointTransition.Ast as tr) => GetEntryPointTran(tr)
              | _                                                                                          => None()
            }
            PseudoStateModelNode.ExitPoint(pos, name, tran)
        | PseudoState.History(PseudoStatesAst.History.HistoryDeep(_, t)) with type = HistoryType.Deep
        | PseudoState.History(PseudoStatesAst.History.HistoryShallow(_, t)) with type = HistoryType.Shallow => 
            def tran = match (t)
                       {
                         | Some((t, _)) => GetDefaultTran(t)
                         | _            => None()
                       }
            PseudoStateModelNode.History(pos, type, tran)
        | PseudoState.History(PseudoStatesAst.History.HistoryLong(_, _, type, t, _)) => 
            match (type)
            {
              | PseudoStatesAst.History.HistoryLong.Nested.Type.Deep    with type = HistoryType.Deep
              | PseudoStatesAst.History.HistoryLong.Nested.Type.Shallow with type = HistoryType.Shallow =>
                 def tran = match (t)
                      {
                        | Some(t) => GetDefaultTran(t)
                        | _       => None()
                      }
                 PseudoStateModelNode.History(pos, type, tran)
              | _                                                       => null
            }
            
        | PseudoState.Initial(_, g, a, _, t) => 
            def act = a.Map(GetActions);
            def guard = g.MapDefault(GetGuard, GuardNode.Empty(-1));
            def tar = match (t)
            {
              | PseudoState.Initial.Nested.InitialTarget.Simple(t, _)                                       => 
                 match (GetSimpleTarget(t))
                 {
                   | Some(t) => StateNode.Transition(pos, TargetType.NoTarget(-1), [], guard, act, t, TransitionKind.Local) :: []
                   | _       => []
                 }
               
               
              | PseudoState.Initial.Nested.InitialTarget.JunctionTarget(TargetsAst.JunctionTarget.Ast as t) => 
                 match (GetJunctionTarget(t, JunctionType.Junction))
                 {
                   | Some(TargetType.PseudoState(PseudoStateModelNode.Junction as j)) => 
                       j.nodes.Map(x => StateNode.Transition(x.pos, TargetType.NoTarget(-1), [], x.guard, x.action, x.to, TransitionKind.Local))
                   | _ => []
                 }
              | _ => []
            }
          
            match (tar)
            {
              | []  => null
              | lst => PseudoStateModelNode.Initial(pos, lst)
            }
        | PseudoState.Join(_, BaseAst.AnyIdentifier.Ast as n, TransitionsAst.TransitionPart.Ast(g, a, _, t)) => 
           def name = n.GetText();
           match (GetTran(p, None(), g, a, t, TransitionKind.External))
           {
             | Some(t) => PseudoStateModelNode.Join(pos, name, [], t)
             | _       => null
           }
           
        | PseudoState.Junction(_, n, PseudoStatesAst.JunctionBody.Ast as b) => 
           def name = n.GetText();
           def nodes = GetNodes(b);
           PseudoStateModelNode.Junction(pos, name, nodes, JunctionType.Junction)
           
        | PseudoState.Merge(_, n, TransitionsAst.TransitionPart.Ast(g, a, _, t)) =>
           def name = n.GetText();
           match (GetTran(p, None(), g, a, t, TransitionKind.External))
           {
             | Some(t) => def node = JunctionNode(pos, t.guard, t.action, t.to);
                          PseudoStateModelNode.Junction(pos, name, node :: [], JunctionType.Merge)
             | _       => null
           }
           
        | PseudoState.Terminate => PseudoStateModelNode.Terminate(pos)
        | _ => null
      }
      if (pseudo != null) Some(StateNode.PseudoState(pos, pseudo)) else None()
    }

    GetParent(par : MainAst.Parent) : option[string]
    {
      | MainAst.Parent.Ast(_, MainAst.Parent.ParentIdentifier.RegionReference(RegionsAst.RegionReference.Ast as r)) =>
          def parent = r.GetText();
          Some(parent)
      | MainAst.Parent.Ast(_, MainAst.Parent.ParentIdentifier.FullyQualified(BaseAst.FullyQualified.Ast((id, _)))) => Some($<#..$(id; ".")#>)
      | _ => None()
    }
    
    GetAttribute(attr : BaseAst.Attributes) : list[StateAttribute]
    {
      | BaseAst.Attributes.Ast(_, (a, _), _) => 
      
        def pos = attr.Location.StartPos;
        def check_attr(x)
        {
          if (x is BaseAst.Identifier.Ast as x) 
            match (x.GetText())
            {
              | "Initial" => StateAttribute.Initial(pos)
              | str       => StateAttribute.Unknown(pos, str)
            }
           else StateAttribute.Unknown(pos, null)
        }
        
        a.Map(check_attr)
      | _ => []
    }
    
    CreateState(st : StateDecl.State, decls : list[MainAst.StateDecl], type : StateType) : StateNode.State
    {
      match (st)
      {
        | StateDecl.State(a, _, n, p, _, d, _) as t => CreateState(t, n, p, a, decls ?? d, type)
      }
    }

    CreateState(ast : Nitra.Ast, name : BaseAst.AnyIdentifier, parent : option[MainAst.Parent], attr : option[BaseAst.Attributes], decls : list[MainAst.StateDecl], type : StateType) : StateNode.State
    {
      def name = name.GetText();
      def parent = if (parent is Some(p)) GetParent(p) else None();
      def attr = attr.MapDefault(GetAttribute, []);
      CreateState(ast.Location.StartPos, attr, name, decls, type, parent);
    }
    
    CreateState(pos : int, attr : list[StateAttribute], name : string, decls : list[MainAst.StateDecl], type : StateType, parent : option[string]) : StateNode.State
    {
      mutable defer  = [];
      mutable do_act = [];
      mutable entry  = [];
      mutable exit   = [];
      mutable pseudo = [];
      mutable states = [];
      mutable tran   = [];
      mutable err    = [];
      def decls = decls.FoldBack([], (x, a) => if (x is MainAst.StateDecl.Sequence(h, t)) (h :: t) + a else x :: a);
      foreach (d in decls)
        {
          | StateDecl.DeferrableEvent(EventsAst.DeferrableEvent.Deferrable(Events = EventsAst.SimpleEventList.Ast((e, _))))
          | StateDecl.DeferrableEvent(EventsAst.DeferrableEvent.Deferred(Events = EventsAst.SimpleEventList.Ast((e, _)))) =>
              def lst = e.FoldBack([], (x, a) => if (x is EventIdentifier.Ast as x) TransitionEvent.Normal(x.Location.StartPos, x.GetText(), []) :: a else a);
              defer ::= StateNode.Defer(d.Location.StartPos, lst)
          | StateDecl.DoActivity(ActionsAst.DoActivity.Ast(ActList = a))                   => 
              def act = GetActions(a);
              do_act ::= StateNode.DoActivity(d.Location.StartPos, act, ActivityFlag.None);
          | StateDecl.Entry(ActionsAst.Entry.Ast(ActList = a)) => 
              def act = GetActions(a);
              entry ::= StateNode.Entry(d.Location.StartPos, ActionFlags.None, act)
          | StateDecl.Exit(ActionsAst.Exit.Ast(ActList = a)) => 
              def act = GetActions(a);
              exit ::= StateNode.Exit(d.Location.StartPos, ActionFlags.None, act)
          | StateDecl.PseudoState(p) => match (CreatePseudo(p))
                                        {
                                          | Some(p) => pseudo ::= p
                                          | _       => ()
                                        }
          | StateDecl.Regions(r) => match (CreateRegion(r))
                                    {
                                      | Some(st) => states ::= st
                                      | _        => ()
                                    }
          
          | StateDecl.State as t => 
              def state = if (t.StateDecls is StateDecl.RegionSequence as r :: []) 
               {
                 CreateRegionFromSequence(t, r); 
               } else
               {
                 CreateState(t, null, StateType.State())
               }
              states ::= state;
              
          | StateDecl.SubMachine(a, _, n, t, p, _, d, _) as st => 
             def type = t.MapDefault(x => if (x is StateDecl.SubMachine.Nested.TypeDecl.Ast(_, t, _)) t.GetText() else null, null);
             def state = CreateState(st, n, p, a, d, StateType.SubMachine(type, true));
             states ::= state;
             
          | StateDecl.Transition(TransitionsAst.Transition.NormalTransition(t)) => 
             match (CreateTransition(t))
             {
               | Some(t) => tran ::= t
               | _       => ()
             }
          | StateDecl.Transition(TransitionsAst.Transition.RelocateTransition as t) => 
             match (CreateRelocateTran(t))
             {
               | Some(t) => match (t)
                            {
                              | StateNode.Sequence(tr)     => def tr = tr.Map(x => x :> StateNode.Transition);
                                                              tran = tran + tr;   
                              | StateNode.Transition as tr => tran ::= tr
                              | _                          => () // others not supported yet
                            }
               | _       => ()
             }
          | _ => ()
        }
      StateNode.State(pos, name, parent, attr, entry.Rev(), exit.Rev(), tran.Rev(), do_act.Rev(), defer.Rev(), states.Rev(), pseudo.Rev(), type, err.Rev())
    }

    CreateRegion(reg : RegionsAst.Regions) : option[StateNode.State]
    {
      | RegionsAst.Regions.Region(RegionsAst.OneRegion.Ast(a, _, n, p, _, d, _), and_regs) =>
          def pos = reg.Location.StartPos;
          def (region_sep, decls) = d.Partition(x => x is StateDecl.RegionSequence);
          def sep = region_sep.Map(x => StateNode.Region(x.Location.StartPos));
          def err = sep.Map(x => StateNode.Error(x.pos, x));
          def state = CreateState(reg, n, p, a, decls, StateType.SubRegion());
          def (init, pseudo) = state.pseudo_states.Partition(x => x.node is PseudoStateModelNode.Initial);
          def reg = StateNode.State(pos, null, null, [], [], [], [], [], [], state.sub_states, init, StateType.SubRegion(), err);
          
          
          def create_and_regions(x, (a1, a2) as a)
          {
            match (x)
            {
              | RegionsAst.Regions.Region.Nested.AndSubRegion.Ast(tok, _, and_regs, _) => 
                 def state = CreateState(tok.StartPos, [], null, and_regs, StateType.SubRegion(), None());
                 def st = StateNode.State(state.pos, null, state.parent, [], [], [], [], [], [], state.sub_states, state.pseudo_states.Filter(x => x is StateNode.PseudoState(PseudoStateModelNode.Initial)), state.type, state.errors);
                 (st :: a1, state :: a2)
              | _ => a
            }
          }
          
          
          def (and_regs, decls) = and_regs.FoldBack(([], []), create_and_regions);
          
          def decls = state :: decls;
          def states = reg :: and_regs;
          
          def en = decls.SelectMany(_.entry).NToList();
          def ex = decls.SelectMany(_.exit).NToList();
          def trans = decls.SelectMany(_.transitions).NToList();
          def defer = decls.SelectMany(_.defer).NToList();
          def do_act = decls.SelectMany(_.do_activity).NToList();
          def pseudo = decls.SelectMany(x => x.pseudo_states.Exclude(x => x is StateNode.PseudoState(PseudoStateModelNode.Initial))).Concat(pseudo).NToList();
          def err = decls.SelectMany(_.errors).Concat(err).NToList();
          
          def state = StateNode.State(pos, state.name, state.parent, state.attributes, en, ex, trans, do_act, defer, states, pseudo, StateType.Region(), err);
          Some(state)
          
         | RegionsAst.Regions.Empty(RegionsAst.OneRegion.Ast(a, _, n, p, _, d, _) as t) => 
             def state = CreateState(t, n, p, a, d, StateType.Region());
             Some(state)
             
         | _ => None()

    }
    
    CreateRegionFromSequence(st : StateDecl.State, seq : StateDecl.RegionSequence) : StateNode.State
    {
        def first = seq.StateDecl;
        def other = seq.StateDecls;
        def other = other.Map((_, x) => x);
        def lst = first :: other;
        
        def create_sub_regions(reg)
        {
          def st = CreateState(reg.Location.StartPos, [], null, reg :: [], StateType.SubRegion(), None());
          def trans = st.transitions;
          (trans, st.ChangeTransitions([]))
        }
        
        def (trans, regs) = lst.Map(create_sub_regions).Split();
        def trans = trans.Flatten();
        def st = CreateState(st, [], StateType.Region());//StateNode.State(first.Location.StartPos, )
        def st = st.ChangeTransitions(trans);
        def st = st.ChangeSubStates(regs);
        st
    }
    
  }
}
