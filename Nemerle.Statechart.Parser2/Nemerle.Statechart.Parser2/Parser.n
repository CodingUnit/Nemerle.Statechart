using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nitra;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Statechart.Grammar;

namespace Nemerle.Statechart
{
  using Nemerle.Statechart.Grammar.MainAst;
  using Nemerle.Statechart.Grammar.BaseAst;
  using Nemerle.Statechart.Grammar.PseudoStatesAst;
  using Nemerle.Statechart.Grammar.TransitionsAst;
  using Nemerle.Statechart.Grammar.TargetsAst;
  using Nemerle.Statechart.Grammar.TransitionsAst.Guard;
  using Nemerle.Statechart.Grammar.MainAst.StateMachine.StateMachineDecl;
  using Nemerle.Statechart.Grammar.ActionsAst.ActionList.Action;
  /// <summary>
  /// Description of Parser.
  /// </summary>
  partial public class Parser
  {

    parse_action(pos : int, text : string) : Actions
    {
      def expr = parse_expr(text);
      def act = FsmAction.Expr(pos, expr);
      Actions(pos, act :: [])
    }

    GetActions(lst : ActionsAst.ActionList) : Actions
    {
      match (lst)
      {
        | ActionsAst.ActionList.Ast(_, a) => 
            match (a)
            {
              | SimpleActionList(ActionsAst.SimpleActionList.Ast((a, _))) => 
                  def act = a.FoldBack([], ((x, _), a) => if (x is Identifier.Ast as x) FsmAction.Normal(x.Location.StartPos, x.GetText(), []) :: a else a);
                  Actions(lst.Location.StartPos, act)
              | Expr(ActionsAst.ActionList.Action.Expr.Nested.Expr.SimpleExpr as e)
              | Expr(ActionsAst.ActionList.Action.Expr.Nested.Expr.LongExprAction(_, e, _)) => 
                  def text = e.GetText();
                  parse_action(e.Location.StartPos, text);
              | _ => Actions(lst.Location.StartPos, [])
            }
        | _ => Actions(lst.Location.StartPos, [])
      }
    }
    
    CreatePseudo(p : PseudoStatesAst.PseudoState) : option[StateNode.PseudoState]
    {
      def pos = p.Location.StartPos;
      def pseudo = match (p)
      {
        | PseudoState.Choice(_, Identifier.Ast as n, _, JunctionBody.Ast as b) => 
            def nodes = GetNodes(b);
            def name = n.GetText();
            PseudoStateModelNode.Junction(p.Location.StartPos, name, nodes, JunctionType.Choice)
        | PseudoState.EntryPoint(PseudoStatesAst.EntryPoint.Ast(n, TransitionsAst.EntryPointTransition.Ast as tr)) => 
            match (GetEntryPointTran(tr))
            {
              | Some(tr) => 
                  match (n)
                  {
                    | PseudoStatesAst.EntryPoint.EntryPointHead.Ver1(_, BaseAst.Identifier.Ast as n)
                    | PseudoStatesAst.EntryPoint.EntryPointHead.Ver2(BaseAst.Identifier.Ast as n, _)
                    | PseudoStatesAst.EntryPoint.EntryPointHead.Ver3(_, BaseAst.Identifier.Ast as n, _) => 
                        def name = n.GetText();
                        PseudoStateModelNode.EntryPoint(pos, name, tr)
                    | _ => null
                  }
              | _ => null
                                
            }
        | PseudoState.ExitPoint(PseudoStatesAst.ExitPoint.Ast(PseudoStatesAst.ExitPointDecl.Ast(_, BaseAst.Identifier.Ast as n), e)) => 
            def name = n.GetText();
            def tran = match (e)
            {
              | PseudoStatesAst.ExitPoint.ExitPointEnd.End                                                 => None()
              | PseudoStatesAst.ExitPoint.ExitPointEnd.Tran(TransitionsAst.EntryPointTransition.Ast as tr) => GetEntryPointTran(tr)
            }
            PseudoStateModelNode.ExitPoint(pos, name, tran)
        | PseudoState.History(PseudoStatesAst.History.HistoryDeep(_, t)) with type = HistoryType.Deep
        | PseudoState.History(PseudoStatesAst.History.HistoryShallow(_, t)) with type = HistoryType.Shallow => 
            def tran = match (t)
                       {
                         | Some((t, _)) => GetDefaultTran(t)
                         | _            => None()
                       }
            PseudoStateModelNode.History(pos, type, tran)
        | PseudoState.History(PseudoStatesAst.History.HistoryLong(_, _, type, t, _)) => 
            def type = match (p.GetText(type))
            {
              | "Deep"
              | "deep"    => HistoryType.Deep
              | "Shallow"
              | "shallow" => HistoryType.Shallow
              | _                                       => HistoryType.None
            }
            def tran = match (t)
                      {
                        | Some(t) => GetDefaultTran(t)
                        | _       => None()
                      }
            PseudoStateModelNode.History(pos, type, tran)
        | _ => null
      }
      if (pseudo != null) Some(StateNode.PseudoState(pos, pseudo)) else None()
    }

    CreateState(pos : int, name : string, decls : list[MainAst.StateDecl], type : StateType, parent : option[NameIdentifier]) : StateNode.State
    {
      mutable defer = [];
      mutable do_act = [];
      mutable entry = [];
      mutable exit = [];
      mutable pseudo = [];
      foreach (d in decls)
        {
          | StateDecl.DeferrableEvent(EventsAst.DeferrableEvent.Deferrable(Events = EventsAst.SimpleEventList.Ast((e, _))))
          | StateDecl.DeferrableEvent(EventsAst.DeferrableEvent.Deferred(Events = EventsAst.SimpleEventList.Ast((e, _)))) =>
              def lst = e.FoldBack([], (x, a) => if (x is Identifier.Ast as x) TransitionEvent.Normal(x.Location.StartPos, x.GetText(), []) :: a else a);
              defer ::= StateNode.Defer(d.Location.StartPos, lst)
          | StateDecl.DoActivity(ActionsAst.DoActivity.Ast(ActionList = a))                   => 
              def act = GetActions(a);
              do_act ::= StateNode.DoActivity(d.Location.StartPos, act, ActivityFlag.None);
          | StateDecl.Entry(ActionsAst.Entry.Ast(ActionList = a)) => 
              def act = GetActions(a);
              entry ::= StateNode.Entry(d.Location.StartPos, ActionFlags.None, act)
          | StateDecl.Exit(ActionsAst.Exit.Ast(ActionList = a)) => 
              def act = GetActions(a);
              exit ::= StateNode.Exit(d.Location.StartPos, ActionFlags.None, act)
          | StateDecl.PseudoState(p) => CreatePseudo(p).Iter(x => pseudo ::= x)
        }
      null
    }

  }
}
