using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Statechart
{
  using Nemerle.Statechart.Grammar;
  using Nemerle.Statechart.Grammar.MainParseTree;
  using Nemerle.Statechart.Grammar.BaseParseTree;
  using Nemerle.Statechart.Grammar.PseudoStatesParseTree;
  using Nemerle.Statechart.Grammar.TransitionsParseTree;
  using Nemerle.Statechart.Grammar.TargetsParseTree;
  using Nemerle.Statechart.Grammar.TransitionsParseTree.Guard;
  using Nemerle.Statechart.Grammar.MainParseTree.StateMachine.Nested.StateMachineDecl;
  using Nemerle.Statechart.Grammar.ActionsParseTree.ActionList.Nested.Action;
  
  /// <summary>
  /// Description of StateMachine.
  /// </summary>
  partial public class Parser
  {
    
    GetFlags(str : list[string]) : MachineFlags
    {
      def err = List();
      def proc_tok(str, a)
      {
        def flag = if (flags_map.ContainsKey(str)) flags_map[str] else 
                   {
                     err.Add(str);
                     MachineFlag.None
                   }
        flag | a
      }

      def flags = str.FoldLeft(MachineFlag.None, proc_tok);
      MachineFlags(flags, err.NToList());
    }
    
    ConvertTree(ast : MainParseTree.StateMachine) : StateNode.StateMachine
    {
      mutable flags = MachineFlag.None;
      mutable event_class = List();
      mutable event_decls = List();
      mutable names = List();
      mutable usings = List();
      mutable st_decl = List();
      mutable err = List();
      def decls = ast.StateMachineDecls;
      foreach (d in decls)
        {
          | Flags(AnyIdentifiersData = (a, _))                                                         => def data = GetLocatedText(a);
                                                                                                          def fl = GetFlags(data.NToList());
                                                                                                          when (fl.ParseDebug) assert2(false);
                                                                                                          unless (fl.errors.IsEmpty()) StateNode.Flags(d.Location.StartPos, 0, fl) |> err.Add;
                                                                                                          flags |= fl.flags;
          | EventClass(EventClass = EventsParseTree.EventClass(FullyQualifiedAny = f, EventListOptData = o)) => 
                                                                                                          def n = GetNameIdentifier(f);
                                                                                                          def evt = match (o)
                                                                                                                    {
                                                                                                                      | Some(EventsParseTree.EventClass.Nested.EventList(EventIdentifiersData = (e, _))) => GetLocatedText(e)
                                                                                                                      | _                                                                                => []
                                                                                                                    }
                                                                                                          StateNode.EventClassDecl(d.Location.StartPos, 0, n, evt.NToList()) |> event_class.Add
          | EventDecl(EventDecl = EventsParseTree.EventDecl(EventIdentifier = a, AnyIdentifiersData = (t, _)))          => 
                                                                                                          def name = a.GetText();
                                                                                                          def lst = GetLocatedText(t).NToList();
                                                                                                          StateNode.EventDecl(d.Location.StartPos, 0, name, lst) |> event_decls.Add
          | Name(NameIdentifier = n)                                                                         => 
              match (n)
              {
                | Name.Nested.NameIdentifier.CommaIdentifier(String = Double(SData = i)) 
                | Name.Nested.NameIdentifier.CommaIdentifier(String = Single(SData = i)) => StateNode.Name(d.Location.StartPos, 0, i) |> names.Add
                | Name.Nested.NameIdentifier.AnyIdentifier(AnyIdentifier = i) => 
                    def name = i.GetText();
                    StateNode.Name(d.Location.StartPos, 0, name) |> names.Add
                | _                                                          => ();
              }
          | Using(FullyQualifiedAny =  f)                                                                => def data = GetNameIdentifier(f);
                                                                                                            StateNode.Using(d.Location.StartPos, 0, data.FullName) |> usings.Add
          | StateDecl as d                                                                               => d.StateDecl |> st_decl.Add
          | _                                                                                            => ()
        }
      def st = CreateState(ast.Location.StartPos, [], null, st_decl.NToList(), StateType.State(), None());
      def (name, error) = if (names.IsEmpty()) (null, []) else 
      {
        def name = names;
        (name.First(), name.Skip(1));
      }
      def error = error.Map(_ : StateNode).Concat(err);
      def error = error.Map(x => StateNode.Error(x.pos, 0, x));
      StateNode.StateMachine(ast.Location.StartPos, 0, MachineFlags(flags, []), name?.name, st, usings.NToList(), event_decls.NToList(), event_class.NToList(), error)
    }

  }
}
